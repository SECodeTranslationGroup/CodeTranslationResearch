function sumNodes ( l ) { let leafNodeCount = Math . pow ( 2 , l - 1 ) ; let sumLastLevel = 0 ; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; let sum = sumLastLevel * l ; return sum ; }
function shortestChainLen ( start , target , D ) { if ( start == target ) return 0 ; if ( ! D . has ( target ) ) return 0 ; let level = 0 , wordlength = start . length ; let Q = [ ] ; Q . push ( start ) ; while ( Q . length != 0 ) { ++ level ; let sizeofQ = Q . length ; for ( let i = 0 ; i < sizeofQ ; ++ i ) { let word = Q [ 0 ] . split ( " " ) ; Q . shift ( ) ; for ( let pos = 0 ; pos < wordlength ; ++ pos ) { let orig_char = word [ pos ] ; for ( let c = ' ' . charCodeAt ( 0 ) ; c <= ' ' . charCodeAt ( 0 ) ; ++ c ) { word [ pos ] = String . fromCharCode ( c ) ; if ( word . join ( " " ) == target ) return level + 1 ; if ( ! D . has ( word . join ( " " ) ) ) continue ; D . delete ( word . join ( " " ) ) ; Q . push ( word . join ( " " ) ) ; } word [ pos ] = orig_char ; } } } return 0 ; }
function minCost ( cost ) { let dist = new Array ( N ) ; dist . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( let i = 0 ; i < N ; i ++ ) for ( let j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; return dist [ N - 1 ] ; }
function numOfways ( n , k ) { let p = 1 ; if ( k % 2 != 0 ) p = - 1 ; return ( Math . pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ; }
function power ( n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; }
function checkStar ( mat ) { var vertexD1 = 0 , vertexDn_1 = 0 ; if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 0 ] == 1 && mat [ 1 ] [ 1 ] == 0 ) ; for ( var i = 0 ; i < size ; i ++ ) { var degreeI = 0 ; for ( var j = 0 ; j < size ; j ++ ) if ( mat [ i ] [ j ] ) degreeI ++ ; if ( degreeI == 1 ) vertexD1 ++ ; else if ( degreeI == size - 1 ) vertexDn_1 ++ ; } return ( vertexD1 == ( size - 1 ) && vertexDn_1 == 1 ) ; }
function push ( new_data ) { var new_node = new Node ( new_data ) ; new_node . next = head ; head = new_node ; }
function insertAfter ( prev_node , new_data ) { if ( prev_node == null ) { document . write ( " " ) ; return ; } var new_node = new Node ( new_data ) ; new_node . next = prev_node . next ; prev_node . next = new_node ; }
function count ( head , key ) { if ( head == null ) return 0 ; if ( head . data == key ) return 1 + count ( head . next , key ) ; return count ( head . next , key ) ; }
function printSorted ( arr , start , end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; document . write ( arr [ start ] + " " ) ; printSorted ( arr , start * 2 + 2 , end ) ; }
function pairs ( arr , n , k ) { var smallest = 1000000000 ; var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( arr [ i ] + arr [ j ] - k ) < smallest ) { smallest = Math . abs ( arr [ i ] + arr [ j ] - k ) ; count = 1 ; } else if ( Math . abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++ ; } document . write ( " " + smallest + " " ) ; document . write ( " " + count + " " ) ; }
function middlesum ( mat , n ) { var row_sum = 0 , col_sum = 0 ; for ( i = 0 ; i < n ; i ++ ) row_sum += mat [ parseInt ( n / 2 ) ] [ i ] ; document . write ( " " + row_sum + " " ) ; for ( i = 0 ; i < n ; i ++ ) col_sum += mat [ i ] [ parseInt ( n / 2 ) ] ; document . write ( " " + col_sum ) ; }
function interchangeFirstLast ( m ) { let rows = m . length ; for ( let i = 0 ; i < m [ 0 ] . length ; i ++ ) { let t = m [ 0 ] [ i ] ; m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] ; m [ rows - 1 ] [ i ] = t ; } } let m = [ [ 8 , 9 , 7 , 6 ] , [ 4 , 7 , 6 , 5 ] , [ 3 , 2 , 1 , 8 ] , [ 9 , 9 , 7 , 7 ] ] interchangeFirstLast ( m ) ; for ( let i = 0 ; i < m . length ; i ++ ) { for ( let j = 0 ; j < m [ 0 ] . length ; j ++ ) document . write ( m [ i ] [ j ] + " " ) ; document . write ( " " ) ; }
function checkMarkov ( m ) { for ( let i = 0 ; i < n ; i ++ ) { let sum = 0 ; for ( let j = 0 ; j < n ; j ++ ) sum = sum + m [ i ] [ j ] ; if ( sum != 1 ) return false ; } return true ; }
function isDiagonalMatrix ( mat ) { for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; return true ; }
function isScalarMatrix ( mat ) { for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; for ( let i = 0 ; i < N - 1 ; i ++ ) if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) return false ; return true ; }
function Kroneckerproduct ( A , B ) { let C = new Array ( rowa * rowb ) for ( let i = 0 ; i < ( rowa * rowb ) ; i ++ ) { C [ i ] = new Array ( cola * colb ) ; for ( let j = 0 ; j < ( cola * colb ) ; j ++ ) { C [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < rowa ; i ++ ) { for ( let k = 0 ; k < rowb ; k ++ ) { for ( let j = 0 ; j < cola ; j ++ ) { for ( let l = 0 ; l < colb ; l ++ ) { C [ i + l + 1 ] [ j + k + 1 ] = A [ i ] [ j ] * B [ k ] [ l ] ; document . write ( C [ i + l + 1 ] [ j + k + 1 ] + " " ) ; } } document . write ( " " ) ; } } }
function find ( n , k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; }
function minimumflip ( mat , n ) { let transpose = new Array ( n ) ; for ( var i = 0 ; i < transpose . length ; i ++ ) { transpose [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) transpose [ i ] [ j ] = mat [ j ] [ i ] ; let flip = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) if ( transpose [ i ] [ j ] != mat [ i ] [ j ] ) flip ++ ; return flip / 2 ; }
function minimumflip ( mat , n ) { let flip = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; return flip ; }
function isLowerTriangularMatrix ( mat ) { for ( let i = 0 ; i < N ; i ++ ) for ( let j = i + 1 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; }
function isUpperTriangularMatrix ( mat ) { for ( let i = 1 ; i < N ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; }
function freq ( ar , m , n ) { let even = 0 , odd = 0 ; for ( let i = 0 ; i < m ; ++ i ) { for ( let j = 0 ; j < n ; ++ j ) { if ( ( ar [ i ] [ j ] % 2 ) == 0 ) ++ even ; else ++ odd ; } } document . write ( " " + odd + " " ) ; document . write ( " " + even + " " ) ; }
function Identity ( num ) { var row ; var col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) document . write ( 1 + " " ) ; else document . write ( 0 + " " ) ; } document . write ( " " + " " ) ; } return 0 ; }
function isIdentity ( mat , N ) { for ( let row = 0 ; row < N ; row ++ ) { for ( let col = 0 ; col < N ; col ++ ) { if ( row == col && mat [ row ] [ col ] != 1 ) return false ; else if ( row != col && mat [ row ] [ col ] != 0 ) return false ; } } return true ; }
function search ( mat , n , x ) { if ( n == 0 ) return - 1 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) if ( mat [ i ] [ j ] == x ) { document . write ( " " + i + " " + j + " " ) ; return 1 ; } } document . write ( " " ) ; return 0 ; }
function search ( mat , n , x ) { let i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { document . write ( " " + i + " " + j ) ; return ; } if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; } document . write ( " " ) ; return ; }
function calculateEnergy ( mat , n ) { let i_des , j_des , q ; let tot_energy = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { q = Math . floor ( mat [ i ] [ j ] / n ) ; i_des = q ; j_des = mat [ i ] [ j ] - ( n * q ) ; tot_energy += Math . abs ( i_des - i ) + Math . abs ( j_des - j ) ; } } return tot_energy ; }
function countUnique ( mat , n , m ) { let rowsum = new Array ( n ) ; rowsum . fill ( 0 ) ; let colsum = new Array ( m ) ; colsum . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] != 0 ) { rowsum [ i ] ++ ; colsum [ j ] ++ ; } let uniquecount = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] != 0 && rowsum [ i ] == 1 && colsum [ j ] == 1 ) uniquecount ++ ; return uniquecount ; }
function countCommon ( mat , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++ ; return res ; }
function areSumSame ( a , n , m ) { let sum1 = 0 , sum2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum1 = 0 ; sum2 = 0 ; for ( let j = 0 ; j < m ; j ++ ) { sum1 += a [ i ] [ j ] ; sum2 += a [ j ] [ i ] ; } if ( sum1 == sum2 ) return true ; } return false ; }
function findMax ( arr ) { var row = 0 , i , j ; for ( i = 0 , j = N - 1 ; i < N ; i ++ ) { while ( arr [ i ] [ j ] == 1 && j >= 0 ) { row = i ; j -- ; } } document . write ( " " + ( row + 1 ) ) ; document . write ( " " + ( N - 1 - j ) ) ; }
function isSymmetric ( mat , N ) { for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; }
function printDiagonalSums ( mat , n ) { let principal = 0 , secondary = 0 ; for ( let i = 0 ; i < n ; i ++ ) { principal += mat [ i ] [ i ] ; secondary += mat [ i ] [ n - i - 1 ] ; } document . write ( " " + principal + " " ) ; document . write ( " " + secondary ) ; }
function getBoundarySum ( a , m , n ) { let sum = 0 ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i == 0 ) sum += a [ i ] [ j ] ; else if ( i == m - 1 ) sum += a [ i ] [ j ] ; else if ( j == 0 ) sum += a [ i ] [ j ] ; else if ( j == n - 1 ) sum += a [ i ] [ j ] ; } } return sum ; }
function printSpiral ( mat , r , c ) { let i , a = 0 , b = 2 ; let low_row = ( 0 > a ) ? 0 : a ; let low_column = ( 0 > b ) ? 0 : b - 1 ; let high_row = ( ( a + 1 ) >= r ) ? r - 1 : a + 1 ; let high_column = ( ( b + 1 ) >= c ) ? c - 1 : b + 1 ; while ( ( low_row > 0 - r && low_column > 0 - c ) ) { for ( i = low_column + 1 ; i <= high_column && i < c && low_row >= 0 ; ++ i ) document . write ( mat [ low_row ] [ i ] + " " ) ; low_row -= 1 ; for ( i = low_row + 2 ; i <= high_row && i < r && high_column < c ; ++ i ) document . write ( mat [ i ] [ high_column ] + " " ) ; high_column += 1 ; for ( i = high_column - 2 ; i >= low_column && i >= 0 && high_row < r ; -- i ) document . write ( mat [ high_row ] [ i ] + " " ) ; high_row += 1 ; for ( i = high_row - 2 ; i > low_row && i >= 0 && low_column >= 0 ; -- i ) document . write ( mat [ i ] [ low_column ] + " " ) ; low_column -= 1 ; } document . write ( " " ) ; }
function difference ( arr , n ) { let d1 = 0 , d2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i == j ) d1 += arr [ i ] [ j ] ; if ( i == n - j - 1 ) d2 += arr [ i ] [ j ] ; } } return Math . abs ( d1 - d2 ) ; }
function difference ( arr , n ) { let d1 = 0 , d2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { d1 += arr [ i ] [ i ] ; d2 += arr [ i ] [ n - i - 1 ] ; } return Math . abs ( d1 - d2 ) ; }
function maxMin ( arr , n ) { let min = + 2147483647 ; let max = - 2147483648 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j <= n / 2 ; j ++ ) { if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) { if ( min > arr [ i ] [ n - j - 1 ] ) min = arr [ i ] [ n - j - 1 ] ; if ( max < arr [ i ] [ j ] ) max = arr [ i ] [ j ] ; } else { if ( min > arr [ i ] [ j ] ) min = arr [ i ] [ j ] ; if ( max < arr [ i ] [ n - j - 1 ] ) max = arr [ i ] [ n - j - 1 ] ; } } } document . write ( " " + max + " " + min ) ; }
function minOperation ( arr ) { let ans = 0 ; for ( let i = N - 1 ; i >= 0 ; i -- ) { for ( let j = M - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] [ j ] == false ) { ans ++ ; for ( let k = 0 ; k <= i ; k ++ ) { for ( let h = 0 ; h <= j ; h ++ ) { if ( arr [ k ] [ h ] == true ) { arr [ k ] [ h ] = false ; } else { arr [ k ] [ h ] = true ; } } } } } } return ans ; }
function findSum ( n ) { let ans = 0 , temp = 0 , num ; for ( let i = 1 ; i <= n && temp < n ; i ++ ) { temp = i - 1 ; num = 1 ; while ( temp < n ) { if ( temp + i <= n ) ans += ( i * num ) ; else ans += ( ( n - temp ) * num ) ; temp += i ; num ++ ; } } return ans ; }
function findSum ( n ) { let arr = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { arr [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { arr [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = Math . abs ( i - j ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) sum += arr [ i ] [ j ] ; return sum ; }
function findSum ( n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; }
function findSum ( n ) { n -- ; let sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; }
function spiralDiaSum ( n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; }
function maxXOR ( mat , N ) { let r_xor , c_xor ; let max_xor = 0 ; for ( let i = 0 ; i < N ; i ++ ) { r_xor = 0 , c_xor = 0 ; for ( let j = 0 ; j < N ; j ++ ) { r_xor = r_xor ^ mat [ i ] [ j ] ; c_xor = c_xor ^ mat [ j ] [ i ] ; } if ( max_xor < Math . max ( r_xor , c_xor ) ) max_xor = Math . max ( r_xor , c_xor ) ; } return max_xor ; }
function findK ( A , i , j , n , m , k ) { if ( n < 1 m < 1 ) return - 1 ; if ( k <= m ) return A [ i + 0 ] [ j + k - 1 ] ; if ( k <= ( m + n - 1 ) ) return A [ i + ( k - m ) ] [ j + m - 1 ] ; if ( k <= ( m + n - 1 + m - 1 ) ) return A [ i + n - 1 ] [ j + m - 1 - ( k - ( m + n - 1 ) ) ] ; if ( k <= ( m + n - 1 + m - 1 + n - 2 ) ) return A [ i + n - 1 - ( k - ( m + n - 1 + m - 1 ) ) ] [ j + 0 ] ; return findK ( A , i + 1 , j + 1 , n - 2 , m - 2 , k - ( 2 * n + 2 * m - 4 ) ) ; }
function countZeroes ( mat ) { let row = N - 1 , col = 0 ; let count = 0 ; while ( col < N ) { while ( mat [ row ] [ col ] > 0 ) if ( -- row < 0 ) return count ; count += ( row + 1 ) ; col ++ ; } return count ; }
function countNegative ( M , n , m ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ; else break ; } } return count ; }
function countNegative ( M , n , m ) { let count = 0 ; let i = 0 ; let j = m - 1 ; while ( j >= 0 && i < n ) { if ( M [ i ] [ j ] < 0 ) { count += j + 1 ; i += 1 ; } else j -= 1 ; } return count ; }
function printSpiral ( n ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { let x ; x = Math . min ( Math . min ( i , j ) , Math . min ( n - 1 - i , n - 1 - j ) ) ; if ( i <= j ) document . write ( ` ${ ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) } ` ) ; else document . write ( ` ${ ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) } ` ) ; } document . write ( " " ) ; } }
function findMaxValue ( N , mat ) { let maxValue = Number . MIN_VALUE ; for ( let a = 0 ; a < N - 1 ; a ++ ) for ( let b = 0 ; b < N - 1 ; b ++ ) for ( let d = a + 1 ; d < N ; d ++ ) for ( let e = b + 1 ; e < N ; e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] ; return maxValue ; }
function countIslands ( mat , m , n ) { let count = 0 ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == ' ' ) { if ( ( i == 0 mat [ i - 1 ] [ j ] == ' ' ) && ( j == 0 mat [ i ] [ j - 1 ] == ' ' ) ) count ++ ; } } } return count ; }
function printSumSimple ( mat , k ) { if ( k > n ) return ; for ( let i = 0 ; i < n - k + 1 ; i ++ ) { for ( let j = 0 ; j < n - k + 1 ; j ++ ) { let sum = 0 ; for ( let p = i ; p < k + i ; p ++ ) for ( let q = j ; q < k + j ; q ++ ) sum += mat [ p ] [ q ] ; document . write ( sum + " " ) ; } document . write ( " " ) ; } }
function transpose ( A , B ) { var i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < M ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; } var A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] ] ; var B = Array ( N ) ; for ( i = 0 ; i < N ; i ++ ) B [ i ] = Array ( M ) . fill ( 0 ) ; transpose ( A , B ) ; document . write ( " " ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < M ; j ++ ) document . write ( B [ i ] [ j ] + " " ) ; document . write ( " " ) ; }
function transpose ( A ) { for ( i = 0 ; i < N ; i ++ ) for ( j = i + 1 ; j < N ; j ++ ) { var temp = A [ i ] [ j ] ; A [ i ] [ j ] = A [ j ] [ i ] ; A [ j ] [ i ] = temp ; } } var A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; transpose ( A ) ; document . write ( " " ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) document . write ( A [ i ] [ j ] + " " ) ; document . write ( " \< " ) ; }
function add ( A , B , C ) { let i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; } let A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; let B = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; let C = new Array ( N ) ; for ( let k = 0 ; k < N ; k ++ ) C [ k ] = new Array ( N ) ; let i , j ; add ( A , B , C ) ; document . write ( " " ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) document . write ( C [ i ] [ j ] + " " ) ; document . write ( " " ) ; }
function subtract ( A , B , C ) { var i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; } var A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; var B = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; var C = Array . from ( Array ( N ) , ( ) => Array ( N ) ) ; var i , j ; subtract ( A , B , C ) ; document . write ( " " + " " ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) document . write ( C [ i ] [ j ] + " " ) ; document . write ( " " ) ; }
function printNGE ( arr , n ) { var next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } document . write ( arr [ i ] + " " + next ) ; document . write ( " " ) ; } }
function towerOfHanoi ( n , from_rod , to_rod , aux_rod ) { if ( n == 1 ) { document . write ( " " + from_rod + " " + to_rod + " " ) ; return ; } towerOfHanoi ( n - 1 , from_rod , aux_rod , to_rod ) ; document . write ( " " + n + " " + from_rod + " " + to_rod + " " ) ; towerOfHanoi ( n - 1 , aux_rod , to_rod , from_rod ) ; }
function printMaxOfMin ( n ) { for ( k = 1 ; k <= n ; k ++ ) { var maxOfMin = Number . MIN_VALUE ; for ( i = 0 ; i <= n - k ; i ++ ) { var min = arr [ i ] ; for ( j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] < min ) min = arr [ i + j ] ; } if ( min > maxOfMin ) maxOfMin = min ; } document . write ( maxOfMin + " " ) ; } }
function PrintMinNumberForPattern ( seq ) { let result = " " ; let stk = [ ] ; for ( let i = 0 ; i <= seq . length ; i ++ ) { stk . push ( i + 1 ) ; if ( i == seq . length seq [ i ] == ' ' ) { while ( stk . length != 0 ) { result += ( stk [ stk . length - 1 ] ) . toString ( ) ; result += " " ; stk . pop ( ) ; } } } document . write ( result + " " ) ; }
function getMinNumberForPattern ( seq ) { let n = seq . length ; if ( n >= 9 ) return " " ; let result = new Array ( n + 1 ) ; let count = 1 ; for ( let i = 0 ; i <= n ; i ++ ) { if ( i == n seq [ i ] == ' ' ) { for ( let j = i - 1 ; j >= - 1 ; j -- ) { result [ j + 1 ] = String . fromCharCode ( ' ' . charCodeAt ( ) + count ++ ) ; if ( j >= 0 && seq [ j ] == ' ' ) break ; } } } return result . join ( " " ) ; } let inputs = [ " " , " " , " " , " " , " " , " " , " " ] ; for ( let input = 0 ; input < inputs . length ; input ++ ) { document . write ( getMinNumberForPattern ( inputs [ input ] ) + " " ) ; }
function generate_derangement ( N ) { let S = [ ] ; for ( let i = 1 ; i <= N ; i ++ ) S [ i ] = i ; let D = [ ] ; for ( let i = 1 ; i <= N ; i += 2 ) { if ( i == N ) { D [ N ] = S [ N - 1 ] ; D [ N - 1 ] = S [ N ] ; } else { D [ i ] = i + 1 ; D [ i + 1 ] = i ; } } for ( let i = 1 ; i <= N ; i ++ ) document . write ( D [ i ] + " " ) ; document . write ( " " ) ; }
function sumBetweenTwoKth ( arr , k1 , k2 ) { arr . sort ( function ( a , b ) { return a - b } ) ; var result = 0 ; for ( var i = k1 ; i < k2 - 1 ; i ++ ) result += arr [ i ] ; return result ; }
function minSum ( a , n ) { a . sort ( ) ; let num1 = 0 ; let num2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ; else num2 = num2 * 10 + a [ i ] ; } return num2 + num1 ; }
function maxDistance ( arr , n ) { let map = new Map ( ) ; let max_dist = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! map . has ( arr [ i ] ) ) map . set ( arr [ i ] , i ) ; else max_dist = Math . max ( max_dist , i - map . get ( arr [ i ] ) ) ; } return max_dist ; }
function checkDuplicatesWithinK ( arr , n , k ) { let myset = [ ] ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr . includes ( arr [ i ] ) ) { return true ; } myset . add ( arr [ i ] ) ; if ( i >= k ) { index = array . indexOf ( arr [ i - k ] ) ; array . splice ( index , 1 ) ; } } return false ; } let arr = [ 10 , 5 , 3 , 4 , 3 , 5 , 6 ] ; let n = arr . length ; if ( checkDuplicatesWithinK ( arr , n , 3 ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function findSymPairs ( arr ) { let hM = new Map ( ) ; for ( let i = 0 ; i < arr . length ; i ++ ) { let first = arr [ i ] [ 0 ] ; let sec = arr [ i ] [ 1 ] ; let val = hM . get ( sec ) ; if ( val != null && val == first ) document . write ( " " + sec + " " + first + " " ) ; else hM . set ( first , sec ) ; } } let arr = new Array ( 5 ) ; for ( let i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) { arr [ i ] [ j ] = 0 ; } }
function aredisjoint ( set1 , set2 ) { for ( let i = 0 ; i < set1 . length ; i ++ ) { for ( let j = 0 ; j < set2 . length ; j ++ ) { if ( set1 [ i ] == set2 [ j ] ) return false ; } } return true ; }
function aredisjoint ( set1 , set2 ) { let i = 0 , j = 0 ; set1 . sort ( function ( a , b ) { return a - b } ) ; set2 . sort ( function ( a , b ) { return a - b } ) ; while ( i < set1 . length && j < set2 . length ) { if ( set1 [ i ] < set2 [ j ] ) i ++ ; else if ( set1 [ i ] > set2 [ j ] ) j ++ ; else return false ; } return true ; }
function findMissing ( a , b , n , m ) { for ( let i = 0 ; i < n ; i ++ ) { let j ; for ( j = 0 ; j < m ; j ++ ) if ( a [ i ] == b [ j ] ) break ; if ( j == m ) document . write ( a [ i ] + " " ) ; } }
function findMissing ( a , b , n , m ) { let s = new Set ( ) ; for ( let i = 0 ; i < m ; i ++ ) s . add ( b [ i ] ) ; for ( let i = 0 ; i < n ; i ++ ) if ( ! s . has ( a [ i ] ) ) document . write ( a [ i ] + " " ) ; }
function areEqual ( arr1 , arr2 ) { let n = arr1 . length ; let m = arr2 . length ; if ( n != m ) return false ; arr1 . sort ( ) ; arr2 . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; }
function isProduct ( arr , n , x ) { for ( var i = 0 ; i < n - 1 ; i ++ ) for ( var j = i + 1 ; i < n ; i ++ ) if ( arr [ i ] * arr [ j ] == x ) return true ; return false ; }
function find ( a , b , k , n1 , n2 ) { var s = new Set ( ) ; for ( var i = 0 ; i < n2 ; i ++ ) s . add ( b [ i ] ) ; var missing = 0 ; for ( var i = 0 ; i < n1 ; i ++ ) { if ( ! s . has ( a [ i ] ) ) missing ++ ; if ( missing == k ) return a [ i ] ; } return - 1 ; }
function findGreatest ( arr , n ) { let result = - 1 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n - 1 ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = Math . max ( result , arr [ i ] ) ; return result ; }
function subset ( ar , n ) { let res = 0 ; ar . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) { let count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = Math . max ( res , count ) ; } return res ; }
function getPairsCount ( arr , n , sum ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) count ++ ; return count ; }
function countPairs ( arr1 , arr2 , m , n , x ) { let count = 0 ; for ( let i = 0 ; i < m ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ; return count ; }
function countPairs ( arr1 , arr2 , m , n , x ) { let count = 0 ; let us = new Set ( ) ; for ( let i = 0 ; i < m ; i ++ ) us . add ( arr1 [ i ] ) ; for ( let j = 0 ; j < n ; j ++ ) if ( us . has ( x - arr2 [ j ] ) ) count ++ ; return count ; }
function countPairs ( arr1 , arr2 , m , n , x ) { let count = 0 ; let l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { l ++ ; r -- ; count ++ ; } else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++ ; else r -- ; } return count ; }
function findSubarraySum ( arr , n , sum ) { let prevSum = new Map ( ) ; let res = 0 ; let currsum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { currsum += arr [ i ] ; if ( currsum == sum ) res ++ ; if ( prevSum . has ( currsum - sum ) ) res += prevSum . get ( currsum - sum ) ; let count = prevSum . get ( currsum ) ; if ( count == null ) prevSum . set ( currsum , 1 ) ; else prevSum . set ( currsum , count + 1 ) ; } return res ; }
function countPairs ( arr , n ) { var result = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { var product = arr [ i ] * arr [ j ] ; for ( k = 0 ; k < n ; k ++ ) { if ( arr [ k ] == product ) { result ++ ; break ; } } } } return result ; }
function findPairs ( arr1 , arr2 , n , m , x ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < m ; j ++ ) if ( arr1 [ i ] + arr2 [ j ] == x ) document . write ( arr1 [ i ] + " " + arr2 [ j ] + " " ) ; }
function countFreq ( a , n ) { let hm = new Array ( n ) ; for ( let i = 0 ; i < hm . length ; i ++ ) { hm [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) hm [ a [ i ] ] ++ ; let cumul = 0 ; for ( let i = 0 ; i < n ; i ++ ) { cumul += hm [ a [ i ] ] ; if ( hm [ a [ i ] ] != 0 ) { document . write ( a [ i ] + " " + cumul + " " ) ; } hm [ a [ i ] ] = 0 ; } }
function findPair ( arr , n ) { let found = false ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { for ( let k = 0 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] == arr [ k ] ) { document . write ( arr [ i ] + " " + arr [ j ] + " " ) ; found = true ; } } } } if ( found == false ) document . write ( " " ) ; }
function printPairs ( arr , n , k ) { let isPairFound = true ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i != j && arr [ i ] % arr [ j ] == k ) { document . write ( " " + arr [ i ] + " " + arr [ j ] + " " + " " ) ; isPairFound = true ; } } } return isPairFound ; }
function printKDistinct ( arr , n , k ) { var dist_count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { var j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ; if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return - 1 ; }
function printPairs ( arr , n ) { let v = [ ] ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( arr [ i ] ) == Math . abs ( arr [ j ] ) ) v . push ( Math . abs ( arr [ i ] ) ) ; if ( v . length == 0 ) return ; v . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < v . length ; i ++ ) document . write ( - v [ i ] + " " + v [ i ] ) ; }
function findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) { for ( var i = 0 ; i < n1 ; i ++ ) for ( var j = 0 ; j < n2 ; j ++ ) for ( var k = 0 ; k < n3 ; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ; return false ; }
function maxLen ( arr ) { let hM = new Map ( ) ; let sum = 0 ; let max_len = 0 ; for ( let i = 0 ; i < arr . length ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] == 0 && max_len == 0 ) max_len = 1 ; if ( sum == 0 ) max_len = i + 1 ; let prev_i = hM . get ( sum ) ; if ( prev_i != null ) max_len = Math . max ( max_len , i - prev_i ) ; else hM . set ( sum , i ) ; } return max_len ; }
function longLenSub ( arr , n ) { let um = new Map ( ) ; let longLen = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let len = 0 ; if ( um . has ( arr [ i ] - 1 ) && len < um . get ( arr [ i ] - 1 ) ) len = um . get ( arr [ i ] - 1 ) ; if ( um . has ( arr [ i ] + 1 ) && len < um . get ( arr [ i ] + 1 ) ) len = um . get ( arr [ i ] + 1 ) ; um . set ( arr [ i ] , len + 1 ) ; if ( longLen < um . get ( arr [ i ] ) ) longLen = um . get ( arr [ i ] ) ; } return longLen ; }
function areElementsContiguous ( arr , n ) { let max = Number . MIN_VALUE ; let min = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { max = Math . max ( max , arr [ i ] ) ; min = Math . min ( min , arr [ i ] ) ; } let m = max - min + 1 ; if ( m > n ) return false ; let visited = new Array ( n ) ; visited . fill ( false ) ; for ( let i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( let i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; }
function minInsertion ( str ) { let n = str . length ; let res = 0 ; let count = new Array ( 26 ) ; for ( let i = 0 ; i < count . length ; i ++ ) { count [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) count [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] % 2 == 1 ) res ++ ; } return ( res == 0 ) ? 0 : res - 1 ; }
function findDiff ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let count = 0 , max_count = 0 , min_count = n ; for ( let i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_count = Math . max ( max_count , count ) ; min_count = Math . min ( min_count , count ) ; count = 0 ; } } return ( max_count - min_count ) ; }
function maxDiff ( arr , n ) { var result = 0 ; arr . sort ( ( a , b ) => a - b ) for ( var i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) result += Math . abs ( arr [ i ] ) ; else i ++ ; } if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += Math . abs ( arr [ n - 1 ] ) ; return result ; }
function calculate ( a , n ) { a . sort ( ) ; let count = 1 ; let answer = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { count += 1 ; } else { answer = answer + Math . floor ( ( count * ( count - 1 ) ) / 2 ) ; count = 1 ; } } answer = answer + Math . floor ( ( count * ( count - 1 ) ) / 2 ) ; return answer ; }
function findSubArray ( arr , n ) { let sum = 0 ; let maxsize = - 1 , startindex = 0 ; let endindex = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ; for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] == 0 ) sum += - 1 ; else sum += 1 ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } endindex = startindex + maxsize - 1 ; if ( maxsize == - 1 ) document . write ( " " ) ; else document . write ( startindex + " " + endindex ) ; return maxsize ; }
function lenOfLongSubarr ( arr , n ) { var um = new Map ( ) ; var sum = 0 , maxLen = 0 ; for ( var i = 0 ; i < n ; i ++ ) { sum += arr [ i ] == 0 ? - 1 : 1 ; if ( sum == 1 ) maxLen = i + 1 ; else if ( ! um . has ( sum ) ) um . set ( sum , i ) ; if ( um . has ( sum - 1 ) ) { if ( maxLen < ( i - um . get ( sum - 1 ) ) ) maxLen = i - um . get ( sum - 1 ) ; } } return maxLen ; }
function printAllAPTriplets ( arr , n ) { const s = new Set ( ) for ( let i = 0 ; i < n - 1 ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { let diff = arr [ j ] - arr [ i ] ; if ( s . has ( arr [ i ] - diff ) ) document . write ( arr [ i ] - diff + " " + arr [ i ] + " " + arr [ j ] + " " ) ; } s . add ( arr [ i ] ) ; } }
function printAllAPTriplets ( arr , n ) { for ( let i = 1 ; i < n - 1 ; i ++ ) { for ( let j = i - 1 , k = i + 1 ; j >= 0 && k < n ; ) { if ( arr [ j ] + arr [ k ] == 2 * arr [ i ] ) { document . write ( arr [ j ] + " " + arr [ i ] + " " + arr [ k ] + " " ) ; k ++ ; j -- ; } else if ( arr [ j ] + arr [ k ] < 2 * arr [ i ] ) k ++ ; else j -- ; } } }
function countPairs ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; return ans ; }
function countNum ( arr , n ) { let count = 0 ; arr . sort ( ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ; return count ; }
function countNum ( arr , n ) { let s = new Set ( ) ; let count = 0 , maxm = Number . MIN_VALUE , minm = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { s . add ( arr [ i ] ) ; if ( arr [ i ] < minm ) minm = arr [ i ] ; if ( arr [ i ] > maxm ) maxm = arr [ i ] ; } for ( let i = minm ; i <= maxm ; i ++ ) if ( ! s . has ( i ) ) count ++ ; return count ; }
function sumoflength ( arr , n ) { let s = new Set ( ) ; let j = 0 , ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { while ( j < n && ! s . has ( arr [ j ] ) ) { s . add ( arr [ i ] ) ; j ++ ; } ans += Math . floor ( ( ( j - i ) * ( j - i + 1 ) ) / 2 ) ; s . delete ( arr [ i ] ) ; } return ans ; }
function findLargestd ( S , n ) { let found = false ; S . sort ( ) ; for ( let i = n - 1 ; i >= 0 ; i -- ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; for ( let k = j + 1 ; k < n ; k ++ ) { if ( i == k ) continue ; for ( let l = k + 1 ; l < n ; l ++ ) { if ( i == l ) continue ; if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true ; return S [ i ] ; } } } } } if ( found == false ) return Number . MAX_VALUE ; return - 1 ; }
function recaman ( n ) { let arr = new Array ( n ) ; arr [ 0 ] = 0 ; document . write ( arr [ 0 ] + " " ) ; for ( let i = 1 ; i < n ; i ++ ) { let curr = arr [ i - 1 ] - i ; let j ; for ( j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] == curr ) curr < 0 ) { curr = arr [ i - 1 ] + i ; break ; } } arr [ i ] = curr ; document . write ( arr [ i ] + " " ) ; } }
function findArea ( arr , n ) { arr . sort ( ( a , b ) => { return b - a ; } ) var dimension = [ 0 , 0 ] ; for ( var i = 0 , j = 0 ; i < n - 1 && j < 2 ; i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ; return ( dimension [ 0 ] * dimension [ 1 ] ) ; }
function leftRotate ( arr , d , n ) { if ( d == 0 d == n ) return ; let i = d ; let j = n - d ; while ( i != j ) { if ( i < j ) { arr = swap ( arr , d - i , d + j - i , i ) ; j -= i ; } else { arr = swap ( arr , d - i , d , j ) ; i -= j ; } } arr = swap ( arr , d - i , d , i ) ; }
function search ( arr , l , h , key ) { if ( l > h ) return - 1 ; let mid = Math . floor ( ( l + h ) / 2 ) ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }
function pairInSortedRotated ( arr , n , x ) { let i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; let l = ( i + 1 ) % n ; let r = i ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) return true ; if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return false ; }
function pairsInSortedRotated ( arr , n , x ) { let i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; let l = ( i + 1 ) % n ; let r = i ; let cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { cnt ++ ; if ( l == ( r - 1 + n ) % n ) { return cnt ; } l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return cnt ; }
function maxSum ( arr , n ) { var res = Number . MIN_VALUE ; for ( i = 0 ; i < n ; i ++ ) { var curr_sum = 0 ; for ( j = 0 ; j < n ; j ++ ) { var index = ( i + j ) % n ; curr_sum += j * arr [ index ] ; } res = Math . max ( res , curr_sum ) ; } return res ; }
function maxSum ( arr , n ) { let cum_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) cum_sum += arr [ i ] ; let curr_val = 0 ; for ( let i = 0 ; i < n ; i ++ ) curr_val += i * arr [ i ] ; let res = curr_val ; for ( let i = 1 ; i < n ; i ++ ) { let next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ; curr_val = next_val ; res = Math . max ( res , next_val ) ; } return res ; }
function countRotations ( arr , n ) { let min = arr [ 0 ] , min_index = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( min > arr [ i ] ) { min = arr [ i ] ; min_index = i ; } } return min_index ; }
function countRotations ( arr , low , high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; let mid = Math . floor ( low + ( high - low ) / 2 ) ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; }
function leftRotate ( arr , n , k ) { for ( let i = k ; i < k + n ; i ++ ) document . write ( arr [ i % n ] + " " ) ; }
function findMin ( arr , low , high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; let mid = low + Math . floor ( ( high - low ) / 2 ) ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; }
function findMin ( arr , low , high ) { while ( low < high ) { let mid = Math . floor ( low + ( high - low ) / 2 ) ; if ( arr [ mid ] == arr [ high ] ) high -- ; else if ( arr [ mid ] > arr [ high ] ) low = mid + 1 ; else high = mid ; } return arr [ high ] ; }
function maxHamming ( arr , n ) { let brr = new Array ( 2 * n + 1 ) ; for ( let i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) brr [ n + i ] = arr [ i ] ; let maxHam = 0 ; for ( let i = 1 ; i < n ; i ++ ) { let currHam = 0 ; for ( let j = i , k = 0 ; j < ( i + n ) ; j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ; if ( currHam == n ) return n ; maxHam = max ( maxHam , currHam ) ; } return maxHam ; }
function leftRotate ( arr , n , k ) { let mod = k % n ; for ( let i = 0 ; i < n ; i ++ ) document . write ( ( arr [ ( mod + i ) % n ] ) + " " ) ; document . write ( " " ) ; }
function splitArr ( arr , n , k ) { for ( let i = 0 ; i < k ; i ++ ) { let x = arr [ 0 ] ; for ( let j = 0 ; j < n - 1 ; ++ j ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } }
function pushZerosToEnd ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; }
function reorder ( arr , index , n ) { var temp = [ ... Array ( n ) ] ; for ( var i = 0 ; i < n ; i ++ ) temp [ index [ i ] ] = arr [ i ] ; for ( var i = 0 ; i < n ; i ++ ) { arr [ i ] = temp [ i ] ; index [ i ] = i ; } }
function reorder ( arr , index , n ) { for ( let i = 0 ; i < n ; i ++ ) { while ( index [ i ] != i ) { let oldTargetI = index [ index [ i ] ] ; let oldTargetE = arr [ index [ i ] ] ; arr [ index [ i ] ] = arr [ i ] ; index [ index [ i ] ] = index [ i ] ; index [ i ] = oldTargetI ; arr [ i ] = oldTargetE ; } } }
function RearrangePosNeg ( arr ) { var i = 0 ; var j = arr . length - 1 ; while ( true ) { while ( arr [ i ] < 0 && i < arr . length ) i ++ ; while ( arr [ j ] > 0 && j >= 0 ) j -- ; if ( i < j ) { var temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } else break ; } }
function rearrange ( arr , n ) { let temp = new Array ( n ) ; let small = 0 , large = n - 1 ; let flag = true ; for ( let i = 0 ; i < n ; i ++ ) { if ( flag ) temp [ i ] = arr [ large -- ] ; else temp [ i ] = arr [ small ++ ] ; flag = ! flag ; } for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
function rearrange ( arr , n ) { let max_idx = n - 1 , min_idx = 0 ; let max_elem = arr [ n - 1 ] + 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem ; max_idx -- ; } else { arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem ; min_idx ++ ; } } for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = Math . floor ( arr [ i ] / max_elem ) ; }
function rearrange ( arr , n ) { let max_ele = arr [ n - 1 ] ; let min_ele = arr [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] = max_ele ; max_ele -= 1 ; } else { arr [ i ] = min_ele ; min_ele += 1 ; } } }
function segregateElements ( arr , n ) { let temp = new Array ( n ) ; let j = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n j == 0 ) return ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
function rearrange ( a , size ) { let positive = 0 ; let negative = 1 ; let temp ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) { temp = a [ positive ] ; a [ positive ] = a [ negative ] ; a [ negative ] = temp ; } else break ; } }
function arrayEvenAndOdd ( arr , n ) { let i = - 1 , j = 0 ; let t ; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++ ; let temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } j ++ ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ; }
function largest ( arr , n ) { arr . sort ( ) ; return arr [ n - 1 ] ; }
function find3largest ( arr ) { arr . sort ( ( a , b ) => a - b ) ; let check = 0 , count = 1 ; for ( let i = 1 ; i <= arr . length ; i ++ ) { if ( count < 4 ) { if ( check != arr [ arr . length - i ] ) { document . write ( arr [ arr . length - i ] + " " ) ; check = arr [ arr . length - i ] ; count ++ ; } } else break ; } }
function findElements ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { let count = 0 ; for ( let j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) document . write ( arr [ i ] + " " ) ; } }
function findElements ( arr , n ) { arr . sort ( ) ; for ( let i = 0 ; i < n - 2 ; i ++ ) document . write ( arr [ i ] + " " ) ; }
function findElements ( arr , n ) { let first = Number . MIN_VALUE ; let second = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) document . write ( arr [ i ] + " " ) ; }
function findFirstMissing ( array , start , end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; let mid = parseInt ( ( start + end ) / 2 , 10 ) ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }
function FindMaxSum ( arr , n ) { let incl = arr [ 0 ] ; let excl = 0 ; let excl_new ; let i ; for ( i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; }
function countInRange ( arr , n , x , y ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ; } return count ; }
function answerQuery ( a , n , l , r ) { var count = 0 ; l = l - 1 ; for ( i = l ; i < r ; i ++ ) { var element = a [ i ] ; var divisors = 0 ; for ( j = l ; j < r ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) divisors ++ ; else break ; } if ( divisors == ( r - l ) ) count ++ ; } return count ; }
function record_sum ( record , l , r , n , adder ) { for ( let i = l ; i <= r ; i ++ ) { record [ i ] += adder ; } } let n = 5 , m = 5 ; let arr = new Array ( n ) ; for ( let i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = 0 ; } let query = [ [ 1 , 1 , 2 ] , [ 1 , 4 , 5 ] , [ 2 , 1 , 2 ] , [ 2 , 1 , 3 ] , [ 2 , 3 , 4 ] ] ; let record = new Array ( m ) ; for ( let i = 0 ; i < record . length ; i ++ ) { record [ i ] = 0 ; } for ( let i = m - 1 ; i >= 0 ; i -- ) { if ( query [ i ] [ 0 ] == 2 ) { record_sum ( record , query [ i ] [ 1 ] - 1 , query [ i ] [ 2 ] - 1 , m , record [ i ] + 1 ) ; } else { record_sum ( record , i , i , m , 1 ) ; } } for ( let i = 0 ; i < m ; i ++ ) { if ( query [ i ] [ 0 ] == 1 ) { record_sum ( arr , query [ i ] [ 1 ] - 1 , query [ i ] [ 2 ] - 1 , n , record [ i ] ) ; } } for ( let i = 0 ; i < n ; i ++ ) { document . write ( arr [ i ] + " " ) ; }
function answer_query ( a , n , l , r ) { var count = 0 ; for ( var i = l ; i < r ; i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ; return count ; }
function maxSubArraySum ( a , size ) { var maxint = Math . pow ( 2 , 53 ) var max_so_far = - maxint - 1 var max_ending_here = 0 for ( var i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] if ( max_so_far < max_ending_here ) max_so_far = max_ending_here if ( max_ending_here < 0 ) max_ending_here = 0 } return max_so_far }
function maxSubArraySum ( a , size ) { let max_so_far = a [ 0 ] ; let curr_max = a [ 0 ] ; for ( let i = 1 ; i < size ; i ++ ) { curr_max = Math . max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = Math . max ( max_so_far , curr_max ) ; } return max_so_far ; }
function findMinAvgSubarray ( arr , n , k ) { if ( n < k ) return ; let res_index = 0 ; let curr_sum = 0 ; for ( let i = 0 ; i < k ; i ++ ) curr_sum += arr [ i ] ; let min_sum = curr_sum ; for ( let i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; if ( curr_sum < min_sum ) { min_sum = curr_sum ; res_index = ( i - k + 1 ) ; } } document . write ( " " + res_index + " " + ( res_index + k - 1 ) + " " ) ; }
function minJumps ( arr , n ) { if ( n == 1 ) return 0 ; let res = Number . MAX_VALUE ; for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( i + arr [ i ] >= n - 1 ) { let sub_res = minJumps ( arr , i + 1 ) ; if ( sub_res != Number . MAX_VALUE ) res = Math . min ( res , sub_res + 1 ) ; } } return res ; }
function smallestSubWithSum ( arr , n , x ) { let curr_sum = 0 , min_len = n + 1 ; let start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) curr_sum += arr [ end ++ ] ; while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start ; curr_sum -= arr [ start ++ ] ; } } return min_len ; }
function findMaxAverage ( arr , n , k ) { if ( k > n ) return - 1 ; let csum = new Array ( n ) ; csum [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; let max_sum = csum [ k - 1 ] , max_end = k - 1 ; for ( let i = k ; i < n ; i ++ ) { let curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } return max_end - k + 1 ; }
function findMaxAverage ( arr , n , k ) { if ( k > n ) return - 1 ; let sum = arr [ 0 ] ; for ( let i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; let max_sum = sum ; let max_end = k - 1 ; for ( let i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; }
function findSmallest ( arr , n ) { var res = 1 ; for ( i = 0 ; i < n && arr [ i ] <= res ; i ++ ) res = res + arr [ i ] ; return res ; }
function findMinDiff ( arr , n ) { let diff = Number . MAX_VALUE ; for ( let i = 0 ; i < n - 1 ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( ( arr [ i ] - arr [ j ] ) ) < diff ) diff = Math . abs ( ( arr [ i ] - arr [ j ] ) ) ; return diff ; }
function findMinDiff ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let diff = Number . MAX_VALUE ; for ( let i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; return diff ; }
function longestCommonSum ( n ) { let maxLen = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let sum1 = 0 , sum2 = 0 ; for ( let j = i ; j < n ; j ++ ) { sum1 += arr1 [ j ] ; sum2 += arr2 [ j ] ; if ( sum1 == sum2 ) { let len = j - i + 1 ; if ( len > maxLen ) maxLen = len ; } } } return maxLen ; }
function segregate0and1 ( arr , n ) { let type0 = 0 ; let type1 = n - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { arr [ type0 ] = arr [ type0 ] + arr [ type1 ] ; arr [ type1 ] = arr [ type0 ] - arr [ type1 ] ; arr [ type0 ] = arr [ type0 ] - arr [ type1 ] ; type1 -- ; } else { type0 ++ ; } } }
function getInvCount ( arr ) { let inv_count = 0 ; for ( let i = 0 ; i < arr . length - 1 ; i ++ ) { for ( let j = i + 1 ; j < arr . length ; j ++ ) { if ( arr [ i ] > arr [ j ] ) inv_count ++ ; } } return inv_count ; }
function findNumberOfTriangles ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { for ( let k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] > arr [ k ] && arr [ i ] + arr [ k ] > arr [ j ] && arr [ k ] + arr [ j ] > arr [ i ] ) count ++ ; } } return count ; }
function CountTriangles ( A ) { var n = A . length ; A . sort ( ) ; var count = 0 ; for ( i = n - 1 ; i >= 1 ; i -- ) { var l = 0 , r = i - 1 ; while ( l < r ) { if ( A [ l ] + A [ r ] > A [ i ] ) { count += r - l ; r -- ; } else { l ++ ; } } } document . write ( " " + count ) ; }
function countPairsBruteForce ( X , Y , m , n ) { let ans = 0 ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( ( Math . pow ( X [ i ] , Y [ j ] ) > Math . pow ( Y [ j ] , X [ i ] ) ) ) { ans += 1 ; } } } return ans ; }
function countPairsWithDiffK ( arr , n , k ) { count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; }
function countPairsWithDiffK ( arr , n , k ) { let count = 0 ; arr . sort ( ) ; let l = 0 ; let r = 0 ; while ( r < n ) { if ( arr [ r ] - arr [ l ] == k ) { count ++ ; l ++ ; r ++ ; } else if ( arr [ r ] - arr [ l ] > k ) l ++ ; else r ++ ; } return count ; }
function constructArr ( arr , pair , n ) { arr [ 0 ] = Math . floor ( ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ) ; for ( let i = 1 ; i < n ; i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ; }
function merge ( m , n ) { for ( let i = n - 1 ; i >= 0 ; i -- ) { let j , last = arr1 [ m - 1 ] ; for ( j = m - 2 ; j >= 0 && arr1 [ j ] > arr2 [ i ] ; j -- ) arr1 [ j + 1 ] = arr1 [ j ] ; if ( j != m - 2 last > arr2 [ i ] ) { arr1 [ j + 1 ] = arr2 [ i ] ; arr2 [ i ] = last ; } } } merge ( arr1 . length , arr2 . length ) ; document . write ( " " ) ; for ( let i = 0 ; i < arr1 . length ; i ++ ) { document . write ( arr1 [ i ] + " " ) ; } document . write ( " " ) ; for ( let i = 0 ; i < arr2 . length ; i ++ ) { document . write ( arr2 [ i ] + " " ) ; }
function minMaxProduct ( arr1 , arr2 , n1 , n2 ) { arr1 . sort ( ( a , b ) => a - b ) ; arr2 . sort ( ( a , b ) => a - b ) ; return ( arr1 [ n1 - 1 ] * arr2 [ 0 ] ) ; }
function findElement ( arr , n , key ) { let i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; }
function findCommon ( ar1 , ar2 , ar3 , n1 , n2 , n3 ) { var i = 0 , j = 0 , k = 0 ; while ( i < n1 && j < n2 && k < n3 ) { if ( ar1 [ i ] == ar2 [ j ] && ar2 [ j ] == ar3 [ k ] ) { document . write ( ar1 [ i ] + " " ) ; i ++ ; j ++ ; k ++ ; } else if ( ar1 [ i ] < ar2 [ j ] ) i ++ ; else if ( ar2 [ j ] < ar3 [ k ] ) j ++ ; else k ++ ; } }
function findSingle ( ar , ar_size ) { let res = ar [ 0 ] ; for ( let i = 1 ; i < ar_size ; i ++ ) res = res ^ ar [ i ] ; return res ; }
function singleNumber ( nums , n ) { let m = new Map ( ) ; let sum1 = 0 , sum2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! m . has ( nums [ i ] ) ) { sum1 += nums [ i ] ; m . set ( nums [ i ] , 1 ) ; } sum2 += nums [ i ] ; } return ( 2 * ( sum1 ) - sum2 ) ; }
function findMaxSum ( arr , n ) { var res = - 1000000000 ; for ( var i = 0 ; i < n ; i ++ ) { var prefix_sum = arr [ i ] ; for ( var j = 0 ; j < i ; j ++ ) prefix_sum += arr [ j ] ; var suffix_sum = arr [ i ] ; for ( var j = n - 1 ; j > i ; j -- ) suffix_sum += arr [ j ] ; if ( prefix_sum == suffix_sum ) res = Math . max ( res , prefix_sum ) ; } return res ; }
function findMaxSum ( arr , n ) { let preSum = new Array ( n ) ; preSum . fill ( 0 ) ; let suffSum = new Array ( n ) ; suffSum . fill ( 0 ) ; let ans = Number . MIN_VALUE ; preSum [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) preSum [ i ] = preSum [ i - 1 ] + arr [ i ] ; suffSum [ n - 1 ] = arr [ n - 1 ] ; if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) ans = Math . max ( ans , preSum [ n - 1 ] ) ; for ( let i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] ; if ( suffSum [ i ] == preSum [ i ] ) ans = Math . max ( ans , preSum [ i ] ) ; } return ans ; }
function equilibrium ( arr , n ) { var i , j ; var leftsum , rightsum ; for ( i = 0 ; i < n ; ++ i ) { leftsum = 0 ; rightsum = 0 ; for ( let j = 0 ; j < i ; j ++ ) leftsum += arr [ j ] ; for ( let j = i + 1 ; j < n ; j ++ ) rightsum += arr [ j ] ; if ( leftsum == rightsum ) return i ; } return - 1 ; }
function equilibrium ( arr , n ) { sum = 0 ; leftsum = 0 ; for ( let i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( let i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; } return - 1 ; }
function printLeaders ( arr , size ) { for ( let i = 0 ; i < size ; i ++ ) { let j ; for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] <= arr [ j ] ) break ; } if ( j == size ) document . write ( arr [ i ] + " " ) ; } }
function ceilSearch ( arr , low , high , x ) { let i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return - 1 ; }
function ceilSearch ( arr , low , high , x ) { let mid ; if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return - 1 ; mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } } let arr = [ 1 , 2 , 8 , 10 , 10 , 12 , 19 ] ; let n = arr . length ; let x = 20 ; let index = ceilSearch ( arr , 0 , n - 1 , x ) ; if ( index == - 1 ) { document . write ( ` ${ x } ` ) ; } else { document . write ( ` ${ x } ${ arr [ index ] } ` ) ; }
function isMajority ( arr , n , x ) { let i , last_index = 0 ; last_index = ( n % 2 == 0 ) ? parseInt ( n / 2 , 10 ) : parseInt ( n / 2 , 10 ) + 1 ; for ( i = 0 ; i < last_index ; i ++ ) { if ( arr [ i ] == x && arr [ i + parseInt ( n / 2 , 10 ) ] == x ) return true ; } return false ; }
function isMajorityElement ( arr , n , key ) { if ( arr [ parseInt ( n / 2 , 10 ) ] == key ) return true ; else return false ; }
function findPeak ( arr , n ) { if ( n == 1 ) return 0 ; if ( arr [ 0 ] >= arr [ 1 ] ) return 0 ; if ( arr [ n - 1 ] >= arr [ n - 2 ] ) return n - 1 ; for ( var i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] >= arr [ i - 1 ] && arr [ i ] >= arr [ i + 1 ] ) return i ; } }
function printRepeating ( arr , size ) { var i , j ; document . write ( " " ) ; for ( i = 0 ; i < size ; i ++ ) { for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) document . write ( arr [ i ] + " " ) ; } } }
function printRepeating ( arr , size ) { let count = new Array ( size ) ; count . fill ( 0 ) ; let i ; document . write ( " " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) document . write ( arr [ i ] + " " ) ; else count [ arr [ i ] ] ++ ; } }
function printRepeating ( arr , size ) { var i ; document . write ( " " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ Math . abs ( arr [ i ] ) ] > 0 ) arr [ Math . abs ( arr [ i ] ) ] = - arr [ Math . abs ( arr [ i ] ) ] ; else document . write ( Math . abs ( arr [ i ] ) + " " ) ; } }
function linearSearch ( arr , n ) { let i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return - 1 ; }
function binarySearch ( arr , low , high ) { if ( high >= low ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; } return - 1 ; }
function subArraySum ( arr , n , sum ) { let curr_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { curr_sum = arr [ i ] ; for ( let j = i + 1 ; j <= n ; j ++ ) { if ( curr_sum == sum ) { document . write ( " " + i + " " + ( j - 1 ) ) ; return ; } if ( curr_sum > sum j == n ) break ; curr_sum = curr_sum + arr [ j ] ; } } document . write ( " " ) ; return ; }
function maxTripletSum ( arr , n ) { let sum = - 1000000 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; }
function maxTripletSum ( arr , n ) { arr . sort ( ) ; return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; }
function find3Numbers ( A , arr_size , sum ) { let l , r ; for ( let i = 0 ; i < arr_size - 2 ; i ++ ) { for ( let j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( let k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { document . write ( " " + A [ i ] + " " + A [ j ] + " " + A [ k ] ) ; return true ; } } } } return false ; }
function subArray ( n ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { for ( let k = i ; k <= j ; k ++ ) document . write ( arr [ k ] + " " ) ; document . write ( " " ) ; } } }
function printSubsequences ( arr , n ) { let opsize = parseInt ( Math . pow ( 2 , n ) , 10 ) ; for ( let counter = 1 ; counter < opsize ; counter ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( ( counter & ( 1 << j ) ) != 0 ) document . write ( arr [ j ] + " " ) ; } document . write ( " " ) ; } }
function minOps ( arr , n , k ) { var max = arr [ 0 ] ; for ( var i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ; else res += ( max - arr [ i ] ) / k ; } return res ; }
function solve ( A , B , C ) { let i , j , k ; i = A . length - 1 ; j = B . length - 1 ; k = C . length - 1 ; let min_diff , current_diff , max_term ; min_diff = Math . abs ( Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , Math . min ( B [ j ] , C [ k ] ) ) ) ; while ( i != - 1 && j != - 1 && k != - 1 ) { current_diff = Math . abs ( Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , Math . min ( B [ j ] , C [ k ] ) ) ) ; if ( current_diff < min_diff ) min_diff = current_diff ; max_term = Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) ; if ( A [ i ] == max_term ) i -= 1 ; else if ( B [ j ] == max_term ) j -= 1 ; else k -= 1 ; } return min_diff ; }
function search ( arr , n , x ) { let i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) return i ; return - 1 ; }
function binarySearch ( arr , l , r , x ) { if ( r >= l ) { let mid = l + Math . floor ( ( r - l ) / 2 ) ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; }
function interpolationSearch ( arr , lo , hi , x ) { let pos ; if ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) { pos = lo + Math . floor ( ( ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ; ; if ( arr [ pos ] == x ) { return pos ; } if ( arr [ pos ] < x ) { return interpolationSearch ( arr , pos + 1 , hi , x ) ; } if ( arr [ pos ] > x ) { return interpolationSearch ( arr , lo , pos - 1 , x ) ; } } return - 1 ; } let arr = [ 10 , 12 , 13 , 16 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 33 , 35 , 42 , 47 ] ; let n = arr . length ; let x = 18 let index = interpolationSearch ( arr , 0 , n - 1 , x ) ; if ( index != - 1 ) { document . write ( ` ${ index } ` ) } else { document . write ( " " ) ; }
function sort ( arr ) { var n = arr . length ; var output = Array . from ( { length : n } , ( _ , i ) => 0 ) ; var count = Array . from ( { length : 256 } , ( _ , i ) => 0 ) ; for ( var i = 0 ; i < n ; ++ i ) ++ count [ arr [ i ] . charCodeAt ( 0 ) ] ; for ( var i = 1 ; i <= 255 ; ++ i ) count [ i ] += count [ i - 1 ] ; for ( var i = n - 1 ; i >= 0 ; i -- ) { output [ count [ arr [ i ] . charCodeAt ( 0 ) ] - 1 ] = arr [ i ] ; -- count [ arr [ i ] . charCodeAt ( 0 ) ] ; } for ( var i = 0 ; i < n ; ++ i ) arr [ i ] = output [ i ] ; return arr ; }
function printClosest ( ar1 , ar2 , m , n , x ) { let diff = Number . MAX_VALUE ; let res_l , res_r ; let l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) ; } if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ; else l ++ ; } document . write ( " " + ar1 [ res_l ] + " " + ar2 [ res_r ] + " " ) ; }
function printClosest ( arr , n , x ) { let res_l = 0 , res_r = 0 ; let l = 0 , r = n - 1 , diff = Number . MAX_VALUE ; while ( r > l ) { if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } document . write ( " " + arr [ res_l ] + " " + arr [ res_r ] ) ; }
function countOnes ( arr , low , high ) { if ( high >= low ) { let mid = Math . trunc ( low + ( high - low ) / 2 ) ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
function printMaxActivities ( s , f , n ) { let i , j ; document . write ( " " ) ; i = 0 ; document . write ( i + " " ) ; for ( j = 1 ; j < n ; j ++ ) { if ( s [ j ] >= f [ i ] ) { document . write ( j + " " ) ; i = j ; } } }
function lis ( arr , n ) { let lis = Array ( n ) . fill ( 0 ) ; let i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return max ; }
function count ( S , m , n ) { let table = new Array ( n + 1 ) ; table . fill ( 0 ) ; table [ 0 ] = 1 ; for ( let i = 0 ; i < m ; i ++ ) for ( let j = S [ i ] ; j <= n ; j ++ ) table [ j ] += table [ j - S [ i ] ] ; return table [ n ] ; }
function MatrixChainOrder ( p , n ) { var m = Array ( n ) . fill ( 0 ) . map ( x => Array ( n ) . fill ( 0 ) ) ; var i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( j == n ) continue ; m [ i ] [ j ] = Number . MAX_VALUE ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; }
function binomialCoeff ( n , k ) { if ( k > n ) return 0 ; if ( k == 0 k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }
function binomialCoeff ( n , k ) { let C = new Array ( k + 1 ) ; C . fill ( 0 ) ; C [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
function lbs ( arr , n ) { let i , j ; let lis = new Array ( n ) for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; let lds = new Array ( n ) ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; let max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }
function isSubsetSum ( set , n , sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
function countNonDecreasing ( n ) { let dp = new Array ( 10 ) ; for ( let i = 0 ; i < 10 ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; } for ( let i = 0 ; i < 10 ; i ++ ) { for ( let j = 0 ; j < n + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < 10 ; i ++ ) dp [ i ] [ 1 ] = 1 ; for ( let digit = 0 ; digit <= 9 ; digit ++ ) { for ( let len = 2 ; len <= n ; len ++ ) { for ( let x = 0 ; x <= digit ; x ++ ) dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] ; } } let count = 0 ; for ( let i = 0 ; i < 10 ; i ++ ) count += dp [ i ] [ n ] ; return count ; }
function countNonDecreasing ( n ) { let N = 10 ; let count = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { count *= ( N + i - 1 ) ; count = Math . floor ( count / i ) ; } return count ; }
function getMinSquares ( n ) { if ( n <= 3 ) return n ; let res = n ; for ( let x = 1 ; x <= n ; x ++ ) { let temp = x * x ; if ( temp > n ) break ; else res = Math . min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; }
function getMinSquares ( n ) { if ( n <= 3 ) return n ; var dp = new Array ( n + 1 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( var i = 4 ; i <= n ; i ++ ) { dp [ i ] = i ; for ( var x = 1 ; x <= Math . ceil ( Math . sqrt ( i ) ) ; x ++ ) { var temp = x * x ; if ( temp > i ) break ; else dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } } var res = dp [ n ] ; return res ; }
function minCoins ( coins , m , V ) { if ( V == 0 ) return 0 ; let res = Number . MAX_VALUE ; for ( let i = 0 ; i < m ; i ++ ) { if ( coins [ i ] <= V ) { let sub_res = minCoins ( coins , m , V - coins [ i ] ) ; if ( sub_res != Number . MAX_VALUE && sub_res + 1 < res ) res = sub_res + 1 ; } } return res ; }
function minCoins ( coins , m , v ) { let table = new Array ( V + 1 ) ; for ( let i = 0 ; i < V + 1 ; i ++ ) { table [ i ] = 0 ; } for ( let i = 1 ; i <= V ; i ++ ) { table [ i ] = Number . MAX_VALUE ; } for ( let i = 1 ; i <= V ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) if ( coins [ j ] <= i ) { let sub_res = table [ i - coins [ j ] ] ; if ( sub_res != Number . MAX_VALUE && sub_res + 1 < table [ i ] ) table [ i ] = sub_res + 1 ; } } if ( table [ V ] == Number . MAX_VALUE ) return - 1 ; return table [ V ] ; }
function superSeq ( X , Y , m , n ) { if ( m == 0 ) return n ; if ( n == 0 ) return m ; if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ; return 1 + Math . min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ; }
function superSeq ( X , Y , m , n ) { var dp = Array ( m + 1 ) . fill ( 0 ) . map ( x => Array ( n + 1 ) . fill ( 0 ) ) ; for ( var i = 0 ; i <= m ; i ++ ) { for ( var j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; }
function sumOfDigitsFrom1ToN ( n ) { if ( n < 10 ) return ( n * ( n + 1 ) / 2 ) ; let d = parseInt ( Math . log ( n ) / Math . log ( 10 ) , 10 ) ; let a = new Array ( d + 1 ) ; a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( let i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * parseInt ( Math . ceil ( Math . pow ( 10 , i - 1 ) ) , 10 ) ; let p = parseInt ( Math . ceil ( Math . pow ( 10 , d ) ) , 10 ) ; let msd = parseInt ( n / p , 10 ) ; return ( msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ) ; }
function countWays ( N ) { if ( N == 1 ) return 4 ; let countB = 1 , countS = 1 , prev_countB , prev_countS ; for ( let i = 2 ; i <= N ; i ++ ) { prev_countB = countB ; prev_countS = countS ; countS = prev_countB + prev_countS ; countB = prev_countS ; } let result = countS + countB ; return ( result * result ) ; }
function findoptimal ( N ) { if ( N <= 6 ) return N ; let max = 0 ; let b ; for ( b = N - 3 ; b >= 1 ; b -- ) { let curr = ( N - b - 1 ) * findoptimal ( b ) ; if ( curr > max ) max = curr ; } return max ; }
function findoptimal ( N ) { if ( N <= 6 ) return N ; let screen = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { screen [ i ] = 0 ; } let b ; let n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = 0 ; for ( b = n - 3 ; b >= 1 ; b -- ) { let curr = ( n - b - 1 ) * screen [ b - 1 ] ; if ( curr > screen [ n - 1 ] ) screen [ n - 1 ] = curr ; } } return screen [ N - 1 ] ; }
function findoptimal ( N ) { if ( N <= 6 ) return N ; let screen = [ ] ; let b ; let n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = Math . max ( 2 * screen [ n - 4 ] , Math . max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; } return screen [ N - 1 ] ; }
function count ( n ) { let table = new Array ( n + 1 ) , i ; for ( let j = 0 ; j < n + 1 ; j ++ ) table [ j ] = 0 ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; }
function search ( txt , pat ) { let M = pat . length ; let N = txt . length ; for ( let i = 0 ; i <= N - M ; i ++ ) { let j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) document . write ( " " + i + " " ) ; } }
function search ( pat , txt ) { let M = pat . length ; let N = txt . length ; let i = 0 ; while ( i <= N - M ) { let j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) { document . write ( " " + i + " " ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } }
function power ( x , y ) { var temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; }
function power ( x , y ) { var temp ; if ( y == 0 ) return 1 ; temp = power ( x , parseInt ( y / 2 ) ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } }
function power ( x , y ) { if ( y == 0 ) return 1 ; if ( x == 0 ) return 0 ; return x * power ( x , y - 1 ) ; }
function isLucky ( n ) { let counter = 2 ; let next_position = n ; if ( counter > n ) return 1 ; if ( n % counter == 0 ) return 0 ; next_position -= Math . floor ( next_position / counter ) ; counter ++ ; return isLucky ( next_position ) ; }
function pow ( a , b ) { if ( b == 0 ) return 1 ; var answer = a ; var increment = a ; var i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; }
function count ( n ) { if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ; var po = 1 ; while ( parseInt ( n / po ) > 9 ) po = po * 10 ; var msd = parseInt ( n / po ) ; if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ; else return count ( msd * po - 1 ) ; }
function binomialCoeff ( n , k ) { let res = 1 ; if ( k > n - k ) k = n - k ; for ( let i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
function printPascal ( n ) { arr = a = Array ( n ) . fill ( 0 ) . map ( x => Array ( n ) . fill ( 0 ) ) ; for ( line = 0 ; line < n ; line ++ ) { for ( i = 0 ; i <= line ; i ++ ) { if ( line == i i == 0 ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ; document . write ( arr [ line ] [ i ] ) ; } document . write ( " " ) ; } }
function printPascal ( n ) { for ( line = 1 ; line <= n ; line ++ ) { var C = 1 ; for ( i = 1 ; i <= line ; i ++ ) { document . write ( C + " " ) ; C = C * ( line - i ) / i ; } document . write ( " " ) ; } }
function exponential ( n , x ) { var sum = 1 ; for ( i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; }
function findgroups ( arr , n ) { let c = [ 0 , 0 , 0 ] ; let i ; let res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * Math . floor ( ( c [ 0 ] - 2 ) ) / 6 ) ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * Math . floor ( ( c [ 1 ] - 2 ) ) / 6 ) ; res += ( Math . floor ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; }
function findTrailingZeros ( n ) { let count = 0 ; for ( let i = 5 ; Math . floor ( n / i ) >= 1 ; i *= 5 ) count += Math . floor ( n / i ) ; return count ; }
function catalanDP ( n ) { let catalan = [ ] ; catalan [ 0 ] = catalan [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( let j = 0 ; j < i ; j ++ ) catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } return catalan [ n ] ; }
function catalan ( n ) { let cat_ = 1 ; document . write ( cat_ + " " ) ; for ( let i = 1 ; i < n ; i ++ ) { cat_ *= ( 4 * i - 2 ) ; cat_ /= ( i + 1 ) ; document . write ( cat_ + " " ) ; } }
function find ( p ) { return Math . ceil ( Math . sqrt ( 2 * 365 * Math . log ( 1 / ( 1 - p ) ) ) ) ; }
function countSolutions ( n ) { let res = 0 ; for ( let x = 0 ; x * x < n ; x ++ ) { for ( let y = 0 ; x * x + y * y < n ; y ++ ) { res ++ ; } } return res ; }
function countSolutions ( n ) { let x = 0 , yCount , res = 0 ; for ( yCount = 0 ; yCount * yCount < n ; yCount ++ ) ; while ( yCount != 0 ) { res += yCount ; x ++ ; while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount -- ; } return res ; }
function getSingle ( arr , n ) { let ones = 0 , twos = 0 ; let common_bit_mask ; for ( let i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; }
function getSingle ( arr , n ) { let result = 0 ; let x , sum ; for ( let i = 0 ; i < INT_SIZE ; i ++ ) { sum = 0 ; x = ( 1 << i ) ; for ( let j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & x ) sum ++ ; } if ( ( sum % 3 ) != 0 ) result |= x ; } return result ; }
function oppositeSigns ( x , y ) { return ( ( x ^ y ) < 0 ) ; }
function countSetBits ( n ) { let i = 0 ; let ans = 0 ; while ( ( 1 << i ) <= n ) { let k = 0 ; let change = 1 << i ; for ( let j = 0 ; j <= n ; j ++ ) { ans += k ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; }
function getSetBitsFromOneToN ( N ) { var two = 2 var ans = 0 var n = N while ( n != 0 ) { ans += Math . floor ( N / two ) * ( two >> 1 ) if ( ( N & ( two - 1 ) ) > ( two >> 1 ) - 1 ) ans += ( N & ( two - 1 ) ) - ( two >> 1 ) + 1 two <<= 1 ; n >>= 1 ; } return ans }
function swapBits ( x , p1 , p2 , n ) { let set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ; let set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ; let xor = ( set1 ^ set2 ) ; xor = ( xor << p1 ) | ( xor << p2 ) ; let result = x ^ xor ; return result ; }
function swapBits ( num , p1 , p2 , n ) { let shift1 , shift2 , value1 , value2 ; while ( n -- > 0 ) { shift1 = 1 << p1 ; shift2 = 1 << p2 ; value1 = ( ( num & shift1 ) ) ; value2 = ( ( num & shift2 ) ) ; if ( ( value1 == 0 && value2 != 0 ) || ( value2 == 0 && value1 != 0 ) ) { if ( value1 != 0 ) { num = num & ( ~ shift1 ) ; num = num | shift2 ; } else { num = num & ( ~ shift2 ) ; num = num | shift1 ; } } p1 ++ ; p2 ++ ; } return num ; }
function Add ( x , y ) { while ( y != 0 ) { let carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; }
function smallest ( x , y , z ) { let c = 0 ; while ( x && y && z ) { x -- ; y -- ; z -- ; c ++ ; } return c ; }
function smallest ( x , y , z ) { if ( ! ( y / x ) ) return ( ! ( y / z ) ) ? y : z ; return ( ! ( x / z ) ) ? x : z ; }
function snoob ( x ) { let rightOne , nextHigherOneBit , rightOnesPattern , next = 0 ; if ( x > 0 ) { rightOne = x & - x ; nextHigherOneBit = x + rightOne ; rightOnesPattern = x ^ nextHigherOneBit ; rightOnesPattern = ( rightOnesPattern ) / rightOne ; rightOnesPattern >>= 2 ; next = nextHigherOneBit | rightOnesPattern ; } return next ; }
function addOne ( x ) { let m = 1 ; while ( x & m ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
function addOne ( x ) { return ( - ( ~ x ) ) ; }
function multiplyWith3Point5 ( x ) { return ( x << 1 ) + x + ( x >> 1 ) ; }
function fun ( n ) { return n & ( n - 1 ) ; }
function isPowerOfFour ( n ) { let count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % 2 == 0 ) ? 1 : 0 ; } return 0 ; }
function isPowerOfFour ( n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ! ( n & 0xAAAAAAAA ) ; }
function getModulo ( n , d ) { return ( n & ( d - 1 ) ) ; }
function getOddOccurrence ( arr , arr_size ) { for ( let i = 0 ; i < arr_size ; i ++ ) { let count = 0 ; for ( let j = 0 ; j < arr_size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count % 2 != 0 ) return arr [ i ] ; } return - 1 ; }
function countSetBits ( n ) { var count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; }
function countSetBits ( n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; }
function countSetBitsRec ( num ) { var nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; }
function countSetBits ( N ) { var count = 0 ; for ( i = 0 ; i < 4 * 8 ; i ++ ) { if ( ( N & ( 1 << i ) ) != 0 ) count ++ ; } return count ; }
function nextPowerOf2 ( n ) { var count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
function nextPowerOf2 ( n ) { p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; }
function nextPowerOf2 ( n ) { n -= 1 n |= n >> 1 n |= n >> 2 n |= n >> 4 n |= n >> 8 n |= n >> 16 n += 1 return n }
function getParity ( n ) { var parity = false ; while ( n != 0 ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; }
function isPowerOfTwo ( n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 2 != 0 ) return 0 ; n = n / 2 ; } return 1 ; }
function powerOf2 ( n ) { if ( n == 1 ) return true ; else if ( n % 2 != 0 n == 0 ) return false ; return powerOf2 ( n / 2 ) ; }
function isPowerOfTwo ( x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }
function PositionRightmostSetbit ( n ) { let position = 1 ; let m = 1 ; while ( ( n & m ) == 0 ) { m = m << 1 ; position ++ ; } return position ; }
function Last_set_bit ( n ) { let p = 1 ; while ( n > 0 ) { if ( ( n & 1 ) > 0 ) { return p ; } p ++ ; n = n >> 1 ; } return - 1 ; } let n = 18 ; let pos = Last_set_bit ( n ) ; if ( pos != - 1 ) { document . write ( pos ) ; } else { document . write ( 0 ) ; }
function bin ( n ) { let i ; document . write ( " " ) ; for ( i = 1 << 30 ; i > 0 ; i = Math . floor ( i / 2 ) ) { if ( ( n & i ) != 0 ) { document . write ( " " ) ; } else { document . write ( " " ) ; } } }
function bin ( n ) { if ( n > 1 ) bin ( n >> 1 ) ; document . write ( n & 1 ) ; }
function swapBits ( x ) { even_bits = x & 0xAAAAAAAA ; odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return ( even_bits odd_bits ) ; }
function swap ( xp , yp ) { xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; }
function swap ( a , b ) { a = ( a & b ) + ( a b ) ; b = a + ( ~ b ) + 1 ; a = a + ( ~ b ) + 1 ; document . write ( " " + a + " " + b ) ; }
function checkSentence ( str ) { var len = str . length ; if ( str [ 0 ] . charCodeAt ( 0 ) < " " . charCodeAt ( 0 ) || str [ 0 ] . charCodeAt ( 0 ) > " " . charCodeAt ( 0 ) ) return false ; if ( str [ len - 1 ] !== " " ) return false ; var prev_state = 0 , curr_state = 0 ; var index = 1 ; while ( index <= str . length ) { if ( str [ index ] . charCodeAt ( 0 ) >= " " . charCodeAt ( 0 ) && str [ index ] . charCodeAt ( 0 ) <= " " . charCodeAt ( 0 ) ) curr_state = 0 ; else if ( str [ index ] === " " ) curr_state = 1 ; else if ( str [ index ] . charCodeAt ( 0 ) >= " " . charCodeAt ( 0 ) && str [ index ] . charCodeAt ( 0 ) <= " " . charCodeAt ( 0 ) ) curr_state = 2 ; else if ( str [ index ] === " " ) curr_state = 3 ; if ( prev_state === curr_state && curr_state !== 2 ) return false ; if ( prev_state === 2 && curr_state === 0 ) return false ; if ( curr_state === 3 && prev_state !== 1 ) return index + 1 == str . length ; index ++ ; prev_state = curr_state ; } return false ; } var str = [ " " , " " , " " , " " , " " , " " , " " , " " , " " , ] ; var str_size = str . length ; var i = 0 ; for ( i = 0 ; i < str_size ; i ++ ) { var temp = str [ i ] . split ( " " ) ; if ( checkSentence ( temp ) ) document . write ( ' ' + str [ i ] + ' ' + " " + " " ) ; else document . write ( ' ' + str [ i ] + ' ' + " " + " " ) ; }
function maxOnesIndex ( arr , n ) { let max_count = 0 ; let max_index = 0 ; let prev_zero = - 1 ; let prev_prev_zero = - 1 ; for ( let curr = 0 ; curr < n ; ++ curr ) { if ( arr [ curr ] == 0 ) { if ( curr - prev_prev_zero > max_count ) { max_count = curr - prev_prev_zero ; max_index = prev_zero ; } prev_prev_zero = prev_zero ; prev_zero = curr ; } } if ( n - prev_prev_zero > max_count ) max_index = prev_zero ; return max_index ; }
function isSubSequence ( str1 , str2 , m , n ) { if ( m == 0 ) return true ; if ( n == 0 ) return false ; if ( str1 [ m - 1 ] == str2 [ n - 1 ] ) return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) ; return isSubSequence ( str1 , str2 , m , n - 1 ) ; }
function segregate0and1 ( arr , size ) { let left = 0 , right = size - 1 ; while ( left < right ) { while ( arr [ left ] == 0 && left < right ) left ++ ; while ( arr [ right ] == 1 && left < right ) right -- ; if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } }
function segregate0and1 ( arr , size ) { let type0 = 0 ; let type1 = size - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { arr [ type1 ] = arr [ type1 ] + arr [ type0 ] ; arr [ type0 ] = arr [ type1 ] - arr [ type0 ] ; arr [ type1 ] = arr [ type1 ] - arr [ type0 ] ; type1 -- ; } else type0 ++ ; } }
function maxSubarrayProduct ( arr , n ) { let result = arr [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) { let mul = arr [ i ] ; for ( let j = i + 1 ; j < n ; j ++ ) { result = Math . max ( result , mul ) ; mul *= arr [ j ] ; } result = Math . max ( result , mul ) ; } return result ; }
function maxSum ( arr , n ) { let sum = 0 ; arr . sort ( ) ; for ( let i = 0 ; i < n / 2 ; i ++ ) { sum -= ( 2 * arr [ i ] ) ; sum += ( 2 * arr [ n - i - 1 ] ) ; } return sum ; }
function replace_elements ( arr , n ) { let pos = 0 ; for ( let i = 0 ; i < n ; i ++ ) { arr [ pos ++ ] = arr [ i ] ; while ( pos > 1 && arr [ pos - 2 ] == arr [ pos - 1 ] ) { pos -- ; arr [ pos - 1 ] ++ ; } } for ( let i = 0 ; i < pos ; i ++ ) document . write ( arr [ i ] + " " ) ; }
function rearrange ( arr , n ) { if ( arr == null n % 2 == 1 ) return ; let currIdx = Math . floor ( ( n - 1 ) / 2 ) ; while ( currIdx > 0 ) { let count = currIdx , swapIdx = currIdx ; while ( count -- > 0 ) { let temp = arr [ swapIdx + 1 ] ; arr [ swapIdx + 1 ] = arr [ swapIdx ] ; arr [ swapIdx ] = temp ; swapIdx ++ ; } currIdx -- ; } }
function maxDiff ( arr , arr_size ) { let max_diff = arr [ 1 ] - arr [ 0 ] ; for ( let i = 0 ; i < arr_size ; i ++ ) { for ( let j = i + 1 ; j < arr_size ; j ++ ) { if ( arr [ j ] - arr [ i ] > max_diff ) max_diff = arr [ j ] - arr [ i ] ; } } return max_diff ; }
function maxDiff ( arr , n ) { let maxDiff = - 1 ; let maxRight = arr [ n - 1 ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > maxRight ) maxRight = arr [ i ] ; else { let diff = maxRight - arr [ i ] ; if ( diff > maxDiff ) { maxDiff = diff ; } } } return maxDiff ; }
function maxDiff ( arr , n ) { let diff = arr [ 1 ] - arr [ 0 ] ; let curr_sum = diff ; let max_sum = curr_sum ; for ( let i = 1 ; i < n - 1 ; i ++ ) { diff = arr [ i + 1 ] - arr [ i ] ; if ( curr_sum > 0 ) curr_sum += diff ; else curr_sum = diff ; if ( curr_sum > max_sum ) max_sum = curr_sum ; } return max_sum ; }
function maxIndexDiff ( arr , n ) { let maxDiff = - 1 ; let i , j ; for ( i = 0 ; i < n ; ++ i ) { for ( j = n - 1 ; j > i ; -- j ) { if ( arr [ j ] > arr [ i ] && maxDiff < ( j - i ) ) maxDiff = j - i ; } } return maxDiff ; }
function findMaximum ( arr , low , high ) { var max = arr [ low ] ; var i ; for ( i = low + 1 ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; else break ; } return max ; }
function findMaximum ( arr , low , high ) { if ( low == high ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ; return findMaximum ( arr , mid + 1 , high ) ; }
function maxRepeating ( arr , n , k ) { for ( let i = 0 ; i < n ; i ++ ) arr [ arr [ i ] % k ] += k ; let max = arr [ 0 ] , result = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; result = i ; } } return result ; }
function smallestGreater ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { let diff = Number . MAX_VALUE ; let closest = - 1 ; for ( let j = 0 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] && arr [ j ] - arr [ i ] < diff ) { diff = arr [ j ] - arr [ i ] ; closest = j ; } } if ( closest == - 1 ) document . write ( " " ) ; else document . write ( arr [ closest ] + " " ) ; } }
function countIncreasing ( arr , n ) { let cnt = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ j - 1 ] ) cnt ++ ; else break ; } } return cnt ; }
function countIncreasing ( n ) { let cnt = 0 ; let len = 1 ; for ( let i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] > arr [ i ] ) len ++ ; else { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; }
function minNumber ( a , n , x ) { a . sort ( ) ; let k ; for ( k = 0 ; a [ parseInt ( ( n - 1 ) / 2 , 10 ) ] != x ; k ++ ) { a [ n ++ ] = x ; a . sort ( ) ; } return k ; }
function minNumber ( a , n , x ) { let l = 0 , h = 0 , e = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == x ) e ++ ; else if ( a [ i ] > x ) h ++ ; else if ( a [ i ] < x ) l ++ ; } let ans = 0 ; if ( l > h ) ans = l - h ; else if ( l < h ) ans = h - l - 1 ; return ans + 1 - e ; }
function checkEVENodd ( arr , n , l , r ) { if ( arr [ r ] == 1 ) document . write ( " " ) ; else document . write ( " " ) ; }
function findMean ( arr , l , r ) { let sum = 0 , count = 0 ; for ( let i = l ; i <= r ; i ++ ) { sum += arr [ i ] ; count ++ ; } let mean = Math . floor ( sum / count ) ; return mean ; }
function calculateProduct ( A , L , R , P ) { L = L - 1 ; R = R - 1 ; let ans = 1 ; for ( let i = L ; i <= R ; i ++ ) { ans = ans * A [ i ] ; ans = ans % P ; } return ans ; }
function countDe ( arr , n ) { let v = [ ] ; for ( let i = 0 ; i < n ; i ++ ) v [ i ] = arr [ i ] ; arr . sort ( ) ; let count1 = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count1 ++ ; arr . reverse ( ) ; let count2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count2 ++ ; return ( Math . min ( count1 , count2 ) ) ; }
function maxOfSegmentMins ( a , n , k ) { if ( k == 1 ) { a . sort ( ) ; return a [ 0 ] ; } if ( k == 2 ) return Math . max ( a [ 0 ] , a [ n - 1 ] ) ; return a [ n - 1 ] ; }
function printMinimumProduct ( arr , n ) { let first_min = Math . min ( arr [ 0 ] , arr [ 1 ] ) ; let second_min = Math . max ( arr [ 0 ] , arr [ 1 ] ) ; for ( let i = 2 ; i < n ; i ++ ) { if ( arr [ i ] < first_min ) { second_min = first_min ; first_min = arr [ i ] ; } else if ( arr [ i ] < second_min ) second_min = arr [ i ] ; } return first_min * second_min ; }
function noOfTriples ( arr , n ) { arr . sort ( ) ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] == arr [ 2 ] ) count ++ ; if ( arr [ 0 ] == arr [ 2 ] ) return ( count - 2 ) * ( count - 1 ) * ( count ) / 6 ; else if ( arr [ 1 ] == arr [ 2 ] ) return ( count - 1 ) * ( count ) / 2 ; return count ; }
function MinOperation ( a , b , n ) { a . sort ( function ( a , b ) { return a - b } ) ; b . sort ( function ( a , b ) { return a - b } ) ; let result = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( a [ i ] > b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; else if ( a [ i ] < b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; } return result ; }
function sortExceptUandL ( a , l , u , n ) { let b = [ ] ; for ( let i = 0 ; i < l ; i ++ ) b [ i ] = a [ i ] ; for ( let i = u + 1 ; i < n ; i ++ ) b [ l + ( i - ( u + 1 ) ) ] = a [ i ] ; b . sort ( ) ; for ( let i = 0 ; i < l ; i ++ ) a [ i ] = b [ i ] ; for ( let i = u + 1 ; i < n ; i ++ ) a [ i ] = b [ l + ( i - ( u + 1 ) ) ] ; }
function sortExceptK ( arr , k , n ) { let temp = arr [ k ] ; arr [ k ] = arr [ n - 1 ] ; arr [ n - 1 ] = temp ; arr . sort ( function ( a , b ) { return a - b } ) ; let last = arr [ n - 1 ] ; for ( let i = n - 1 ; i > k ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ k ] = last ; temp = arr [ k ] ; arr [ k ] = arr [ n - 1 ] ; arr [ n - 1 ] = temp ; return 0 ; }
function minswaps ( arr , n ) { var count = 0 ; var num_unplaced_zeros = 0 ; for ( var index = n - 1 ; index >= 0 ; index -- ) { if ( arr [ index ] == 0 ) num_unplaced_zeros += 1 ; else count += num_unplaced_zeros ; } return count ; }
function printRepeating ( arr , size ) { var s = new Set ( arr ) ; [ ... s ] . sort ( ( a , b ) => a - b ) . forEach ( x => { document . write ( x + " " ) } ) ; }
function maxPartitions ( arr , n ) { let ans = 0 , max_so_far = 0 ; for ( let i = 0 ; i < n ; ++ i ) { max_so_far = Math . max ( max_so_far , arr [ i ] ) ; if ( max_so_far == i ) ans ++ ; } return ans ; }
function min_noOf_operation ( arr , n , k ) { let noOfSubtraction ; let res = 0 ; for ( let i = 1 ; i < n ; i ++ ) { noOfSubtraction = 0 ; if ( arr [ i ] > arr [ i - 1 ] ) { noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) noOfSubtraction ++ ; arr [ i ] = arr [ i ] - k * noOfSubtraction ; } res = res + noOfSubtraction ; } return res ; }
function maxSum ( arr , n ) { arr . sort ( ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += ( arr [ i ] * i ) ; return sum ; }
function countPairs ( a , n , k ) { var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( a [ j ] - a [ i ] ) < k ) res ++ ; return res ; }
function countPairs ( a , n , k ) { a . sort ( ( a , b ) => a - b ) ; let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let j = i + 1 ; while ( j < n && a [ j ] - a [ i ] < k ) { res ++ ; j ++ ; } } return res ; }
function findMaxPairs ( a , b , n , k ) { a . sort ( function ( c , d ) { return c - d ; } ) ; b . sort ( function ( c , d ) { return c - d ; } ) let flag = new Array ( n ) ; for ( let i = 0 ; i < flag . length ; i ++ ) { flag [ i ] = false ; } let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( Math . abs ( a [ i ] - b [ j ] ) <= k && flag [ j ] == false ) { result ++ ; flag [ j ] = true ; break ; } } } return result ; }
function findMaxPairs ( a , b , n , k ) { a . sort ( function ( a , b ) { return a - b } ) ; b . sort ( function ( a , b ) { return a - b } ) ; let result = 0 ; for ( let i = 0 , j = 0 ; i < n && j < n ; ) { if ( Math . abs ( a [ i ] - b [ j ] ) <= k ) { result ++ ; i ++ ; j ++ ; } else if ( a [ i ] > b [ j ] ) j ++ ; else i ++ ; } return result ; }
function sumOfMinAbsDifferences ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let sum = 0 ; sum += Math . abs ( arr [ 0 ] - arr [ 1 ] ) ; sum += Math . abs ( arr [ n - 1 ] - arr [ n - 2 ] ) ; for ( let i = 1 ; i < n - 1 ; i ++ ) sum += Math . min ( Math . abs ( arr [ i ] - arr [ i - 1 ] ) , Math . abs ( arr [ i ] - arr [ i + 1 ] ) ) ; return sum ; }
function findSmallestDifference ( A , B , m , n ) { A . sort ( ( a , b ) => a - b ) ; B . sort ( ( a , b ) => a - b ) ; let a = 0 , b = 0 ; let result = Number . MAX_SAFE_INTEGER ; while ( a < m && b < n ) { if ( Math . abs ( A [ a ] - B [ b ] ) < result ) result = Math . abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; }
function arraySortedOrNot ( arr , n ) { if ( n == 0 n == 1 ) return true ; for ( let i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; }
function findLarger ( arr , n ) { arr . sort ( ) ; for ( let i = n - 1 ; i >= n / 2 ; i -- ) document . write ( arr [ i ] + " " ) ; }
function singleelement ( arr , n ) { let low = 0 , high = n - 2 ; let mid ; while ( low <= high ) { mid = ( low + high ) / 2 ; if ( arr [ mid ] == arr [ mid ^ 1 ] ) { low = mid + 1 ; } else { high = mid - 1 ; } } return arr [ low ] ; }
function countTriplets ( n , sum ) { let ans = 0 ; for ( let i = 0 ; i < n - 2 ; i ++ ) { for ( let j = i + 1 ; j < n - 1 ; j ++ ) { for ( let k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] < sum ) ans ++ ; } } return ans ; }
function countTriplets ( n , sum ) { arr . sort ( function ( a , b ) { return b - a } ) ; let ans = 0 ; for ( let i = 0 ; i < n - 2 ; i ++ ) { let j = i + 1 , k = n - 1 ; while ( j < k ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) k -- ; else { ans += ( k - j ) ; j ++ ; } } } return ans ; }
function countTriplets ( a , n ) { var s = [ ] ; for ( i = 0 ; i < n ; i ++ ) s . push ( a [ i ] ) ; var count = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { var xr = a [ i ] ^ a [ j ] ; if ( s . includes ( xr ) && xr != a [ i ] && xr != a [ j ] ) count ++ ; } } return count / 3 ; }
function getMissingNo ( a ) { let n = a . length ; let i , total = 1 ; for ( i = 2 ; i <= ( n + 1 ) ; i ++ ) { total += i ; total -= a [ i - 2 ] ; } return total ; }
function getMissingNo ( a , n ) { let n_elements_sum = Math . floor ( n * ( n + 1 ) / 2 ) ; let sum = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) sum += a [ i ] ; return n_elements_sum - sum ; }
function countOccurrences ( arr , n , x ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( x == arr [ i ] ) res ++ ; } return res ; }
function printClosest ( arr , n , x ) { let res_l = 0 , res_r = 0 ; let l = 0 , r = n - 1 , diff = Number . MAX_VALUE ; while ( r > l ) { if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } document . write ( " " + arr [ res_l ] + " " + arr [ res_r ] ) ; }
function countOnes ( arr , low , high ) { if ( high >= low ) { let mid = Math . trunc ( low + ( high - low ) / 2 ) ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
function findMissing ( arr1 , arr2 , M , N ) { if ( M != N - 1 && N != M - 1 ) { document . write ( " " ) ; return ; } let res = 0 ; for ( let i = 0 ; i < M ; i ++ ) res = res ^ arr1 [ i ] ; for ( let i = 0 ; i < N ; i ++ ) res = res ^ arr2 [ i ] ; document . write ( " " + res ) ; }
function printTwoOdd ( arr , size ) { let xor2 = arr [ 0 ] ; let set_bit_no ; let i ; int n = size - 2 ; let x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ; set_bit_no = xor2 & ~ ( xor2 - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } document . write ( " " + x + " " + y + " " ) ; }
function findPair ( arr , size , n ) { let i = 0 ; let j = 1 ; while ( i < size && j < size ) { if ( i != j && arr [ j ] - arr [ i ] == n ) { document . write ( " " + arr [ i ] + " " + arr [ j ] + " " ) ; return true ; } else if ( arr [ j ] - arr [ i ] < n ) j ++ ; else i ++ ; } document . write ( " " ) ; return false ; }
function findFourElements ( A , n , X ) { for ( let i = 0 ; i < n - 3 ; i ++ ) { for ( let j = i + 1 ; j < n - 2 ; j ++ ) { for ( let k = j + 1 ; k < n - 1 ; k ++ ) { for ( let l = k + 1 ; l < n ; l ++ ) if ( A [ i ] + A [ j ] + A [ k ] + A [ l ] == X ) document . write ( A [ i ] + " " + A [ j ] + " " + A [ k ] + " " + A [ l ] ) ; } } } }
function search ( arr , n , x ) { let i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + Math . abs ( arr [ i ] - x ) ; } document . write ( " " ) ; return - 1 ; }
function thirdLargest ( arr , arr_size ) { if ( arr_size < 3 ) { document . write ( " " ) ; return ; } let first = arr [ 0 ] ; for ( let i = 1 ; i < arr_size ; i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ; let second = Number . MIN_VALUE ; for ( let i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ; let third = Number . MIN_VALUE ; for ( let i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; document . write ( " " + " " , third ) ; }
function search ( arr , n , x ) { if ( arr [ n - 1 ] == x ) return " " ; let backup = arr [ n - 1 ] ; arr [ n - 1 ] = x ; for ( let i = 0 ; ; i ++ ) { if ( arr [ i ] == x ) { arr [ n - 1 ] = backup ; if ( i < n - 1 ) return " " ; return " " ; } } }
function findMajority ( arr , n ) { return arr [ Math . floor ( n / 2 ) ] ; }
function minAdjDifference ( arr , n ) { if ( n < 2 ) return ; let res = Math . abs ( arr [ 1 ] - arr [ 0 ] ) ; for ( let i = 2 ; i < n ; i ++ ) res = Math . min ( res , Math . abs ( arr [ i ] - arr [ i - 1 ] ) ) ; res = Math . min ( res , Math . abs ( arr [ n - 1 ] - arr [ 0 ] ) ) ; document . write ( " " + res ) ; }
function deleteElement ( arr , n , x ) { let i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) break ; if ( i < n ) { n = n - 1 ; for ( let j = i ; j < n ; j ++ ) arr [ j ] = arr [ j + 1 ] ; } return n ; }
function deleteElement ( arr , n , x ) { if ( arr [ n - 1 ] == x ) return ( n - 1 ) ; let prev = arr [ n - 1 ] , i ; for ( i = n - 2 ; i >= 0 && arr [ i ] != x ; i -- ) { let curr = arr [ i ] ; arr [ i ] = prev ; prev = curr ; } if ( i < 0 ) return 0 ; arr [ i ] = prev ; return ( n - 1 ) ; }
function getInvCount ( arr , n ) { let invcount = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let small = 0 ; for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ; let great = 0 ; for ( let j = i - 1 ; j >= 0 ; j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ; invcount += great * small ; } return invcount ; }
function findWater ( n ) { let left = new Array ( n ) ; let right = new Array ( n ) ; let water = 0 ; left [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) left [ i ] = Math . max ( left [ i - 1 ] , arr [ i ] ) ; right [ n - 1 ] = arr [ n - 1 ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) right [ i ] = Math . max ( right [ i + 1 ] , arr [ i ] ) ; for ( let i = 0 ; i < n ; i ++ ) water += Math . min ( left [ i ] , right [ i ] ) - arr [ i ] ; return water ; }
function findWater ( arr , n ) { let result = 0 ; let left_max = 0 , right_max = 0 ; let lo = 0 , hi = n - 1 ; while ( lo <= hi ) { if ( arr [ lo ] < arr [ hi ] ) { if ( arr [ lo ] > left_max ) left_max = arr [ lo ] ; else result += left_max - arr [ lo ] ; lo ++ ; } else { if ( arr [ hi ] > right_max ) right_max = arr [ hi ] ; else result += right_max - arr [ hi ] ; hi -- ; } } return result ; }
function maxWater ( arr , n ) { let left = 0 ; let right = n - 1 ; let l_max = 0 ; let r_max = 0 ; let result = 0 ; while ( left <= right ) { if ( r_max <= l_max ) { result += Math . max ( 0 , r_max - arr [ right ] ) ; r_max = Math . max ( r_max , arr [ right ] ) ; right -= 1 ; } else { result += Math . max ( 0 , l_max - arr [ left ] ) ; l_max = Math . max ( l_max , arr [ left ] ) ; left += 1 ; } } return result ; }
function missingK ( a , k , n ) { let difference = 0 , ans = 0 , count = k ; let flag = false ; for ( let i = 0 ; i < n - 1 ; i ++ ) { difference = 0 ; if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) { difference += ( a [ i + 1 ] - a [ i ] ) - 1 ; if ( difference >= count ) { ans = a [ i ] + count ; flag = true ; break ; } else count -= difference ; } } if ( flag ) return ans ; else return - 1 ; }
function countPairs ( A , n , k ) { var ans = 0 ; A . sort ( ( a , b ) => a - b ) for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { var x = 0 ; while ( ( A [ i ] * Math . pow ( k , x ) ) <= A [ j ] ) { if ( ( A [ i ] * Math . pow ( k , x ) ) == A [ j ] ) { ans ++ ; break ; } x ++ ; } } } return ans ; }
function findValue ( arr , n , k ) { for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] == k ) k *= 2 ; return k ; }
function dupLastIndex ( arr , n ) { if ( arr == null n <= 0 ) return ; for ( let i = n - 1 ; i > 0 ; i -- ) { if ( arr [ i ] == arr [ i - 1 ] ) { document . write ( " " + i + " " ) ; document . write ( " " + arr [ i ] + " " ) ; return ; } } document . write ( " " ) ; }
function findSmallest ( a , n ) { for ( let i = 0 ; i < n ; i ++ ) { let j ; for ( j = 0 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] >= 1 ) break ; if ( j == n ) return a [ i ] ; } return - 1 ; }
function findIndex ( arr , len ) { let maxIndex = 0 ; for ( let i = 0 ; i < len ; ++ i ) if ( arr [ i ] > arr [ maxIndex ] ) maxIndex = i ; for ( let i = 0 ; i < len ; ++ i ) if ( maxIndex != i && arr [ maxIndex ] < 2 * arr [ i ] ) return - 1 ; return maxIndex ; }
function find_consecutive_steps ( arr , len ) { let count = 0 ; let maximum = 0 ; for ( let index = 1 ; index < len ; index ++ ) { if ( arr [ index ] > arr [ index - 1 ] ) count ++ ; else { maximum = Math . max ( maximum , count ) ; count = 0 ; } } return Math . max ( maximum , count ) ; }
function CalculateMax ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let min_sum = arr [ 0 ] + arr [ 1 ] ; let max_sum = arr [ n - 1 ] + arr [ n - 2 ] ; return ( Math . abs ( max_sum - min_sum ) ) ; }
function calculate ( a , n ) { a . sort ( ) ; let i , j ; let s = [ ] ; for ( i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) s . push ( ( a [ i ] + a [ j ] ) ) ; let mini = Math . min ( ... s ) ; let maxi = Math . max ( ... s ) ; return Math . abs ( maxi - mini ) ; }
function printMinDiffPairs ( arr , n ) { if ( n <= 1 ) return ; arr . sort ( ) ; let minDiff = arr [ 1 ] - arr [ 0 ] ; for ( let i = 2 ; i < n ; i ++ ) minDiff = Math . min ( minDiff , arr [ i ] - arr [ i - 1 ] ) ; for ( let i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] - arr [ i - 1 ] ) == minDiff ) { document . write ( " " + arr [ i - 1 ] + " " + arr [ i ] + " " ) ; } } }
function maxDistance ( array ) { let max1 = Number . MIN_VALUE ; let min1 = Number . MAX_VALUE ; let max2 = Number . MIN_VALUE ; let min2 = Number . MAX_VALUE ; for ( let i = 0 ; i < array . length ; i ++ ) { max1 = Math . max ( max1 , array [ i ] + i ) ; min1 = Math . min ( min1 , array [ i ] + i ) ; max2 = Math . max ( max2 , array [ i ] - i ) ; min2 = Math . min ( min2 , array [ i ] - i ) ; } return Math . max ( max1 - min1 , max2 - min2 ) ; }
function extrema ( a , n ) { let count = 0 ; for ( let i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i ] > a [ i - 1 ] && a [ i ] > a [ i + 1 ] ) count += 1 ; if ( a [ i ] < a [ i - 1 ] && a [ i ] < a [ i + 1 ] ) count += 1 ; } return count ; }
function sum ( a , n ) { let maxSum = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) maxSum = Math . max ( maxSum , a [ i ] + a [ j ] ) ; let c = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( a [ i ] + a [ j ] == maxSum ) c ++ ; return c ; }
function nobleInteger ( arr ) { let size = arr . length ; for ( let i = 0 ; i < size ; i ++ ) { let count = 0 ; for ( let j = 0 ; j < size ; j ++ ) if ( arr [ i ] < arr [ j ] ) count ++ ; if ( count == arr [ i ] ) return arr [ i ] ; } return - 1 ; }
function nobleInteger ( arr ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; let n = arr . length ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue ; if ( arr [ i ] == n - i - 1 ) return arr [ i ] ; } if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ; return - 1 ; }
function findMinSum ( a , b , n ) { a . sort ( ) ; b . sort ( ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum = sum + Math . abs ( a [ i ] - b [ i ] ) ; return sum ; }
function checkIsAP ( arr , n ) { if ( n == 1 ) return true ; arr . sort ( ( a , b ) => a - b ) ; let d = arr [ 1 ] - arr [ 0 ] ; for ( let i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }
function deleteAlt ( head ) { if ( head == null ) return ; var node = head . next ; if ( node == null ) return ; head . next = node . next ; head . next = deleteAlt ( head . next ) ; }
function rotate ( arr , N , X ) { let nextPower = 1 ; while ( nextPower <= N ) nextPower *= 2 ; if ( X == 1 ) return nextPower - N ; let prevPower = nextPower / 2 ; return 2 * ( N - prevPower ) + 1 ; }
function findLargestRotation ( num ) { let ans = num ; let len = Math . floor ( Math . log10 ( num ) + 1 ) ; let x = Math . pow ( 10 , len - 1 ) ; for ( let i = 1 ; i < len ; i ++ ) { let lastDigit = num % 10 ; num = parseInt ( num / 10 ) ; num += ( lastDigit * x ) ; if ( num > ans ) { ans = num ; } } document . write ( ans ) ; }
function getFirstElement ( a , N , K , M ) { K %= N ; let index ; if ( K >= M ) index = ( N - K ) + ( M - 1 ) ; else index = ( M - K - 1 ) ; let result = a [ index ] ; return result ; }
function getFirstElement ( a , N , K , M ) { K %= N ; var index = ( K + M - 1 ) % N ; var result = a [ index ] ; return result ; }
function countRotation ( arr , n ) { for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { return i ; } } return 0 ; }
function isConversionPossible ( s1 , s2 , x ) { let diff = 0 , n ; n = s1 . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( s1 [ i ] == s2 [ i ] ) continue ; diff = ( ( s2 [ i ] . charCodeAt ( 0 ) - s1 [ i ] . charCodeAt ( 0 ) ) + 26 ) % 26 ; if ( diff > x ) { document . write ( " " ) ; return ; } } document . write ( " " ) ; }
function RightRotate ( a , n , k ) { k = k % n ; for ( let i = 0 ; i < n ; i ++ ) { if ( i < k ) { document . write ( a [ n + i - k ] + " " ) ; } else { document . write ( ( a [ i - k ] ) + " " ) ; } } document . write ( " " ) ; }
function countRotation ( n ) { let count = 0 ; do { let digit = n % 10 ; if ( digit == 0 ) count ++ ; n = parseInt ( n / 10 ) ; } while ( n != 0 ) ; return count ; }
function performQueries ( str , n , queries , q ) { var ptr = 0 ; for ( var i = 0 ; i < q ; i ++ ) { if ( queries [ i ] [ 0 ] == 1 ) { ptr = ( ptr + queries [ i ] [ 1 ] ) % n ; } else { var k = queries [ i ] [ 1 ] ; var index = ( ptr + k - 1 ) % n ; document . write ( str [ index ] + " " ) ; } } }
function countOddRotations ( n ) { var odd_count = 0 , even_count = 0 ; do { var digit = n % 10 ; if ( digit % 2 == 1 ) odd_count ++ ; else even_count ++ ; n = parseInt ( n / 10 ) ; } while ( n != 0 ) ; document . write ( " " + odd_count + " " ) ; document . write ( " " + even_count + " " ) ; }
function generateNumbers ( m ) { let numbers = [ ] ; let k_max , x ; for ( let y = 0 ; y < 10 ; y ++ ) { k_max = Math . floor ( ( Math . pow ( 10 , m - 2 ) * ( 10 * y + 1 ) ) / Math . floor ( Math . pow ( 10 , m - 1 ) + y ) ) ; for ( let k = 1 ; k <= k_max ; k ++ ) { x = Math . floor ( ( y * ( Math . pow ( 10 , m - 1 ) - k ) ) / ( 10 * k - 1 ) ) ; if ( Math . floor ( ( y * ( Math . pow ( 10 , m - 1 ) - k ) ) % ( 10 * k - 1 ) ) == 0 ) numbers . push ( 10 * x + y ) ; } } numbers . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < numbers . length ; i ++ ) document . write ( numbers [ i ] + " " ) ; }
function rotate90Clockwise ( arr ) { for ( j = 0 ; j < N ; j ++ ) { for ( i = N - 1 ; i >= 0 ; i -- ) document . write ( arr [ i ] [ j ] + " " ) ; document . write ( " " ) ; } }
function occurredOnce ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; if ( arr [ 0 ] != arr [ 1 ] ) document . write ( arr [ 0 ] + " " ) ; for ( let i = 1 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i - 1 ] ) document . write ( arr [ i ] + " " ) ; if ( arr [ n - 2 ] != arr [ n - 1 ] ) document . write ( arr [ n - 1 ] + " " ) ; }
function occurredOnce ( arr , n ) { var i = 1 , len = n ; if ( arr [ 0 ] == arr [ len - 1 ] ) { i = 2 ; len -- ; } for ( ; i < n ; i ++ ) if ( arr [ i ] == arr [ i - 1 ] ) i ++ ; else document . write ( arr [ i - 1 ] + " " ) ; if ( arr [ n - 1 ] != arr [ 0 ] && arr [ n - 1 ] != arr [ n - 2 ] ) document . write ( arr [ n - 1 ] ) ; }
function minimunMoves ( arr , n ) { let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { let curr_count = 0 ; let tmp = " " ; for ( let j = 0 ; j < n ; j ++ ) { tmp = arr [ j ] + arr [ j ] ; let index = tmp . indexOf ( arr [ i ] ) ; if ( index == arr [ i ] . length ) return - 1 ; curr_count += index ; } ans = Math . min ( curr_count , ans ) ; } return ans ; }
function isRotation ( x , y ) { var x64 = x | ( x << 32 ) ; while ( x64 >= y ) { if ( x64 == y ) { return true ; } x64 >>= 1 ; } return false ; } var x = 122 ; var y = 2147483678 ; if ( isRotation ( x , y ) == false ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function minLexRotation ( str ) { let n = str . length ; let arr = new Array ( n ) ; let concat = str + str ; for ( let i = 0 ; i < n ; i ++ ) { arr [ i ] = concat . substring ( i , i + n ) ; } arr . sort ( ) ; return arr [ 0 ] ; }
function findPair ( a , n , z ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) if ( i != j && a [ i ] + a [ j ] == z ) return true ; return false ; }
function print ( a , n ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i != j ) document . write ( a [ i ] + " " + a [ j ] + " " ) ; } } }
function linearSearch ( a , n , key ) { for ( var i = 0 ; i < n ; i ++ ) { if ( a [ i ] == key ) return true ; } return false ; }
function NimGame ( N , A , B ) { let sum = A + B ; if ( N % sum <= A - 1 ) return " " ; else return " " ; }
function maximumSum ( arr , N ) { let Sum = 0 ; for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) Sum += ( arr [ i ] - arr [ i - 1 ] ) ; } return Sum ; }
function findWinner ( n , m ) { let X = 0 ; let Y = 0 ; if ( n >= m ) { X = n - 1 ; Y = m ; } else { X = m - 1 ; Y = n ; } if ( X > Y ) document . write ( " " ) ; else if ( Y > X ) document . write ( " " ) ; else document . write ( " " ) ; }
function checkPascaltriangle ( N ) { var x = ( Math . sqrt ( 8 * N + 1 ) - 1 ) / 2 ; if ( Math . ceil ( x ) - x == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function countSubarrays ( arr , n ) { var count = 0 ; var i , j ; for ( i = 0 ; i < n ; i ++ ) { var sum = 0 ; for ( j = i ; j < n ; j ++ ) { if ( ( j - i ) % 2 == 0 ) sum += arr [ j ] ; else sum -= arr [ j ] ; if ( sum == 0 ) count ++ ; } } document . write ( count ) ; }
function checkIfDivisible ( str , num ) { let powerOf2 = ( Math . log ( num ) / Math . log ( 2 ) ) ; if ( str . length < powerOf2 ) return false ; if ( powerOf2 == 0 ) return true ; let i , number = 0 ; let len = str . length ; for ( i = len - powerOf2 ; i < len ; i ++ ) { number += ( str [ i ] - ' ' ) * Math . pow ( 10 , powerOf2 - 1 ) ; powerOf2 -- ; } if ( number % num != 0 ) return false ; else return true ; }
function countNo ( A , N , L , R ) { var ans = L - 1 + N + Math . floor ( ( N - 1 ) / ( A - 1 ) ) ; if ( ans % A == 0 ) { ans = ans + 1 ; } document . write ( ans ) ; }
function check_order ( arr ) { var cnt = 0 ; for ( i = 0 ; i < arr . length - 1 ; i ++ ) { if ( Math . abs ( arr [ i + 1 ] - arr [ i ] ) > 1 ) cnt ++ ; } if ( Math . abs ( arr [ 0 ] - arr [ arr . length - 1 ] ) > 1 ) cnt ++ ; if ( cnt > 1 ) return false ; return true ; }
function getM ( n ) { if ( n == 1 ) return - 1 ; else return n - 2 ; }
function compute ( query ) { var v = Array ( 100001 ) . fill ( 0 ) ; var dp = Array ( 100001 ) . fill ( 0 ) ; v [ 1 ] = 1 , v [ 2 ] = 0 ; dp [ 1 ] = 0 , dp [ 2 ] = 0 ; for ( var i = 3 ; i < 100001 ; i ++ ) { if ( i % 2 != 0 ) { if ( parseInt ( i / 2 ) % 2 == 0 ) { v [ i ] = 1 ; dp [ i ] = dp [ i - 1 ] ; } else { v [ i ] = v [ parseInt ( i / 2 ) ] + 1 ; dp [ i ] = dp [ i - 1 ] + v [ i ] - 1 ; } } else { v [ i ] = 0 ; dp [ i ] = dp [ i - 1 ] ; } } query . forEach ( x => { document . write ( dp [ x ] + " " ) ; } ) ; }
function findSubarrays ( arr , N , K ) { return N - K + 1 ; }
function findCycles ( N ) { let res = 0 ; let finalResult = 0 ; let val = 2 * N - 1 ; let s = val ; res = ( N - 1 ) * ( N - 2 ) ; finalResult = res + s ; return finalResult ; }
function countPairs ( A , B ) { var countY = 0 , countX = ( B - A ) + 1 , next_val = 9 ; while ( next_val <= B ) { if ( next_val >= A ) { countY += 1 ; } next_val = next_val * 10 + 9 ; } return ( countX * countY ) ; }
function solve ( N , M ) { var ans = ( N ) * parseInt ( ( M / 2 ) ) ; if ( M % 2 == 1 ) { ans += parseInt ( ( N + 1 ) / 2 ) ; } document . write ( ans ) ; }
function precompute ( s , K ) { var n = s . length ; for ( var i = 0 ; i < n - 1 ; i ++ ) { cnt [ i + 1 ] = cnt [ i ] + ( s . substring ( i , i + K . length ) == K ) ; } } var s = " " ; var K = " " ; precompute ( s , K ) ; var Q = [ [ 1 , 6 ] , [ 5 , 11 ] ] ; Q . forEach ( ( it ) => { document . write ( cnt [ it [ 1 ] - 1 ] - cnt [ it [ 0 ] - 1 ] + " " ) ; }
function constructArray ( N , K , X ) { let ans = new Array ( K ) . fill ( 0 ) ; ans [ 0 ] = X ; for ( let i = 0 ; i < N ; ++ i ) { document . write ( ans [ i % K ] + " " ) ; } document . write ( " " ) ; }
function formQuadruplets ( arr , n ) { var ans = 0 , pairs = 0 ; pairs = parseInt ( n / 4 ) ; arr . sort ( ) . reverse ( ) ; for ( var i = 0 ; i < n - pairs ; i += 3 ) { ans += arr [ i + 2 ] ; } return ans ; }
function possiblePositions ( n ) { let term1 = Math . pow ( n , 4 ) ; let term2 = Math . pow ( n , 3 ) ; let term3 = Math . pow ( n , 2 ) ; let term4 = n / 3 ; let ans = ( Math . ceil ( term1 / 2 ) ) - ( Math . ceil ( 5 * term2 ) / 3 ) + ( Math . ceil ( 3 * term3 ) / 2 ) - term4 ; return ans ; }
function countIntgralPoints ( x1 , y1 , x2 , y2 ) { document . write ( ( y2 - y1 - 1 ) * ( x2 - x1 - 1 ) ) ; }
function ShortestPalindrome ( s ) { let n = s . length ; let ans = s [ 0 ] . charCodeAt ( ) ; for ( let i = 1 ; i < n ; i ++ ) { ans = Math . min ( ans , s [ i ] . charCodeAt ( ) ) ; } return String . fromCharCode ( ans ) ; }
function printArray ( a , n ) { a . sort ( function ( a , b ) { return a - b ; } ) ; var i = 0 ; var j = n - 1 ; while ( i <= j ) { if ( i == j ) { document . write ( a [ i ] + " " ) ; } else { document . write ( a [ j ] + " " ) ; document . write ( a [ i ] + " " ) ; } i = i + 1 ; j = j - 1 ; } document . write ( " " ) ; }
function SmallestDiv ( n ) { for ( let i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return i ; } } return n ; }
function minimumAdjacentDifference ( a , n , k ) { let minDiff = Number . MAX_VALUE ; for ( let i = 0 ; i <= k ; i ++ ) { let maxDiff = Number . MIN_VALUE ; for ( let j = 0 ; j < n - k - 1 ; j ++ ) { for ( let p = i ; p <= i + j ; p ++ ) { maxDiff = Math . max ( maxDiff , a [ p + 1 ] - a [ p ] ) ; } } minDiff = Math . min ( minDiff , maxDiff ) ; } return minDiff ; }
function maximumArea ( l , b , x , y ) { var left = x * b ; var right = ( l - x - 1 ) * b ; var above = l * y ; var below = ( b - y - 1 ) * l ; document . write ( Math . max ( Math . max ( left , right ) , Math . max ( above , below ) ) ) ; }
function countPair ( a , b ) { var s = ( b . toString ( ) ) ; var i ; for ( i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] != ' ' ) break ; } var result ; if ( i == s . length ) result = a * s . length ; else result = a * ( s . length - 1 ) ; return result ; }
function getArea ( a ) { var area = ( Math . PI * a * a ) / 4 ; return area ; }
function flipsPossible ( a , n ) { let count_odd = 0 ; let count_even = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] & 1 ) == 1 ) count_odd ++ ; else count_even ++ ; } if ( count_odd % 2 == 1 && count_even % 2 == 1 ) return false ; else return true ; }
function minSum ( n ) { var sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n = parseInt ( n / 10 ) ; } if ( sum == 1 ) return 10 ; return sum ; }
function getWinner ( str , len ) { var total = 0 ; if ( str [ 0 ] == ' ' str [ len - 1 ] == ' ' ) return " " ; else { for ( var i = 0 ; i < len ; i ++ ) { if ( str [ i ] == ' ' ) { total ++ ; } } if ( ( total % 2 ) == 1 ) return " " ; return " " ; } }
function findTriangle ( S ) { let X1 = 0 , Y1 = 0 ; let X2 = MAX , Y2 = 1 ; let X3 = ( MAX - S % MAX ) % MAX ; let Y3 = ( S + X3 ) / MAX ; document . write ( " " + X1 + " " + Y1 + " " ) ; document . write ( " " + X2 + " " + Y2 + " " ) ; document . write ( " " + X3 + " " + Y3 + " " ) }
function maxOperations ( X , Y ) { if ( X > Y ) return - 1 ; let diff = Y - X ; if ( diff == 1 ) return - 1 ; if ( diff % 2 == 0 ) return ( diff / 2 ) ; return ( 1 + ( ( diff - 3 ) / 2 ) ) ; }
function precompute ( ) { F [ 1 ] = 2 ; F [ 2 ] = 3 ; F [ 3 ] = 4 ; for ( var i = 4 ; i < N ; i ++ ) F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD ; }
function get ( L , R ) { let x = 1.0 / L ; let y = 1.0 / ( R + 1.0 ) ; return ( x - y ) ; }
function findMin ( N ) { let digit = N % 10 ; switch ( digit ) { case 0 : if ( N >= 90 ) return 10 ; break ; case 1 : if ( N >= 81 ) return 9 ; break ; case 2 : if ( N >= 72 ) return 8 ; break ; case 3 : if ( N >= 63 ) return 7 ; break ; case 4 : if ( N >= 54 ) return 6 ; break ; case 5 : if ( N >= 45 ) return 5 ; break ; case 6 : if ( N >= 36 ) return 4 ; break ; case 7 : if ( N >= 27 ) return 3 ; break ; case 8 : if ( N >= 18 ) return 2 ; break ; case 9 : if ( N >= 9 ) return 1 ; break ; } return - 1 ; }
function checkEvenOdd ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { document . write ( " " ) ; return ; } } document . write ( " " ) ; }
function maxPartition ( s ) { var n = s . length , P = 0 ; var current = " " , previous = " " ; for ( var i = 0 ; i < n ; i ++ ) { current += s [ i ] ; if ( current != previous ) { previous = current ; current = " " ; P ++ ; } } return P ; }
function find_maximum_value ( a , n ) { var sum = 0 ; var minimum = Number . MAX_VALUE ; var pos = 0 , neg = 0 ; for ( i = 0 ; i < n ; i ++ ) { minimum = Math . min ( minimum , Math . abs ( a [ i ] ) ) ; sum += Math . abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) pos += 1 ; else neg += 1 ; } if ( pos > 0 && neg > 0 ) return sum ; return ( sum - 2 * minimum ) ; }
function find_number ( N , K ) { var r ; if ( N % 100 == 0 ) { N += 1 ; r = N . toString ( ) ; } else { r = N . toString ( ) ; } for ( var i = 1 ; i <= K ; i ++ ) r += " " ; return r ; }
function maxCountAB ( s , n ) { var A = 0 , B = 0 , BA = 0 , ans = 0 ; for ( var i = 0 ; i < n ; i ++ ) { var S = s [ i ] ; var L = S . length ; for ( var j = 0 ; j < L - 1 ; j ++ ) { if ( S [ j ] == ' ' && S [ j + 1 ] == ' ' ) { ans ++ ; } } if ( S [ 0 ] == ' ' && S [ L - 1 ] == ' ' ) BA ++ ; else if ( S [ 0 ] == ' ' ) B ++ ; else if ( S [ L - 1 ] == ' ' ) A ++ ; } if ( BA == 0 ) ans += Math . min ( B , A ) ; else if ( A + B == 0 ) ans += BA - 1 ; else ans += BA + Math . min ( B , A ) ; return ans ; }
function countPairs ( s ) { let st = new Set ( ) ; st . add ( ' ' ) ; st . add ( ' ' ) ; st . add ( ' ' ) ; st . add ( ' ' ) ; st . add ( ' ' ) ; let count = 0 ; let n = s . length ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( st . has ( s [ i ] ) && ! st . has ( s [ i + 1 ] ) ) count ++ ; } return count ; }
function maxSize ( v , n ) { v . push ( 0 ) ; v . push ( 100001 ) ; n += 2 ; v . sort ( ( a , b ) => a - b ) ; let mx = 0 ; for ( let i = 1 ; i < n - 1 ; i ++ ) { let L = v [ i - 1 ] + 1 ; let R = v [ i + 1 ] - 1 ; let cnt = R - L + 1 ; mx = Math . max ( mx , cnt ) ; } return mx ; }
function power ( x , y , p ) { let res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; }
function getMinVal ( p , q ) { if ( q % p == 0 ) return p ; return - 1 ; }
function findPoints ( l1 , r1 , l2 , r2 ) { var x = ( l1 != l2 ) ? Math . min ( l1 , l2 ) : - 1 ; var y = ( r1 != r2 ) ? Math . max ( r1 , r2 ) : - 1 ; document . write ( x + " " + y ) ; }
function minOperations ( N ) { var x = Math . log ( N ) / Math . log ( 2 ) ; var ans = parseInt ( ( Math . ceil ( x ) ) ) ; return ans ; }
function find_greatest_divisor ( l , r ) { if ( l == r ) return l ; return 1 ; }
function findNumbers ( arr , n ) { sumN = ( n * ( n + 1 ) ) / 2 ; sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; let sum = 0 ; let sumSq = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; sumSq += Math . pow ( arr [ i ] , 2 ) ; } B = ( ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2 ; A = sum - sumN + B ; document . write ( " " + A , " " , B ) ; }
function getProbability ( p , q ) { p /= 100 ; q /= 100 ; let probability = ( p * p + q * q ) / ( p + q ) ; return probability ; }
function check ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) return true ; } return false ; }
function fib ( n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
function fact ( n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; }
function minimumOperations ( arr , N ) { let mx = 0 , pos = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= mx ) { mx = arr [ i ] ; pos = i ; } } document . write ( ( mx - 1 ) * N + pos + 1 ) ; }
function printFreq ( arr , N ) { let freq = 1 ; for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { freq ++ ; } else { document . write ( " " + parseInt ( arr [ i - 1 ] ) + " " + parseInt ( freq ) + " " ) ; freq = 1 ; } } document . write ( " " + parseInt ( arr [ N - 1 ] ) + " " + parseInt ( freq ) + " " ) ; }
function findLargestIndex ( arr , n ) { for ( var i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] == i ) { document . write ( i ) ; return ; } } document . write ( - 1 ) ; }
function getPairsCount ( a , n ) { let count = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( ( a [ i ] * a [ j ] ) == Math . abs ( i - j ) ) count ++ ; } } return count ; }
function getPairsCount ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && arr [ i ] * arr [ j ] == Math . abs ( i - j ) ) { count ++ ; } } } return count ; }
function Minimum ( N , K ) { let sum = N * ( N + 1 ) / 2 ; if ( K > sum ) return - 1 ; if ( K <= N ) return 1 ; sum = 0 ; let count = 0 ; while ( N >= 1 && sum < K ) { count += 1 ; sum += N ; N -= 1 ; } return count ; }
function numberofBoxes ( W , B , O ) { let low = 0 , high = Math . min ( W , B ) ; let ans = 0 ; while ( low <= high ) { let mid = low + Math . floor ( ( high - low ) / 2 ) ; if ( ( ( W >= mid ) && ( B >= mid ) ) && ( ( W - mid ) + ( B - mid ) + O ) >= mid ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } document . write ( ans ) ; }
function minSwaps ( N , M , A , B ) { let count01 = 0 ; let count10 = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) { if ( A [ i ] [ j ] != B [ i ] [ j ] ) { if ( A [ i ] [ j ] == 1 ) count10 ++ ; else count01 ++ ; } } } if ( count01 == count10 ) return count01 ; else return - 1 ; }
function Count ( N , K ) { if ( K == 0 ) return 0 ; let sum = 0 ; let res = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { sum += i ; if ( sum <= K ) res ++ ; else break ; } return res ; }
function Count ( N , K ) { if ( K == 0 ) return 0 ; var res = 0 ; var low = 2 , high = N ; while ( low <= high ) { var mid = ( low + high ) / 2 ; var sum = ( mid * mid + mid ) / 2 ; if ( sum <= K ) { res = Math . max ( res , mid ) ; low = mid + 1 ; } else { high = mid - 1 ; } } return res ; }
function repeatingElement ( arr , N ) { let M = 0 , sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; M = Math . max ( M , arr [ i ] ) ; } let sum1 = parseInt ( M * ( M + 1 ) / 2 ) ; let ans = parseInt ( ( sum - sum1 ) / ( N - M ) ) ; return ans ; }
function largestNum ( arr ) { let set = new Set ( ) ; let res = 0 ; for ( let i = 0 ; i < arr . length ; i ++ ) { set . add ( arr [ i ] ) ; if ( set . has ( - 1 * arr [ i ] ) ) { res = Math . max ( res , Math . abs ( arr [ i ] ) ) ; } } return res ; }
function probability ( arr1 , arr2 ) { let N = arr1 . length ; let M = arr2 . length ; let res = 0 ; for ( let i = 0 ; i < N ; i ++ ) { let y = 0 ; for ( let j = 0 ; j < M ; j ++ ) { if ( arr2 [ j ] > arr1 [ i ] ) y ++ ; } res += y ; } res = ( res / ( N * M ) ) ; return res ; }
function minCost ( arr , A , B ) { let n = arr . length ; let m = arr [ 0 ] . length ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { if ( arr [ i ] [ j ] == ' ' ) continue ; if ( j == m - 1 ) ans += A ; else { if ( arr [ i ] [ j + 1 ] == ' ' ) { ans += Math . min ( 2 * A , B ) ; j ++ ; } else ans += A ; } } } document . write ( ans ) ; }
function findkthElement ( arr , n , K ) { var l = 0 ; var h = n - 1 , r ; while ( l + 1 < h ) { var mid = parseInt ( ( l + h ) / 2 ) ; if ( arr [ l ] >= arr [ mid ] ) l = mid ; else h = mid ; } if ( arr [ l ] < arr [ h ] ) r = l ; else r = h ; if ( K <= r + 1 ) return arr [ r + 1 - K ] ; else return arr [ n - ( K - ( r + 1 ) ) ] ; }
function find ( arr , N , key ) { let l = 0 ; let h = N - 1 ; while ( l <= h ) { let mid = Math . floor ( ( l + h ) / 2 ) ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] >= arr [ mid ] ) { if ( arr [ l ] >= key && key >= arr [ mid ] ) h = mid - 1 ; else l = mid + 1 ; } else { if ( arr [ mid ] >= key && key >= arr [ h ] ) l = mid + 1 ; else h = mid - 1 ; } } return - 1 ; }
function findPairs ( A , B ) { for ( let i = 1 ; i <= B ; i ++ ) { let y = A ^ i ; if ( y > 0 && ( i y ) == B ) { document . write ( i + " " + y + " " ) ; } } }
function NthComposite ( N ) { let IsPrime = [ ] ; for ( let i = 0 ; i < MAX_SIZE ; i ++ ) IsPrime . push ( true ) ; for ( let p = 2 ; p * p < MAX_SIZE ; p ++ ) { if ( IsPrime [ p ] == true ) { for ( let i = p * p ; i < MAX_SIZE ; i += p ) IsPrime [ i ] = false ; } } let Composites = [ ] ; for ( let p = 4 ; p < MAX_SIZE ; p ++ ) if ( ! IsPrime [ p ] ) Composites . push ( p ) ; return Composites [ N - 1 ] ; }
function maximumValue ( arr , n ) { var ans = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { ans = Math . max ( ans , arr [ i ] + arr [ j ] + i - j ) ; } } document . write ( ans ) ; }
function maximumValue ( arr , n ) { var maxvalue = arr [ 0 ] ; var result = 0 ; for ( i = 1 ; i < n ; i ++ ) { result = Math . max ( result , maxvalue + arr [ i ] - i ) ; maxvalue = Math . max ( maxvalue , arr [ i ] + i ) ; } document . write ( result ) ; }
function productOfTwoPerfectCubes ( N ) { var cube_root ; cube_root = Math . round ( Math . cbrt ( N ) ) ; if ( cube_root * cube_root * cube_root == N ) { document . write ( " " ) ; return ; } else { document . write ( " " ) ; return ; } }
function printNumberOfPairs ( N ) { var st = new Set ( ) ; for ( let i = 2 ; i * i <= N ; i ++ ) { let x = i ; while ( x <= N ) { x *= i ; if ( x <= N ) { st . add ( x ) ; } } } document . write ( st . size ) ; }
function findCost ( A , N ) { var totalCost = 0 ; var i ; for ( i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 0 ) { A [ i ] = 1 ; totalCost += i ; } } return totalCost ; }
function minCount ( A , B , N ) { var i = 0 for ( let j = 0 ; j < N ; j ++ ) { if ( A [ i ] == B [ j ] ) i += 1 } return N - i }
function checkExists ( arr , N , M , K ) { let count = 0 ; for ( let i = 0 ; i < N - M ; i ++ ) { if ( arr [ i ] == arr [ i + M ] ) count ++ ; else count = 0 ; if ( count == M * ( K - 1 ) ) return true ; } return false ; } let arr = [ 2 , 1 , 2 , 1 , 1 , 1 , 3 ] ; let N = arr . length ; let M = 2 , K = 2 ; if ( checkExists ( arr , N , M , K ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function CountPairs ( arr , n ) { var count = 0 ; for ( i = 0 ; i < n - 1 ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( ( i * j ) == ( arr [ i ] * arr [ j ] ) ) count ++ ; } } return count ; }
function numberOfGates ( s ) { let N = s . length ; let ans = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' ) { ans ++ ; } } document . write ( ans ) ; }
function findPairs ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) arr [ i ] = Math . abs ( arr [ i ] ) ; arr . sort ( ( a , b ) => a - b ) ; let left = 0 ; let ans = 0 ; for ( let right = 0 ; right < N ; right ++ ) { while ( 2 * arr [ left ] < arr [ right ] ) left ++ ; ans += ( right - left ) ; } document . write ( ans ) ; }
function CalculateValues ( N ) { var A = 0 , B = 0 , C = 0 ; for ( C = 0 ; C < N / 7 ; C ++ ) { for ( B = 0 ; B < N / 5 ; B ++ ) { var A = N - 7 * C - 5 * B ; if ( A >= 0 && A % 3 == 0 ) { document . write ( " " + A / 3 + " " + B + " " + C ) ; return ; } } } document . write ( - 1 ) ; }
function mininsert ( arr , K , N ) { var ans = 0 ; for ( i = 0 ; i < N - 1 ; i ++ ) { var a = Math . min ( arr [ i ] , arr [ i + 1 ] ) ; var b = Math . max ( arr [ i ] , arr [ i + 1 ] ) ; while ( K * a < b ) { a *= K ; ans ++ ; } } return ans ; }
function sumOfDigits ( s ) { var curr = 0 ; var ret = 0 ; s . split ( ' ' ) . forEach ( ch => { if ( parseInt ( ch ) ) { curr = curr * 10 + ch . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; } else { ret += curr ; curr = 0 ; } } ) ; ret += curr ; return ret ; }
function print_triplet ( arr , n ) { for ( var i = 1 ; i <= n - 2 ; i ++ ) { if ( arr [ i - 1 ] < arr [ i ] && arr [ i ] > arr [ i + 1 ] ) { document . write ( i - 1 + " " + i + " " + ( i + 1 ) ) ; return ; } } document . write ( - 1 ) ; }
function evenproduct ( arr , length ) { var count = 0 ; var i , j ; for ( i = 0 ; i < length + 1 ; i ++ ) { var product = 1 ; for ( j = i ; j < length + 1 ; j ++ ) { product *= arr [ j ] ; if ( product % 2 == 0 ) ++ count ; } } document . write ( count ) ; }
function evenproduct ( arr , length ) { var total_subarray = length * ( length + 1 ) / 2 ; var total_odd = 0 ; var count_odd = 0 ; for ( i = 0 ; i < arr . length ; ++ i ) { if ( arr [ i ] % 2 == 0 ) { count_odd = 0 ; } else { ++ count_odd ; total_odd += count_odd ; } } document . write ( total_subarray - total_odd ) ; }
function countSubstrings ( s ) { let ans = 0 ; let subs = 1 ; let pre = ' ' ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( pre == s [ i ] ) { subs += 1 ; } else { subs = 1 ; } ans += subs ; pre = s [ i ] ; } document . write ( ans ) ; }
function minimumOperations ( arr , N ) { let oddCnt = 0 , evenCnt = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { evenCnt ++ ; } else { oddCnt ++ ; } } document . write ( Math . min ( oddCnt , evenCnt ) ) ; }
function minIncr ( arr , n ) { let forEven = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 ) { if ( ( arr [ i ] % 2 ) == 0 ) forEven += 1 ; } else { if ( arr [ i ] % 2 ) forEven += 1 ; } } return Math . min ( forEven , n - forEven ) ; }
function KthCharacter ( S , N , K ) { var strarray = S . split ( ' ' ) ; strarray . sort ( ) ; var ch = strarray [ K - 1 ] ; var count = 0 ; strarray . forEach ( c => { if ( c == ch ) count ++ ; } ) ; document . write ( count ) ; }
function findMinLength ( arr , N ) { let front = 0 , back = N - 1 ; while ( front < back ) { let x = arr [ front ] ; if ( arr [ front ] != arr [ back ] ) break ; while ( arr [ front ] == x && front <= back ) front ++ ; while ( arr [ back ] == x && front <= back ) back -- ; } document . write ( back - front + 1 ) ; document . write ( " " ) ; }
function check ( a , n ) { flag = false ; for ( i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i + 1 ] > a [ i ] && a [ i ] < a [ i - 1 ] ) flag = true ; } if ( flag ) return false ; else return true ; }
function minOperations ( S ) { var count = 0 ; for ( var i = 1 ; i < S . length ; i ++ ) { if ( S [ i ] !== S [ i - 1 ] ) { count += 1 ; } } document . write ( count ) ; }
function mulsum ( arr , n , N ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % N == 0 ) { sum = sum + arr [ i ] ; } } document . write ( sum ) ; }
function getCount ( rows , columns , A ) { var res = 0 ; for ( var i = 0 ; i < rows ; i ++ ) { for ( var j = i + 1 ; j < rows ; j ++ ) { if ( A [ i ] [ 0 ] * A [ j ] [ 1 ] == A [ i ] [ 1 ] * A [ j ] [ 0 ] ) { res ++ ; } } } return res ; }
function minLength ( S , T , N , M ) { let temp = " " ; let subtract = 0 ; for ( let i = 0 ; i < N ; ++ i ) { temp += S [ i ] ; if ( temp . length >= M ) { if ( T == temp . substr ( temp . length - M , temp . length ) ) { subtract += M ; let cnt = 0 ; while ( cnt != M ) { temp = temp . substr ( 0 , temp . length - 1 ) ; ++ cnt ; } } } } document . write ( ( N - subtract ) ) ; }
function Count_numbers ( L , R ) { var count = ( R - L ) / 2 ; if ( R % 2 != 0 L % 2 != 0 ) count += 1 ; document . write ( count ) ; }
function minimumTime ( arr , n ) { var sum = 0 ; var T = Math . max ( ... arr ) ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } document . write ( Math . max ( 2 * T , sum ) ) ; }
function CountSubarray ( arr , n , k ) { var temp = k , count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == temp ) { if ( temp == 1 ) { count ++ ; temp = k ; } else temp -- ; } else { temp = k ; if ( arr [ i ] == k ) i -- ; } } return count ; }
function minSum ( N ) { let ans = Math . ceil ( 2 * Math . sqrt ( N + 1 ) ) ; document . write ( ans ) ; }
function findMinDeletions ( v , n ) { let minDel = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { let L = v [ i ] [ 0 ] ; let R = v [ i ] [ 1 ] ; let Count = 0 ; for ( let j = 0 ; j < n ; j ++ ) { if ( v [ j ] [ 0 ] >= L && v [ j ] [ 1 ] <= R ) { Count += 1 ; } } minDel = Math . min ( minDel , n - Count ) ; } return minDel ; }
function maxEvenIntegers ( arr , N , M ) { let ans = 0 ; for ( let i = 0 ; i <= N - M ; i ++ ) { let cnt = 0 ; for ( let j = 0 ; j < M ; j ++ ) { if ( arr [ i + j ] % 2 == 0 ) cnt ++ ; } ans = Math . max ( ans , cnt ) ; } return ans ; }
function countNumbers ( n , d ) { let total = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let x = i ; while ( x > 0 ) { if ( x % 8 == d ) { total ++ ; break ; } x = x / 8 ; } } document . write ( total ) ; }
function getcount ( n , k ) { let res = ( n >> ( k + 1 ) ) << k ; if ( ( ( n >> k ) & 1 ) != 0 ) res += n & ( ( 1 << k ) - 1 ) ; return res ; }
function findCntTriplet ( N ) { let cntTriplet = 0 ; for ( let i = 1 ; i < N ; i ++ ) { if ( N % i != 0 ) { cntTriplet += Math . floor ( N / i ) ; } else { cntTriplet += Math . floor ( N / i ) - 1 ; } } return cntTriplet ; }
function splitString ( S , N ) { var c = S . charAt ( N - 1 ) ; var f = 0 ; for ( var i = 0 ; i < N - 1 ; i ++ ) { if ( S . charAt ( i ) == c ) { f = 1 ; break ; } } if ( f > 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function make_String_S_to_T ( S , T ) { var possible = false ; var M = T . length ; var N = S . length ; for ( i = 0 ; i <= M ; i ++ ) { var prefix_length = i ; var suffix_length = M - i ; var prefix = S . substring ( 0 , prefix_length ) ; var suffix = S . substring ( N - suffix_length , N ) ; if ( ( prefix + suffix ) == ( T ) ) { possible = true ; break ; } } if ( possible ) return " " ; else return " " ; }
function findSum ( a ) { var ans = 0 ; for ( var low = 0 ; low < a . length ; low ++ ) { for ( var high = low ; high < a . length ; high ++ ) { var count = 0 ; var maxNumber = 0 ; for ( var i = low ; i <= high ; i ++ ) { if ( a [ i ] === maxNumber ) count ++ ; else if ( a [ i ] > maxNumber ) { maxNumber = a [ i ] ; count = 1 ; } } ans += maxNumber * ( count % 2 === 0 ? 2 : 1 ) ; } } document . write ( ans ) ; }
function minimum_deci_binary_number ( s ) { let m = Number . MIN_VALUE ; for ( let i = 0 ; i < s . length ; i ++ ) { let temp = s [ i ] - ' ' ; if ( temp > m ) { m = temp ; } } return m ; }
function minimumReverse ( s , n ) { let k = 0 , l = 0 ; let sum1 = 0 , sum0 = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( s [ i ] == ' ' ) sum1 ++ ; else sum0 ++ ; if ( s [ i ] == s [ i - 1 ] && s [ i ] == ' ' ) k ++ ; else if ( s [ i ] == s [ i - 1 ] && s [ i ] == ' ' ) l ++ ; } if ( s [ 0 ] == ' ' ) sum1 ++ ; sum0 ++ ; if ( Math . abs ( sum1 - sum0 ) > 1 ) return - 1 ; return Math . max ( k , l ) ; }
function maxPairs ( nums , k ) { nums . sort ( ) ; let result = 0 ; let start = 0 , end = nums . length - 1 ; while ( start < end ) { if ( nums [ start ] + nums [ end ] > k ) end -- ; else if ( nums [ start ] + nums [ end ] < k ) start ++ ; else { start ++ ; end -- ; result ++ ; } } document . write ( result ) ; }
function maxPairs ( nums , k ) { var m = new Map ( ) ; var result = 0 ; nums . forEach ( i => { if ( m . has ( i ) && m . get ( i ) > 0 ) { m . set ( i , m . get ( i ) - 1 ) ; result ++ ; } else { if ( m . has ( k - i ) ) m . set ( k - i , m . get ( k - i ) + 1 ) else m . set ( k - i , 1 ) } } ) ; document . write ( result ) ; }
function SmallestString ( s , c ) { for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] > c ) { let temp = s ; s = s . substring ( 0 , i ) ; s += c ; s += temp . substring ( i , temp . length ) ; return s ; } } s += c ; return s ; }
function countSubarrays ( A , N ) { let ans = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] != A [ i + 1 ] ) { ans ++ ; for ( let j = i - 1 , k = i + 2 ; j >= 0 && k < N && A [ j ] == A [ i ] && A [ k ] == A [ i + 1 ] ; j -- , k ++ ) { ans ++ ; } } } document . write ( ans + " " ) ; }
function longestSubsequence ( N , Q , arr , Queries ) { for ( let i = 0 ; i < Q ; i ++ ) { let x = Queries [ i ] [ 0 ] ; let y = Queries [ i ] [ 1 ] ; arr [ x - 1 ] = y ; let count = 1 ; for ( let j = 1 ; j < N ; j ++ ) { if ( arr [ j ] != arr [ j - 1 ] ) { count += 1 ; } } document . write ( count + " " ) ; } }
function countString ( S ) { var count = 0 ; for ( var it = 0 ; it < S . length ; it ++ ) { if ( S [ it ] == ' ' && count > 0 ) { count -- ; } else { count ++ ; } } document . write ( ( 1 << count ) - 1 ) ; }
function find_longest_subarray ( A , N , K ) { let MaxLen = 0 ; let Len = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( K % A [ i ] == 0 ) { Len ++ ; MaxLen = Math . max ( MaxLen , Len ) ; } else { Len = 0 ; } } return MaxLen ; }
function MinDistK ( arr , N , K ) { let res = Number . MAX_VALUE ; let dist = 0 ; for ( let i = 0 ; i <= ( N - K ) ; i ++ ) { if ( arr [ i ] >= 0 && arr [ i + K - 1 ] >= 0 ) { dist = Math . max ( arr [ i ] , arr [ i + K - 1 ] ) ; } else { dist = Math . abs ( arr [ i ] ) + Math . abs ( arr [ i + K - 1 ] ) + Math . min ( Math . abs ( arr [ i ] ) , Math . abs ( arr [ i + K - 1 ] ) ) ; } res = Math . min ( res , dist ) ; } return res ; }
function countSubsequece ( a , n ) { let i , j , k , l ; let answer = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { for ( k = j + 1 ; k < n ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ j ] == a [ l ] && a [ i ] == a [ k ] ) { answer ++ ; } } } } } return answer ; }
function checkPointRange ( arr , X , Y , N ) { for ( let i = 0 ; i < N ; i ++ ) { let dist = Math . sqrt ( ( arr [ i ] [ 0 ] - X ) * ( arr [ i ] [ 0 ] - X ) + ( arr [ i ] [ 1 ] - Y ) * ( arr [ i ] [ 1 ] - Y ) ) ; if ( dist <= arr [ i ] [ 2 ] ) { return true ; } } return false ; } let arr = [ [ 1 , 1 , 3 ] , [ 10 , 10 , 3 ] , [ 15 , 15 , 15 ] ] ; let X = 5 , Y = 5 ; let N = arr . length ; if ( checkPointRange ( arr , X , Y , N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function removeOuterParentheses ( S ) { let res = " " ; let count = 0 ; for ( let c = 0 ; c < S . length ; c ++ ) { if ( S . charAt ( c ) == ' ' && count ++ > 0 ) res += S . charAt ( c ) ; if ( S . charAt ( c ) == ' ' && count -- > 1 ) res += S . charAt ( c ) ; } return res ; }
function countSum ( a , n , sum ) { let i , j , k , l ; let count = 0 ; for ( i = 0 ; i < n - 3 ; i ++ ) { for ( j = i + 1 ; j < n - 2 ; j ++ ) { for ( k = j + 1 ; k < n - 1 ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ i ] + a [ j ] + a [ k ] + a [ l ] == sum ) count ++ ; } } } } return count ; }
function check ( arr , n ) { var hm = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { hm . set ( arr [ i ] , 1 ) ; for ( var j = i + 1 ; j < n ; j ++ ) { if ( hm . has ( arr [ j ] ) ) hm . set ( arr [ j ] , hm . get ( arr [ j ] ) + 1 ) ; else hm . set ( arr [ j ] , 1 ) var flag = false ; hm . forEach ( ( value , key ) => { if ( value == 1 ) { flag = true ; } } ) ; if ( ! flag ) return " " ; } hm = new Map ( ) ; } return " " ; }
function check ( arr , n ) { for ( var i = 0 ; i < n ; i ++ ) { var hm = new Map ( ) ; var count = 0 ; for ( var j = i ; j < n ; j ++ ) { if ( hm . has ( arr [ j ] ) ) hm . set ( arr [ j ] , hm . get ( arr [ j ] ) + 1 ) else hm . set ( arr [ j ] , 1 ) if ( hm . get ( arr [ j ] ) == 1 ) count ++ ; if ( hm . get ( arr [ j ] ) == 2 ) count -- ; if ( count == 0 ) return " " ; } } return " " ; }
function countPairsWithDiffK ( arr , N , K ) { var vis = new Array ( N ) ; vis . fill ( 0 ) ; var count = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( vis [ i ] == 1 ) continue ; for ( var j = i + 1 ; j < N ; j ++ ) { if ( vis [ j ] == 1 ) continue ; if ( Math . abs ( arr [ i ] - arr [ j ] ) >= K ) { count ++ ; vis [ i ] = 1 ; vis [ j ] = 1 ; break ; } } } document . write ( count + " " ) ; }
function maxiConsecutiveSubarray ( arr , N ) { let maxi = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { let cnt = 1 , j ; for ( j = i ; j < N - 1 ; j ++ ) { if ( arr [ j + 1 ] == arr [ j ] + 1 ) { cnt ++ ; } else { break ; } } maxi = Math . max ( maxi , cnt ) ; i = j ; } return maxi ; }
function FindTrip ( arr , N ) { for ( let i = 1 ; i < N - 1 ; i ++ ) { let p = arr [ i - 1 ] ; let q = arr [ i ] ; let r = arr [ i + 1 ] ; if ( p < q && q > r ) { document . write ( ( i - 1 ) + " " + ( i ) + " " + ( i + 1 ) ) ; return ; } } document . write ( - 1 ) ; }
function find_index ( arr , n , K ) { for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] == K ) return i ; else if ( arr [ i ] > K ) return i ; return n ; }
function find_index ( arr , n , K ) { let start = 0 ; let end = n - 1 ; while ( start <= end ) { let mid = Math . floor ( ( start + end ) / 2 ) ; if ( arr [ mid ] == K ) return mid ; else if ( arr [ mid ] < K ) start = mid + 1 ; else end = mid - 1 ; } return end + 1 ; }
function printAlter ( arr , N ) { for ( var currIndex = 0 ; currIndex < N ; currIndex ++ ) { if ( currIndex % 2 == 0 ) { document . write ( arr [ currIndex ] + " " ) ; } } }
function printAlter ( arr , N ) { for ( var currIndex = 0 ; currIndex < N ; currIndex += 2 ) { document . write ( arr [ currIndex ] + " " ) ; } }
function numberOfGP ( L , N ) { if ( N <= 2 ) return 0 ; let count = 0 ; let res = 0 ; for ( let i = 2 ; i < N ; ++ i ) { if ( L [ i - 1 ] * L [ i - 1 ] == L [ i ] * L [ i - 2 ] ) { ++ count ; } else { count = 0 ; } res += count ; } return res ; }
function conVowUpp ( str ) { var N = str . length ; for ( var i = 0 ; i < N ; i ++ ) { if ( str [ i ] === " " str [ i ] === " " str [ i ] === " " str [ i ] === " " str [ i ] === " " ) { document . write ( str [ i ] . toUpperCase ( ) ) ; } else { document . write ( str [ i ] ) ; } } }
function cntSubarr ( arr , N ) { var res = 0 ; var prefixXor = 0 ; var i , j ; for ( i = 0 ; i < N - 1 ; i ++ ) { prefixXor = arr [ i ] ; for ( j = i + 1 ; j < N ; j ++ ) { prefixXor ^= arr [ j ] ; if ( prefixXor == 0 && ( j - i + 1 ) % 2 == 0 ) { res ++ ; } } } return res ; }
function cntSubXor ( arr , N ) { let prefixXor = 0 ; let Even = Array . from ( { length : M } , ( _ , i ) => 0 ) ; let Odd = Array . from ( { length : M } , ( _ , i ) => 0 ) ; let cntSub = 0 ; Odd [ 0 ] = 1 ; for ( let i = 0 ; i < N ; i ++ ) { prefixXor = Math . floor ( prefixXor ^ arr [ i ] ) ; if ( i % 2 == 1 ) { cntSub += Odd [ prefixXor ] ; Odd [ prefixXor ] ++ ; } else { cntSub += Even [ prefixXor ] ; Even [ prefixXor ] ++ ; } } return cntSub ; }
function minLength ( arr , N ) { for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ 0 ] != arr [ i ] ) { return 1 ; } } return N ; }
function PrintIndexes ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) { let currSubSum = 0 ; for ( let j = i ; j < N ; j ++ ) { currSubSum += arr [ j ] ; let sq = Math . floor ( Math . sqrt ( currSubSum ) ) ; if ( sq * sq == currSubSum ) { document . write ( " " + i + " " + j + " " + " " ) ; } } } }
function productSum ( arr , N ) { let cntOne = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) cntOne ++ ; } return cntOne * ( cntOne - 1 ) / 2 ; }
function minCost ( A , B ) { var n = A . length ; var i = 0 ; var maxlen = 0 ; while ( i < n ) { var length = 0 ; for ( var j = 0 ; j < n ; ++ j ) { if ( A [ i ] == B [ j ] ) { ++ i ; ++ length ; if ( i == n ) break ; } } maxlen = Math . max ( maxlen , length ) ; } return n - maxlen ; }
function countSubarrays ( a , n , k ) { var ans = 0 ; var pref = [ ] ; pref . push ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) pref . push ( ( a [ i ] + pref [ i ] ) % k ) ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = i ; j <= n ; j ++ ) { if ( ( pref [ j ] - pref [ i - 1 ] + k ) % k == j - i + 1 ) { ans ++ ; } } } document . write ( ans + ' ' ) ; }
function EvenLIS ( arr ) { let n = arr . length ; let lis = new Array ( n ) . fill ( 1 ) ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { if ( Math . abs ( arr [ i ] ) > Math . abs ( arr [ j ] ) && Math . abs ( arr [ i ] ) % 2 == 0 && Math . abs ( arr [ j ] ) % 2 == 0 && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } } let maxlen = 0 ; for ( let i = 0 ; i < n ; i ++ ) maxlen = Math . max ( maxlen , lis [ i ] ) ; document . write ( maxlen ) ; }
function findMinLength ( arr ) { let index = parseInt ( arr . length ) - 1 ; while ( index > 0 && arr [ index ] >= arr [ index - 1 ] ) { index -- ; } return index ; }
function convertBfromA ( a , b ) { let moves = 0 ; let x = Math . abs ( a - b ) ; for ( let i = 10 ; i > 0 ; i -- ) { moves += Math . floor ( x / i ) ; x = x % i ; } document . write ( moves + " " ) ; }
function smallestNth ( A , B , N ) { let res = Number . MAX_VALUE ; for ( let i = 1 ; i < N ; i ++ ) { for ( let j = N ; j > i ; j -- ) { if ( ( B - A ) % ( j - i ) == 0 ) { let D = ( B - A ) / ( j - i ) ; let FirstTerm = A - ( i - 1 ) * D ; let NthTerm = FirstTerm + ( N - 1 ) * D ; if ( FirstTerm > 0 ) res = Math . min ( res , NthTerm ) ; } } } return res ; }
function maximumSum ( a , b , n , index , lastpicked ) { if ( index == n ) return 0 ; let option1 = 0 , option2 = 0 ; if ( lastpicked == - 1 a [ lastpicked ] != a [ index ] ) option1 = b [ index ] + maximumSum ( a , b , n , index + 1 , index ) ; option2 = maximumSum ( a , b , n , index + 1 , lastpicked ) ; return Math . max ( option1 , option2 ) ; }
function hIndex ( citations , n ) { let hindex = 0 ; let low = 0 , high = n - 1 ; while ( low <= high ) { let mid = ( low + high ) / 2 ; if ( citations [ mid ] >= ( mid + 1 ) ) { low = mid + 1 ; hindex = mid + 1 ; } else { high = mid - 1 ; } } document . write ( hindex ) ; return hindex ; }
function minOperation ( arr ) { let minOp = Number . MIN_VALUE ; let minNeg = 0 , maxPos = 0 ; for ( let i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] < 0 ) { if ( arr [ i ] < minNeg ) minNeg = arr [ i ] ; } else { if ( arr [ i ] > maxPos ) maxPos = arr [ i ] ; } } return Math . abs ( minNeg ) + maxPos ; }
function checkHex ( s ) { let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) { let ch = s [ i ] ; if ( ( ch < ' ' ch > ' ' ) && ( ch < ' ' ch > ' ' ) ) { document . write ( " " ) ; return ; } } document . write ( " " ) ; }
function checkArrInStack ( s , arr , n ) { var freq = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( freq . has ( arr [ i ] ) ) freq . set ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) else freq . set ( arr [ i ] , 1 ) } while ( s . length != 0 ) { var poppedEle = s [ s . length - 1 ] ; s . pop ( ) ; if ( freq . has ( poppedEle ) ) freq . set ( poppedEle , freq . get ( poppedEle ) - 1 ) ; } if ( freq . size == 0 ) return 0 ; return 1 ; }
function lenghtOfLongestAP ( A , n ) { var dp = new Map ( ) ; var res = 2 ; for ( var i = 0 ; i < n ; ++ i ) { for ( var j = i + 1 ; j < n ; ++ j ) { var d = A [ j ] - A [ i ] ; if ( dp . has ( d ) ) { if ( dp . get ( d ) . has ( i ) ) { var tmp = dp . get ( d ) ; tmp . set ( j , dp . get ( d ) . get ( i ) + 1 ) ; } else { var tmp = new Map ( ) ; tmp . set ( j , 2 ) ; dp . set ( d , tmp ) ; } } else { var tmp = new Map ( ) ; tmp . set ( j , 2 ) ; dp . set ( d , tmp ) ; } res = Math . max ( res , dp . get ( d ) . get ( j ) ) ; } } return res ; }
function isCubeSum ( n ) { for ( var i = 1 ; i * i * i <= n ; i ++ ) { if ( i * i * i + ( i + 1 ) * ( i + 1 ) * ( i + 1 ) == n ) return true ; } return false ; }
function isSumCube ( N ) { var a = parseInt ( Math . cbrt ( N ) ) ; var b = a - 1 ; return ( ( a * a * a + b * b * b ) == N ) ; } var i = 35 ; if ( isSumCube ( i ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function checkSumOfNatural ( n ) { var i = 1 ; var flag = false ; while ( i * ( i + 1 ) < n * 2 ) { var X = i * ( i + 1 ) ; var t = n * 2 - X ; var k = parseInt ( Math . sqrt ( t ) ) ; if ( k * ( k + 1 ) == t ) { flag = true ; break ; } i += 1 ; } if ( flag ) document . write ( " " ) ; else document . write ( " " ) ; }
function countNumEnds ( A , L , R ) { let temp = 0 , count = 0 , digits = 0 ; let cycle = 0 ; digits = Math . round ( Math . log10 ( A ) ) + 1 ; temp = Math . round ( Math . pow ( 10 , digits ) ) ; cycle = temp ; while ( temp <= R ) { if ( temp >= L ) count ++ ; temp += cycle ; } document . write ( count ) ; }
function minOperations ( s ) { var len = s . length ; var result = 0 ; for ( var i = 0 ; i < len / 2 ; i ++ ) { var D1 = Math . max ( s [ i ] . charCodeAt ( 0 ) , s [ len - 1 - i ] . charCodeAt ( 0 ) ) - Math . min ( s [ i ] . charCodeAt ( 0 ) , s [ len - 1 - i ] . charCodeAt ( 0 ) ) ; var D2 = 26 - D1 ; result += Math . min ( D1 , D2 ) ; } return result ; }
function transformSubsequence ( n , m , A , B ) { if ( B . length == 0 ) return n ; var dp = Array . from ( Array ( n + 1 ) , ( ) => Array ( m + 1 ) . fill ( 0 ) ) ; for ( var i = 0 ; i < n + 1 ; i ++ ) { for ( var j = 0 ; j < m + 1 ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 0 ; else if ( A [ i - 1 ] == B [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return n - dp [ n ] [ m ] ; }
function MaximumPath ( grid ) { let N = grid . length ; let M = grid [ 0 ] . length ; let sum = new Array ( N + 1 ) ; for ( var i = 0 ; i < sum . length ; i ++ ) { sum [ i ] = new Array ( 2 ) ; } for ( var i = 0 ; i < sum . length ; i ++ ) { for ( var j = 0 ; j < sum . length ; j ++ ) { sum [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= N ; i ++ ) { for ( let j = 1 ; j <= M ; j ++ ) { sum [ i ] [ j ] = Math . max ( sum [ i - 1 ] [ j ] , sum [ i ] [ j - 1 ] ) + grid [ i - 1 ] [ j - 1 ] ; } } return sum [ N ] [ M ] ; }
function right_angled ( n ) { var count = 0 ; for ( z = 1 ; z <= n ; z ++ ) { for ( y = 1 ; y <= z ; y ++ ) { for ( x = 1 ; x <= y ; x ++ ) { if ( ( x * x ) + ( y * y ) == ( z * z ) ) { count ++ ; } } } } return count ; }
function mirrorMatrix ( mat1 , mat2 , N ) { let row = 0 ; let col = 0 ; let isMirrorImage = true ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = N - 1 ; j >= 0 ; j -- ) { if ( mat2 [ row ] [ col ] != mat1 [ i ] [ j ] ) { isMirrorImage = false ; } col ++ ; } col = 0 ; row ++ ; } if ( isMirrorImage ) document . write ( " " ) ; else document . write ( " " ) ; }
function findMinCost ( a , k ) { var n = a . length ; var max_ele = a . reduce ( ( a , b ) => Math . max ( a , b ) ) var dp = Array ( n + 1 ) . fill ( 1000000000 ) ; dp [ 0 ] = 0 ; for ( var i = 0 ; i < n ; ++ i ) { var freq = Array ( max_ele + 1 ) . fill ( 0 ) ; for ( var j = i ; j < n ; ++ j ) { freq [ a [ j ] ] ++ ; var cost = 0 ; for ( var x = 0 ; x <= max_ele ; ++ x ) { cost += ( freq [ x ] == 1 ) ? 0 : freq [ x ] ; } dp [ j + 1 ] = Math . min ( dp [ i ] + cost + k , dp [ j + 1 ] ) ; } } return dp [ n ] ; }
function Maxcost ( s , cost ) { let maxcost = 0 ; let i = 0 ; while ( i < s . length - 1 ) { if ( s [ i ] == s [ i + 1 ] ) { if ( cost [ i ] > cost [ i + 1 ] ) maxcost += cost [ i ] ; else { maxcost += cost [ i + 1 ] ; cost [ i + 1 ] = cost [ i ] ; } } i ++ ; } return maxcost ; }
function maxSumSubarray ( arr , n ) { var i = 0 , j = 1 ; var set = new Set ( ) ; set . add ( arr [ 0 ] ) ; var sum = arr [ 0 ] ; var maxsum = sum ; while ( i < n - 1 && j < n ) { var is_in = set . has ( arr [ j ] ) ; if ( ! is_in ) { sum = sum + arr [ j ] ; maxsum = Math . max ( sum , maxsum ) ; set . add ( arr [ j ++ ] ) ; } else { sum -= arr [ i ] ; set . delete ( arr [ i ++ ] ) ; } } return maxsum ; }
function findSum ( s ) { let sum = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { for ( let j = i + 1 ; j < s . length ; j ++ ) { if ( s [ i ] == s [ j ] ) { sum += ( j - i ) ; } } } return sum ; }
function maxSubarray ( a , k , n ) { var answer = 0 ; var start = 0 ; var s = 0 ; var dq = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { var x = a [ i ] ; while ( dq . length != 0 && a [ dq [ 0 ] ] <= x ) dq . shift ( ) ; dq . push ( i ) ; s += x ; var cost = a [ dq [ 0 ] ] * ( answer + 1 ) - s ; if ( cost <= k ) answer ++ ; else { if ( dq [ 0 ] == start ) dq . shift ( ) ; s -= a [ start ++ ] ; } } return answer ; }
function maxGCD ( n ) { return parseInt ( n / 2 ) ; }
function canSplitArray ( arr , n , k ) { for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] <= k ) { return " " ; } } return " " ; }
function longestGP ( A , N ) { if ( N < 2 ) return N ; let length = 1 , common_ratio = 1 ; let maxlength = 1 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i + 1 ] % A [ i ] == 0 ) { if ( A [ i + 1 ] / A [ i ] == common_ratio ) { length = length + 1 ; maxlength = Math . max ( maxlength , length ) ; } else { common_ratio = A [ i + 1 ] / A [ i ] ; length = 2 ; } } else { maxlength = Math . max ( maxlength , length ) ; length = 1 ; } } maxlength = Math . max ( maxlength , length ) ; return maxlength ; }
function uncrossedLines ( a , b , n , m ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < ( n + 1 ) ; i ++ ) { dp [ i ] = new Array ( m + 1 ) ; for ( let j = 0 ; j < ( m + 1 ) ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= m ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 0 ; else if ( a [ i - 1 ] == b [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ n ] [ m ] ; }
function minFlips ( mat , s ) { let N = mat . length ; let M = mat [ 0 ] . length ; let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) { if ( mat [ i ] [ j ] != s [ ( i + j ) ] - ' ' ) { count ++ ; } } } return count ; }
function lcmpair ( l , r ) { var x , y ; x = l ; y = 2 * l ; if ( y > r ) { document . write ( " " ) ; } else { document . write ( " " + x + " " + y + " " ) ; } }
function smallSumSubset ( data , target , maxVal ) { let sum = 0 ; for ( let i = 0 ; i < data . length ; i ++ ) sum += data [ i ] ; if ( target <= 0 ) return 0 ; else if ( sum < target ) return maxVal ; else if ( sum == target ) return data . length ; else if ( data [ 0 ] >= target ) return 1 ; else if ( data [ 0 ] < target ) { let temp = [ ] ; for ( let i = 1 ; i < data . length ; i ++ ) temp . push ( data [ i ] ) ; return Math . min ( smallSumSubset ( temp , target , maxVal ) , 1 + smallSumSubset ( temp , target - data [ 0 ] , maxVal ) ) ; } }
function minServerLoads ( n , servers ) { var totalLoad = 0 ; servers . forEach ( i => { totalLoad += i ; } ) ; var requiredLoad = parseInt ( totalLoad / 2 ) ; var dp = Array . from ( Array ( n + 1 ) , ( ) => Array ( requiredLoad + 1 ) . fill ( 0 ) ) ; for ( var i = 1 ; i < n + 1 ; i ++ ) { for ( var j = 1 ; j < requiredLoad + 1 ; j ++ ) { if ( servers [ i - 1 ] > j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; else dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , servers [ i - 1 ] + dp [ i - 1 ] [ j - servers [ i - 1 ] ] ) ; } } return totalLoad - 2 * dp [ n ] [ requiredLoad ] ; }
function maxDiffSubsets ( arr ) { var totalSum = 0 ; var pos = false , neg = false ; var min = Number . MAX_VALUE ; for ( i = 0 ; i < arr . length ; i ++ ) { totalSum += Math . abs ( arr [ i ] ) ; if ( arr [ i ] > 0 ) pos = true ; if ( arr [ i ] < 0 ) neg = true ; if ( arr [ i ] < min ) min = arr [ i ] ; } if ( pos && neg ) return totalSum ; else return totalSum - 2 * min ; }
function minDiffSubArray ( arr , n ) { let prefix_sum = new Array ( n ) ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; let suffix_sum = new Array ( n ) ; suffix_sum [ n - 1 ] = arr [ n - 1 ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) suffix_sum [ i ] = suffix_sum [ i + 1 ] + arr [ i ] ; let minDiff = Number . MAX_VALUE ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let diff = Math . abs ( prefix_sum [ i ] - suffix_sum [ i + 1 ] ) ; if ( diff < minDiff ) minDiff = diff ; } return minDiff ; }
function minDiffSubArray ( arr , n ) { var total_sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) total_sum += arr [ i ] ; var prefix_sum = 0 ; var minDiff = 1000000000 ; for ( var i = 0 ; i < n - 1 ; i ++ ) { prefix_sum += arr [ i ] ; var diff = Math . abs ( ( total_sum - prefix_sum ) - prefix_sum ) ; if ( diff < minDiff ) minDiff = diff ; } return minDiff ; }
function CtSubarr ( arr , N , K ) { var st = new Set ( ) ; var prefixSum = 0 ; st . add ( prefixSum ) ; var res = 0 ; for ( var i = 0 ; i < N ; i ++ ) { prefixSum += arr [ i ] ; if ( st . has ( prefixSum - K ) ) { res += 1 ; prefixSum = 0 ; st = new Set ( ) ; st . add ( 0 ) ; } st . add ( prefixSum ) ; } return res ; }
function getMaxLength ( arr , N ) { let res = 2 ; let dist = 2 ; let curradj = ( arr [ 1 ] - arr [ 0 ] ) ; let prevadj = ( arr [ 1 ] - arr [ 0 ] ) ; for ( let i = 2 ; i < N ; i ++ ) { curradj = arr [ i ] - arr [ i - 1 ] ; if ( curradj == prevadj ) { dist ++ ; } else { prevadj = curradj ; res = Math . max ( res , dist ) ; dist = 2 ; } } res = Math . max ( res , dist ) ; return res ; }
function uniqueElement ( arr ) { var x = arr [ 0 ] ; var flag = 1 ; for ( var i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] != x ) { flag = 0 ; break ; } } if ( flag == 1 ) document . write ( " " ) ; else document . write ( " " ) ; }
function findPermutation ( arr , N ) { var pos = arr . size + 1 ; if ( pos > N ) return 1 ; var res = 0 ; for ( var i = 1 ; i <= N ; i ++ ) { if ( ! arr . has ( i ) ) { if ( i % pos == 0 pos % i == 0 ) { arr . add ( i ) ; res += findPermutation ( arr , N ) ; arr . delete ( i ) ; } } } return res ; }
function minimum_required_operations ( arr , n , k ) { let answer = 0 ; let mod = 1000000007 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] + arr [ i + 1 ] > k ) { if ( arr [ i ] > k ) { answer += ( arr [ i ] - k ) ; arr [ i ] = k ; } answer += ( arr [ i ] + arr [ i + 1 ] ) - k ; arr [ i + 1 ] = ( k - arr [ i ] ) ; answer %= mod ; } } return answer ; }
function minSteps ( arr , n , k ) { let i , cnt = 0 ; let flag ; if ( k == 1 ) flag = 0 ; else flag = 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == flag ) { cnt ++ ; flag = ( flag + 1 ) % 2 ; } } return cnt ; }
function solve ( arr , n , X , Y ) { var diff = Y - X ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 1 ) { diff = diff % ( arr [ i ] - 1 ) ; } } if ( diff == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function Numberofways ( n ) { var count = 0 ; for ( var a = 1 ; a < n ; a ++ ) { for ( var b = 1 ; b < n ; b ++ ) { var c = n - ( a + b ) ; if ( a + b > c && a + c > b && b + c > a ) { count ++ ; } } } return count ; }
function getMinOps ( arr ) { let ans = 0 ; for ( let i = 0 ; i < arr . length - 1 ; i ++ ) { ans += Math . max ( arr [ i ] - arr [ i + 1 ] , 0 ) ; } return ans ; }
function maxsubStringLength ( S , N ) { let arr = Array . from ( { length : N } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < N ; i ++ ) if ( S [ i ] == ' ' S [ i ] == ' ' S [ i ] == ' ' S [ i ] == ' ' S [ i ] == ' ' ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; let maxLen = 0 ; let curr_sum = 0 ; let hash = new Map ( ) ; for ( let i = 0 ; i < N ; i ++ ) { curr_sum += arr [ i ] ; if ( curr_sum == 0 ) maxLen = Math . max ( maxLen , i + 1 ) ; if ( hash . has ( curr_sum ) ) maxLen = Math . max ( maxLen , i - hash . get ( curr_sum ) ) ; else hash . set ( curr_sum , i ) ; } return maxLen ; }
function largest_subarray ( a , n ) { let index = new Map ( ) ; let ans = 0 ; for ( let i = 0 , j = 0 ; i < n ; i ++ ) { j = Math . max ( index . has ( a [ i ] ) ? index . get ( a [ i ] ) : 0 , j ) ; ans = Math . max ( ans , i - j + 1 ) ; index . set ( a [ i ] , i + 1 ) ; } return ans ; }
function knapSack ( nums , S ) { let sum = 0 ; for ( let i = 0 ; i < nums . length ; i ++ ) sum += nums [ i ] ; if ( sum < S || - sum > - S || ( S + sum ) % 2 == 1 ) return 0 ; let dp = new Array ( parseInt ( ( S + sum ) / 2 , 10 ) + 1 ) ; dp . fill ( 0 ) ; dp [ 0 ] = 1 ; for ( let num = 0 ; num < nums . length ; num ++ ) { for ( let i = dp . length - 1 ; i >= nums [ num ] ; i -- ) { dp [ i ] += dp [ i - nums [ num ] ] ; } } return dp [ dp . length - 1 ] ; }
function getMaxSum ( a , n ) { let dp = new Array ( n ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } dp [ 0 ] [ 0 ] = a [ 0 ] ; dp [ 0 ] [ 1 ] = a [ 0 ] * a [ 0 ] ; let max_sum = Math . max ( dp [ 0 ] [ 0 ] , dp [ 0 ] [ 1 ] ) ; for ( let i = 1 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = Math . max ( a [ i ] , dp [ i - 1 ] [ 0 ] + a [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( dp [ i - 1 ] [ 1 ] + a [ i ] , a [ i ] * a [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 0 ] + a [ i ] * a [ i ] ) ; max_sum = Math . max ( max_sum , dp [ i ] [ 1 ] ) ; max_sum = Math . max ( max_sum , dp [ i ] [ 0 ] ) ; } return max_sum ; }
function countSubstrings ( s , n ) { var count = 0 , sum = 0 ; var mp = new Map ( ) ; if ( mp . has ( 0 ) ) mp . set ( 0 , mp . get ( 0 ) + 1 ) else mp . set ( 0 , 1 ) ; for ( var i = 0 ; i < n ; ++ i ) { sum += ( s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ; if ( mp . has ( sum - ( i + 1 ) ) ) count += mp . get ( sum - ( i + 1 ) ) ; if ( mp . has ( sum - ( i + 1 ) ) ) mp . set ( sum - ( i + 1 ) , mp . get ( sum - ( i + 1 ) ) + 1 ) else mp . set ( sum - ( i + 1 ) , 1 ) } return count ; }
function min_operations ( A ) { if ( A . length == 0 ) return 0 ; let ans = A [ 0 ] ; for ( let i = 1 ; i < A . length ; i ++ ) { ans += Math . max ( A [ i ] - A [ i - 1 ] , 0 ) ; } return ans ; }
function solve ( n ) { var ans = 0 ; for ( y = n + 1 ; y <= n * n + n ; y ++ ) { if ( ( n * n ) % ( y - n ) == 0 ) { ans += 1 ; } } document . write ( ans ) ; }
function check ( arr , n ) { var i , g ; g = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] > 0 && g == 1 ) return false ; if ( arr [ i ] - arr [ i - 1 ] < 0 ) g = 1 ; } return true ; }
function findMinSum ( A , K , n ) { let minimum_sum = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { let mini = Number . MAX_VALUE ; for ( let j = i + K ; j < n ; j ++ ) mini = Math . min ( mini , A [ j ] ) ; if ( mini == Number . MAX_VALUE ) continue ; minimum_sum = Math . min ( minimum_sum , A [ i ] + mini ) ; } document . write ( minimum_sum ) ; }
function calc_distance ( A , B , n ) { var distance_traveled_A = 0 ; var distance_traveled_B = 0 ; var answer = 0 ; for ( i = 0 ; i < 5 ; i ++ ) { distance_traveled_A += A [ i ] ; distance_traveled_B += B [ i ] ; if ( ( distance_traveled_A == distance_traveled_B ) && ( A [ i ] == B [ i ] ) ) { answer += A [ i ] ; } } return answer ; }
function solve ( n , d , input ) { let a = new Array ( N ) ; let cnt = new Array ( V + 1 ) ; for ( let i = 0 ; i < n ; ++ i ) a [ i ] = input [ i ] ; let answer = 0 ; for ( let i = 0 ; i < d ; ++ i ) cnt [ a [ i ] ] ++ ; for ( let i = d ; i <= n - 1 ; ++ i ) { let acc = 0 ; let low_median = - 1 , high_median = - 1 ; for ( let v = 0 ; v <= V ; ++ v ) { acc += cnt [ v ] ; if ( low_median == - 1 && acc >= parseInt ( Math . floor ( ( d + 1 ) / 2.0 ) ) ) low_median = v ; if ( high_median == - 1 && acc >= parseInt ( Math . ceil ( ( d + 1 ) / 2.0 ) ) ) high_median = v ; } let double_median = low_median + high_median ; if ( a [ i ] >= double_median ) answer ++ ; cnt [ a [ i - d ] ] -- ; cnt [ a [ i ] ] ++ ; } document . write ( answer ) ; }
function equalXORandOR ( n ) { var m = 0 ; var MSB = parseInt ( Math . log ( n ) ) ; for ( i = 0 ; i <= MSB ; i ++ ) { if ( ( n & ( 1 << i ) ) <= 0 ) { m += ( 1 << i ) ; } } return m ; }
function findMinSoln ( n , k ) { var minSoln = 1000000000 ; for ( var i = 1 ; i < k ; i ++ ) { if ( n % i == 0 ) minSoln = Math . min ( minSoln , ( n / i ) * k + i ) ; } return minSoln ; }
function dfs ( val , cost , tr , u , s ) { s = s + cost [ u ] ; if ( s < 0 ) s = 0 ; if ( s > val [ u ] ) return ; cnt ++ ; for ( var i = 0 ; i < tr [ u ] . length ; i ++ ) { dfs ( val , cost , tr , tr [ u ] [ i ] , s ) ; } }
function ContinuousElements ( a , n ) { if ( n == 1 ) return false ; let curr = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( a [ i ] != a [ i - 1 ] ) { if ( curr == 1 ) return false ; else curr = 0 ; } curr ++ ; } if ( curr == 1 ) return false ; return true ; }
function findNewString ( s ) { var ans = 0 ; var freq = new Array ( 26 ) . fill ( 0 ) ; var n = s . length ; for ( let i = 0 ; i < n ; i ++ ) { ans += freq [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] ; freq [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] += 1 ; } return ans ; }
function min_remove ( arr , n , k ) { arr . sort ( ) ; let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { if ( arr [ j ] - arr [ i ] <= k ) { ans = Math . min ( ans , n - j + i - 1 ) ; } } } return ans ; }
function solve ( arr , n ) { var countzeroes = 0 ; var countones = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) countzeroes ++ ; else countones ++ ; } if ( Math . abs ( countzeroes - countones ) == 1 ) document . write ( " " ) ; else document . write ( " " ) ; }
function bs ( ar , n , ele ) { let start = 0 ; let end = n - 1 ; let ch = ' ' ; while ( start <= end ) { let mid = start + Math . floor ( ( end - start ) / 2 ) ; if ( ar [ mid ] == ele ) end = mid - 1 ; else if ( ar [ mid ] < ele ) { ch = ar [ mid ] ; start = mid + 1 ; } else end = mid - 1 ; } return ch ; }
function countPairs ( N , arr ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( i == arr [ arr [ i ] - 1 ] - 1 ) { count ++ ; } } document . write ( count / 2 ) ; }
function solve ( A , N ) { let i = 0 ; let k = 0 ; for ( let j = 1 ; j < N ; j ++ ) { let tempK = Math . min ( A [ i ] , A [ j ] ) / ( j - i ) ; if ( tempK > k ) { k = tempK ; } if ( A [ j ] >= A [ i ] / ( j - i ) ) i = j ; } return k ; }
function split ( arr , n ) { arr . sort ( ) ; let count = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] == 1 ) { count = 2 ; break ; } } document . write ( count ) ; }
function FindPairs ( n , k ) { document . write ( 1 + " " + n + " " ) ; k -- ; for ( let i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { document . write ( 1 + " " + i + " " ) ; k -- ; if ( k == 0 ) break ; if ( i != n / i ) { document . write ( 1 + " " + n / i + " " ) ; k -- ; } if ( k == 0 ) break ; } } }
function minOperations ( S , K ) { var ans = 0 ; for ( var i = 0 ; i < K ; i ++ ) { var zero = 0 , one = 0 ; for ( var j = i ; j < S . length ; j += K ) { if ( S [ j ] === " " ) zero ++ ; else one ++ ; } ans += Math . min ( zero , one ) ; } return ans ; }
function countSubString ( S , C ) { var count = 0 ; var conCount = 0 ; for ( var i = 0 ; i < S . length ; i ++ ) { var ch = S [ i ] ; if ( ch === C ) conCount ++ ; else { count += ( conCount * ( conCount + 1 ) ) / 2 ; conCount = 0 ; } } count += ( conCount * ( conCount + 1 ) ) / 2 ; document . write ( count ) ; }
function findsubArray ( arr , N , K ) { var res = N + 1 ; for ( i = 0 ; i < N ; i ++ ) { var curr_prod = 1 ; for ( j = i ; j < N ; j ++ ) { curr_prod = curr_prod * arr [ j ] ; if ( curr_prod % N == K && res > ( j - i + 1 ) ) { res = Math . min ( res , j - i + 1 ) ; break ; } } } return ( res == N + 1 ) ? 0 : res ; }
function countTriplets ( A , N ) { let ans = 0 ; let map = new Map ( ) ; for ( let j = N - 2 ; j >= 1 ; j -- ) { if ( map . has ( A [ j + 1 ] ) ) map . set ( A [ j + 1 ] , map . get ( A [ j + 1 ] ) + 1 ) ; else map . set ( A [ j + 1 ] , 1 ) ; for ( let i = 0 ; i < j ; i ++ ) { let target = A [ i ] * A [ j ] ; if ( map . has ( target ) ) ans += map . get ( target ) ; } } return ans ; }
function checkrules ( s ) { if ( s . length == 0 ) return true ; if ( s [ 0 ] != ' ' ) return false ; if ( s . length > 2 ) { if ( s [ 1 ] == ' ' && s [ 2 ] == ' ' ) return checkrules ( s . substring ( 3 ) ) ; } return checkrules ( s . substring ( 1 ) ) ; } var str = " " ; if ( checkrules ( str ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function Maxlen ( arr , n ) { let ans = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count = 0 ; else count ++ ; ans = Math . max ( ans , count ) ; } return ans ; }
function count_elements ( arr , n ) { let count = 1 ; let max = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { count += 1 ; max = arr [ i ] ; } } return count ; }
function printNum ( L , R ) { for ( let i = L ; i <= R ; i ++ ) { let temp = i ; let c = 10 ; let flag = 0 ; while ( temp > 0 ) { if ( temp % 10 >= c ) { flag = 1 ; break ; } c = temp % 10 ; temp /= 10 ; } if ( flag == 0 ) document . write ( i + " " ) ; } }
function countSub ( str ) { var n = str . length ; var ans = 0 ; var cnt = Array ( 26 ) . fill ( 0 ) ; var i = 0 , j = 0 ; while ( i < n ) { if ( j < n && ( cnt [ str [ j ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] == 0 ) ) { cnt [ str [ j ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; ans += ( j - i + 1 ) ; j ++ ; } else { cnt [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] -- ; i ++ ; } } return ans ; }
function findMaxValue ( N , K ) { let packages ; let maxi = 1 ; for ( let i = 1 ; i <= K ; i ++ ) { if ( N % i == 0 ) maxi = Math . max ( maxi , i ) ; } packages = parseInt ( N / maxi ) ; document . write ( packages ) ; }
function solve ( a , n ) { let mx = 0 ; for ( let j = 1 ; j < n ; j ++ ) { if ( mx > a [ j ] ) return false ; mx = Math . max ( mx , a [ j - 1 ] ) ; } return true ; }
function maxSide ( a , n ) { let sideLength = 0 ; a . sort ( ) ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( a [ i ] > sideLength ) { sideLength ++ ; } else { break ; } } document . write ( sideLength ) ; }
function countPairs ( X , Y , m , n ) { let suffix = Array . from ( { length : 1005 } , ( _ , i ) => 0 ) ; let total_pairs = 0 ; for ( let i = 0 ; i < n ; i ++ ) suffix [ Y [ i ] ] ++ ; for ( let i = 1e3 ; i >= 3 ; i -- ) suffix [ i ] += suffix [ i + 1 ] ; for ( let i = 0 ; i < m ; i ++ ) { if ( X [ i ] == 0 ) continue ; else if ( X [ i ] == 1 ) { total_pairs += suffix [ 0 ] ; continue ; } else if ( X [ i ] == 2 ) total_pairs += suffix [ 5 ] ; else if ( X [ i ] == 3 ) total_pairs += suffix [ 2 ] + suffix [ 4 ] ; else total_pairs += suffix [ X [ i ] + 1 ] ; total_pairs += suffix [ 0 ] + suffix [ 1 ] ; } return total_pairs ; }
function splitArray ( arr , N ) { arr . sort ( ) ; let result = Number . MAX_VALUE ; for ( let i = 1 ; i < N ; i ++ ) { result = Math . min ( result , arr [ i ] - arr [ i - 1 ] ) ; } return result ; }
function findSolutions ( N ) { let count = 0 ; for ( let i = 1 ; i <= Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { if ( ( i + parseInt ( N / i ) ) % 2 == 0 ) { count ++ ; } } } document . write ( 4 * count + " " ) ; }
function findValue ( R , C ) { let k = ( R * ( R - 1 ) ) / 2 + 1 ; let diff = R + 1 ; for ( let i = 1 ; i < C ; i ++ ) { k = ( k + diff ) ; diff ++ ; } return k ; }
function get_subset_count ( arr , K , N ) { ( arr ) . sort ( function ( a , b ) { return a - b ; } ) ; let left , right ; left = 0 ; right = N - 1 ; let ans = 0 ; while ( left <= right ) { if ( arr [ left ] + arr [ right ] < K ) { ans += 1 << ( right - left ) ; left ++ ; } else { right -- ; } } return ans ; }
function naive_find_x ( N ) { var c = 0 , i ; for ( i = 1 ; i < N ; i ++ ) { c += i * i * i ; if ( c >= N ) break ; } return i ; }
function binary_searched_find_x ( k ) { var l = 0 ; var r = k ; var ans = 0 ; while ( l <= r ) { var mid = parseInt ( l + ( r - l ) / 2 ) ; if ( Math . pow ( ( ( mid * ( mid + 1 ) ) / 2 ) , 2 ) >= k ) { ans = mid ; r = mid - 1 ; } else { l = mid + 1 ; } } return ans ; }
function lenOfLongZigZagArr ( a , n ) { var max = 1 , len = 1 ; for ( var i = 0 ; i < n - 1 ; i ++ ) { if ( i % 2 == 0 && ( a [ i ] < a [ i + 1 ] ) ) len ++ ; else if ( i % 2 == 1 && ( a [ i ] > a [ i + 1 ] ) ) len ++ ; else { if ( max < len ) max = len ; len = 1 ; } } if ( max < len ) max = len ; return max ; }
function FindColumn ( mat ) { let row = 0 , col = M - 1 ; let flag = 0 ; while ( row < N && col >= 0 ) { if ( mat [ row ] [ col ] == 1 ) { col -- ; flag = 1 ; } else { row ++ ; } } col ++ ; if ( flag != 0 ) return col + 1 ; else return - 1 ; }
function minMaxDiff ( arr , n , k ) { var max_adj_dif = - 1000000000 ; for ( var i = 0 ; i < n - 1 ; i ++ ) max_adj_dif = Math . max ( max_adj_dif , Math . abs ( arr [ i ] - arr [ i + 1 ] ) ) ; if ( max_adj_dif == 0 ) return 0 ; var best = 1 ; var worst = max_adj_dif ; var mid , required ; while ( best < worst ) { mid = ( best + worst ) / 2 ; required = 0 ; for ( var i = 0 ; i < n - 1 ; i ++ ) { required += parseInt ( ( Math . abs ( arr [ i ] - arr [ i + 1 ] ) - 1 ) / mid ) ; } if ( required > k ) best = mid + 1 ; else worst = mid ; } return worst ; }
function findNumbers ( N , M ) { let m = M ; let remLen = new Map ( ) ; let len , remainder = 0 ; for ( len = 1 ; len <= N + 1 ; ++ len ) { remainder = M % N ; if ( ! remLen . has ( remainder ) ) { remLen . set ( remainder , len ) ; } else { break ; } M = M * 10 + m ; M = M % N ; } let LenA = len ; let LenB = remLen . get ( remainder ) ; for ( let i = 0 ; i < LenB ; ++ i ) document . write ( m ) ; document . write ( " " ) ; for ( let i = 0 ; i < LenA ; ++ i ) document . write ( m ) ; }
function countTriplets ( a , n , x ) { var answer = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { for ( var k = j + 1 ; k < n ; k ++ ) { var temp = [ ] ; temp . push ( a [ i ] ) ; temp . push ( a [ j ] ) ; temp . push ( a [ k ] ) ; temp . sort ( ( a , b ) => a - b ) if ( temp [ 0 ] < temp [ 1 ] && temp [ 1 ] < temp [ 2 ] && temp [ 0 ] * temp [ 1 ] * temp [ 2 ] <= x ) answer ++ ; } } } return answer ; }
function FindRank ( arr , length ) { document . write ( " " + " " ) ; for ( i = 1 ; i < arr . length ; i ++ ) { var rank = 1 ; for ( j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) rank ++ ; } document . write ( rank + " " ) ; } }
function xorOfSum ( a , n ) { let answer = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) answer ^= ( a [ i ] + a [ j ] ) ; } return answer ; }
function permutation ( arr , n ) { let hash = new Set ( ) ; let maxEle = 0 ; for ( let i = 0 ; i < n ; i ++ ) { hash . add ( arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } if ( maxEle != n ) return false ; if ( hash . length == n ) return true ; return false ; }
function getPositionCount ( a , n ) { var count = 1 ; var min = a [ 0 ] ; for ( var i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= min ) { min = a [ i ] ; count ++ ; } } return count ; }
function CountSubSet ( arr , n , X ) { let N = Math . pow ( 2 , n ) ; let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i & ( 1 << j ) ) if ( arr [ j ] == X ) count += 1 ; } } return count ; }
function countNums ( l , r ) { let cnt = 0 ; for ( let i = l ; i <= r ; i ++ ) { let lastDigit = ( i % 10 ) ; if ( ( lastDigit % 10 ) == 2 || ( lastDigit % 10 ) == 3 || ( lastDigit % 10 ) == 9 ) { cnt ++ ; } } return cnt ; }
function canBeBalanced ( s , n ) { var count = 0 , count_1 = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' ) count ++ ; else count -- ; count_1 = Math . min ( count_1 , count ) ; } if ( count_1 >= - 1 && count == 0 ) return true ; return false ; }
function sentinelSearch ( arr , n , key ) { var last = arr [ n - 1 ] ; arr [ n - 1 ] = key ; var i = 0 ; while ( arr [ i ] != key ) i ++ ; arr [ n - 1 ] = last ; if ( ( i < n - 1 ) || ( arr [ n - 1 ] == key ) ) document . write ( key + " " + i ) ; else document . write ( " " ) ; }
function insertNames ( arr , n ) { let set = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! set . has ( arr [ i ] ) ) { document . write ( " " + " " ) ; set . add ( arr [ i ] ) ; } else { document . write ( " " + " " ) ; } } }
function containsElement ( arr , n ) { let xorArr = 0 ; for ( let i = 0 ; i < n ; ++ i ) xorArr ^= arr [ i ] ; for ( let i = 0 ; i < n ; ++ i ) { let x = xorArr ^ arr [ i ] ; if ( arr [ i ] == x ) return true ; } return false ; }
function length_substring ( S , K ) { let curr_cnt = 0 , prev_cnt = 0 , max_len ; for ( let i = 0 ; i < S . length ; i ++ ) { if ( S [ i ] == K ) { curr_cnt += 1 ; } else { prev_cnt = Math . max ( prev_cnt , curr_cnt ) ; curr_cnt = 0 ; } } prev_cnt = Math . max ( prev_cnt , curr_cnt ) ; max_len = prev_cnt ; return max_len ; }
function LeftRightNode ( preorder , n ) { var min = 1000000000 , max = - 1000000000 ; for ( var i = 0 ; i < n ; i ++ ) { if ( min > preorder [ i ] ) min = preorder [ i ] ; if ( max < preorder [ i ] ) max = preorder [ i ] ; } document . write ( " " + min + " " ) ; document . write ( " " + max ) ; }
function distinct ( arr , n ) { let count = 0 ; if ( n == 1 ) return 1 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( i == 0 ) { if ( arr [ i ] != arr [ i + 1 ] ) count += 1 ; } else { if ( arr [ i ] != arr [ i + 1 ] arr [ i ] != arr [ i - 1 ] ) count += 1 ; } } if ( arr [ n - 1 ] != arr [ n - 2 ] ) count += 1 ; return count ; }
function linearCheck ( ar , arr ) { for ( let i = 0 ; i < m ; i ++ ) { let matched = true ; for ( let j = 0 ; j < n ; j ++ ) { if ( ar [ i ] [ j ] != arr [ j ] ) { matched = false ; break ; } } if ( matched ) return i + 1 ; } return - 1 ; }
function maximum_middle_value ( n , k , arr ) { let ans = - 1 ; let low = Math . floor ( ( n + 1 - k ) / 2 ) ; let high = Math . floor ( ( ( n + 1 - k ) / 2 ) + k ) ; for ( let i = low ; i <= high ; i ++ ) { ans = Math . max ( ans , arr [ i - 1 ] ) ; } return ans ; }
function firstRepeating ( str ) { let visited = new Array ( NO_OF_CHARS ) ; for ( let i = 0 ; i < NO_OF_CHARS ; i ++ ) visited [ i ] = false ; let res = - 1 ; for ( let i = str . length - 1 ; i >= 0 ; i -- ) { if ( visited [ str [ i ] . charCodeAt ( ) ] == false ) visited [ str [ i ] . charCodeAt ( ) ] = true ; else res = i ; } return res ; }
function maxSumArray ( arr , n ) { var sum = 0 ; var mp = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( mp . has ( arr [ i ] ) ) mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) else mp . set ( arr [ i ] , 1 ) } var minimum = 1000000000 ; mp . forEach ( ( value , key ) => { minimum = Math . min ( minimum , value * key ) ; } ) ; return ( sum - minimum ) ; }
function MinimumX ( a , b , c , k ) { let x = Number . MAX_VALUE ; if ( k <= c ) return 0 ; let h = k - c ; let l = 0 ; while ( l <= h ) { let m = Math . floor ( ( l + h ) / 2 ) ; if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) { x = Math . min ( x , m ) ; h = m - 1 ; } else if ( ( a * m * m ) + ( b * m ) < ( k - c ) ) l = m + 1 ; else return m ; } return x ; }
function findMissing ( arr , n ) { let l = 0 , h = n - 1 ; let mid ; while ( h > l ) { mid = l + Math . floor ( ( h - l ) / 2 ) ; if ( arr [ mid ] - mid == arr [ 0 ] ) { if ( arr [ mid + 1 ] - arr [ mid ] > 1 ) return arr [ mid ] + 1 ; else { l = mid + 1 ; } } else { if ( arr [ mid ] - arr [ mid - 1 ] > 1 ) return arr [ mid ] - 1 ; else { h = mid - 1 ; } } } return - 1 ; }
function maxSum ( arr , n , K ) { var maximum = - 1000000000 ; for ( var i = 0 ; i < n ; i ++ ) { var sumk = 0 ; for ( var j = i ; j < n ; j += K ) sumk = sumk + arr [ j ] ; maximum = Math . max ( maximum , sumk ) ; } return maximum ; }
function countGreater ( arr , n , k ) { var l = 0 ; var r = n - 1 ; var leftGreater = n ; while ( l <= r ) { var m = l + parseInt ( ( r - l ) / 2 ) ; if ( arr [ m ] > k ) { leftGreater = m ; r = m - 1 ; } else l = m + 1 ; } return ( n - leftGreater ) ; }
function countPairs ( s1 , n1 , s2 , n2 ) { let freq1 = new Array ( 26 ) ; let freq2 = new Array ( 26 ) ; freq1 . fill ( 0 ) ; freq2 . fill ( 0 ) ; let i , count = 0 ; for ( i = 0 ; i < n1 ; i ++ ) freq1 [ s1 [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ++ ; for ( i = 0 ; i < n2 ; i ++ ) freq2 [ s2 [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ++ ; for ( i = 0 ; i < 26 ; i ++ ) count += ( Math . min ( freq1 [ i ] , freq2 [ i ] ) ) ; return count ; }
function findpair ( l , r ) { let c = 0 ; for ( let i = l ; i <= r ; i ++ ) { for ( let j = i + 1 ; j <= r ; j ++ ) { if ( j % i == 0 && j != i ) { document . write ( i + " " + j + " " ) ; c = 1 ; break ; } } if ( c == 1 ) break ; } }
function findpair ( l , r ) { let ans1 = l ; let ans2 = 2 * l ; document . write ( ans1 + " " + ans2 ) ; }
function minIndex ( arr , n , pos ) { var num = arr [ pos ] ; var i = pos - 1 ; while ( i >= 0 ) { if ( arr [ i ] != num ) break ; i -- ; } return i + 1 ; }
function strScore ( str , s , n ) { let m = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) m . set ( str [ i ] , i + 1 ) ; if ( ! m . has ( s ) ) return 0 ; let score = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) score += s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) + 1 ; score = score * m . get ( s ) ; return score ; }
function countSubArrays ( arr , n , K ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { let bitwise_or = 0 ; for ( let k = i ; k <= j ; k ++ ) { bitwise_or = bitwise_or | arr [ k ] ; } if ( bitwise_or >= K ) count ++ ; } } return count ; }
function max_min ( a , n ) { a . sort ( ) ; return Math . min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) ; }
function findMinDifference ( arr , n ) { arr . sort ( ) ; let diff1 = arr [ n - 1 ] - arr [ 1 ] ; let diff2 = arr [ n - 2 ] - arr [ 0 ] ; return Math . min ( diff1 , diff2 ) ; }
function minimal ( a , n ) { let lo = 0 , hi = n - 1 ; while ( lo < hi ) { let mid = ( lo + hi ) >> 1 ; if ( a [ mid ] < a [ mid + 1 ] ) { hi = mid ; } else { lo = mid + 1 ; } } return lo ; }
function LowerInsertionPoint ( arr , n , X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; let lowerPnt = 0 ; let i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i = i * 2 ; } while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ; return lowerPnt ; }
function minIndex ( arr , n ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) { if ( 2 * arr [ i ] == sum ) return ( i + 1 ) ; } return - 1 ; }
function smallest_pair ( a , n ) { let min = Number . MAX_VALUE , secondMin = Number . MAX_VALUE ; for ( let j = 0 ; j < n ; j ++ ) { if ( a [ j ] < min ) { secondMin = min ; min = a [ j ] ; } else if ( ( a [ j ] < secondMin ) && a [ j ] != min ) secondMin = a [ j ] ; } return ( secondMin + min ) ; }
function checkSorted ( n , arr ) { var b = Array ( n ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) b [ i ] = arr [ i ] ; b . sort ( ) ; var ct = 0 ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] != b [ i ] ) ct ++ ; if ( ct == 0 ct == 2 ) return true ; else return false ; }
function printIntersection ( A , B ) { for ( var i = 0 ; i < M ; i ++ ) { for ( var j = 0 ; j < N ; j ++ ) { if ( A [ i ] [ j ] == B [ i ] [ j ] ) document . write ( A [ i ] [ j ] + " " ) ; else document . write ( " " ) ; } document . write ( " " ) ; } }
function checkIndices ( Arr , N ) { for ( var i = 0 ; i < N - 1 ; i ++ ) { for ( var j = i + 1 ; j < N ; j ++ ) { if ( Arr [ i ] != Arr [ j ] ) { if ( Arr [ Arr [ i ] - 1 ] == Arr [ Arr [ j ] - 1 ] ) return true ; } } } return false ; }
function LongestSubarray ( arr , n , k ) { let count = 1 ; let max_length = 1 ; let prev_mod = arr [ 0 ] % k ; for ( let i = 1 ; i < n ; i ++ ) { let curr_mod = arr [ i ] % k ; if ( curr_mod == prev_mod ) { count ++ ; } else { max_length = Math . max ( max_length , count ) ; count = 1 ; prev_mod = curr_mod ; } } return Math . max ( max_length , count ) ; }
function longestsubarray ( arr , n , k ) { let current_count = 0 ; let max_count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) current_count ++ ; else current_count = 0 ; max_count = Math . max ( current_count , max_count ) ; } return max_count ; }
function countSegments ( a , n , x ) { let flag = false ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) { flag = true ; } else { if ( flag ) count += 1 ; flag = false ; } } if ( flag ) count += 1 ; return count ; }
function check ( s ) { for ( let i = 0 ; i < s . length - 1 ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return true ; return false ; }
function numberOfElements ( height , n ) { var max_so_far = 0 ; var coun = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( height [ i ] > max_so_far ) { max_so_far = height [ i ] ; coun ++ ; } } return coun ; }
function count_triples ( n , k ) { var i = 0 , j = 0 , l = 0 ; var count = 0 ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { for ( l = 1 ; l <= n ; l ++ ) { if ( ( i + j ) % k == 0 && ( i + l ) % k == 0 && ( j + l ) % k == 0 ) count ++ ; } } } return count ; }
function countAnomalies ( arr , n , k ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && Math . abs ( arr [ i ] - arr [ j ] ) <= k ) break ; if ( j == n ) res ++ ; } return res ; }
function countEle ( s , a , N ) { var mp = new Map ( ) ; for ( var i = 0 ; i < N ; ++ i ) { var num = a [ i ] ; if ( mp . has ( num ) ) document . write ( " " ) ; else { var cnt = 0 ; while ( s [ s . length - 1 ] != num ) { mp . set ( s [ s . length - 1 ] , true ) ; s . pop ( ) ; cnt ++ ; } s . pop ( ) ; cnt ++ ; document . write ( cnt + " " ) ; } } }
function colMaxDiff ( mat ) { let max_diff = Number . MIN_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { let max_val = mat [ 0 ] [ i ] , min_val = mat [ 0 ] [ i ] ; for ( let j = 1 ; j < N ; j ++ ) { max_val = Math . max ( max_val , mat [ j ] [ i ] ) ; min_val = Math . min ( min_val , mat [ j ] [ i ] ) ; } max_diff = Math . max ( max_diff , max_val - min_val ) ; } return max_diff ; }
function countChar ( str ) { var n = str . length ; if ( n <= 2 ) return n ; var count = 2 ; for ( var i = 1 ; i < n - 1 ; i ++ ) if ( str [ i - 1 ] == str [ i + 1 ] ) count ++ ; return count ; }
function search ( ar , size ) { let a = 0 , b = size - 1 ; let mid = 0 ; while ( ( b - a ) > 1 ) { mid = ( a + b ) / 2 ; if ( ( ar [ a ] - a ) != ( ar [ mid ] - mid ) ) b = mid ; else if ( ( ar [ b ] - b ) != ( ar [ mid ] - mid ) ) a = mid ; } return ( ar [ a ] + 3 ) ; }
function next ( arr , target ) { let start = 0 , end = arr . length - 1 ; let ans = - 1 ; while ( start <= end ) { let mid = parseInt ( ( start + end ) / 2 , 10 ) ; if ( arr [ mid ] <= target ) { start = mid + 1 ; } else { ans = mid ; end = mid - 1 ; } } return ans ; }
function printNSE ( arr , n ) { var next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { next = arr [ j ] ; break ; } } document . write ( arr [ i ] + " " + next + " " ) ; } }
function deleteElement ( A , L , R , N ) { let i , j = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( i <= L i >= R ) { A [ j ] = A [ i ] ; j ++ ; } } return j ; }
function search ( arr , n , x ) { let res = - 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res = i ; if ( res == - 1 ) return false ; let temp = arr [ res ] ; for ( let i = res ; i > 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = temp ; return true ; }
function majorityNumber ( arr , n ) { let ans = - 1 ; let freq = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; if ( freq . has ( arr [ i ] ) ) { freq . set ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) } else { freq . set ( arr [ i ] , 1 ) } if ( freq . get ( arr [ i ] ) > n / 2 ) ans = arr [ i ] ; } return ans ; }
function kPresentProbability ( a , n , k ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( a [ i ] == k ) count += 1 ; return count / n ; }
function slopeOfNum ( num , n ) { let slope = 0 ; for ( let i = 1 ; i < n - 1 ; i ++ ) { if ( num [ i ] > num [ i - 1 ] && num [ i ] > num [ i + 1 ] ) slope ++ ; else if ( num [ i ] < num [ i - 1 ] && num [ i ] < num [ i + 1 ] ) slope ++ ; } return slope ; }
function pairExists ( arr1 , m , arr2 , n ) { let s = new Set ( ) ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( s . has ( arr2 [ j ] - arr1 [ i ] ) ) return true ; } s . add ( arr1 [ i ] ) ; } return false ; }
function prevGreater ( arr , n ) { document . write ( " " ) ; for ( let i = 1 ; i < n ; i ++ ) { let j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] < arr [ j ] ) { document . write ( arr [ j ] + " " ) ; break ; } } if ( j == - 1 ) document . write ( " " ) ; } }
function prevGreater ( arr , n ) { let s = [ ] ; s . push ( arr [ 0 ] ) ; document . write ( " " ) ; for ( let i = 1 ; i < n ; i ++ ) { while ( s . length != 0 && s [ s . length - 1 ] < arr [ i ] ) s . pop ( ) ; if ( s . length == 0 ) document . write ( " " ) ; else document . write ( s [ s . length - 1 ] + " " ) ; s . push ( arr [ i ] ) ; } }
function printDuplicates ( arr , n ) { let i ; let fl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ arr [ i ] % n ] >= n ) { if ( arr [ arr [ i ] % n ] < 2 * n ) { document . write ( arr [ i ] % n + " " ) ; fl = 1 ; } } arr [ arr [ i ] % n ] += n ; } if ( ! fl ) document . write ( " " ) ; }
function findTriplets ( arr , n , sum ) { for ( let i = 0 ; i < n - 2 ; i ++ ) { for ( let j = i + 1 ; j < n - 1 ; j ++ ) { for ( let k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] == sum ) { document . write ( arr [ i ] + " " + arr [ j ] + " " + arr [ k ] + " " ) ; } } } } }
function findTriplets ( arr , n , sum ) { for ( let i = 0 ; i < n - 1 ; i ++ ) { let s = new Set ( ) ; for ( let j = i + 1 ; j < n ; j ++ ) { let x = sum - ( arr [ i ] + arr [ j ] ) ; if ( s . has ( x ) ) document . write ( x + " " + arr [ i ] + " " + arr [ j ] + " " ) ; else s . add ( arr [ j ] ) ; } } }
function printPairs ( arr , n , sum ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) document . write ( " " + arr [ i ] + " " + arr [ j ] + " " + " " ) ; }
function solve ( a , n ) { let max1 = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( Math . abs ( a [ i ] - a [ j ] ) > max1 ) { max1 = Math . abs ( a [ i ] - a [ j ] ) ; } } } return max1 ; }
function solve ( a , n ) { let min1 = a [ 0 ] ; let max1 = a [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max1 ) max1 = a [ i ] ; if ( a [ i ] < min1 ) min1 = a [ i ] ; } return Math . abs ( min1 - max1 ) ; }
function maxProduct ( arr , n ) { if ( n < 4 ) return - 1 ; let max_product = Number . MIN_VALUE ; for ( let i = 0 ; i < n - 3 ; i ++ ) for ( let j = i + 1 ; j < n - 2 ; j ++ ) for ( let k = j + 1 ; k < n - 1 ; k ++ ) for ( let l = k + 1 ; l < n ; l ++ ) max_product = Math . max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] * arr [ l ] ) ; return max_product ; }
function maxProduct ( arr , n ) { if ( n < 4 ) return - 1 ; arr . sort ( function ( a , b ) { return a - b ; } ) ; let x = arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] * arr [ n - 4 ] ; let y = arr [ 0 ] * arr [ 1 ] * arr [ 2 ] * arr [ 3 ] ; let z = arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] * arr [ n - 2 ] ; return Math . max ( x , Math . max ( y , z ) ) ; }
function maxSum ( arr , n ) { if ( n < 2 ) return - 1 ; let ans = arr [ 0 ] + arr [ 1 ] ; for ( let i = 1 ; i + 1 < n ; i ++ ) ans = Math . min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) ; return ans ; }
function countTripletsLessThanL ( n , L , arr ) { arr . sort ( ) ; var ways = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { for ( k = j + 1 ; k < n ; k ++ ) { var mostDistantDistance = arr [ k ] - arr [ i ] ; if ( mostDistantDistance <= L ) { ways ++ ; } } } } return ways ; }
function isSuffix ( s1 , s2 ) { let n1 = s1 . length , n2 = s2 . length ; if ( n1 > n2 ) return false ; for ( let i = 0 ; i < n1 ; i ++ ) if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) return false ; return true ; }
function replaceOriginal ( s , n ) { var r = new Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) { r [ i ] = s . charAt ( n - 1 - i ) ; if ( s . charAt ( i ) != ' ' && s . charAt ( i ) != ' ' && s . charAt ( i ) != ' ' && s . charAt ( i ) != ' ' && s . charAt ( i ) != ' ' ) { document . write ( r [ i ] ) ; } } document . write ( " " ) ; }
function checkIfAllTogether ( s , c ) { let oneSeen = false ; let i = 0 , n = s . length ; while ( i < n ) { if ( s [ i ] == c ) { if ( oneSeen == true ) return false ; while ( i < n && s [ i ] == c ) i ++ ; oneSeen = true ; } else i ++ ; } return true ; }
function search ( arr , n , x ) { let front = 0 , back = n - 1 ; while ( front <= back ) { if ( arr [ front ] == x arr [ back ] == x ) return true ; front ++ ; back -- ; } return false ; }
function sortString ( str , n ) { var i ; var arr = Array ( 26 ) . fill ( 0 ) ; var new_str = " " ; for ( i = 0 ; i < n ; i ++ ) ++ arr [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ; for ( i = 0 ; i < 26 ; i ++ ) while ( arr [ i ] -- ) new_str += String . fromCharCode ( i + ' ' . charCodeAt ( 0 ) ) ; return new_str ; }
function getGreatestSum ( a ) { let prev_max = 0 ; for ( let j = 0 ; j < N ; j ++ ) if ( prev_max < a [ N - 1 ] [ j ] ) prev_max = a [ N - 1 ] [ j ] ; let sum = prev_max ; for ( let i = N - 2 ; i >= 0 ; i -- ) { let curr_max = - 2147483648 ; for ( let j = 0 ; j < N ; j ++ ) if ( prev_max > a [ i ] [ j ] && a [ i ] [ j ] > curr_max ) curr_max = a [ i ] [ j ] ; if ( curr_max == - 2147483648 ) return - 1 ; prev_max = curr_max ; sum += prev_max ; } return sum ; }
function minSum ( arr , n ) { let sum = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { let j = i ; while ( j < n && arr [ j ] <= arr [ j - 1 ] ) { arr [ j ] = arr [ j ] + 1 ; j ++ ; } } sum = sum + arr [ i ] ; } return sum ; }
function minSum ( arr , n ) { let sum = arr [ 0 ] , prev = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; }
function findLastIndex ( str , x ) { let index = - 1 ; for ( let i = 0 ; i < str . length ; i ++ ) if ( str [ i ] == x ) index = i ; return index ; }
function findLastIndex ( str , x ) { for ( let i = str . length - 1 ; i >= 0 ; i -- ) if ( str [ i ] == x ) return i ; return - 1 ; }
function middleOfThree ( a , b , c ) { if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ; else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a ; else return c ; }
function middleOfThree ( a , b , c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else { if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } }
function middleOfThree ( a , b , c ) { let x = a - b ; let y = b - c ; let z = a - c ; if ( x * y > 0 ) return b ; else if ( x * z > 0 ) return c ; else return a ; }
function findValue ( X , Y , P ) { if ( P % 2 == 0 ) return parseInt ( ( Math . max ( X , Y ) / Math . min ( X , Y ) ) , 10 ) ; else return parseInt ( ( Math . max ( 2 * X , Y ) / Math . min ( 2 * X , Y ) ) , 10 ) ; }
function countCountries ( ans , N ) { let total_countries = 0 , i = 0 ; let invalid = false ; while ( i < N ) { let curr_size = ans [ i ] ; let num = ans [ i ] ; while ( num > 0 ) { if ( ans [ i ] != curr_size ) { document . write ( " " ) ; return ; } else num -- ; i ++ ; } total_countries ++ ; } document . write ( " " + total_countries + " " ) ; }
function countMaxSetBits ( left , right ) { while ( ( left | ( left + 1 ) ) <= right ) left |= left + 1 ; return left ; }
function findS ( s ) { var sum = 0 ; for ( n = 1 ; sum < s ; n ++ ) { sum += n ; if ( sum == s ) return n ; } return - 1 ; }
function findS ( s ) { var l = 1 , r = parseInt ( ( s / 2 ) + 1 ) ; while ( l <= r ) { var mid = parseInt ( ( l + r ) / 2 ) ; var sum = mid * parseInt ( ( mid + 1 ) / 2 ) ; if ( sum == s ) return mid ; else if ( sum > s ) r = mid - 1 ; else l = mid + 1 ; } return - 1 ; }
function isvalid ( s ) { let k = ( - 1.0 + Math . sqrt ( 1 + 8 * s ) ) / 2 ; if ( Math . ceil ( k ) == Math . floor ( k ) ) return k ; else return - 1 ; }
function calcSafe ( pos ) { let j = pos % 10 ; let i = Math . floor ( pos / 10 ) ; let dis_11 = Math . min ( Math . abs ( 1 - i ) , Math . abs ( 1 - j ) ) ; let dis_18 = Math . min ( Math . abs ( 1 - i ) , Math . abs ( 8 - j ) ) ; let dis_81 = Math . min ( Math . abs ( 8 - i ) , Math . abs ( 1 - j ) ) ; let dis_88 = Math . min ( Math . abs ( 8 - i ) , Math . abs ( 8 - j ) ) ; let sum = dis_11 + dis_18 + dis_81 + dis_88 + 1 ; return ( 64 - sum ) ; }
function countCrossLine ( arr , n ) { let count_crossline = 0 ; let i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; count_crossline ++ ; } arr [ j + 1 ] = key ; } return count_crossline ; }
function missing4 ( arr ) { let helper = [ ] ; for ( let i = 0 ; i < 4 ; i ++ ) { helper [ i ] = 0 ; } for ( let i = 0 ; i < arr . length ; i ++ ) { let temp = Math . abs ( arr [ i ] ) ; if ( temp <= arr . length ) arr [ temp - 1 ] = Math . floor ( arr [ temp - 1 ] * ( - 1 ) ) ; else if ( temp > arr . length ) { if ( temp % arr . length != 0 ) helper [ temp % arr . length - 1 ] = - 1 ; else helper [ ( temp % arr . length ) + arr . length - 1 ] = - 1 ; } } for ( let i = 0 ; i < arr . length ; i ++ ) if ( arr [ i ] > 0 ) document . write ( i + 1 + " " ) ; for ( let i = 0 ; i < helper . length ; i ++ ) if ( helper [ i ] >= 0 ) document . write ( arr . length + i + 1 + " " ) ; return ; }
function getCount ( arr , n , num1 , num2 ) { let i = 0 ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == num1 ) break ; if ( i >= n - 1 ) return 0 ; let j ; for ( j = n - 1 ; j >= i + 1 ; j -- ) if ( arr [ j ] == num2 ) break ; if ( j == i ) return 0 ; return ( j - i - 1 ) ; }
function minTotalDistance ( grid ) { if ( ROW == 0 COL == 0 ) return 0 ; let vertical = [ ] ; let horizontal = [ ] ; for ( let i = 0 ; i < ROW ; i ++ ) { for ( let j = 0 ; j < COL ; j ++ ) { if ( grid [ i ] [ j ] == 1 ) { vertical . push ( i ) ; horizontal . push ( j ) ; } } } ( vertical ) . sort ( function ( a , b ) { return a - b ; } ) ; ( horizontal ) . sort ( function ( a , b ) { return a - b ; } ) ; let size = vertical . length / 2 ; let x = vertical [ size ] ; let y = horizontal [ size ] ; let distance = 0 ; for ( let i = 0 ; i < ROW ; i ++ ) for ( let j = 0 ; j < COL ; j ++ ) if ( grid [ i ] [ j ] == 1 ) distance += Math . abs ( x - i ) + Math . abs ( y - j ) ; return distance ; }
function findMinRec ( A , n ) { if ( n == 1 ) return A [ 0 ] ; return Math . min ( A [ n - 1 ] , findMinRec ( A , n - 1 ) ) ; }
function findMaxRec ( A , n ) { if ( n == 1 ) return A [ 0 ] ; return Math . max ( A [ n - 1 ] , findMaxRec ( A , n - 1 ) ) ; }
function countBuildings ( arr , n ) { let count = 1 ; let curr_max = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > curr_max arr [ i ] == curr_max ) { count ++ ; curr_max = arr [ i ] ; } } return count ; }
function findExtra ( arr1 , arr2 , n ) { for ( let i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ; return n ; }
function findExtra ( arr1 , arr2 , n ) { let index = n ; let left = 0 , right = n - 1 ; while ( left <= right ) { let mid = Math . floor ( ( left + right ) / 2 ) ; if ( arr2 [ mid ] == arr1 [ mid ] ) left = mid + 1 ; else { index = mid ; right = mid - 1 ; } } return index ; }
function minCostToMakeElementEqual ( a , n ) { let y ; if ( n % 2 == 1 ) y = a [ Math . trunc ( n / 2 ) ] ; else y = Math . trunc ( ( a [ n / 2 ] + a [ ( n - 2 ) / 2 ] ) / 2 ) ; let s = 0 ; for ( let i = 0 ; i < n ; i ++ ) s += Math . abs ( a [ i ] - y ) ; return s ; }
function maxConsecutiveRopes ( ropes , N ) { let curSize = 0 ; ropes . sort ( ( a , b ) => a - b ) for ( let i = 0 ; i < N ; i ++ ) { if ( ropes [ i ] <= curSize + 1 ) { curSize = curSize + ropes [ i ] ; } else break ; } return curSize ; }
function check ( arr , n ) { var count = 0 ; var index = - 1 ; for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] >= arr [ i ] ) { count ++ ; index = i ; } } if ( count > 1 ) return false ; if ( count == 0 ) return true ; if ( index == n - 1 index == 1 ) return true ; if ( arr [ index - 1 ] < arr [ index + 1 ] ) return true ; if ( arr [ index - 2 ] < arr [ index ] ) return true ; return false ; }
function isSortedArray ( arr , n ) { var l = 0 var r = ( n - 1 ) while ( ( l + 1 ) < r ) { if ( arr [ l ] >= Math . max ( arr [ l + 1 ] , arr [ r - 1 ] ) && arr [ r ] >= Math . max ( arr [ r - 1 ] , arr [ l + 1 ] ) ) { l += 1 r -= 1 } else return false } return true }
function minCost ( arr , N , X ) { arr . sort ( ) ; var sum = 0 ; var cost = 0 ; var INT_MAX = Number . MAX_VALUE ; var min_cost = INT_MAX ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < 0 ) { cost = Math . abs ( arr [ i ] ) * X + ( sum - Math . abs ( arr [ i ] ) * i ) ; sum += Math . abs ( arr [ i ] ) ; min_cost = Math . min ( min_cost , cost ) ; } } document . write ( min_cost ) ; }
function maximumSum ( arr , N ) { let sum ; arr . sort ( ) ; sum = ( arr [ N - 1 ] - arr [ 0 ] ) + ( arr [ N - 2 ] - arr [ 0 ] ) + ( arr [ N - 1 ] - arr [ N - 2 ] ) ; document . write ( sum ) ; }
function getBuckets ( arr , N ) { let availableWater = N * ( N - 1 ) / 2 ; arr . sort ( function ( a , b ) { return a - b } ) ; let i = 0 , sum = 0 ; while ( sum <= availableWater ) { sum += arr [ i ] ; i ++ ; } document . write ( i - 1 ) ; }
function minimum_sum ( A , N ) { A . sort ( ) ; var sum = 1000000000 ; for ( var i = 0 ; i <= N - 3 ; i ++ ) { sum = Math . min ( sum , Math . abs ( A [ i ] - A [ i + 1 ] ) + Math . abs ( A [ i + 1 ] - A [ i + 2 ] ) ) ; } document . write ( sum ) ; }
function maximumSumPermutation ( arr ) { var N = arr . length ; arr . sort ( ( a , b ) => a - b ) ; var temp = arr [ 0 ] ; arr [ 0 ] = arr [ N - 1 ] ; arr [ N - 1 ] = temp ; document . write ( arr ) ; }
function findMaxNumbers ( arr , n , k ) { arr . sort ( ) ; let cnt = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let opr = Math . ceil ( Math . log2 ( arr [ i ] ) ) ; k -= opr ; if ( k < 0 ) { break ; } cnt ++ ; } document . write ( cnt ) ; }
function sameChar ( S , N ) { var arr = S . split ( " " ) ; var sorted = arr . sort ( ) ; S = sorted . join ( " " ) ; var mid = S [ parseInt ( N / 2 ) ] . charCodeAt ( 0 ) ; var total_operations = 0 ; for ( var i = 0 ; i < N ; i ++ ) { total_operations += Math . abs ( S [ i ] . charCodeAt ( 0 ) - mid ) ; } document . write ( total_operations ) ; }
function minimumIncreasingSubsequences ( arr , N ) { arr . sort ( function ( a , b ) { return a - b } ) ; let count = 0 ; let i = 0 ; while ( i < N ) { let x = arr [ i ] ; let freqX = 0 ; while ( i < N && arr [ i ] == x ) { freqX ++ ; i ++ ; } count = Math . max ( count , freqX ) ; } document . write ( count ) ; }
function findLastElement ( arr , N ) { arr . sort ( ) ; let i = 0 ; for ( i = 1 ; i < N ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] != 0 && arr [ i ] - arr [ i - 1 ] != 2 ) { document . write ( " " + " " ) ; return ; } } document . write ( arr [ N - 1 ] + " " ) ; }
function maxDivisions ( arr , N , X ) { arr . sort ( ) ; let maxSub = 0 ; let size = 0 ; for ( let i = 0 ; i < N ; i ++ ) { size ++ ; if ( arr [ i ] * size >= X ) { maxSub ++ ; size = 0 ; } } document . write ( maxSub + " " ) ; }
function meanOfRemainingElements ( arr , N , K ) { arr . sort ( function ( a , b ) { return a - b } ) ; let kthPercent = Math . floor ( ( N * K ) / 100 ) ; let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( i >= kthPercent && i < ( N - kthPercent ) ) sum += arr [ i ] ; let mean = sum / ( N - 2 * kthPercent ) ; document . write ( mean . toFixed ( 5 ) ) ; }
function getCount ( arr , N ) { var count = 0 ; if ( N < 3 ) return 0 ; for ( var b = 0 ; b < N ; b ++ ) { for ( var a = 0 ; a < N ; a ++ ) { if ( a == b ) continue ; for ( var c = 0 ; c < N ; c ++ ) { if ( c == a c == b ) continue ; var d = arr [ b ] * arr [ b ] / 4 ; if ( arr [ a ] * arr <= d ) count ++ ; } } } return count ; }
function maxPossibleSum ( arr , N ) { arr . sort ( ) ; let sum = 0 ; let j = N - 3 ; while ( j >= 0 ) { sum += arr [ j ] ; j -= 3 ; } document . write ( sum ) ; }
function findMaxDifference ( arr , n ) { arr . sort ( ) ; let Leftsum = 0 ; let Totalsum = 0 ; let Min = Number . MAX_VALUE , Max = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) Totalsum += arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) { let leftNumbers = i ; let rightNumbers = n - i - 1 ; Totalsum = Totalsum - arr [ i ] ; let sum = ( leftNumbers * arr [ i ] ) - Leftsum + Totalsum - ( rightNumbers * arr [ i ] ) ; Min = Math . min ( Min , sum ) ; Max = Math . max ( Max , sum ) ; Leftsum += arr [ i ] ; } document . write ( Max - Min ) ; }
function check ( a , b , Na , Nb , k , m ) { if ( Na < k Nb < m ) return " " ; a . sort ( ) ; b . sort ( ) ; if ( a [ k - 1 ] < b [ Nb - m ] ) { return " " ; } return " " ; }
function splitArray ( arr , N ) { arr . sort ( ) ; let result = Number . MAX_VALUE ; for ( let i = 1 ; i < N ; i ++ ) { result = Math . min ( result , arr [ i ] - arr [ i - 1 ] ) ; } return result ; }
function CountMaximum ( arr , n , k ) { arr . sort ( ) ; let sum = 0 , count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; }
function CountMaximum ( arr , n , k ) { arr . sort ( function ( a , b ) { return a - b } ) ; let sum = 0 , count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; }
function rearrange ( A , B , N , X ) { let flag = true ; A . sort ( ) ; B . sort ( ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( A [ i ] + B [ N - 1 - i ] > X ) { flag = false ; break ; } } if ( flag == true ) document . write ( " " ) ; else document . write ( " " ) ; }
function findSum ( A , N , K ) { A . sort ( ) ; let sum = 0 ; for ( let i = N / K ; i < N ; i += K - 1 ) { sum += A [ i ] ; } document . write ( sum ) ; }
function maxcntPairsSumKRemoved ( arr , k ) { var cntPairs = 0 ; if ( arr . length <= 1 ) return cntPairs ; arr . sort ( ) ; var left = 0 ; var right = arr . length - 1 ; while ( left < right ) { var s = arr [ left ] + arr [ right ] ; if ( s == k ) { cntPairs += 1 ; left += 1 ; right -= 1 ; } else if ( s > k ) right -= 1 ; else left += 1 ; } return cntPairs ; }
function minDiff ( A , K ) { A . sort ( function ( a , b ) { return a - b } ) ; let n = A . length ; if ( n <= K ) return 0 ; let mindiff = A [ n - 1 ] - A [ 0 ] ; if ( K == 0 ) return mindiff ; for ( let i = 0 , j = n - 1 - K ; j < n ; ) { mindiff = Math . min ( mindiff , A [ j ] - A [ i ] ) ; i ++ ; j ++ ; } return mindiff ; }
function findMinimum ( arr , N , K ) { arr . sort ( ( a , b ) => a - b ) ; var ans = 0 ; for ( i = 1 ; i < 2 * ( parseInt ( N / K ) ) ; i += 2 ) { ans += arr [ i ] ; } document . write ( ans ) ; }
function findSubarrays ( arr , N ) { arr . sort ( ) ; var i = 0 ; for ( i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { document . write ( " " ) ; return ; } } document . write ( " " ) ; }
function getPairs ( arr , N , K ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] > K * arr [ i + 1 ] ) count ++ ; } } document . write ( count ) ; }
function Selection_Sort ( arr , n ) { for ( let i = 0 ; i < n - 1 ; ++ i ) { let min_index = i ; for ( let j = i + 1 ; j < n ; ++ j ) { if ( arr [ j ] < arr [ min_index ] ) min_index = j ; } let temp = arr [ i ] ; arr [ i ] = arr [ min_index ] ; arr [ min_index ] = temp ; } }
function Bubble_Sort ( arr , n ) { for ( var i = 1 ; i < n ; ++ i ) { for ( var j = 0 ; j <= ( n - i - 1 ) ; ++ j ) { if ( arr [ j ] > arr [ j + 1 ] ) { var temm = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temm ; } } } } var n = 5 ; var arr = [ 2 , 0 , 1 , 4 , 3 ] ; Bubble_Sort ( arr , n ) ; document . write ( " " ) ; for ( var i = 0 ; i < n ; i ++ ) { document . write ( arr [ i ] + " " ) ; }
function Bubble_Sort ( arr , n ) { Boolean ( flag = true ) ; for ( var i = 1 ; i < n ; ++ i ) { flag = false ; for ( var j = 0 ; j <= ( n - i - 1 ) ; ++ j ) { if ( arr [ j ] > arr [ j + 1 ] ) { var temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; flag = true ; } } if ( flag == false ) break ; } }
function splitArray ( arr , n , K ) { arr . sort ( ) ; let i = n - 1 ; let result = 0 ; while ( K -- != 0 ) { result += arr [ i - 1 ] ; i -= 2 ; } document . write ( result ) ; }
function maxCostToRemove ( arr , N , K ) { let maxCost = 0 ; arr . sort ( ) ; for ( let i = 0 ; i < N ; i += K ) { maxCost += arr [ i + 1 ] ; } return maxCost ; }
function countPairs ( A , N ) { var count = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { var xo = ( A [ i ] ^ A [ j ] ) ; var mx = Math . max ( A [ i ] , A [ j ] ) ; if ( xo > mx ) { count ++ ; } } } document . write ( count ) ; }
function checkArrangement ( A1 , A2 , n , k ) { A1 . sort ( ) ; A2 . sort ( ) ; A2 . reverse ( ) ; let flag = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( A1 [ i ] + A2 [ i ] > k ) || ( A1 [ i ] + A2 [ i ] < k / 2 ) ) { flag = 1 ; break ; } } if ( flag == 1 ) document . write ( " " ) ; else document . write ( " " ) ; }
function MaxRearrngeSum ( A , B , N ) { A . sort ( ) ; B . sort ( ) ; B . reverse ( ) ; let maxSum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { maxSum += Math . abs ( A [ i ] - B [ i ] ) ; } return maxSum ; }
function largestArea ( arr1 , n , arr2 , m ) { var end = 0 , start = 0 , i = 0 , j = 0 ; arr1 . sort ( ) ; arr2 . sort ( ) ; while ( i < n && j < m ) { if ( arr1 [ i ] == arr2 [ j ] ) { if ( start == 0 ) start = arr1 [ i ] ; else end = arr1 [ i ] ; i ++ ; j ++ ; } else if ( arr1 [ i ] > arr2 [ j ] ) j ++ ; else i ++ ; } if ( end == 0 start == 0 ) return 0 ; else return ( end - start ) ; }
function count_pairs ( arr , brr , N , M , K ) { let i = 0 ; let j = 0 ; let cntPairs = 0 ; ( arr ) . sort ( function ( a , b ) { return a - b ; } ) ; ( brr ) . sort ( function ( a , b ) { return a - b ; } ) ; while ( i < N && j < M ) { if ( brr [ j ] - arr [ i ] > K ) { cntPairs += ( M - j ) ; i ++ ; } else { j ++ ; } } return cntPairs ; }
function firstSubsequence ( s ) { let allsubseq = [ ] ; for ( let i = 0 ; i < s . length ; i ++ ) { let k = " " ; for ( let j = 0 ; j < s . length ; j ++ ) { if ( i != j ) { k += s [ j ] ; } } allsubseq . push ( k ) ; } ( allsubseq ) . sort ( ) ; document . write ( allsubseq [ 0 ] ) ; }
function rankLessThanK ( arr , k , n ) { let rank = 1 ; let position = 1 ; arr . sort ( ) ; for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( i == n - 1 arr [ i ] != arr [ i + 1 ] ) { rank = position ; if ( rank > k ) return position - 1 ; } position ++ ; } return n ; }
function maxArea ( polet_x , polet_y , n , length , width ) { polet_x . sort ( ( a , b ) => a - b ) ; ; polet_y . sort ( ( a , b ) => a - b ) ; ; let dx = polet_x [ 0 ] ; let dy = polet_y [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { dx = Math . max ( dx , polet_x [ i ] - polet_x [ i - 1 ] ) ; dy = Math . max ( dy , polet_y [ i ] - polet_y [ i - 1 ] ) ; } dx = Math . max ( dx , ( length + 1 ) - polet_x [ n - 1 ] ) ; dy = Math . max ( dy , ( width + 1 ) - polet_y [ n - 1 ] ) ; document . write ( ( dx - 1 ) * ( dy - 1 ) ) ; }
function solve ( values , salary ) { var ret = 1 ; var amt = 0 ; values . sort ( ( a , b ) => a - b ) ; salary . sort ( ( a , b ) => a - b ) ; while ( salary . length ) { while ( values . length && values [ values . length - 1 ] >= salary [ salary . length - 1 ] ) { amt ++ ; values . pop ( ) ; } if ( amt == 0 ) return 0 ; ret *= amt -- ; ret %= MOD ; salary . pop ( ) ; } return ret ; }
function minsteps ( arr , n ) { arr . sort ( ( a , b ) => a - b ) var ans = 0 ; for ( var i = 0 ; i < n ; i ++ ) { ans += Math . abs ( arr [ i ] - Math . pow ( 2 , i ) ) ; } return ans ; }
function findCost ( a , n ) { a . sort ( ( x , y ) => y - x ) ; var count = 0 ; for ( var j = 0 ; j < n ; j ++ ) { var p = a [ j ] - j ; a [ j ] = 0 ; if ( p < 0 ) { p = 0 ; continue ; } count += p ; } return count ; }
function XorSum ( A , B , N ) { var ans = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { ans = ans ^ ( A [ i ] + B [ j ] ) ; } } return ans ; }
function findCount ( arr , N , K ) { arr . sort ( ) ; let result = 1 ; let cur_max = arr [ 0 ] ; let cur_min = arr [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) { cur_max = arr [ i ] ; if ( cur_max - cur_min > K ) { result ++ ; cur_max = arr [ i ] ; cur_min = arr [ i ] ; } } return result ; }
function findMaxValue ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; let ans = arr [ n - 1 ] ; let maxPossible = arr [ n - 1 ] ; for ( let i = n - 2 ; i >= 0 ; -- i ) { if ( maxPossible > 0 ) { if ( arr [ i ] >= maxPossible ) { ans += ( maxPossible - 1 ) ; maxPossible = maxPossible - 1 ; } else { maxPossible = arr [ i ] ; ans += maxPossible ; } } } return ans ; }
function countPairs ( arr , n ) { let ans = 0 ; arr . sort ( function ( a , b ) { return a - b } ) ; let left = 0 , right = 1 ; while ( right < n ) { if ( arr [ left ] == arr [ right ] ) ans += right - left ; else left = right ; right ++ ; } return ans ; }
function countPairs ( arr , n ) { let ans = 0 ; let count = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( count . has ( arr [ i ] ) ) { ans += count . get ( arr [ i ] ) ; count . set ( arr [ i ] , count . get ( arr [ i ] ) + 1 ) ; } else { count . set ( arr [ i ] , 1 ) ; } } return ans ; }
function maximizeFinalElement ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; if ( arr [ 0 ] != 1 ) arr [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] > 1 ) { arr [ i ] = arr [ i - 1 ] + 1 ; } } return arr [ n - 1 ] ; }
function findLeastDist ( A , N ) { A . sort ( ( a , b ) => a - b ) ; console . log ( A ) ; if ( ( N % 2 ) == 0 ) { return A [ parseInt ( ( N - 1 ) / 2 ) ] ; } else { return A [ parseInt ( N / 2 ) ] ; } }
function solution ( A , B , C ) { let arr = Array . from ( { length : 3 } , ( _ , i ) => 0 ) ; arr [ 0 ] = A ; arr [ 1 ] = B ; arr [ 2 ] = C ; arr . sort ( ) ; if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) / 2 ) ; else return ( arr [ 0 ] + arr [ 1 ] ) ; }
function removeElements ( arr , n ) { arr . sort ( ( a , b ) => b - a ) ; var ans = 0 ; for ( var i = 0 ; i < n ; i ++ ) { ans += arr [ i ] * Math . pow ( 2 , i ) ; } return ans ; }
function canMadeEqual ( A , B , n ) { A . sort ( ) ; B . sort ( ) ; for ( var i = 0 ; i < n ; i ++ ) if ( A [ i ] != B [ i ] ) return false ; return true ; }
function maxMinDifference ( arr , n , k ) { if ( k >= n - 1 ) return 0 ; arr . sort ( ( a , b ) => a - b ) ; let ans = arr [ n - 1 ] - arr [ 0 ] ; for ( let i = k , j = n - 1 ; i >= 0 ; -- i , -- j ) { ans = Math . min ( arr [ j ] - arr [ i ] , ans ) ; } return ans ; }
function numberofpairs ( arr , N ) { let answer = 0 ; arr . sort ( ) ; let minDiff = Number . MAX_VALUE ; for ( let i = 0 ; i < N - 1 ; i ++ ) minDiff = Math . min ( minDiff , arr [ i + 1 ] - arr [ i ] ) ; for ( let i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i + 1 ] - arr [ i ] == minDiff ) answer ++ ; } return answer ; }
function sortarray ( arr , N ) { if ( N == 3 ) document . write ( " " ) ; else if ( N % 4 == 0 N % 4 == 1 ) { document . write ( " " ) ; document . write ( Math . floor ( N / 2 ) + " " ) ; let k = 1 , l ; for ( l = 0 ; l < Math . floor ( N / 4 ) ; l ++ ) { document . write ( k + " " + ( k + 1 ) + " " + N + " " ) ; document . write ( k + 1 + " " + N + " " + ( N - 1 ) + " " ) ; k = k + 2 ; N = N - 2 ; } } else document . write ( " " ) ; }
function countMinSteps ( arr , target , n ) { arr = arr . sort ( function ( a , b ) { return a - b ; } ) ; var minimumSteps = 0 ; var i = 0 , j = n - 1 ; while ( i <= j ) { if ( arr [ i ] + arr [ j ] <= target ) { i ++ ; j -- ; } else { j -- ; } minimumSteps ++ ; } return minimumSteps ; }
function findMinSum ( arr , K , L , size ) { if ( K * L > size ) return - 1 ; let minsum = 0 ; arr . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < K ; i ++ ) minsum += arr [ i ] ; return minsum ; }
function minBox ( arr , n ) { var box = n ; arr . sort ( ) ; var curr_box = 0 , next_box = 1 ; while ( curr_box < n && next_box < n ) { if ( arr [ curr_box ] < arr [ next_box ] ) { box -- ; curr_box ++ ; next_box ++ ; } else if ( arr [ curr_box ] == arr [ next_box ] ) next_box ++ ; } document . write ( box ) ; }
function redistribute ( arr , n , x ) { arr . sort ( ) ; arr . reverse ( ) ; let i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( ( sum / ( i + 1 ) ) < x ) { document . write ( i ) ; break ; } } if ( i == n ) document . write ( n ) ; }
function lexNumbers ( n ) { let s = [ ] ; for ( let i = 1 ; i <= n ; i ++ ) { s . push ( i . toString ( ) ) ; } s . sort ( ) ; let ans = [ ] ; for ( let i = 0 ; i < n ; i ++ ) ans . push ( parseInt ( s [ i ] ) ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( ans [ i ] + " " ) ; }
function findMinDif ( arr , N ) { arr . sort ( ( a , b ) => a - b ) ; return ( arr [ N - 1 ] - arr [ N - 2 ] ) ; }
function sortArray ( A , N ) { let x = 0 , y = 0 , z = 0 ; if ( N % 4 == 0 N % 4 == 1 ) { for ( let i = 0 ; i < N / 2 ; i ++ ) { x = i ; if ( i % 2 == 0 ) { y = N - i - 2 ; z = N - i - 1 ; } A [ z ] = A [ y ] ; A [ y ] = A [ x ] ; A [ x ] = x + 1 ; } document . write ( " " ) ; for ( let i = 0 ; i < N ; i ++ ) document . write ( A [ i ] + " " ) ; } else { document . write ( " " ) ; } }
function maximumSum ( a , b , k , n ) { let i , j ; a . sort ( ) ; b . sort ( ) ; for ( i = 0 , j = n - 1 ; i < k ; i ++ , j -- ) { if ( a [ i ] < b [ j ] ) { let temp = a [ i ] ; a [ i ] = b [ j ] ; b [ j ] = temp ; } else break ; } let sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += a [ i ] ; document . write ( sum ) ; }
function calculate_minimum_split ( n , a , k ) { let p = Array . from ( { length : n - 1 } , ( _ , i ) => 0 ) ; for ( let i = 1 ; i < n ; i ++ ) p [ i - 1 ] = a [ i ] - a [ i - 1 ] ; p . sort ( ( a , b ) => a - b ) ; p . reverse ( ) ; let min_sum = 0 ; for ( let i = 0 ; i < k - 1 ; i ++ ) min_sum += p [ i ] ; let res = a [ n - 1 ] - a [ 0 ] - min_sum ; return res ; }
function maxProfit ( arr ) { arr . sort ( ) ; arr . reverse ( ) ; let ans = 0 ; for ( let i = 0 ; i < arr . length ; i ++ ) { if ( ( arr [ i ] - ( 1 * i ) ) > 0 ) ans += ( arr [ i ] - ( 1 * i ) ) ; if ( ( arr [ i ] - ( 1 * i ) ) == 0 ) break ; } return ans ; }
function sortDiff ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; let out = [ ] ; while ( n > 0 ) { out . push ( arr [ Math . floor ( n / 2 ) ] ) ; arr . splice ( Math . floor ( n / 2 ) , 1 ) ; n = n - 1 ; } for ( let i = 0 ; i < out . length ; i ++ ) document . write ( out [ i ] + " " ) ; }
function countPairs ( A , B ) { let n = A . length ; let ans = 0 ; A . sort ( ) ; B . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( A [ i ] > B [ ans ] ) { ans ++ ; } } return ans ; }
function kthpair ( n , k , arr ) { let i , t = 0 ; arr . sort ( ) ; -- k ; for ( i = 0 ; i < n ; i += t ) { for ( t = 1 ; arr [ i ] == arr [ i + t ] ; ++ t ) ; if ( t * n > k ) break ; k = k - t * n ; } document . write ( arr [ i ] + " " + arr [ k / t ] ) ; }
function get_permutation ( arr , n ) { arr . sort ( ) ; var result = 0 ; for ( i = 0 ; i < n ; i ++ ) { result += Math . abs ( arr [ i ] - ( i + 1 ) ) ; } return result ; }
function make_permutation ( arr , n ) { arr . sort ( ) ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) ans += Math . abs ( i + 1 - arr [ i ] ) ; return ans ; }
function minimumProduct ( arr , n ) { arr . sort ( ) ; let product = 1 ; for ( let i = 0 ; i < n ; i += 2 ) { product *= ( arr [ i ] + arr [ i + 1 ] ) ; } return product ; }
function minimiseMedian ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; return Math . abs ( arr [ n / 2 ] - arr [ ( n / 2 ) - 1 ] ) ; }
function findK ( arr , size , N ) { arr . sort ( function ( a , b ) { return a - b } ) ; let temp_sum = 0 ; for ( let i = 0 ; i < size ; i ++ ) { temp_sum += arr [ i ] ; if ( N - temp_sum == arr [ i ] * ( size - i - 1 ) ) { return arr [ i ] ; } } return - 1 ; }
function minimumSwaps ( arr ) { let count = 0 ; let i = 0 ; while ( i < arr . length ) { if ( arr [ i ] != i + 1 ) { while ( arr [ i ] != i + 1 ) { let temp = 0 ; temp = arr [ arr [ i ] - 1 ] ; arr [ arr [ i ] - 1 ] = arr [ i ] ; arr [ i ] = temp ; count ++ ; } } i ++ ; } return count ; }
function canBeEqual ( a , b , c , k ) { var arr = Array ( 3 ) ; arr [ 0 ] = a ; arr [ 1 ] = b ; arr [ 2 ] = c ; arr . sort ( ( a , b ) => a - b ) ; var diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] ; k = k - diff ; if ( k < 0 k % 3 != 0 ) return false ; return true ; }
function findSum ( arr , n , k , l , r ) { if ( ( l ) + ( n - 1 - r ) == k ) return arr [ r ] - arr [ l ] ; if ( vis [ l ] [ r ] ) return dp [ l ] [ r ] ; vis [ l ] [ r ] = 1 ; dp [ l ] [ r ] = Math . min ( findSum ( arr , n , k , l , r - 1 ) , findSum ( arr , n , k , l + 1 , r ) ) ; return dp [ l ] [ r ] ; }
function findSum ( arr , n , k ) { var ans = arr [ n - k - 1 ] - arr [ 0 ] ; for ( var i = 1 ; i <= k ; i ++ ) { ans = Math . min ( arr [ n - 1 - ( k - i ) ] - arr [ i ] , ans ) ; } return ans ; }
function checkRectangles ( arr , n ) { let ans = true ; arr . sort ( ) ; var area = arr [ 0 ] * arr [ 4 * n - 1 ] ; for ( let i = 0 ; i < 2 * n ; i = i + 2 ) { if ( arr [ i ] != arr [ i + 1 ] arr [ 4 * n - i - 1 ] != arr [ 4 * n - i - 2 ] arr [ i ] * arr [ 4 * n - i - 1 ] != area ) { ans = false ; break ; } } if ( ans ) return true ; return false ; }
function findMin ( arr , n ) { let ans = 1 ; for ( let i = 0 ; i < n ; i ++ ) { let j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; ans = Math . max ( ans , j - i ) ; i = j - 1 ; } return n - ans ; }
function maxLen ( arr , n ) { var c_sum = 0 ; arr . sort ( ( a , b ) => b - a ) for ( var i = 0 ; i < n ; i ++ ) { c_sum += arr [ i ] ; if ( c_sum < 0 ) return i ; } return n ; }
function maxSum ( a , n ) { a . sort ( ( a , b ) => a - b ) ; let sum = 0 ; for ( let i = 0 ; i < n - 1 ; i += 2 ) { sum += a [ i ] ; } return sum ; }
function isPossible ( A , B , n , m , x , y ) { if ( x > n y > m ) return false ; A . sort ( ) ; B . sort ( ) ; if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; }
function cntElements ( arr , n ) { let copy_arr = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) copy_arr [ i ] = arr [ i ] ; let count = 0 ; arr . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != copy_arr [ i ] ) { count ++ ; } } return count ; }
function Min_Replace ( arr , n , k ) { arr . sort ( ( a , b ) => a - b ) var freq = Array ( MAX ) . fill ( 0 ) ; var p = 0 ; freq [ p ] = 1 ; for ( var i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) ++ freq [ p ] ; else ++ freq [ ++ p ] ; } freq . sort ( ( a , b ) => b - a ) ; var ans = 0 ; for ( var i = k ; i <= p ; i ++ ) ans += freq [ i ] ; return ans ; }
function Segment ( x , l , n ) { if ( n == 1 ) return 1 ; let ans = 2 ; for ( let i = 1 ; i < n - 1 ; i ++ ) { if ( x [ i ] - l [ i ] > x [ i - 1 ] ) ans ++ ; else if ( x [ i ] + l [ i ] < x [ i + 1 ] ) { x [ i ] = x [ i ] + l [ i ] ; ans ++ ; } } return ans ; }
function Next_greater ( a , n , x ) { a . sort ( function ( aa , bb ) { return aa - bb } ) ; let low = 0 , high = n - 1 , ans = x + 1 ; while ( low <= high ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( a [ mid ] <= ans ) { if ( a [ mid ] == ans ) { ans ++ ; high = n - 1 ; } low = mid + 1 ; } else high = mid - 1 ; } return ans ; }
function pairs_count ( arr , n , sum ) { let ans = 0 ; arr . sort ( ) ; let i = 0 , j = n - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] < sum ) i ++ ; else if ( arr [ i ] + arr [ j ] > sum ) j -- ; else { let x = arr [ i ] , xx = i ; while ( i < j && arr [ i ] == x ) i ++ ; let y = arr [ j ] , yy = j ; while ( j >= i && arr [ j ] == y ) j -- ; if ( x == y ) { let temp = i - xx + yy - j - 1 ; ans += ( temp * ( temp + 1 ) ) / 2 ; } else ans += ( i - xx ) * ( yy - j ) ; } } return ans ; }
function knapSack ( W , wt , val , n ) { var maxratio = - 1000000000 ; var maxindex = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( parseInt ( val [ i ] / wt [ i ] ) > maxratio ) { maxratio = ( val [ i ] / wt [ i ] ) ; maxindex = i ; } } return ( W * maxratio ) ; }
function solution ( arr , x ) { let closestSum = Number . MAX_VALUE ; for ( let i = 0 ; i < arr . length ; i ++ ) { for ( let j = i + 1 ; j < arr . length ; j ++ ) { for ( let k = j + 1 ; k < arr . length ; k ++ ) { if ( Math . abs ( x - closestSum ) > Math . abs ( x - ( arr [ i ] + arr [ j ] + arr [ k ] ) ) ) closestSum = ( arr [ i ] + arr [ j ] + arr [ k ] ) ; } } } return closestSum ; }
function removeElements ( arr , n ) { let brr = new Array ( n ) ; brr . fill ( 0 ) ; let l = 1 ; brr [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( brr [ l - 1 ] <= arr [ i ] ) { brr [ l ] = arr [ i ] ; l ++ ; } } for ( let i = 0 ; i < l ; i ++ ) document . write ( brr [ i ] + " " ) ; }
function maxWater ( height , n ) { let maximum = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { let current = ( Math . min ( height [ i ] , height [ j ] ) * ( j - i - 1 ) ) ; maximum = Math . max ( maximum , current ) ; } } return maximum ; }
function maxSelectionCount ( a , n ) { var res = 0 ; a . sort ( ) ; var select = 1 ; for ( var i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= select ) { res ++ ; select ++ ; } } return res ; }
function sort ( s ) { var c = s . split ( ' ' ) ; c . sort ( ) ; var al_c = 0 , nu_c = 0 ; while ( c [ al_c ] . charCodeAt ( 0 ) < 97 ) al_c ++ ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] . charCodeAt ( 0 ) < 97 ) s = s . substring ( 0 , i ) + c [ nu_c ++ ] + s . substring ( i + 1 ) ; else s = s . substring ( 0 , i ) + c [ al_c ++ ] + s . substring ( i + 1 ) ; } return s ; }
function reArrange ( words , n ) { var mp = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) mp . set ( words [ i ] , i + 1 ) ; words . sort ( ) ; for ( var i = 0 ; i < n ; i ++ ) { document . write ( mp . get ( words [ i ] ) + " " ) ; } }
function PrletBothArrays ( a , n ) { let v1 = [ ] , v2 = [ ] ; let mpp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { mpp . set ( a [ i ] , ( mpp . get ( a [ i ] ) == null ? 0 : mpp . get ( a [ i ] ) ) + 1 ) ; if ( mpp . get ( a [ i ] ) == 1 ) v1 . push ( a [ i ] ) ; else if ( mpp . get ( a [ i ] ) == 2 ) v2 . push ( a [ i ] ) ; else { document . write ( " " ) ; return ; } } v1 . sort ( ) ; document . write ( " " + " " ) ; for ( let i = 0 ; i < v1 . length ; i ++ ) document . write ( v1 [ i ] + " " ) ; v2 . sort ( ) ; v2 . reverse ( ) ; document . write ( " " + " " + " " ) ; for ( let i = 0 ; i < v2 . length ; i ++ ) document . write ( v2 [ i ] + " " ) ; }
function selectionSort ( head ) { var temp = head ; while ( temp ) { var min = temp ; var r = temp . next ; while ( r ) { if ( min . data > r . data ) min = r ; r = r . next ; } var x = temp . data ; temp . data = min . data ; min . data = x ; temp = temp . next ; } }
function check ( s ) { let l = s . length ; s . sort ( ) ; for ( let i = 1 ; i < l ; i ++ ) { if ( ( s [ i ] . charCodeAt ( ) - s [ i - 1 ] . charCodeAt ( ) ) != 1 ) return false ; } return true ; }
function check ( str ) { var min = Number . MAX_VALUE ; var max = Number . MIN_VALUE ; var sum = 0 ; for ( i = 0 ; i < str . length ; i ++ ) { var ascii = parseInt ( str . charCodeAt ( i ) ) ; if ( ascii < 96 ascii > 122 ) return false ; sum += ascii ; if ( min > ascii ) min = ascii ; if ( max < ascii ) max = ascii ; } min -= 1 ; var eSum = parseInt ( ( max * ( max + 1 ) ) / 2 ) - ( ( min * ( min + 1 ) ) / 2 ) ; return sum == eSum ; }
function getMaxMedian ( arr , n , k ) { let size = n + k ; arr . sort ( ( a , b ) => a - b ) ; if ( size % 2 == 0 ) { let median = ( arr [ Math . floor ( size / 2 ) - 1 ] + arr [ Math . floor ( size / 2 ) ] ) / 2 ; return median ; } let median = arr [ Math . floor ( size / 2 ) ] ; return median ; }
function countPoints ( n , m , a , b , x , y ) { a . sort ( function ( a , b ) { return a - b } ) ; b . sort ( function ( a , b ) { return a - b } ) ; let j = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { while ( j < m ) { if ( a [ i ] + y < b [ j ] ) break ; if ( b [ j ] >= a [ i ] - x && b [ j ] <= a [ i ] + y ) { count ++ ; j ++ ; break ; } else j ++ ; } } return count ; }
function findAnswer ( n , arr ) { arr . sort ( ( a , b ) => a - b ) ; let sum = 0 ; for ( let i = 0 ; i < Math . floor ( n / 2 ) ; ++ i ) { sum += ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ; } return sum ; }
function merge_and_sort ( output , arr , n , k ) { for ( let i = 0 ; i < k ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { output [ i * n + j ] = arr [ i ] [ j ] ; } } output . sort ( function ( a , b ) { return a - b } ) ; }
function minSum ( arr , n ) { arr . sort ( ) ; let x = arr [ Math . floor ( n / 2 ) ] ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += Math . abs ( arr [ i ] - x ) ; return sum ; }
function odd_even ( arr , n ) { var odd_indexes = [ ] ; var even_indexes = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) odd_indexes . push ( arr [ i ] ) ; else even_indexes . push ( arr [ i ] ) ; } odd_indexes . sort ( ) ; even_indexes . sort ( ) ; for ( var i = 0 ; i < odd_indexes . length ; i ++ ) document . write ( odd_indexes [ i ] + " " ) ; for ( var i = 0 ; i < even_indexes . length ; i ++ ) document . write ( even_indexes [ i ] + " " ) ; }
function AlternateRearrange ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) v1 . push ( arr [ i ] ) ; else v2 . push ( arr [ i ] ) ; var index = 0 , i = 0 , j = 0 ; var flag = false ; if ( arr [ 0 ] % 2 == 0 ) flag = true ; while ( index < n ) { if ( flag == true ) { arr [ index ++ ] = v1 [ i ++ ] ; flag = ! flag ; } else { arr [ index ++ ] = v2 [ j ++ ] ; flag = ! flag ; } } for ( i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ; }
function countDistinct ( arr , n ) { let res = 1 ; for ( let i = 1 ; i < n ; i ++ ) { let j = 0 ; for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] === arr [ j ] ) break ; if ( i === j ) res ++ ; } return res ; }
function countDistinct ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) { i ++ ; } res ++ ; } return res ; }
function countDistinct ( arr , n ) { let hs = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) { hs . add ( arr [ i ] ) ; } return hs . size ; }
function getNumToAdd ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; var d = arr [ 1 ] - arr [ 0 ] ; var numToAdd = - 1 ; var numAdded = false ; for ( var i = 2 ; i < n ; i ++ ) { var diff = arr [ i ] - arr [ i - 1 ] ; if ( diff != d ) { if ( numAdded ) return - 1 ; if ( diff == 2 * d ) { numToAdd = arr [ i ] - d ; numAdded = true ; } else return - 1 ; } } if ( numToAdd == - 1 ) return ( arr [ n - 1 ] + d ) ; return numToAdd ; }
function countSequences ( arr , n ) { let count = 1 ; arr . sort ( function ( a , b ) { return a - b } ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; return count ; }
function average ( arr , n , k ) { var total = 0 ; if ( 2 * k >= n ) return 0 ; arr . sort ( ) ; var start = k , end = n - k - 1 ; for ( i = start ; i <= end ; i ++ ) total += arr [ i ] ; return ( total / ( n - 2 * k ) ) ; }
function minMovesToSort ( arr , n ) { var moves = 0 ; var i , mn = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > mn ) moves += arr [ i ] - mn ; mn = arr [ i ] ; } return moves ; }
function PointInKSquares ( n , a , k ) { a . sort ( ) ; return a [ n - k ] ; }
function minimumMoves ( a , n ) { let operations = 0 ; a . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) operations += Math . abs ( a [ i ] - ( i + 1 ) ) ; return operations ; }
function printCase ( n ) { if ( n <= 2 ) { document . write ( - 1 ) ; return ; } for ( let i = n ; i >= 1 ; i -- ) document . write ( i + " " ) ; }
function minCost ( A , n ) { var cost = 0 ; A . sort ( ) ; var K = A [ parseInt ( n / 2 ) ] ; var i ; for ( i = 0 ; i < n ; ++ i ) cost += Math . abs ( A [ i ] - K ) ; if ( n % 2 == 0 ) { var tempCost = 0 ; K = A [ parseInt ( n / 2 ) - 1 ] ; for ( i = 0 ; i < n ; ++ i ) tempCost += Math . abs ( A [ i ] - K ) ; cost = Math . min ( cost , tempCost ) ; } return cost ; }
function items ( n , a ) { a . sort ( function ( a , b ) { return a - b } ) ; let z = a [ n - 1 ] ; let x = 1 ; let s = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { s += a [ i ] ; if ( s <= z ) x += 1 ; else break ; } return x ; }
function SubseqWidths ( A , n ) { A . sort ( ( a , b ) => a - b ) var pow2 = Array ( n ) . fill ( 0 ) ; pow2 [ 0 ] = 1 ; for ( var i = 1 ; i < n ; ++ i ) pow2 [ i ] = ( pow2 [ i - 1 ] * 2 ) % MOD ; var ans = 0 ; for ( var i = 0 ; i < n ; ++ i ) ans = ( ans + ( pow2 [ i ] - pow2 [ n - 1 - i ] ) * A [ i ] ) % MOD ; return ans ; }
function findOptimalSolution ( a , N ) { a . sort ( function ( a , b ) { return a - b } ) ; let points = 0 ; for ( let i = 0 ; i < N ; i ++ ) { points += a [ i ] * i ; } return points ; }
function numBoxes ( A , n , K ) { A . sort ( function ( a , b ) { return a - b } ) ; let i = 0 , j = ( n - 1 ) ; let ans = 0 ; while ( i <= j ) { ans ++ ; if ( A [ i ] + A [ j ] <= K ) i ++ ; j -- ; } return ans ; }
function printArray ( arr , n ) { arr . sort ( ) ; let l = 0 , r = n - 1 , flag = 0 , i ; let k = 2 ; while ( l <= r ) { if ( flag == 0 ) { for ( i = l ; i < l + k && i <= r ; i ++ ) document . write ( arr [ i ] + " " ) ; flag = 1 ; l = i ; } else { for ( i = r ; i > r - k && i >= l ; i -- ) document . write ( arr [ i ] + " " ) ; flag = 0 ; r = i ; } k ++ ; } }
function number_of_tower ( house , range , n ) { house . sort ( function ( a , b ) { return a - b ; } ) ; let numOfTower = 0 ; let i = 0 ; while ( i < n ) { numOfTower ++ ; let loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }
function isAlphabaticOrder ( s ) { var n = s . length ; var c = new Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) { c [ i ] = s [ i ] ; } c . sort ( ) ; for ( var i = 0 ; i < n ; i ++ ) if ( c [ i ] != s [ i ] ) return false ; return true ; }
function isAlphabaticOrder ( s ) { let n = s . length ; for ( let i = 1 ; i < n ; i ++ ) { if ( s [ i ] < s [ i - 1 ] ) return false ; } return true ; }
function findProduct ( arr , n ) { arr . sort ( ) ; var prod = 1 * arr [ 0 ] ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) { prod = prod * arr [ i + 1 ] ; } } return prod ; }
function rotateRec ( n , L , B ) { var m = Number . MAX_VALUE for ( var i = 0 ; i < n ; i ++ ) { if ( Math . max ( L [ i ] , B [ i ] ) <= m ) m = Math . max ( L [ i ] , B [ i ] ) ; else if ( Math . min ( L [ i ] , B [ i ] ) <= m ) m = Math . min ( L [ i ] , B [ i ] ) ; else { return 0 ; } } return 1 ; }
function minimumIncrease ( a , b , c ) { var arr = [ a , b , c ] ; arr . sort ( ( a , b ) => a - b ) ; if ( arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] ) return 0 ; else return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) ; }
function absSumDidd ( a ) { a . sort ( ( a , b ) => a - b ) ; var midValue = a [ a . length / 2 ] ; var sum = 0 ; for ( var i = 0 ; i < a . length ; i ++ ) { sum = sum + Math . abs ( a [ i ] - midValue ) ; } return sum ; }
function minDistance ( n , k , points ) { for ( let i = 0 ; i < k ; i ++ ) ( point [ i ] ) . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < k ; i ++ ) document . write ( point [ i ] [ Math . ceil ( ( n / 2 ) - 1 ) ] + " " ) ; }
function solve ( N , M , cp , sp ) { let profit = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) profit [ i ] = sp [ i ] - cp [ i ] ; profit . sort ( function ( a , b ) { return b - a ; } ) ; let sum = 0 ; for ( let i = 0 ; i < M ; i ++ ) { if ( profit [ i ] > 0 ) sum += profit [ i ] ; else break ; } return sum ; }
function printOrder ( arr , k ) { let n = arr . length ; arr = arr . slice ( 0 , k ) . sort ( function ( a , b ) { return a - b ; } ) . concat ( arr . slice ( k , n ) . sort ( function ( a , b ) { return b - a ; } ) ) ; return arr ; }
function countTriplets ( arr , n , m ) { let count = 0 ; arr . sort ( function ( a , b ) { return a - b } ) ; let end , start , mid ; for ( end = n - 1 ; end >= 2 ; end -- ) { start = 0 ; mid = end - 1 ; while ( start < mid ) { let prod = arr [ end ] * arr [ start ] * arr [ mid ] ; if ( prod > m ) mid -- ; else if ( prod < m ) start ++ ; else if ( prod == m ) { count ++ ; mid -- ; start ++ ; } } } return count ; }
function findMaxNum ( arr , n ) { arr . sort ( function ( a , b ) { return b - a ; } ) ; var num = arr [ 0 ] ; for ( var i = 1 ; i < n ; i ++ ) { num = num * 10 + arr [ i ] ; } return num ; }
function printRLE ( s ) { for ( var i = 0 ; i < s . length ; i ++ ) { var count = 1 ; while ( i + 1 < s . length && s . charAt ( i ) == s . charAt ( i + 1 ) ) { i ++ ; count ++ ; } document . write ( s . charAt ( i ) + " " + count + " " ) ; } document . write ( " " ) ; }
function minimumSets ( arr , n , key ) { var i , j ; arr . sort ( ( a , b ) => a - b ) for ( i = 0 , j = n - 1 ; i <= j ; ++ i ) if ( arr [ i ] + arr [ j ] <= key ) j -- ; return i ; }
function distribution ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; var count = 1 ; for ( var i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) count ++ ; return Math . min ( count , parseInt ( n / 2 ) ) ; }
function distribution ( arr , n ) { let resources = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) resources . add ( arr [ i ] ) ; return Math . min ( resources . size , parseInt ( n / 2 , 10 ) ) ; }
function printPairs ( arr , n ) { let pairs = new Set ( ) ; let pair_exists = false ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] > 0 ) pairs . add ( arr [ i ] ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) if ( pairs . has ( - arr [ i ] ) ) { document . write ( arr [ i ] + " " + - arr [ i ] + " " ) ; pair_exists = true ; } } if ( pair_exists == false ) document . write ( " " ) ; }
function printTriplets ( arr , n , sum ) { for ( let i = 0 ; i < n - 2 ; i ++ ) { for ( let j = i + 1 ; j < n - 1 ; j ++ ) { for ( let k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] < sum ) document . write ( arr [ i ] + " " + arr [ j ] + " " + arr [ k ] + " " ) ; } } }
function printTriplets ( arr , n , sum ) { arr . sort ( function ( a , b ) { return a - b } ) ; for ( let i = 0 ; i < n - 2 ; i ++ ) { let j = i + 1 , k = n - 1 ; while ( j < k ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) k -- ; else { for ( let x = j + 1 ; x <= k ; x ++ ) document . write ( arr [ i ] + " " + arr [ j ] + " " + arr [ x ] + " " ) ; j ++ ; } } } }
function countTriplets ( arr , n , a , b ) { var ans = 0 ; for ( var i = 0 ; i < n - 2 ; i ++ ) { for ( var j = i + 1 ; j < n - 1 ; j ++ ) { for ( var k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] >= a && arr [ i ] + arr [ j ] + arr [ k ] <= b ) ans ++ ; } } return ans ; }
function checkFittingArrays ( A , B , N ) { A . sort ( function ( a , b ) { return a - b ; } ) ; B . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < N ; i ++ ) if ( A [ i ] > B [ i ] ) return false ; return true ; }
function areSame ( a , b ) { a . sort ( ( a , b ) => a - b ) ; b . sort ( ( a , b ) => a - b ) ; return ( a == b ) ; }
function maximum_toys ( cost , N , K ) { let count = 0 , sum = 0 ; cost . sort ( function ( a , b ) { return a - b } ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( sum + cost [ i ] <= K ) { sum = sum + cost [ i ] ; count ++ ; } } return count ; }
function findOptimalPairs ( arr , N ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; for ( var i = 0 , j = N - 1 ; i <= j ; i ++ , j -- ) document . write ( " " + arr [ i ] + " " + arr [ j ] + " " + " " ) ; }
function areBookingsPossible ( A , B , K , N ) { A . sort ( ) ; B . sort ( ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( i + K < N && A [ i + K ] < B [ i ] ) { return " " ; } } return " " ; }
function lexicographicSubConcat ( s ) { var n = s . length ; var sub_count = n * parseInt ( ( n + 1 ) / 2 ) ; var arr = Array ( sub_count ) ; var index = 0 ; for ( var i = 0 ; i < n ; i ++ ) for ( var len = 1 ; len <= n - i ; len ++ ) arr [ index ++ ] = s . substring ( i , i + len ) ; arr . sort ( ) ; var res = " " ; for ( var i = 0 ; i < sub_count ; i ++ ) res += arr [ i ] ; return res ; }
function Function ( str ) { let l = str . length ; let counter = new Array ( MAX ) ; for ( let i = 0 ; i < MAX ; i ++ ) counter [ i ] = 0 ; for ( let i = 0 ; i < l / 2 ; i ++ ) counter [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = Math . floor ( l / 2 ) ; i < l ; i ++ ) counter [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] -- ; for ( let i = 0 ; i < MAX ; i ++ ) if ( counter [ i ] != 0 ) return true ; return false ; }
function Function ( str ) { let l = str . length ; str = ( str . slice ( 0 , Math . floor ( l / 2 ) ) . sort ( ) ) . concat ( str . slice ( Math . floor ( l / 2 ) , l ) . sort ( ) ) ; for ( let i = 0 ; i < Math . floor ( l / 2 ) ; i ++ ) if ( str [ i ] != str [ Math . floor ( l / 2 ) + i ] ) return true ; return false ; }
function operations ( arr , n , k ) { arr . sort ( ) ; let i = 0 , sum = 0 ; while ( k -- > 0 ) { while ( i < n && arr [ i ] - sum == 0 ) i ++ ; if ( i < n && arr [ i ] - sum > 0 ) { document . write ( arr [ i ] - sum + " " ) ; sum = arr [ i ] ; } else document . write ( " " ) ; } }
function minElements ( arr , n ) { let halfSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = parseInt ( halfSum / 2 , 10 ) ; arr . sort ( function ( a , b ) { return a - b } ) ; arr . reverse ( ) ; let res = 0 , curr_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } return res ; }
function distancesum ( x , y , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ) ; return sum ; }
function minimumBox ( arr , n ) { var q = [ ] ; arr . sort ( ( a , b ) => a - b ) q . push ( arr [ 0 ] ) ; for ( var i = 1 ; i < n ; i ++ ) { var now = q [ 0 ] ; if ( arr [ i ] >= 2 * now ) q . pop ( 0 ) ; q . push ( arr [ i ] ) ; } return q . length ; }
function printMedian ( arr , n , K ) { arr . sort ( ) ; document . write ( arr [ Math . floor ( ( n + K ) / 2 ) ] ) ; }
function sortBinaryArray ( a , n ) { let j = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] < 1 ) { j ++ ; let temp = a [ j ] ; a [ j ] = a [ i ] ; a [ i ] = temp ; } } }
function almostSort ( A , n ) { for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { let temp = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = temp ; i ++ ; } } for ( let i = 0 ; i < n - 1 ; i ++ ) if ( A [ i ] > A [ i + 1 ] ) return false ; return true ; }
function check ( v , len ) { let n = v . length ; let tempArray ; for ( let i = 0 ; i < n ; i ++ ) { tempArray = v [ i ] . split ( " " ) ; ( tempArray ) . sort ( ) ; v [ i ] = ( tempArray ) . join ( " " ) ; } for ( let i = 0 ; i < len - 1 ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) if ( v [ i ] [ j ] > v [ i + 1 ] [ j ] ) return false ; return true ; }
function findDuplicate ( arr , n , k ) { arr . sort ( ) ; let i = 0 ; while ( i < n ) { let j , count = 1 ; for ( j = i + 1 ; j < n && arr [ j ] == arr [ i ] ; j ++ ) count ++ ; if ( count == k ) return arr [ i ] ; i = j ; } return - 1 ; }
function longestCommonPrefix ( a ) { let size = a . length ; if ( size == 0 ) return " " ; if ( size == 1 ) return a [ 0 ] ; a . sort ( ) ; let end = Math . min ( a [ 0 ] . length , a [ size - 1 ] . length ) ; let i = 0 ; while ( i < end && a [ 0 ] [ i ] == a [ size - 1 ] [ i ] ) i ++ ; let pre = a [ 0 ] . substring ( 0 , i ) ; return pre ; }
function find ( arr , n , k ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; let b = Math . floor ( Math . ceil ( n / k ) ) ; let min_sum = 0 , max_sum = 0 ; for ( let i = 0 ; i < b ; i ++ ) min_sum += arr [ i ] ; for ( let i = 2 ; i < arr . length ; i ++ ) max_sum += arr [ i ] ; document . write ( " " + min_sum + " " ) ; document . write ( " " + max_sum + " " ) ; }
function checkForSorting ( arr , n ) { let temp = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) { temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } else return false ; } } return true ; }
function pendulumArrangement ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; var op = [ ... Array ( n ) ] ; var mid = parseInt ( ( n - 1 ) / 2 ) ; var j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; } if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ; document . write ( " " ) ; for ( i = 0 ; i < n ; i ++ ) document . write ( op [ i ] + " " ) ; document . write ( " " ) ; }
function maxLevel ( boxes , n ) { boxes . sort ( ) ; let prev_width = boxes [ 0 ] ; let prev_count = 1 ; let curr_count = 0 ; let curr_width = 0 ; for ( let i = 1 ; i < n ; i ++ ) { curr_width += boxes [ i ] ; curr_count += 1 ; if ( curr_width > prev_width && curr_count > prev_count ) { prev_width = curr_width ; prev_count = curr_count ; curr_count = 0 ; curr_width = 0 ; ans ++ ; } } return ans ; }
function minDifferenceAmongMaxMin ( arr , N , K ) { arr . sort ( ( a , b ) => a - b ) ; let res = 2147483647 ; for ( let i = 0 ; i <= ( N - K ) ; i ++ ) { let curSeqDiff = arr [ i + K - 1 ] - arr [ i ] ; res = Math . min ( res , curSeqDiff ) ; } return res ; }
function printSorted ( a , b , c ) { let get_max = Math . max ( a , Math . max ( b , c ) ) ; let get_min = - Math . max ( - a , Math . max ( - b , - c ) ) ; let get_mid = ( a + b + c ) - ( get_max + get_min ) ; document . write ( get_min + " " + get_mid + " " + get_max ) ; }
function twoWaySort ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) arr [ i ] *= - 1 ; arr . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= - 1 ; }
function sortSquares ( arr ) { let n = arr . length ; for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] * arr [ i ] ; arr . sort ( ) ; }
function ksmallest ( arr , n , k ) { arr . sort ( function ( a , b ) { return a - b } ) ; if ( k < arr [ 0 ] ) return k ; if ( k == arr [ 0 ] ) return arr [ 0 ] + 1 ; if ( k > arr [ n - 1 ] ) return k + n ; if ( arr [ 0 ] == 1 ) k -- ; else k -= ( arr [ 0 ] - 1 ) ; for ( let i = 1 ; i < n ; i ++ ) { let c = arr [ i ] - arr [ i - 1 ] - 1 ; if ( k <= c ) return arr [ i - 1 ] + k ; else k -= c ; } return arr [ n - 1 ] + k ; }
function mergeTwoHalf ( A , n ) { A . sort ( ( a , b ) => a - b ) ; }
function minDiff ( arr , n , k ) { var result = Number . MAX_VALUE ; arr . sort ( ( a , b ) => a - b ) ; for ( i = 0 ; i <= n - k ; i ++ ) result = Math . min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; }
function isPossible ( a , b , n , k ) { a . sort ( function ( a , b ) { return a - b } ) ; b . reverse ( ) ; for ( let i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; }
function findMinDiff ( arr , n , m ) { if ( m == 0 n == 0 ) return 0 ; arr . sort ( function ( a , b ) { return a - b } ) ; if ( n < m ) return - 1 ; let min_diff = Number . MAX_VALUE ; for ( let i = 0 ; i + m - 1 < n ; i ++ ) { let diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < min_diff ) min_diff = diff ; } return min_diff ; }
function getIndexInSortedArray ( arr , n , idx ) { let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ idx ] ) result ++ ; if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ; } return result ; }
function minValue ( A , B , n ) { A . sort ( ) ; B . sort ( ) ; let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ; return result ; }
function isEven ( n ) { return ( n % 2 == 0 ) ; }
function isEven ( n ) { return ( ! ( n & 1 ) ) ; }
function findSubsequenceCount ( S , T ) { let m = T . length ; let n = S . length ; if ( m > n ) return 0 ; let mat = new Array ( m + 1 ) ; for ( let i = 0 ; i <= m ; i ++ ) { mat [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j <= n ; j ++ ) { mat [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= m ; i ++ ) mat [ i ] [ 0 ] = 0 ; for ( let j = 0 ; j <= n ; j ++ ) mat [ 0 ] [ j ] = 1 ; for ( let i = 1 ; i <= m ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { if ( T [ i - 1 ] != S [ j - 1 ] ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ; else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ; } } return mat [ m ] [ n ] ; }
function solve ( arr , n ) { arr . sort ( ) ; let a = 0 , b = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; }
function maxProduct ( arr , n ) { if ( n < 3 ) return - 1 ; let max_product = Number . MIN_VALUE ; for ( let i = 0 ; i < n - 2 ; i ++ ) for ( let j = i + 1 ; j < n - 1 ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) max_product = Math . max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; return max_product ; }
function maxProduct ( arr , n ) { if ( n < 3 ) { return - 1 ; } arr . sort ( ) ; return Math . max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ; } var arr = [ - 10 , - 3 , 5 , 6 , - 20 ] ; var n = arr . length ; var max = maxProduct ( arr , n ) ; if ( max == - 1 ) { document . write ( " " ) ; } else { document . write ( " " + max ) ; }
function distinctCount ( arr , n ) { let s = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) s . add ( Math . abs ( arr [ i ] ) ) ; return s . size ; }
function findMaxGuests ( arrl , exit , n ) { arrl . sort ( function ( a , b ) { return a - b } ) ; exit . sort ( function ( a , b ) { return a - b } ) ; let guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ; let i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in ++ ; if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] ; } i ++ ; } else { guests_in -- ; j ++ ; } } document . write ( " " + max_guests + " " + time ) ; }
function maxConsecutiveCnt ( arr ) { let X = 0 ; arr . sort ( function ( a , b ) { return a - b } ) for ( let i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] <= ( X + 1 ) ) { X = X + arr [ i ] ; } else { break ; } } return X + 1 ; }
function minimumPossibleProduct ( K ) { let res = 1 ; let range = ( 1 << K ) - 1 ; for ( let i = 0 ; i < K ; i ++ ) { res *= ( range - 1 ) ; } res *= range ; return res ; }
function countPoints ( D ) { let count = 0 ; for ( let x = 1 ; x * x < D * D ; x ++ ) { let y = Math . floor ( Math . sqrt ( D * D - x * x ) ) ; if ( x * x + y * y == D * D ) { count += 4 ; } } count += 4 ; return count ; }
function minimizeCost ( A , B , C ) { let ans = A + B + C ; for ( let i = 1 ; i <= 2 * C ; i ++ ) { let j = 0 ; while ( i * j <= 2 * C ) { ans = Math . min ( ans , Math . abs ( A - i ) + Math . abs ( B - j ) + Math . abs ( i * j - C ) ) ; j ++ ; } } return ans ; }
function averageSetBits ( N , K , arr ) { let p = N ; let q = 0 ; for ( let i = 0 ; i < K ; i ++ ) { let _p = p , _q = q ; p = _p - _p * arr [ i ] / N + _q * arr [ i ] / N ; q = _q - _q * arr [ i ] / N + _p * arr [ i ] / N ; } return p ; }
function minimumcoins ( arr , N ) { let coins = 0 ; let j = 0 ; if ( arr [ 0 ] == 1 ) coins ++ ; for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ i ] == 2 ) continue ; j = i ; while ( j < N && arr [ j ] == 1 ) { j ++ ; } let x = ( j - i ) ; coins += Math . floor ( x / 3 ) ; i = j - 1 ; } return coins ; }
function findRange ( arr , N , K ) { let L = Number . MIN_VALUE ; let R = Number . MAX_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { let l = Math . ceil ( 1.0 * arr [ i ] * K / ( i + 1 ) ) ; let r = Math . ceil ( ( 1.0 + arr [ i ] ) * K / ( i + 1 ) ) - 1 ; L = Math . max ( L , l ) ; R = Math . min ( R , r ) ; } document . write ( L + " " + R ) ; }
function maximizeProduct ( N ) { let MSB = Math . log2 ( N ) ; let X = 1 << MSB ; let Y = N - ( 1 << MSB ) ; for ( let i = 0 ; i < MSB ; i ++ ) { if ( ! ( N & ( 1 << i ) ) ) { X += 1 << i ; Y += 1 << i ; } } document . write ( X + " " + Y ) ; }
function arrayDivisionByTwo ( arr , n ) { let cnt = 0 ; let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { cnt = 0 ; while ( arr [ i ] % 2 == 0 ) { arr [ i ] = Math . floor ( arr [ i ] / 2 ) ; cnt ++ ; } ans = Math . min ( ans , cnt ) ; } return ans ; }
function minPushes ( N , K , arr ) { let dp = new Array ( 100000 ) . fill ( - 1 ) ; dp [ N ] = 0 ; for ( let i = 0 ; i < arr . length ; i ++ ) { for ( let xx = 0 ; xx < 100000 ; xx ++ ) { let x = xx ; if ( dp [ x ] == - 1 ) continue ; let next = ( x + arr [ i ] ) % 100000 ; while ( dp [ next ] == - 1 dp [ next ] > dp [ x ] + 1 ) { dp [ next ] = dp [ x ] + 1 ; x = next ; next = ( next + arr [ i ] ) % 100000 ; } } } return dp [ K ] ; }
function minApples ( ) { if ( M <= S * K ) return M ; else if ( M <= S * K + E + W ) return S * K + ( M - S * K ) * K ; else return - 1 ; }
function maxAverage ( A , N , X , Y ) { A . sort ( function ( a , b ) { return a - b ; } ) let sum = 0 ; let res = 0 ; let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; count ++ ; if ( count == X ) { if ( N - i - 1 < X ) { i ++ ; let cnt = 0 ; while ( i < N ) { cnt ++ ; sum += A [ i ] ; i ++ ; } X = X + cnt ; res += sum / X ; break ; } res += sum / X ; sum = 0 ; count = 0 ; } } document . write ( res . toPrecision ( 3 ) ) }
function largestMerge ( word1 , word2 ) { let merge = " " ; while ( word1 . length != 0 word2 . length != 0 ) { if ( word1 . localeCompare ( word2 ) == 0 || ( word1 . localeCompare ( word2 ) > 0 ) ) { merge = merge + word1 [ 0 ] ; word1 = word1 . substring ( 1 ) ; } else { merge = merge + word2 [ 0 ] ; word2 = word2 . substring ( 1 ) ; } } return merge ; }
function find ( arr , N ) { let Sum = 0 ; let i = 0 ; let ans = 0 ; for ( i = 0 ; i < N ; i ++ ) { Sum += arr [ i ] ; } if ( Sum % N ) { return - 1 ; } else { k = Math . floor ( Sum / N ) ; ans = 0 ; i = 0 ; while ( i < N ) { ans = ans + Math . abs ( k - arr [ i ] ) ; i += 1 ; } } return Math . floor ( ans / 2 ) ; }
function maxGcd ( a , b ) { document . write ( Math . abs ( a - b ) ) ; }
function printBinaryString ( arr , N ) { for ( let i = 1 ; i <= N ; i ++ ) { if ( i % 2 ) { document . write ( 0 ) ; } else { document . write ( 1 ) ; } } }
function MinCost ( days , cost , N ) { let size = days [ N - 1 ] + 1 ; let dp = new Array ( size ) ; dp [ size - 1 ] = Math . min ( cost [ 0 ] , Math . min ( cost [ 1 ] , cost [ 2 ] ) ) ; let ptr = N - 2 ; for ( let i = size - 2 ; i > 0 ; i -- ) { if ( ptr >= 0 && days [ ptr ] == i ) { let val1 = dp [ i + 1 ] + cost [ 0 ] ; let val2 = cost [ 1 ] + ( ( i + 7 >= size ) ? 0 : dp [ i + 7 ] ) ; let val3 = cost [ 2 ] + ( ( i + 30 >= size ) ? 0 : dp [ i + 30 ] ) ; dp [ i ] = Math . min ( val1 , Math . min ( val2 , val3 ) ) ; ptr -- ; } else { dp [ i ] = dp [ i + 1 ] ; } } return dp [ 1 ] ; }
function minElements ( arr , N , K ) { let count = 0 ; let requiredNum = 1 ; let i = 0 ; while ( requiredNum <= K ) { if ( i < N && requiredNum >= arr [ i ] ) { requiredNum += arr [ i ] ; i ++ ; } else { count ++ ; requiredNum += requiredNum ; } } return count ; }
function minimumSteps ( a , b ) { let cnt = 0 ; a = Math . abs ( a - b ) ; cnt = Math . floor ( a / 5 ) + Math . floor ( ( a % 5 ) / 2 ) + ( a % 5 ) % 2 ; return cnt ; }
function maximumCount ( arr , N ) { let odd = 0 ; let even = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 ) odd ++ ; else even ++ ; } if ( odd && even ) return N - 2 ; else return N - 1 ; }
function countOpenDoors ( N ) { let doorsOpen = parseInt ( Math . sqrt ( N ) ) ; return doorsOpen ; }
function minPossibleValue ( N , K , X ) { for ( let i = 1 ; i <= N ; i ++ ) { if ( X <= K ) { X = X * 2 ; } else { X = X + K ; } } return X ; }
function possibleNumbers ( numbers , N , M , A , B ) { if ( M == 0 ) { numbers . add ( N ) ; return ; } possibleNumbers ( numbers , N + A , M - 1 , A , B ) ; possibleNumbers ( numbers , N + B , M - 1 , A , B ) ; } var N = 5 , M = 3 , A = 4 , B = 6 ; var numbers = new Set ( ) ; possibleNumbers ( numbers , N , M , A , B ) ; for ( let x of numbers ) { document . write ( x + ' ' ) ; }
function convertXintoY ( X , Y ) { while ( Y > X ) { if ( Y % 2 == 0 ) Y = parseInt ( Y / 2 ) ; else if ( Y % 10 == 1 ) Y = parseInt ( Y /= 10 ) ; else break ; } if ( X == Y ) document . write ( " " ) ; else document . write ( " " ) ; }
function MaxXOR ( arr , N ) { var res = 0 ; for ( var i = 0 ; i < N ; i ++ ) { res |= arr [ i ] ; } return res ; }
function leastBricks ( wall ) { let map = new Map ( ) ; let res = 0 ; for ( let list of wall ) { let width = 0 ; for ( let i = 0 ; i < list . length - 1 ; i ++ ) { width += list [ i ] ; if ( map . has ( width ) ) { map . set ( width , map . get ( width ) + 1 ) ; } else { map . set ( width , 1 ) } res = Math . max ( res , map . get ( width ) ) ; } } document . write ( wall . length - res ) ; }
function findPermutation ( N ) { for ( var i = 1 ; i <= N ; i ++ ) document . write ( i + " " ) ; document . write ( " " ) ; }
function countOfPairs ( x , y ) { var count = 0 ; var k ; for ( k = 1 ; k * k <= x ; ++ k ) { count += Math . max ( 0 , Math . min ( y , x / k - 1 ) - k ) ; } document . write ( count + " " ) ; }
function numberOfWays ( N , X , Y ) { let S1 = ( N - 1 ) * X + Y ; let S2 = ( N - 1 ) * Y + X ; return ( S2 - S1 + 1 ) ; }
function countPermutations ( N ) { let adj = [ ] ; for ( let i = 0 ; i < 105 ; i ++ ) adj . push ( [ ] ) ; let indeg = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { for ( let j = 1 ; j <= N ; j ++ ) { if ( i == j ) continue ; let sum = i + j ; if ( Math . ceil ( Math . sqrt ( sum ) ) == Math . floor ( Math . sqrt ( sum ) ) ) { adj [ i ] . push ( j ) ; } } if ( adj [ i ] . length == 1 ) indeg ++ ; } if ( indeg == 0 ) return N ; else if ( indeg <= 2 ) return 2 ; else return 0 ; }
function findMaximumProfit ( arr , M , N ) { let max_heap = [ ] ; let maxProfit = 0 ; for ( let i = 0 ; i < N ; i ++ ) max_heap . push ( arr [ i ] ) ; max_heap . sort ( function ( a , b ) { return a - b } ) ; max_heap . reverse ( ) ; while ( M > 0 ) { M -- ; let X = max_heap [ 0 ] ; max_heap . shift ( ) ; maxProfit += X ; max_heap . push ( X - 1 ) ; max_heap . sort ( function ( a , b ) { return a - b } ) ; max_heap . reverse ( ) ; } document . write ( maxProfit ) ; }
function largestNumber ( N ) { if ( N > 45 ) return - 1 ; let num = 0 , digit = 9 ; while ( N > 0 && digit > 0 ) { if ( digit <= N ) { num *= 10 ; num += digit ; N -= digit ; } digit -= 1 ; } return num * 10 ; }
function MinimumOperations ( A , N , K ) { let Count = 0 ; let i = 0 ; while ( i < N - 1 ) { i = i + K - 1 ; Count ++ ; } return Count ; }
function sumOfMedians ( arr , N , K ) { let selectMedian = Math . floor ( ( K + 1 ) / 2 ) ; let totalArrays = Math . floor ( N / K ) ; let minSum = 0 ; let i = selectMedian - 1 ; while ( i < N && totalArrays != 0 ) { minSum = minSum + arr [ i ] ; i = i + selectMedian ; totalArrays -- ; } document . write ( minSum ) ; }
function generateString ( K ) { var s = " " ; for ( var i = 97 ; i < 97 + K ; i ++ ) { s = s + String . fromCharCode ( i ) ; for ( var j = i + 1 ; j < 97 + K ; j ++ ) { s += String . fromCharCode ( i ) ; s += String . fromCharCode ( j ) ; } } s += String . fromCharCode ( 97 ) ; document . write ( s ) ; }
function minimumValue ( N , K ) { return Math . ceil ( K / N ) ; }
function minModulo ( L , R , N ) { if ( R - L < N ) { let ans = Number . MAX_VALUE ; for ( let i = L ; i <= R ; i ++ ) for ( let j = L ; j <= R ; j ++ ) if ( i != j ) ans = Math . min ( ans , ( i * j ) % N ) ; document . write ( ans ) ; } else { document . write ( 0 ) ; } }
function countNumbers ( N ) { var count = 0 ; for ( i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { count ++ ; if ( parseInt ( N / i ) != i ) { count ++ ; } } } return count ; }
function findEquation ( A , B , C , K ) { document . write ( A + " " + K * B + " " + K * K * C ) ; }
function checkString ( s , k ) { let n = s . length ; if ( 2 * k + 1 > n ) { document . write ( " " ) ; return ; } let a = s . substr ( 0 , k ) ; let b = s . substr ( n - k , k ) ; b . split ( " " ) . reverse ( ) . join ( " " ) if ( a == b ) document . write ( " " ) ; else document . write ( " " ) ; }
function findMin ( arr , N , k ) { let pairs = 0 ; for ( let i = 0 ; i < N ; i ++ ) { pairs += arr [ i ] / 2 ; } if ( k > pairs ) return - 1 ; else return 2 * k + N - 1 ; }
function minOperations ( arr , n ) { var oddcount = 0 , evencount = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) oddcount ++ ; else evencount ++ ; } return Math . min ( oddcount , evencount ) ; }
function printLastElement ( arr , N ) { var leftTurn = true ; var remainElements = N ; var step = 1 ; var head = 1 ; while ( remainElements > 1 ) { if ( leftTurn ) { head = head + step ; } else { if ( remainElements % 2 == 1 ) head = head + step ; } remainElements = remainElements / 2 ; step = step * 2 ; leftTurn = ! leftTurn ; } document . write ( arr [ head - 1 ] ) ; }
function findEquation ( S , M ) { document . write ( " " + ( ( - 1 ) * S ) + " " + M ) ; }
function countTriplets ( N , K ) { if ( K % 2 == 0 ) { var x = parseInt ( N / K ) ; var y = parseInt ( ( N + ( K / 2 ) ) / K ) ; return x * x * x + y * y * y ; } else { var x = parseInt ( N / K ) ; return x * x * x ; } }
function minLength ( s ) { i = 0 ; j = s . length - 1 while ( i < j && s [ i ] == s [ j ] ) { d = s [ i ] while ( i <= j && s [ i ] == d ) i += 1 while ( i <= j && s [ j ] == d ) j -= 1 } return j - i + 1 }
function findNumber ( N ) { let ans = [ 1 , 2 , 4 , 8 , 7 , 5 ] ; return ans [ N % 6 ] ; }
function canBeEmptied ( A , B ) { if ( Math . max ( A , B ) > 2 * Math . min ( A , B ) ) { document . write ( " " ) ; return ; } if ( ( A + B ) % 3 == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function countDecrements ( arr ) { let count_1 = 0 ; let count_2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { if ( ( i + j ) % 2 == arr [ i ] [ j ] % 2 ) count_1 ++ ; if ( 1 - ( i + j ) % 2 == arr [ i ] [ j ] % 2 ) count_2 ++ ; } } document . write ( Math . min ( count_1 , count_2 ) ) ; }
function findScoreSum ( n ) { let total = 0 ; let prev_monday = 0 , curr_day = 0 ; for ( let day = 1 ; day <= n ; day ++ ) { if ( day % 7 == 1 ) { prev_monday ++ ; curr_day = prev_monday ; } total += curr_day ++ ; } document . write ( total ) ; }
function findScoreSum ( n ) { let F = n / 7 ; let D = n % 7 ; let fullWeekScore = ( 49 + 7 * F ) * F / 2 ; let lastNonFullWeekScore = ( 2 * F + D + 1 ) * D / 2 ; document . write ( Math . floor ( fullWeekScore + lastNonFullWeekScore ) ) ; }
function distIntegers ( L , R ) { return 2 * R - 2 * L + 1 ; }
function maximumNum ( X , Y , N ) { let num = 0 ; if ( N - N % X + Y <= N ) { num = N - N % X + Y ; } else { num = N - N % X - ( X - Y ) ; } return num ; }
function evenXorSubarray ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let XOR = 0 ; for ( let j = i ; j < n ; j ++ ) { XOR = XOR ^ arr [ j ] ; if ( ( XOR & 1 ) == 0 ) ans ++ ; } } document . write ( ans ) ; }
function countOccurrences ( n , x ) { var count = 0 ; for ( var i = 1 ; i <= n ; i ++ ) { if ( x % i == 0 ) { if ( x / i <= n ) count ++ ; } } document . write ( count ) ; }
function MinimumCost ( A , B , N ) { var totalCost = 0 ; for ( i = 0 ; i < N ; i ++ ) { var mod_A = B [ i ] % A [ i ] ; var totalCost_A = Math . min ( mod_A , A [ i ] - mod_A ) ; var mod_B = A [ i ] % B [ i ] ; var totalCost_B = Math . min ( mod_B , B [ i ] - mod_B ) ; totalCost += Math . min ( totalCost_A , totalCost_B ) ; } return totalCost ; }
function countOccurrences ( N , X ) { var count = 0 ; for ( var i = 1 ; i < Math . sqrt ( X ) ; i ++ ) { if ( X % i == 0 ) { var a = i ; var b = X / i ; if ( a <= N && b <= N ) { if ( a == b ) count += 1 ; else count += 2 ; } } } return count ; }
function winner ( arr , N ) { if ( N % 2 === 1 ) { document . write ( " " ) ; } else { document . write ( " " ) ; } }
function LCMPairs ( arr , N ) { var total_pairs = ( N * ( N - 1 ) ) / 2 ; var odd = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) odd ++ ; } odd = ( odd * ( odd - 1 ) ) / 2 ; document . write ( " " + ( total_pairs - odd ) + " " + odd ) ; }
function printNumber ( N , K , M ) { var sum = K * ( ( M * ( M + 1 ) ) / 2 ) ; return sum - N ; }
function countPairs ( L , R ) { let firstNum = 2 * L ; let lastNum = 2 * R ; let Cntpairs = lastNum - firstNum + 1 ; document . write ( Cntpairs + " " ) ; }
function countPairs ( A , n ) { var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) if ( ( A [ i ] A [ j ] ) > ( A [ i ] & A [ j ] ) ) { count ++ ; } } document . write ( count ) ; }
function maximumCandy ( candies , safety , N , M ) { let total = 0 ; let ans = Number . MAX_VALUE ; let all_safe = true ; for ( let i = 0 ; i < N ; i ++ ) { if ( candies [ i ] + M > safety [ i ] ) { all_safe = false ; ans = Math . min ( ans , safety [ i ] ) ; } else { ans = Math . min ( ans , candies [ i ] + M ) ; } total += candies [ i ] ; } if ( all_safe ) return total ; else return ans ; }
function checkArrays ( arr1 , arr2 , N ) { let count = 0 ; let flag = true ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr1 [ i ] != arr2 [ i ] ) { if ( arr1 [ i ] == 0 ) count ++ ; else { count -- ; if ( count < 0 ) { flag = false ; break ; } } } } if ( ( flag && ( count == 0 ) ) == true ) document . write ( " " ) ; else document . write ( " " ) ; }
function construct_Array ( N , K ) { for ( let i = 1 ; i <= N ; i ++ ) { document . write ( K * i + " " ) ; } }
function MinimumMoves ( A , B , N ) { let totalOperations = 0 ; let carry = 0 ; let K = 0 ; for ( let i = N - 1 ; i >= 0 ; i -- ) { let nearestMultiple = ( Math . ceil ( ( A [ i ] + carry ) / ( B [ i ] ) ) * B [ i ] ) ; K = nearestMultiple - ( A [ i ] + carry ) ; totalOperations += K ; carry += K ; } return totalOperations ; }
function maxSheets ( A , B ) { let area = A * B ; let count = 1 ; while ( area % 2 == 0 ) { area /= 2 ; count *= 2 ; } return count ; }
function findMinMoves ( a , b ) { let ans = 0 ; if ( a == b || Math . abs ( a - b ) == 1 ) { ans = a + b ; } else { let k = Math . min ( a , b ) ; let j = Math . max ( a , b ) ; ans = 2 * k + 2 * ( j - k ) - 1 ; } document . write ( ans ) ; }
function find ( N ) { var T , F , O ; F = parseInt ( ( N - 4 ) / 5 ) ; if ( ( ( N - 5 * F ) % 2 ) == 0 ) { O = 2 ; } else { O = 1 ; } T = Math . floor ( ( N - 5 * F - O ) / 2 ) ; document . write ( " " + F + " " ) ; document . write ( " " + T + " " ) ; document . write ( " " + O + " " ) ; }
function check ( current_row , current_col , destination_row , destination_col ) { if ( current_row == destination_row ) return " " ; else if ( current_col == destination_col ) return " " ; else return " " ; }
function generatepermutation ( N ) { var answer = [ ] ; answer . push ( N ) ; console . log ( answer ) ; for ( var i = 1 ; i < N ; i ++ ) { console . log ( answer ) ; answer . push ( i ) ; } for ( var i in answer ) document . write ( answer [ i ] + " " ) ; }
function cntEvenSumPairs ( X , Y ) { var cntXEvenNums = parseInt ( X / 2 ) ; var cntXOddNums = parseInt ( ( X + 1 ) / 2 ) ; var cntYEvenNums = parseInt ( Y / 2 ) ; var cntYOddNums = parseInt ( ( Y + 1 ) / 2 ) ; var cntPairs = ( cntXEvenNums * cntYEvenNums ) + ( cntXOddNums * cntYOddNums ) ; return cntPairs ; }
function maxValueAtIndexK ( N , K , M ) { let S1 = 0 , S2 = 0 ; S1 = K * ( K + 1 ) / 2 ; S2 = ( N - K - 1 ) * ( N - K ) / 2 ; let X = ( M + S1 + S2 ) / N ; document . write ( X ) ; }
function farthestCellDistance ( N , M , R , C ) { let d1 = N + M - R - C ; let d2 = R + C - 2 ; let d3 = N - R + C - 1 ; let d4 = M - C + R - 1 ; let maxDistance = Math . max ( d1 , Math . max ( d2 , Math . max ( d3 , d4 ) ) ) ; document . write ( maxDistance ) ; }
function minimumStepReqArr ( arr , N ) { let cntStep = 0 ; N += 1 ; for ( let i = 31 ; i >= 0 ; i -- ) { if ( ( N & ( 1 << i ) ) != 0 ) { cntStep += 1 ; } } return cntStep ; }
function findInGrid ( i , j ) { if ( i == j ) return ( i * i - ( i - 1 ) ) ; else if ( i > j ) { if ( i % 2 == 0 ) return i * i - ( j - 1 ) ; else return ( i - 1 ) * ( i - 1 ) + 1 + ( j - 1 ) ; } else { if ( j % 2 == 0 ) return ( j - 1 ) * ( j - 1 ) + 1 + ( i - 1 ) ; else return j * j - ( i - 1 ) ; } }
function minOpsToEmptyString ( S , N ) { let one = 0 , zero = 0 ; let x0 = 0 , x1 = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( S [ i ] == ' ' ) { x0 ++ ; x1 = 0 ; } else { x1 ++ ; x0 = 0 ; } zero = Math . max ( x0 , zero ) ; one = Math . max ( x1 , one ) ; } document . write ( Math . max ( one , zero ) ) ; }
function minOpsToTurnArrToZero ( arr , N ) { var st = new Set ( ) ; for ( var i = 0 ; i < N ; i ++ ) { if ( st . has ( arr [ i ] ) arr [ i ] == 0 ) { continue ; } else { st . add ( arr [ i ] ) ; } } document . write ( st . size ) }
function minMoves ( arr ) { let N = arr . length ; if ( N <= 2 ) return 0 ; let ans = Number . MAX_VALUE ; for ( let i = - 1 ; i <= 1 ; i ++ ) { for ( let j = - 1 ; j <= 1 ; j ++ ) { let num1 = arr [ 0 ] + i ; let num2 = arr [ 1 ] + j ; let flag = 1 ; let moves = Math . abs ( i ) + Math . abs ( j ) ; for ( let idx = 2 ; idx < N ; idx ++ ) { let num = num1 + num2 ; if ( Math . abs ( arr [ idx ] - num ) > 1 ) flag = 0 ; else moves += Math . abs ( arr [ idx ] - num ) ; num1 = num2 ; num2 = num ; } if ( flag > 0 ) ans = Math . min ( ans , moves ) ; } } if ( ans == Number . MAX_VALUE ) return - 1 ; return ans ; }
function querySum ( arr , N , Q , M ) { for ( let i = 0 ; i < M ; i ++ ) { let x = Q [ i ] [ 0 ] ; let y = Q [ i ] [ 1 ] ; let sum = 0 ; while ( x < N ) { sum += arr [ x ] ; x += y ; } document . write ( sum + " " ) ; } }
function minXOR ( Arr , N ) { for ( let i = 0 ; i < N ; i ++ ) { if ( Arr [ i ] == 2 ) { document . write ( ( Arr [ i ] ^ 3 ) + " " ) ; } else { document . write ( ( Arr [ i ] ^ 2 ) + " " ) ; } } }
function findMaxValByRearrArr ( arr , N ) { let res = 0 ; res = parseInt ( ( N * ( N + 1 ) ) / 2 , 10 ) ; return res ; }
function min_steps_required ( n , m , r , c ) { var i , j ; var corner_steps_req = Number . MAX_VALUE ; i = 1 ; j = 1 ; corner_steps_req = Math . min ( corner_steps_req , Math . abs ( r - i ) + Math . abs ( j - c ) ) ; i = n ; j = 1 ; corner_steps_req = Math . min ( corner_steps_req , Math . abs ( r - i ) + Math . abs ( j - c ) ) ; i = 1 ; j = m ; corner_steps_req = Math . min ( corner_steps_req , Math . abs ( r - i ) + Math . abs ( j - c ) ) ; i = n ; j = m ; corner_steps_req = Math . min ( corner_steps_req , Math . abs ( r - i ) + Math . abs ( j - c ) ) ; var minimum_steps = Math . min ( 2 * ( n - 1 ) + m - 1 , 2 * ( m - 1 ) + n - 1 ) ; return minimum_steps + corner_steps_req ; }
function cntOnesArrWithGivenOp ( arr , N ) { var cntOnes = 0 ; cntOnes = parseInt ( Math . sqrt ( N ) ) ; return cntOnes ; }
function cntKnightsAttackPawn ( knights , pawn , M ) { let cntKnights = 0 ; for ( let i = 0 ; i < M ; i ++ ) { let X = Math . abs ( knights [ i ] [ 0 ] - pawn [ 0 ] ) ; let Y = Math . abs ( knights [ i ] [ 1 ] - pawn [ 1 ] ) ; if ( ( X == 1 && Y == 2 ) || ( X == 2 && Y == 1 ) ) { cntKnights ++ ; } } return cntKnights ; }
function maxksum ( L , R , K ) { let N = ( R / 10 - L / 10 ) + 1 ; if ( K > N ) { document . write ( " " ) ; return ; } R = R / 10 ; let X = R - K ; let sum = 10 * ( ( R * ( R + 1 ) ) / 2 - ( X * ( X + 1 ) ) / 2 ) ; document . write ( sum ) ; }
function path_to_root ( node ) { while ( node >= 1 ) { document . write ( node + " " ) ; node = parseInt ( node / 2 , 10 ) ; } }
function minValue ( arr , n ) { var minimum = Math . min . apply ( Math , arr ) ; var sum = 0 ; var i ; for ( i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] - minimum ) ; } return sum ; }
function countEvenPairs ( N , M ) { let count = 0 ; nEven = parseInt ( Math . floor ( N / 2 ) ) ; nOdd = parseInt ( Math . ceil ( N / 2 ) ) ; mEven = parseInt ( Math . floor ( M / 2 ) ) ; mOdd = parseInt ( Math . ceil ( M / 2 ) ) ; count = nEven * mEven + nOdd * mOdd ; return count ; }
function String_palindrome ( N , K ) { for ( let i = 0 ; i < K ; i ++ ) document . write ( " " ) ; let s = " " ; for ( let i = 0 ; i < N - K ; i ++ ) document . write ( s [ i % 3 ] ) ; }
function lastRemovedCharacter ( str ) { var n = str . length ; if ( n == 1 ) return str [ 0 ] ; if ( str [ n - 2 ] == " " ) { return " " - str [ n - 1 ] + " " ; } else return str [ n - 1 ] ; }
function findNumbers ( aXORb , aANDb , aXORc , aANDc , bXORc , bANDc ) { let a , b , c ; let aSUMb ; let aSUMc ; let bSUMc ; aSUMb = aXORb + aANDb * 2 ; aSUMc = aXORc + aANDc * 2 ; bSUMc = bXORc + bANDc * 2 ; a = Math . floor ( ( aSUMb - bSUMc + aSUMc ) / 2 ) ; b = aSUMb - a ; c = aSUMc - a ; document . write ( " " + a ) ; document . write ( " " + b ) ; document . write ( " " + c ) ; }
function findNumber ( N ) { let count = 0 ; while ( ( N & 1 ) == 1 ) { N = N >> 1 ; count ++ ; } return N << count ; }
function findNumber ( N ) { return N & ( N + 1 ) ; }
function countNumberOfStrings ( s ) { let n = s . length - 1 ; let count = ( Math . pow ( 2 , n ) ) ; return count ; }
function findBitwiseORGivenXORAND ( X , Y ) { return X + Y ; }
function minimumcntOperationReq ( arr , N ) { let cntOp = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { cntOp ++ ; } } return ( cntOp + 1 ) / 2 ; }
function isSequenceValid ( B , N ) { for ( let i = 0 ; i < N ; i ++ ) { if ( ( i + 1 ) % B [ i ] != 0 ) { document . write ( " " ) ; return ; } } document . write ( " " ) ; }
function ConstArrayAdjacentCoprime ( N ) { for ( let i = 1 ; i <= N ; i ++ ) { document . write ( i + " " ) ; } }
function minimumCost ( a , b ) { var fre1 = Array ( 256 ) . fill ( 0 ) , fre2 = Array ( 256 ) . fill ( 0 ) ; a . split ( ' ' ) . forEach ( c => { fre1 [ c . charCodeAt ( 0 ) ] ++ ; } ) ; b . split ( ' ' ) . forEach ( c => { fre2 [ c . charCodeAt ( 0 ) ] ++ ; } ) ; var mincost = 0 ; for ( var i = 0 ; i < 256 ; i ++ ) { mincost += Math . abs ( fre1 [ i ] - fre2 [ i ] ) ; } document . write ( mincost ) ; }
function minCost ( arr ) { let odd = 0 , even = 0 ; for ( let i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } document . write ( Math . min ( even , odd ) ) ; }
function bitonicSequence ( num , lower , upper ) { if ( num > ( upper - lower ) * 2 + 1 ) { document . write ( - 1 ) ; return ; } var ans = [ ] ; for ( var i = 0 ; i < Math . min ( upper - lower + 1 , num - 1 ) ; i ++ ) ans . push ( upper - i ) ; for ( var i = 0 ; i < num - ans . length ; i ++ ) { ans . splice ( 0 , 0 , upper - i - 1 ) } document . write ( ' ' ) ; ans . forEach ( element => { document . write ( " " + element ) ; } ) ; document . write ( ' ' + ' ' ) ; }
function checkCount ( A , Q , q ) { for ( let i = 0 ; i < q ; i ++ ) { let L = Q [ i ] [ 0 ] ; let R = Q [ i ] [ 1 ] ; L -- ; R -- ; if ( ( A [ L ] < A [ L + 1 ] ) != ( A [ R - 1 ] < A [ R ] ) ) { document . write ( " " + " " ) ; } else { document . write ( " " + " " ) ; } } }
function findPairs ( N ) { for ( let i = 0 ; i <= N ; i ++ ) { document . write ( " " + i + " " + ( N - i ) + " " ) ; } }
function longestSubsequence ( arr , N ) { let count = 1 ; for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != arr [ i - 1 ] ) { count ++ ; } } document . write ( count ) ; }
function findXandYwithminABSX_Y ( N ) { if ( N % 2 == 1 ) { document . write ( ( N / 2 ) + " " + ( N / 2 + 1 ) ) ; } else { document . write ( ( N / 2 - 1 ) + " " + ( N / 2 + 1 ) ) ; } }
function minSteps ( S ) { let new_str = " " ; let N = S . length ; let i = 0 ; while ( i < N ) { new_str += S [ i ] ; let j = i ; while ( i < N && S [ i ] == S [ j ] ) ++ i ; } document . write ( Math . ceil ( ( new_str . length + 1 ) / 2.0 ) ) ; }
function MaximumSides ( n ) { if ( n < 4 ) return - 1 ; return n % 2 == 0 ? n / 2 : - 1 ; }
function check ( n ) { if ( ( n & n - 1 ) != 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function countOfSubarray ( arr , N ) { var mp = new Map ( ) ; var answer = 0 ; var sum = 0 ; if ( ! mp . has ( 1 ) ) mp . set ( 1 , 1 ) else mp . set ( 1 , mp . get ( 1 ) + 1 ) for ( var i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; answer += mp . has ( sum - i ) ? mp . get ( sum - i ) : 0 ; if ( mp . has ( sum - i ) ) mp . set ( sum - i , mp . get ( sum - i ) + 1 ) else mp . set ( sum - i , 1 ) } document . write ( answer ) ; }
function Moves_Calculator ( x , y , row , col ) { let total_moves = 0 ; if ( ( row - x ) > 0 && ( col - y ) > 0 ) total_moves += Math . min ( ( row - x ) , ( col - y ) ) ; if ( ( y - 1 ) > 0 && ( x - 1 ) > 0 ) total_moves += Math . min ( ( y - 1 ) , ( x - 1 ) ) ; if ( ( x - 1 ) > 0 && ( col - y ) > 0 ) total_moves += Math . min ( ( x - 1 ) , ( col - y ) ) ; if ( ( row - x ) > 0 && ( y - 1 ) > 0 ) total_moves += Math . min ( ( row - x ) , ( y - 1 ) ) ; total_moves += ( row - 1 ) + ( col - 1 ) ; let king_moves = 0 ; if ( x + 1 <= row ) king_moves += 1 ; if ( x - 1 > 0 ) king_moves += 1 ; if ( y + 1 <= col ) king_moves += 1 ; if ( y - 1 > 0 ) king_moves += 1 ; if ( x + 1 <= row && y + 1 <= col ) king_moves += 1 ; if ( x + 1 <= row && y - 1 > 0 ) king_moves += 1 ; if ( x - 1 > 0 && y - 1 > 0 ) king_moves += 1 ; if ( x - 1 > 0 && y + 1 <= col ) king_moves += 1 ; return total_moves - king_moves ; }
function clstNum ( N ) { return ( N - 1 ) ; }
function equvInverse ( arr , N , P ) { let cntElem = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] * arr [ i ] ) % P == 1 ) { cntElem ++ ; } } return cntElem ; }
function pairProductMean ( arr , N ) { var pairArray = [ ] ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { var pairProduct = arr [ i ] * arr [ j ] ; pairArray . push ( pairProduct ) ; } } var length = pairArray . length ; var sum = 0 ; for ( i = 0 ; i < length ; i ++ ) sum += pairArray [ i ] ; var mean ; if ( length != 0 ) mean = sum / length ; else mean = 0 ; return mean ; }
function minProduct ( n ) { let ans = 1 ; for ( let i = 1 ; i <= Math . floor ( ( n - 4 ) / 2 ) ; i ++ ) { ans = ( 1 * ans * ( n - 2 ) ) % mod ; } ans = ( 1 * ans * ( n - 2 ) * ( n - 1 ) ) % mod ; document . write ( ans + " " ) ; }
function TotalXorPair ( arr , N ) { let totalXOR = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { totalXOR ^= arr [ i ] ^ arr [ j ] ; } } return totalXOR ; }
function minAbsDiff ( N ) { var sumSet1 = 0 ; var sumSet2 = 0 ; for ( i = N ; i > 0 ; i -- ) { if ( sumSet1 <= sumSet2 ) { sumSet1 += i ; } else { sumSet2 += i ; } } return Math . abs ( sumSet1 - sumSet2 ) ; }
function minAbsDiff ( N ) { if ( N % 4 == 0 N % 4 == 3 ) { return 0 ; } return 1 ; }
function possibleAcyclicGraph ( N ) { document . write ( Math . pow ( 2 , N - 1 ) ) ; return ; }
function countPairs ( arr , N ) { let countPowerof2 = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( Number ( arr [ i ] . toString ( 2 ) . split ( " " ) . sort ( ) . join ( " " ) ) . toString ( ) . length == 1 ) countPowerof2 ++ ; } let desiredPairs = ( countPowerof2 * ( countPowerof2 - 1 ) ) / 2 ; document . write ( desiredPairs + " " ) ; }
function minProd ( X , Y , N ) { if ( X <= Y ) { if ( N < X ) return ( X - N ) * Y ; else { return Math . max ( Y - ( N - X + 1 ) , 1 ) ; } } if ( Y >= N ) return ( Y - N ) * X ; return Math . max ( X - ( N - Y + 1 ) , 1 ) ; }
function condition ( a , b ) { let d = Math . abs ( a - b ) , count = 0 ; for ( let i = 1 ; i <= Math . sqrt ( d ) ; i ++ ) { if ( d % i == 0 ) { if ( d / i == i ) count += 1 ; else count += 2 ; } } return count ; }
function find_next ( n , k ) { let M = n + 1 ; while ( true ) { if ( ( M & ( 1 << k ) ) > 0 ) break ; M ++ ; } return M ; }
function maximumSubarrays ( arr , N , target ) { var ans = 0 ; var availIdx = - 1 ; var cur_sum = 0 ; var mp = new Map ( ) ; mp . set ( 0 , 1 ) ; for ( var i = 0 ; i < N ; i ++ ) { cur_sum += arr [ i ] ; if ( mp . has ( cur_sum - target ) && mp . get ( cur_sum - target ) >= availIdx ) { ans ++ ; availIdx = i ; } mp . set ( cur_sum , i ) ; } return ans ; }
function factorsOf3 ( arr , N ) { let a = 0 , b = 0 , c = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 3 == 0 ) a ++ ; else if ( arr [ i ] % 3 == 1 ) b ++ ; else if ( arr [ i ] % 3 == 2 ) c ++ ; } if ( a >= 1 && a <= b + c + 1 ) document . write ( " " + " " ) ; else if ( a == 0 && b == 0 && c > 0 ) document . write ( " " + " " ) ; else if ( a == 0 && c == 0 && b > 0 ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; }
function maxBottles ( n , e ) { var s = 0 , b = 0 ; var a = n ; while ( a != 0 ) { s = s + a ; a = ( a + b ) / e ; b = n - ( a * e ) ; n = a + b ; } return s ; }
function getPosition ( N , M ) { if ( M > parseInt ( N / 2 ) ) { return ( M - parseInt ( N / 2 ) ) ; } return ( M + parseInt ( N / 2 ) ) ; }
function clearLastBit ( N , K ) { var mask = ( - 1 << K + 1 ) ; return N = N & mask ; }
function findWinner ( a , n ) { let win = 0 ; if ( n % 2 == 0 ) win = 1 ; else win = 0 ; for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( i % 2 == 1 ) { if ( win == 0 && a [ i ] > 1 ) win = 1 ; } else { if ( win == 1 && a [ i ] > 1 ) win = 0 ; } } if ( win == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function isPossible ( r , b , g ) { r = r % 3 ; b = b % 3 ; g = g % 3 ; if ( r == b b == g g == r ) { return true ; } else { return false ; } } var R = 1 , B = 3 , G = 6 ; if ( isPossible ( R , B , G ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function isReachable ( x1 , y1 , x2 , y2 ) { while ( x2 > x1 && y2 > y1 ) { if ( x2 > y2 ) x2 %= y2 ; else y2 %= x2 ; } if ( x2 == x1 ) return ( y2 - y1 ) >= 0 && ( y2 - y1 ) % x1 == 0 ; else if ( y2 == y1 ) return ( x2 - x1 ) >= 0 && ( x2 - x1 ) % y1 == 0 ; else return false ; }
function minLength ( A , N ) { var elem = A [ 0 ] , count = 1 ; for ( var i = 1 ; i < N ; i ++ ) { if ( A [ i ] == elem ) { count ++ ; } else { break ; } } if ( count == N ) return N ; else return 1 ; }
function checkWinner ( N , K ) { if ( N % ( K + 1 ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; } }
function findMaxSoln ( n , x , y ) { var ans = - 1000000000 ; for ( var k = 0 ; k <= n ; k ++ ) { if ( k % x == y ) { ans = Math . max ( ans , k ) ; } } return ( ( ans >= 0 && ans <= n ) ? ans : - 1 ) ; }
function getMinOps ( arr ) { var res = 0 ; for ( i = 0 ; i < arr . length - 1 ; i ++ ) { res += Math . max ( arr [ i + 1 ] - arr [ i ] , 0 ) ; } return res ; }
function getCount ( N , M ) { let total_count = 0 total_count += Math . floor ( N / 10 ) let x = Math . floor ( N / 10 ) * 10 if ( ( N - x ) >= M ) { total_count = total_count + 1 } return total_count }
function prletMissingElements ( arr , N ) { let diff = arr [ 0 ] - 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] - i != diff ) { while ( diff < arr [ i ] - i ) { document . write ( ( i + diff ) + " " ) ; diff ++ ; } } } }
function countNestedPolygons ( sides ) { var count = 0 ; while ( sides > 5 ) { sides /= 2 ; count += 1 ; } return count ; }
function minCost ( str , a , b ) { let openUnbalanced = 0 ; let closedUnbalanced = 0 ; let openCount = 0 ; let closedCount = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] == ' ' ) { openUnbalanced ++ ; openCount ++ ; } else { if ( openUnbalanced == 0 ) closedUnbalanced ++ ; else openUnbalanced -- ; closedCount ++ ; } } let result = a * ( Math . abs ( openCount - closedCount ) ) ; if ( closedCount > openCount ) closedUnbalanced -= ( closedCount - openCount ) ; if ( openCount > closedCount ) openUnbalanced -= ( openCount - closedCount ) ; result += Math . min ( a * ( openUnbalanced + closedUnbalanced ) , b * closedUnbalanced ) ; document . write ( result + " " ) ; }
function mindigits ( n ) { if ( n % 9 == 0 ) { document . write ( Math . floor ( n / 9 ) + " " ) ; } else { document . write ( Math . floor ( n / 9 ) + 1 + " " ) ; } }
function countOfSubarray ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) arr [ i ] -- ; let pref = [ ] ; pref [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) pref [ i ] = pref [ i - 1 ] + arr [ i ] ; let mp = new Map ; let answer = 0 ; if ( mp [ 0 ] ) mp [ 0 ] ++ ; else mp [ 0 ] = 1 ; for ( let i = 0 ; i < N ; i ++ ) { if ( mp [ pref [ i ] ] ) { answer += mp [ pref [ i ] ] ; mp [ pref [ i ] ] ++ ; } } return answer ; }
function printsubset ( n , k ) { let count = 0 , x = 0 ; let vec = [ ] ; while ( n != 0 ) { x = n & 1 ; if ( x != 0 ) { vec . push ( Math . pow ( k , count ) ) ; } n = n >> 1 ; count ++ ; } for ( let i = 0 ; i < vec . length ; i ++ ) document . write ( vec [ i ] + " " ) ; }
function checkEquall ( arr , N ) { let sumEven = 0 , sumOdd = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( i % 2 == 1 ) sumOdd += arr [ i ] ; else sumEven += arr [ i ] ; } if ( sumEven == sumOdd ) return true ; else return false ; }
function countEvenSum ( low , high , k ) { let even_count = high / 2 - ( low - 1 ) / 2 ; let odd_count = ( high + 1 ) / 2 - low / 2 ; let even_sum = 1 ; let odd_sum = 0 ; for ( let i = 0 ; i < k ; i ++ ) { let prev_even = even_sum ; let prev_odd = odd_sum ; even_sum = ( prev_even * even_count ) + ( prev_odd * odd_count ) ; odd_sum = ( prev_even * odd_count ) + ( prev_odd * even_count ) ; } document . write ( even_sum ) ; }
function incrementCount ( arr , N ) { let mini = arr [ 0 ] - arr [ 1 ] ; for ( let i = 2 ; i < N ; i ++ ) { mini = Math . min ( mini , arr [ i - 1 ] - arr [ i ] ) ; } document . write ( mini ) ; }
function Length_Diagonals ( a , theta ) { let p = a * Math . sqrt ( 2 + ( 2 * Math . cos ( theta * ( Math . PI / 180 ) ) ) ) ; let q = a * Math . sqrt ( 2 - ( 2 * Math . cos ( theta * ( Math . PI / 180 ) ) ) ) ; return [ p , q ] ; }
function maxORminusXOR ( N ) { let MSB = Math . ceil ( Math . log ( N ) ) ; let M = 0 ; for ( let i = 0 ; i <= MSB ; i ++ ) M += ( 1 << i ) ; return M ; }
function No_of_Triangle ( N , K ) { if ( N < K ) return - 1 ; else { let Tri_up = 0 ; Tri_up = Math . floor ( ( ( N - K + 1 ) * ( N - K + 2 ) ) / 2 ) ; let Tri_down = 0 ; Tri_down = Math . floor ( ( ( N - 2 * K + 1 ) * ( N - 2 * K + 2 ) ) / 2 ) ; return Tri_up + Tri_down ; } }
function findPair ( A , B , N ) { var X , Y ; X = N - B + A ; if ( X % 2 != 0 ) { document . write ( " " ) ; } else { X = X / 2 ; Y = N - X ; document . write ( X + " " + Y ) ; } }
function check ( a , n ) { let ma = a [ 1 ] - a [ 0 ] ; for ( let i = 1 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] > a [ i - 1 ] && a [ i + 1 ] < a [ i ] ) || ( a [ i ] < a [ i - 1 ] && a [ i + 1 ] > a [ i ] ) ) ma = Math . max ( ma , Math . abs ( a [ i ] - a [ i + 1 ] ) ) ; else return false ; } document . write ( " " + ma ) ; document . write ( " " ) ; return true ; }
function countSetBits ( L , R ) { let count = 0 ; for ( let i = L ; i <= R ; i ++ ) { let n = i ; while ( n > 0 ) { count += ( n & 1 ) ; n = n >> 1 ; } } return count ; }
function countElement ( A , N , B , M , K ) { let cnt = 0 ; for ( let i = 0 ; i < M ; i ++ ) { let currentElement = B [ i ] ; for ( let j = 0 ; j < N ; j ++ ) { let diff = Math . abs ( currentElement - A [ j ] ) ; if ( diff <= K ) { cnt ++ ; break ; } } } document . write ( cnt ) ; }
function AreaofRectangle ( L , W ) { var area = parseFloat ( ( ( W + L ) * ( W + L ) ) / 2 ) . toFixed ( 1 ) ; return area ; }
function downToZero ( n ) { if ( n <= 3 ) return n ; let dp = new Array ( n + 1 ) dp . fill ( - 1 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; let sqr ; for ( let i = 4 ; i <= n ; i ++ ) { sqr = Math . sqrt ( i ) ; let best = Number . MAX_VALUE ; while ( sqr > 1 ) { if ( i % sqr == 0 ) { best = Math . min ( best , 1 + dp [ sqr ] ) ; } sqr -- ; } best = Math . min ( best , 1 + dp [ i - 1 ] ) ; dp [ i ] = best ; } return dp [ n ] ; }
function downToZero ( n ) { if ( n <= 3 ) return n ; return n % 2 == 0 ? 3 : 4 ; }
function getMinCost ( A , B , N ) { let mini = Number . MAX_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { mini = Math . min ( mini , Math . min ( A [ i ] , B [ i ] ) ) ; } return mini * ( 2 * N - 1 ) ; }
function solve ( n , arr ) { var s = [ ' ' , ' ' , ' ' ] var ans = [ ] ; ans . push ( s . join ( " " ) ) ; for ( var i = n - 1 ; i >= 0 ; i -- ) { if ( s . length - 1 >= arr [ i ] ) { var ch = s [ arr [ i ] ] ; if ( ch == ' ' ) ch = ' ' ; else ch = ' ' ; s [ arr [ i ] ] = ch ; } ans . push ( s . join ( " " ) ) ; } return ans ; } var arr = [ 2 , 0 , 3 ] ; var n = arr . length ; var ans = solve ( n , arr ) ; for ( var i = ans . length - 1 ; i >= 0 ; i -- ) { document . write ( ans [ i ] + " " ) ; }
function countSwaps ( A , n ) { A . sort ( ) ; let ind = 1 , res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { while ( ind < n && A [ ind ] == A [ i ] ) ind ++ ; if ( ind < n && A [ ind ] > A [ i ] ) { res ++ ; ind ++ ; } if ( ind >= n ) break ; } return res ; }
function countSwaps ( A , n ) { var mp = new Map ( ) ; var max_frequency = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( mp . has ( A [ i ] ) ) mp . set ( A [ i ] , mp . get ( A [ i ] ) + 1 ) else mp . set ( A [ i ] , 1 ) ; max_frequency = Math . max ( max_frequency , mp . get ( A [ i ] ) ) ; } return n - max_frequency ; }
function min_operation ( a , n ) { var ans = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( i > 0 ) ans += Math . abs ( a [ i ] - a [ i - 1 ] ) ; else ans += Math . abs ( a [ i ] ) ; } return ans ; }
function find ( n ) { document . write ( parseInt ( n / 2 , 10 ) + " " ) ; }
function maxSubsequences ( arr , n ) { let map = new Map ( ) ; let maxCount = 0 ; let count ; for ( let i = 0 ; i < n ; i ++ ) { if ( map . has ( arr [ i ] ) ) { count = map [ arr [ i ] ] ; if ( count > 1 ) { map . add ( arr [ i ] , count - 1 ) ; } else map . delete ( arr [ i ] ) ; if ( arr [ i ] - 1 > 0 ) if ( map . has ( arr [ i ] - 1 ) ) map [ arr [ i ] - 1 ] ++ ; else map . set ( arr [ i ] - 1 , 1 ) ; } else { maxCount ++ ; if ( arr [ i ] - 1 > 0 ) if ( map . has ( arr [ i ] - 1 ) ) map [ arr [ i ] - 1 ] ++ ; else map . set ( arr [ i ] - 1 , 1 ) ; } } return maxCount ; }
function count ( n , k ) { let count = Math . pow ( 10 , k ) - Math . pow ( 10 , k - 1 ) ; document . write ( count ) ; }
function sumOfFactors ( N ) { var ans = 0 ; for ( i = 1 ; i <= N ; i ++ ) { var first = i ; var last = parseInt ( N / i ) * i ; var factors = parseInt ( ( last - first ) / i ) + 1 ; var totalContribution = parseInt ( ( ( factors ) * ( factors + 1 ) ) / 2 ) * i ; ans += totalContribution ; } return ans ; }
function findAandB ( N ) { if ( N == 1 ) { document . write ( " " ) ; return ; } let a = N * N / ( N - 1 ) ; let b = a / N ; document . write ( " " + a + " " ) ; document . write ( " " + b + " " ) ; }
function maxSelections ( A , n , k ) { A . sort ( ) ; let sum = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum = sum + A [ i ] ; if ( sum > k ) { break ; } count ++ ; } return count ; }
function computePair ( K ) { if ( K == 1 ) { document . write ( " " ) ; return ; } else { document . write ( K * K / ( K - 1 ) + " " ) ; document . write ( K / ( K - 1 ) ) ; } }
function getMaxDifference ( N ) { var M = - 1 ; var maxDiff = 0 ; for ( i = 0 ; i < N ; i ++ ) { var diff = ( N ^ i ) - ( N & i ) ; if ( diff >= maxDiff ) { maxDiff = diff ; M = i ; } } return M ; }
function findM ( N ) { var M = 0 ; var MSB = parseInt ( Math . log ( N ) ) ; for ( i = 0 ; i < MSB ; i ++ ) { if ( ( N & ( 1 << i ) ) == 0 ) M += ( 1 << i ) ; } return M ; }
function countStrings ( A , B , K ) { let X = Math . floor ( ( A + B ) / ( K + 1 ) ) ; return ( Math . min ( A , Math . min ( B , X ) ) * ( K + 1 ) ) ; }
function findShifts ( A , N ) { let shift = Array . from ( { length : N } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( i == A [ i ] - 1 ) shift [ i ] = 0 ; else shift [ i ] = ( A [ i ] - 1 - i + N ) % N ; } for ( let i = 0 ; i < N ; i ++ ) document . write ( shift [ i ] + " " ) ; }
function isDivisible ( N ) { return ( N - 1 ) % 3 != 0 ; }
function calculate ( arr ) { let n = arr . length ; let ans = [ ] ; for ( let i = 0 ; i < arr . length ; i ++ ) { let sum = 0 ; for ( let j = 0 ; j < arr . length ; j ++ ) { sum += Math . abs ( arr [ i ] - arr [ j ] ) ; } ans . push ( sum ) ; } return ans ; }
function no_of_moves ( Matrix , x , y ) { let moves = 0 ; for ( let i = 0 ; i < M ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { if ( Matrix [ i ] [ j ] != 0 ) { moves += Math . abs ( x - i ) ; moves += Math . abs ( y - j ) ; } } } document . write ( moves ) ; }
function is_linear ( s ) { let tmp = 0 ; let first = s [ 0 ] ; for ( let pos = 0 ; pos < s . length ; pos += tmp ) { if ( s [ pos ] != first ) { return false ; } tmp ++ ; } return true ; } let str = " " ; if ( is_linear ( str ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function calculateWays ( arr1 , arr2 , N ) { let A = arr2 [ 0 ] , B = arr2 [ 1 ] ; let C = arr2 [ 2 ] , D = arr2 [ 3 ] ; let ans = 0 ; for ( let b = 0 ; b <= B && b * 5 <= ( N ) ; b ++ ) for ( let c = 0 ; c <= C && b * 5 + c * 10 <= ( N ) ; c ++ ) for ( let d = 0 ; d <= D && b * 5 + c * 10 + d * 20 <= ( N ) ; d ++ ) if ( ( b * 5 ) + ( c * 10 ) + ( d * 20 ) >= ( N - A ) ) ans ++ ; return ans ; }
function removeAll ( arr , n ) { if ( arr [ 0 ] < arr [ n - 1 ] ) document . write ( " " ) ; else document . write ( " " ) ; }
function minNum ( n ) { if ( n < 3 ) document . write ( - 1 ) ; else document . write ( ( 210 * ( parseInt ( Math . pow ( 10 , n - 1 ) / 210 ) + 1 ) ) ) ; }
function numberOfPairs ( n ) { let count = 0 ; let i = 1 , j = n - 1 ; while ( i < j ) { if ( i + j == n ) { count ++ ; } i ++ ; j -- ; } return count ; }
function numberOfPairs ( n ) { if ( n % 2 == 0 ) return ( n / 2 - 1 ) ; else return ( n / 2 ) ; }
function find_max ( n , k ) { var X = Array . from ( { length : 32 } , ( _ , i ) => 0 ) ; var cnt = 0 ; for ( i = 31 ; i >= 0 && cnt != k ; i -- ) { if ( ( n & ( 1 << i ) ) != 0 ) { X [ i ] = 1 ; cnt ++ ; } } var s = " " ; for ( i = 31 ; i >= 0 ; i -- ) s += X [ i ] == 0 ? ' ' : ' ' ; return parseInt ( s , 2 ) ; }
function get_palindrome_time ( str ) { let hh , mm ; hh = ( str [ 0 ] . charCodeAt ( ) - 48 ) * 10 + ( str [ 1 ] . charCodeAt ( ) - 48 ) ; mm = ( str [ 3 ] . charCodeAt ( ) - 48 ) * 10 + ( str [ 4 ] . charCodeAt ( ) - 48 ) ; let requiredTime = 0 ; while ( hh % 10 != Math . floor ( mm / 10 ) || Math . floor ( hh / 10 ) != mm % 10 ) { ++ mm ; if ( mm == 60 ) { mm = 0 ; ++ hh ; } if ( hh == 24 ) hh = 0 ; ++ requiredTime ; } return requiredTime ; }
function Solve ( N , M ) { let temp = ( N - 1 ) * ( M - 1 ) ; let ans = ( Math . pow ( 2 , temp ) ) ; if ( ( N + M ) % 2 != 0 ) document . write ( ans ) ; else document . write ( 2 * ans ) ; }
function minPolets ( n , m ) { let ans = 0 ; if ( ( n % 2 != 0 ) && ( m % 2 != 0 ) ) { ans = Math . floor ( ( n * m ) / 2 ) + 1 ; } else { ans = Math . floor ( ( n * m ) / 2 ) ; } return ans ; }
function maxProfit ( prices , n ) { let profit = 0 , currentDay = n - 1 ; while ( currentDay > 0 ) { let day = currentDay - 1 ; while ( day >= 0 && ( prices [ currentDay ] > prices [ day ] ) ) { profit += ( prices [ currentDay ] - prices [ day ] ) ; day -- ; } currentDay = day ; } return profit ; }
function findDirection ( n , m ) { if ( n > m ) { if ( m % 2 == 0 ) document . write ( " " ) ; else document . write ( " " ) ; } else { if ( n % 2 == 0 ) document . write ( " " ) ; else document . write ( " " ) ; } }
function createArray ( n , s ) { if ( 2 * n <= s ) { for ( let i = 0 ; i < n - 1 ; i ++ ) { document . write ( 2 + " " ) ; s -= 2 ; } document . write ( s + " " ) ; document . write ( 1 ) ; } else document . write ( " " ) ; }
function maxModulosum ( a , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } return sum - n ; }
function findAns ( mat , x , y , n , m ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { ans += Math . abs ( x - i ) + Math . abs ( y - j ) ; } } } return ans ; }
function solve ( n , m , x , y , d ) { let top = Math . min ( d , x - 1 ) ; let down = Math . min ( d , n - x ) ; let left = Math . min ( d , y - 1 ) ; let right = Math . min ( d , m - y ) ; let quad1 = top * left ; let quad2 = left * down ; let quad3 = down * right ; let quad4 = right * top ; let totalsq = quad1 + quad2 + quad3 + quad4 ; let singleBlocks = top + down + left + right + 1 ; return totalsq + singleBlocks ; }
function get_last_two_digit ( N ) { if ( N % 4 == 0 ) return " " ; else if ( N % 4 == 1 ) return " " ; else if ( N % 4 == 2 ) return " " ; return " " ; }
function isSubseqPossible ( arr , N , K ) { let i ; let odd = 0 , even = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd == 0 || ( even == 0 && K % 2 == 0 ) ) return false ; return true ; }
function minimumCost ( arr , cost , N ) { var dp = Array ( N ) . fill ( ) . map ( ( ) => Array ( 3 ) . fill ( 0 ) ) ; dp [ 0 ] [ 0 ] = 0 ; dp [ 0 ] [ 1 ] = cost [ 0 ] ; dp [ 0 ] [ 2 ] = cost [ 0 ] * 2 ; for ( i = 1 ; i < N ; i ++ ) { for ( j = 0 ; j < 3 ; j ++ ) { var minimum = parseInt ( 1e6 ) ; if ( j + arr [ i ] != arr [ i - 1 ] ) minimum = Math . min ( minimum , dp [ i - 1 ] [ 0 ] ) ; if ( j + arr [ i ] != arr [ i - 1 ] + 1 ) minimum = Math . min ( minimum , dp [ i - 1 ] [ 1 ] ) ; if ( j + arr [ i ] != arr [ i - 1 ] + 2 ) minimum = Math . min ( minimum , dp [ i - 1 ] [ 2 ] ) ; dp [ i ] [ j ] = j * cost [ i ] + minimum ; } } var ans = parseInt ( 1e6 ) ; for ( i = 0 ; i < 3 ; i ++ ) ans = Math . min ( ans , dp [ N - 1 ] [ i ] ) ; document . write ( ans + " " ) ; }
function makeZero ( x , y , a , b ) { if ( x > y ) { let temp = x ; x = y ; y = temp ; } let tot_cost = ( y - x ) * a ; let cost1 = 2 * x * a ; let cost2 = x * b ; tot_cost += Math . min ( cost1 , cost2 ) ; document . write ( tot_cost ) ; }
function count_triangles ( a , b , c , d ) { var ans = 0 ; for ( x = a ; x <= b ; ++ x ) { var num_greater_than_d = Math . max ( d , c + x ) - Math . max ( d , b + x - 1 ) ; ans += num_greater_than_d * ( d - c + 1 ) ; var r = Math . min ( Math . max ( c , c + x ) , d ) - c ; var l = Math . min ( Math . max ( c , b + x - 1 ) , d ) - c ; var x1 = ( r * ( r + 1 ) ) / 2 ; var x2 = ( l * ( l + 1 ) ) / 2 ; ans += x1 - x2 ; } return ans ; }
function check ( S , prices , type , n ) { for ( let j = 0 ; j < n ; j ++ ) { for ( let k = j + 1 ; k < n ; k ++ ) { if ( ( type [ j ] == 0 && type [ k ] == 1 ) || ( type [ j ] == 1 && type [ k ] == 0 ) ) { if ( prices [ j ] + prices [ k ] <= S ) { return " " ; } } } } return " " ; }
function numPairs ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) ans ++ ; } } return ans ; }
function maxRemainingSum ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; var i = 0 ; var j = n - 1 ; var result = 0 ; while ( i < j ) { if ( arr [ i ] < arr [ j ] ) { sum -= arr [ i ] ; i ++ ; } else { sum -= arr [ j ] ; j -- ; } result += sum ; } return result ; }
function longestSubsequence ( s ) { var n = s . length ; var answer = 0 ; var prev = ' ' ; for ( var i = 0 ; i < n ; i ++ ) { if ( prev != s [ i ] ) { prev = s [ i ] ; answer ++ ; } } return answer ; }
function MinDiff ( n ) { var val = parseInt ( Math . pow ( 2 , n ) ) ; var sep = n / 2 ; var grp1 = 0 ; var grp2 = 0 ; grp1 = grp1 + val ; for ( i = 1 ; i < sep ; i ++ ) grp1 = grp1 + parseInt ( Math . pow ( 2 , i ) ) ; for ( i = sep ; i < n ; i ++ ) grp2 = grp2 + parseInt ( Math . pow ( 2 , i ) ) ; document . write ( Math . abs ( grp1 - grp2 ) ) ; }
function minOccupiedPosition ( A , n ) { var minPos = 0 ; for ( var i = 0 ; i < n ; ++ i ) { if ( A [ i ] > 0 ) { ++ minPos ; i += 2 ; } } return minPos ; }
function minOperations ( a , b , n ) { var minA = Math . max . apply ( Math , a ) ; ; for ( x = minA ; x >= 0 ; x -- ) { var check = true ; var operations = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( x % b [ i ] == a [ i ] % b [ i ] ) { operations += ( a [ i ] - x ) / b [ i ] ; } else { check = false ; break ; } } if ( check ) return operations ; } return - 1 ; }
function findMinimumK ( a , n , S ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } return Math . ceil ( ( ( S + 1 ) * 1.0 ) / ( sum * 1.0 ) ) ; }
function MinimumValue ( a , n ) { let answer = Number . MAX_SAFE_INTEGER ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { answer = Math . min ( answer , ( ( a [ i ] & a [ j ] ) ^ ( a [ i ] a [ j ] ) ) ) ; } } return answer ; }
function MinimumValue ( arr , n ) { arr . sort ( ) ; let minXor = Number . MAX_VALUE ; let val = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { val = arr [ i ] ^ arr [ i + 1 ] ; minXor = Math . min ( minXor , val ) ; } return minXor ; }
function largestNum ( n ) { let num = 0 ; for ( let i = 0 ; i <= 32 ; i ++ ) { let x = ( 1 << i ) ; if ( ( x - 1 ) <= n ) num = ( 1 << i ) - 1 ; else break ; } return num ; }
function findString ( N , K ) { for ( let i = 0 ; i < N ; i ++ ) { document . write ( String . fromCharCode ( ' ' . charCodeAt ( ) + i % K ) ) ; } }
function getLargestSum ( N ) { var max_sum = 0 ; for ( i = 1 ; i <= N ; i ++ ) { for ( j = i + 1 ; j <= N ; j ++ ) { if ( i * j % ( i + j ) == 0 ) max_sum = Math . max ( max_sum , i + j ) ; } } return max_sum ; }
function getLargestSum ( N ) { let max_sum = 0 ; for ( let i = 1 ; i * i <= N ; i ++ ) { for ( let j = i + 1 ; j * j <= N ; j ++ ) { let k = parseInt ( N / j , 10 ) ; let a = k * i ; let b = k * j ; if ( a <= N && b <= N && a * b % ( a + b ) == 0 ) max_sum = Math . max ( max_sum , a + b ) ; } } return max_sum ; }
function findSum ( L , R ) { var arr = [ ] ; var i = 0 ; var x = 2 ; while ( i <= R ) { arr . push ( i + x ) ; if ( i + 1 <= R ) arr . push ( i + 1 + x ) ; x *= - 1 ; i += 2 ; } var sum = 0 ; for ( var i = L ; i <= R ; ++ i ) sum += arr [ i ] ; return sum ; }
function GetMinSubarrayLength ( a , n ) { var ans = Math . max ( a [ 0 ] , a [ n - 1 ] ) ; var lo = 0 , hi = n - 1 ; while ( lo < n && a [ lo ] % ans == 0 ) lo ++ ; while ( hi > lo && a [ hi ] % ans == 0 ) hi -- ; return ( hi - lo + 1 ) ; }
function count ( s ) { let N , i , cnt = 0 , ans = 0 ; N = s . length ; for ( i = 0 ; i < N ; i ++ ) { if ( s [ i ] == ' ' ) cnt ++ ; if ( s [ i ] == ' ' ) ans += cnt ; } return ans ; }
function minimumValue ( arr , n , k ) { arr . sort ( ( a , b ) => a - b ) ; let answer = 0 ; for ( let i = 0 ; i < k ; i ++ ) answer += arr [ i ] * arr [ i ] ; return answer * ( 2 * k - 2 ) ; }
function sumDivisibles ( A , B , M ) { var sum = 0 ; for ( var i = A ; i <= B ; i ++ ) if ( i % M == 0 ) sum += i ; return sum ; }
function distinctSubstring ( P , N ) { var S = new Set ( ) ; for ( var i = 0 ; i < N ; ++ i ) { var freq = Array ( 26 ) . fill ( false ) ; var s = " " ; for ( var j = i ; j < N ; ++ j ) { var pos = P [ j ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; if ( freq [ pos ] == true ) break ; freq [ pos ] = true ; s += P [ j ] ; S . add ( s ) ; } } return S . size ; }
function calcSum ( arr , n , k ) { for ( var i = 0 ; i <= n - k ; i ++ ) { var sum = 0 ; for ( var j = i ; j < k + i ; j ++ ) sum += arr [ j ] ; document . write ( sum + " " ) ; } }
function calcSum ( arr , n , k ) { var sum = 0 ; for ( var i = 0 ; i < k ; i ++ ) sum += arr [ i ] ; document . write ( sum + " " ) ; for ( var i = k ; i < n ; i ++ ) { sum = ( sum - arr [ i - k ] ) + arr [ i ] ; document . write ( sum + " " ) ; } }
function maxValue ( arr , n , moves ) { for ( var i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > 0 ) { var distance = n - 1 - i ; if ( moves < distance ) break ; var can_take = parseInt ( moves / distance ) ; var take = Math . min ( arr [ i ] , can_take ) ; arr [ n - 1 ] += take ; moves -= take * distance ; } } return arr [ n - 1 ] ; }
function findLCS ( arr , n ) { let mp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( mp . has ( arr [ i ] ) != 0 ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . set ( arr [ i ] , 1 ) ; } } return mp . size ; }
function countPairs ( arr , k , n ) { arr . sort ( ( a , b ) => a - b ) ; let pair = 0 ; let index = 0 ; while ( index < n - 1 ) { if ( arr [ index + 1 ] - arr [ index ] <= k ) { pair += 1 ; index += 2 ; } else { index += 1 ; } } return pair ; }
function minOperations ( n , m ) { var a = 0 , k = 1 ; var p = Math . max ( n , m ) ; while ( n != m ) { var s = ( p - n + p - m ) ; var q = ( ( - 1 + Math . sqrt ( 8 * s + 1 ) ) / 2 ) ; if ( q - Math . floor ( q ) == 0 ) { a = parseInt ( q ) ; n = m ; } p = p + 1 ; } return a ; }
function minCost ( cost , n ) { var totalCost = 0 ; var boardingBus = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( cost [ boardingBus ] > cost [ i ] ) { totalCost += ( ( i - boardingBus ) * cost [ boardingBus ] ) ; boardingBus = i ; } } totalCost += ( ( n - boardingBus ) * cost [ boardingBus ] ) ; return totalCost ; }
function k_sum ( a , n , k ) { let r = 0 , sum = 0 ; let ans = 0 ; for ( let l = 0 ; l < n ; l ++ ) { while ( sum < k ) { if ( r == n ) break ; else { sum += a [ r ] ; r ++ ; } } if ( sum < k ) break ; ans += n - r + 1 ; sum -= a [ l ] ; } return ans ; }
function minCapacity ( enter , exit , n ) { let minCap = 0 ; let currCap = 0 ; for ( let i = 0 ; i < n ; i ++ ) { currCap = currCap + enter [ i ] - exit [ i ] ; minCap = Math . max ( minCap , currCap ) ; } return minCap ; }
function Findpermutation ( n ) { let a = new Array ( n + 1 ) ; a [ 1 ] = n ; for ( let i = 2 ; i <= n ; i ++ ) a [ i ] = i - 1 ; return a ; }
function lexo_small ( n , k ) { var arr = Array . from ( { length : n } , ( _ , i ) => ' ' ) ; for ( var i = n - 1 ; i >= 0 ; i -- ) { k -= i ; if ( k >= 0 ) { if ( k >= 26 ) { arr [ i ] = ' ' ; k -= 26 ; } else { arr [ i ] = String . fromCharCode ( k + 97 - 1 ) ; k -= arr [ i ] - ' ' + 1 ; } } else break ; k += i ; } return arr ; }
function getMin ( arr , n ) { var minVal = Math . min . apply ( Math , arr ) ; return minVal ; }
function Substring ( s ) { var ans = 1 , temp = 1 ; for ( var i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { ++ temp ; } else { ans = Math . max ( ans , temp ) ; temp = 1 ; } } ans = Math . max ( ans , temp ) ; return ans ; }
function Balanced_Substring ( str , n ) { let ans = 0 ; let arr = new Array ( n / 2 + 1 ) . fill ( 0 ) ; let d = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) d ++ ; else { if ( d == 1 ) { for ( let j = 2 ; j <= parseInt ( n / 2 ) + 1 && arr [ j ] != 0 ; j ++ ) arr [ j ] = 0 ; } ++ ans ; ans += arr [ d ] ; arr [ d ] ++ ; d -- ; } } return ans ; }
function find_set ( n ) { if ( n <= 2 ) { document . write ( " " ) ; return ; } let sum1 = parseInt ( ( n * ( n - 1 ) ) / 2 , 10 ) ; let sum2 = n ; document . write ( sum1 + " " + sum2 + " " ) ; }
function longestSubarray ( arr , n ) { var maxMean = 0 ; for ( var i = 1 ; i < n ; i ++ ) maxMean = Math . max ( maxMean , parseInt ( ( arr [ i ] + arr [ i - 1 ] ) / 2 ) ) ; var ans = 0 ; var subarrayLength = 0 ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= maxMean ) ans = Math . max ( ans , ++ subarrayLength ) ; else subarrayLength = 0 ; return ans ; }
function CheckForSequence ( arr , n , k ) { for ( var i = n - 1 ; i >= 0 ; i -- ) { if ( k >= arr [ i ] ) k -= arr [ i ] ; } if ( k != 0 ) return false ; else return true ; }
function printMaxNumber ( n ) { if ( n & 1 ) { document . write ( " " ) ; for ( var i = 0 ; i < ( n - 3 ) / 2 ; i ++ ) document . write ( " " ) ; } else { for ( var i = 0 ; i < n / 2 ; i ++ ) document . write ( " " ) ; } }
function generateArray ( n , k ) { var array = Array ( k ) . fill ( 0 ) ; var remaining = n - parseInt ( k * ( k + 1 ) / 2 ) ; if ( remaining < 0 ) document . write ( " " ) ; var right_most = remaining % k ; var high = parseInt ( Math . ceil ( remaining / ( k * 1.0 ) ) ) ; var low = parseInt ( Math . floor ( remaining / ( k * 1.0 ) ) ) ; for ( i = k - right_most ; i < k ; i ++ ) array [ i ] = high ; for ( i = 0 ; i < ( k - right_most ) ; i ++ ) array [ i ] = low ; for ( i = 0 ; i < k ; i ++ ) array [ i ] += i + 1 ; if ( k - 1 != remaining k == 1 ) { for ( var u = 0 ; u < array . length ; u ++ ) document . write ( array [ u ] + " " ) ; } else if ( k == 2 k == 3 ) document . write ( " " ) ; else { array [ 1 ] -= 1 ; array [ k - 1 ] += 1 ; for ( var f = 0 ; f < array . length ; f ++ ) document . write ( array [ f ] + " " ) ; } }
function get_maximum ( s , a ) { let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) < a [ s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ) { let j = i ; while ( j < n && ( s [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) <= a [ s [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ) ) { s [ j ] = String . fromCharCode ( ' ' . charCodeAt ( ) + a [ s [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ) ; j ++ ; } return s . join ( " " ) ; } } return s . join ( " " ) ; }
function getSum ( n ) { let isOdd = ( n % 2 == 1 ) ? true : false ; let sumOdd = 0 , sumEven = 0 ; while ( n != 0 ) { if ( isOdd ) sumOdd += n % 10 ; else sumEven += n % 10 ; isOdd = ! isOdd ; n = Math . floor ( n / 10 ) ; } document . write ( " " + sumOdd + " " ) ; document . write ( " " + sumEven ) ; }
function getSum ( n ) { let sumOdd = 0 ; let sumEven = 0 ; let num = ( n ) . toString ( ) ; for ( let i = 0 ; i < num . length ; i ++ ) if ( i % 2 == 0 ) sumOdd = sumOdd + ( num [ i ] - ' ' ) ; else sumEven = sumEven + ( num [ i ] - ' ' ) ; document . write ( " " + sumOdd + " " ) ; document . write ( " " + sumEven + " " ) ; }
function bankNotes ( A , B , S , N ) { let numerator = S - ( B * N ) ; let denominator = A - B ; if ( numerator % denominator == 0 ) return ( Math . floor ( numerator / denominator ) ) ; return - 1 ; }
function countSteps ( n ) { let steps = 0 ; while ( n ) { let largest = Math . floor ( Math . sqrt ( n ) ) ; n -= ( largest * largest ) ; steps ++ ; } return steps ; }
function longestSubstring ( s ) { var cnt = 1 , maxi = 1 ; var n = s . length ; for ( i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i - 1 ) ) cnt ++ ; else { maxi = Math . max ( cnt , maxi ) ; cnt = 1 ; } } maxi = Math . max ( cnt , maxi ) ; return maxi ; }
function Minsteps ( n , m ) { let ans = 0 ; while ( m > n ) { if ( m & 1 ) { m ++ ; ans ++ ; } m = Math . floor ( m / 2 ) ; ans ++ ; } return ans + n - m ; }
function maxCandies ( arr , n ) { let prevBought = arr [ n - 1 ] ; let candies = prevBought ; for ( let i = n - 2 ; i >= 0 ; i -- ) { let x = Math . min ( prevBought - 1 , arr [ i ] ) ; if ( x >= 0 ) { candies += x ; prevBought = x ; } } return candies ; }
function Maxsum ( c1 , c2 , c3 , c4 ) { let sum = 0 ; let two34 = Math . min ( c2 , Math . min ( c3 , c4 ) ) ; sum = two34 * 234 ; c2 -= two34 ; sum += Math . min ( c2 , c1 ) * 12 ; return sum ; }
function maximumResult ( a , b , c ) { let countOfNegative = 0 ; let sum = a + b + c ; let product = a * b * c ; let largest = Math . max ( a , Math . max ( b , c ) ) ; let smallest = Math . min ( a , Math . min ( b , c ) ) ; if ( a < 0 ) countOfNegative ++ ; if ( b < 0 ) countOfNegative ++ ; if ( c < 0 ) countOfNegative ++ ; switch ( countOfNegative ) { case 0 : return ( sum - largest ) * largest ; case 1 : return ( product / smallest ) + smallest ; case 2 : return ( product / largest ) + largest ; case 3 : return ( sum - smallest ) * smallest ; } }
function findCountOfPairs ( a , b , n ) { let ans = 0 ; for ( let i = 1 ; i <= a ; i ++ ) { ans += parseInt ( b / n , 10 ) ; ans += ( i % n + b % n ) >= n ? 1 : 0 ; } return ans ; }
function findCountOfPairs ( a , b , n ) { let ans = 0 ; ans += n * parseInt ( a / n , 10 ) * parseInt ( b / n , 10 ) ans += parseInt ( a / n , 10 ) * parseInt ( b % n , 10 ) ; ans += parseInt ( a % n , 10 ) * parseInt ( b / n , 10 ) ; ans += parseInt ( ( ( a % n ) + ( b % n ) ) / n , 10 ) ; return ans ; }
function encryptString ( str , n ) { let i = 0 , cnt = 0 ; let encryptedStr = " " ; while ( i < n ) { cnt = i + 1 ; while ( cnt -- > 0 ) encryptedStr += str [ i ] ; i ++ ; } return encryptedStr ; }
function min_elimination ( n , arr ) { let count = 0 ; let prev_val = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { let curr_val = arr [ i ] ; if ( curr_val % 2 == prev_val % 2 ) count ++ ; prev_val = curr_val ; } return count ; }
function getCount ( N ) { if ( N % 2 == 1 ) return " " ; let result = " " ; for ( let i = 1 ; i <= N / 2 - 1 ; i ++ ) result += " " ; return result ; }
function findIntersection ( intervals , N ) { let l = intervals [ 0 ] [ 0 ] ; let r = intervals [ 0 ] [ 1 ] ; for ( let i = 1 ; i < N ; i ++ ) { if ( intervals [ i ] [ 0 ] > r intervals [ i ] [ 1 ] < l ) { document . write ( - 1 + " " ) ; return ; } else { l = Math . max ( l , intervals [ i ] [ 0 ] ) ; r = Math . min ( r , intervals [ i ] [ 1 ] ) ; } } document . write ( " " + l + " " + r + " " + " " ) ; }
function maxSubStrings ( s , k ) { var maxSubStr = 0 , n = s . length ; for ( var c = 0 ; c < 26 ; c ++ ) { var ch = String . fromCharCode ( " " . charCodeAt ( 0 ) + c ) ; var curr = 0 ; for ( var i = 0 ; i <= n - k ; i ++ ) { if ( s [ i ] !== ch ) continue ; var cnt = 0 ; while ( i < n && s [ i ] === ch && cnt !== k ) { i ++ ; cnt ++ ; } i -- ; if ( cnt === k ) curr ++ ; } maxSubStr = Math . max ( maxSubStr , curr ) ; } return maxSubStr ; }
function find_rectangle ( area ) { let l = 0 , b = 0 ; let M = Math . floor ( Math . sqrt ( area ) ) , ans ; for ( let i = M ; i >= 1 ; i -- ) { if ( area % i == 0 ) { l = Math . floor ( area / i ) ; b = i ; break ; } } document . write ( " " + l + " " + b ) ; }
function find_rectangle ( are ) { for ( let i = Math . floor ( Math . ceil ( Math . sqrt ( area ) ) ) ; i <= area ; i ++ ) { if ( Math . floor ( area / i ) * i == area ) { document . write ( i + " " + Math . floor ( area / i ) ) ; return ; } } }
function sizeSubSet ( a , k , n ) { a . sort ( function ( a , b ) { return a - b ; } ) ; let s = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] % k != 0 || s . get ( a [ i ] / k ) == null ) s . set ( a [ i ] , s . get ( a [ i ] ) == null ? 1 : s . get ( a [ i ] ) + 1 ) ; } return s . size ; }
function minimumSets ( s , y ) { let cnt = 0 ; let num = 0 ; let l = s . length ; let f = false ; for ( let i = 0 ; i < l ; i ++ ) { num = num * 10 + ( s [ i ] - ' ' ) ; if ( num <= y ) f = true ; { if ( f ) cnt += 1 ; num = s [ i ] - ' ' ; f = false ; if ( num <= y ) f = true ; else num = 0 ; } } if ( f == true ) cnt += 1 ; return cnt ; }
function minItems ( k , r ) { for ( let i = 1 ; i < 10 ; i ++ ) if ( ( i * k - r ) % 10 == 0 || ( i * k ) % 10 == 0 ) return i ; return 10 ; }
function check ( n , marks ) { let x = Math . max ( ... marks ) ; let bonus = 100 - x ; let c = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( marks [ i ] + bonus >= 50 ) c += 1 ; } return c ; }
function find_sum ( n , k ) { let total_sum = ( n * ( n + 1 ) ) / 2 ; let power = k ; while ( power <= n ) { total_sum -= power ; power *= k ; } return total_sum ; }
function maxLitres ( budget , plastic , glass , refund ) { if ( glass - refund < plastic ) { let ans = Math . max ( ( budget - refund ) / ( glass - refund ) , 0 ) ; budget -= ans * ( glass - refund ) ; ans += Math . floor ( budget / plastic ) ; document . write ( ans ) ; } else { document . write ( Math . floor ( budget / plastic ) ) ; } }
function minChanges ( A , n ) { var cnt = 0 ; for ( var i = 0 ; i < n - 2 ; ++ i ) { if ( ( i - 1 >= 0 ) && A [ i - 1 ] == 1 && A [ i + 1 ] == 1 && A [ i ] == 0 ) { A [ i + 1 ] = 0 ; cnt ++ ; } } return cnt ; }
function completeSequence ( s ) { let n = s . length ; let open = 0 , close = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' ) open ++ ; else close ++ ; if ( close > open ) { document . write ( " " ) ; return ; } } document . write ( s ) ; for ( let i = 0 ; i < open - close ; i ++ ) document . write ( " " ) ; }
function leastValue ( P , A , N , a ) { let ans = - 1 ; let tmp = Number . MAX_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { let t = ( P - a [ i ] * 0.006 ) ; if ( Math . abs ( t - A ) < tmp ) { tmp = Math . abs ( t - A ) ; ans = i ; } } return a [ ans ] ; }
function minInsertions ( H , n , K ) { var inser = 0 ; for ( var i = 1 ; i < n ; ++ i ) { var diff = Math . abs ( H [ i ] - H [ i - 1 ] ) ; if ( diff <= K ) continue ; else inser += Math . ceil ( diff / K ) - 1 ; } return inser ; }
function minCost ( N , P , Q ) { var cost = 0 ; while ( N > 0 ) { if ( N & 1 ) { cost += P ; N -- ; } else { var temp = parseInt ( N / 2 ) ; if ( temp * P > Q ) cost += Q ; else cost += P * temp ; N = parseInt ( N / 2 ) ; } } return cost ; }
function count_minimum_operations ( n ) { let count = 0 ; while ( n > 1 ) { if ( n % 3 == 0 ) n /= 3 ; else if ( n % 3 == 1 ) n -- ; else { if ( n == 2 ) n -- ; else n ++ ; } count ++ ; } return count ; }
function findPermutation ( n ) { let len = Math . ceil ( Math . log10 ( n ) ) ; for ( let i = 0 ; i < len ; i ++ ) { if ( n % 2 != 0 ) { return parseInt ( n ) ; } else { n = ( n / 10 ) + ( n % 10 ) * Math . pow ( 10 , len - i - 1 ) ; continue ; } } return - 1 ; }
function getMinCost ( arr , n ) { let min_ele = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { min_ele = Math . min ( min_ele , arr [ i ] ) ; } return min_ele * ( n - 1 ) ; }
function cal_minimum_time ( X ) { let t = 0 ; let sum = 0 ; while ( sum < X ) { t ++ ; sum = sum + t ; } return t ; }
function minDiff ( n , x , A ) { var mn = A [ 0 ] , mx = A [ 0 ] ; for ( var i = 0 ; i < n ; ++ i ) { mn = Math . min ( mn , A [ i ] ) ; mx = Math . max ( mx , A [ i ] ) ; } return Math . max ( 0 , mx - mn - 2 * x ) ; }
function maxSum ( a , n ) { let l = [ ] ; let s = 0 ; for ( let i = 0 ; i < n ; i ++ ) { s += Math . abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) continue ; if ( i == 0 ) l . push ( i + 1 ) ; else { l . push ( i + 1 ) ; l . push ( i ) ; } } document . write ( s + " " ) ; for ( let i = 0 ; i < l . length ; i ++ ) document . write ( l [ i ] + " " ) ; }
function CountPair ( L , R ) { let x = ( R - L + 1 ) ; document . write ( x / 2 + " " ) ; }
function problemsLeft ( K , P , N ) { if ( K <= P ) return 0 ; else return ( K - P ) * N ; }
function printCoins ( arr , n ) { var oddSum = 0 ; for ( var i = 0 ; i < n ; i += 2 ) oddSum += arr [ i ] ; var evenSum = 0 ; for ( var i = 1 ; i < n ; i += 2 ) evenSum += arr [ i ] ; var start = ( ( oddSum > evenSum ) ? 0 : 1 ) ; for ( var i = start ; i < n ; i += 2 ) document . write ( arr [ i ] + " " ) ; }
function countSubstrings ( s ) { let ans = 0 ; let subs = 1 ; let pre = ' ' ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( pre == s [ i ] ) { subs += 1 ; } else { subs = 1 ; } ans += subs ; pre = s [ i ] ; } document . write ( ans ) ; }
function results ( n , k ) { return parseInt ( Math . round ( Math . pow ( n , ( 1.0 / Math . pow ( 2.0 , k ) ) ) ) ) ; }
function smallestSumSubarr ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = - arr [ i ] ; let sum_here = arr [ 0 ] , max_sum = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { sum_here = Math . max ( sum_here + arr [ i ] , arr [ i ] ) ; max_sum = Math . max ( max_sum , sum_here ) ; } return ( - 1 ) * max_sum ; }
function printLargest ( a , n ) { let max = - 1 ; let ind = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { let num = a [ i ] ; while ( num > 0 ) { let r = num % 10 ; num = Math . floor ( num / 10 ) ; if ( num == 0 ) { if ( max < r ) { max = r ; ind = i ; } } } } for ( let i = ind ; i < n ; i ++ ) document . write ( a [ i ] ) ; for ( let i = 0 ; i < ind ; i ++ ) document . write ( a [ i ] ) ; }
function findMinimumAdjacentSwaps ( arr , N ) { let visited = Array ( N + 1 ) . fill ( false ) ; let minimumSwaps = 0 ; for ( let i = 0 ; i < 2 * N ; i ++ ) { if ( visited [ arr [ i ] ] == false ) { visited [ arr [ i ] ] = true ; let count = 0 ; for ( let j = i + 1 ; j < 2 * N ; j ++ ) { if ( visited [ arr [ j ] ] == false ) count ++ ; else if ( arr [ i ] == arr [ j ] ) minimumSwaps += count ; } } } return minimumSwaps ; }
function steps ( N , M ) { if ( N == 1 ) return 0 ; return M ; return 2 * M + ( N - 3 ) ; }
function DecreasingArray ( a , n ) { var sum = 0 , dif = 0 ; var pq = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { if ( pq . length != 0 && pq [ pq . length - 1 ] < a [ i ] ) { dif = a [ i ] - pq [ pq . length - 1 ] ; sum += dif ; pq . pop ( ) ; } pq . push ( a [ i ] ) ; pq . sort ( ( a , b ) => b - a ) ; } return sum ; }
function ifPossible ( arr , n ) { let copy = arr ; copy . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! ( arr [ i ] == copy [ i ] ) && ! ( arr [ n - 1 - i ] == copy [ i ] ) ) return false ; } return true ; }
function findMinRooms ( slots , n , m ) { let counts = Array ( m ) . fill ( 0 ) ; for ( let i = 0 ; i < m ; i ++ ) counts [ i ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < m ; j ++ ) if ( slots [ i ] [ j ] == ' ' ) counts [ j ] ++ ; let max = - 1 ; for ( let i = 0 ; i < m ; i ++ ) if ( max < counts [ i ] ) max = counts [ i ] ; return max ; }
function MinOperation ( a , n , k ) { let result = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( a [ i ] != 1 && a [ i ] > k ) { result = result + Math . min ( a [ i ] % k , k - a [ i ] % k ) ; } else { result = result + k - a [ i ] ; } } return result ; }
function survival ( S , N , M ) { if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) M > N ) document . write ( " " ) ; else { let days = ( M * S ) / N ; if ( ( ( M * S ) % N ) != 0 ) days ++ ; document . write ( " " + Math . round ( days ) ) ; } }
function digitsNum ( N ) { if ( N == 0 ) document . write ( " " ) ; if ( N % 9 != 0 ) document . write ( N % 9 ) ; for ( var i = 1 ; i <= N / 9 ; ++ i ) document . write ( " " ) ; for ( var i = 1 ; i <= N ; ++ i ) document . write ( " " ) ; document . write ( " " ) ; }
function noAdjacentDup ( s1 ) { let n = s1 . length ; let s = s1 . split ( ' ' ) ; for ( let i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { s [ i ] = ' ' ; while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] ++ ; i ++ ; } } return ( s ) ; }
function cost ( a , n ) { let min = a [ 0 ] ; for ( let i = 1 ; i < a . length ; i ++ ) { if ( a [ i ] < min ) min = a [ i ] ; } return ( n - 1 ) * min ; }
function maxDifference ( arr , N , k ) { let M , S = 0 , S1 = 0 , max_difference = 0 ; for ( let i = 0 ; i < N ; i ++ ) S += arr [ i ] ; let temp ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } M = Math . max ( k , N - k ) ; for ( let i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; }
function winner ( a , n , k ) { if ( k >= n - 1 ) return n ; let best = 0 , times = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) { best = a [ i ] ; if ( i ) times = 1 ; } else times += 1 ; if ( times >= k ) return best ; } return best ; }
function minproduct ( a , b , n , k ) { let diff = 0 , res = 0 ; let temp = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let pro = a [ i ] * b [ i ] ; res = res + pro ; if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; let d = Math . abs ( pro - temp ) ; if ( d > diff ) diff = d ; } return res - diff ; }
function minSum ( A , n ) { let min_val = Math . min ( ... A ) ; return ( min_val * ( n - 1 ) ) ; }
function minRotation ( input , unlock_code ) { let rotation = 0 ; let input_digit , code_digit ; while ( input > 0 unlock_code > 0 ) { input_digit = input % 10 ; code_digit = unlock_code % 10 ; rotation += Math . min ( Math . abs ( input_digit - code_digit ) , 10 - Math . abs ( input_digit - code_digit ) ) ; input = Math . floor ( input / 10 ) ; unlock_code = Math . floor ( unlock_code / 10 ) ; } return rotation ; }
function minCost ( coin , n , k ) { coin . sort ( function ( a , b ) { return a - b } ) var coins_needed = Math . ceil ( n / ( k + 1 ) ) ; var ans = 0 ; for ( var i = 0 ; i <= coins_needed - 1 ; i ++ ) ans += coin [ i ] ; return ans ; }
function minimumCostOfBreaking ( X , Y , m , n ) { let res = 0 ; X . sort ( ) ; X . reverse ( ) ; Y . sort ( ) ; Y . reverse ( ) ; let hzntl = 1 , vert = 1 ; let i = 0 , j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ; vert ++ ; j ++ ; } } let total = 0 ; while ( i < m ) total += X [ i ++ ] ; res += total * vert ; total = 0 ; while ( j < n ) total += Y [ j ++ ] ; res += total * hzntl ; return res ; }
function maximumSum ( arr , n , k ) { for ( let i = 1 ; i <= k ; i ++ ) { let min = + 2147483647 ; let index = - 1 ; for ( let j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < min ) { min = arr [ j ] ; index = j ; } } if ( min == 0 ) break ; arr [ index ] = - arr [ index ] ; } let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
function maxDiffSum ( arr , n ) { let dp = new Array ( n ) . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { let maxVal = arr [ i ] , minVal = arr [ i ] ; for ( let j = i ; j >= 0 ; j -- ) { minVal = Math . min ( minVal , arr [ j ] ) ; maxVal = Math . max ( maxVal , arr [ j ] ) ; if ( j - 1 >= 0 ) dp [ i ] = Math . max ( dp [ i ] , maxVal - minVal + dp [ j - 1 ] ) ; else dp [ i ] = Math . max ( dp [ i ] , maxVal - minVal ) ; } } return dp [ n - 1 ] ; }
function LongestOddEvenSubarray ( A , N ) { let dp = new Array ( N ) ; dp [ 0 ] = 1 ; let ans = 1 ; for ( let i = 1 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 == 0 && A [ i - 1 ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ i - 1 ] % 2 != 0 ) ) { dp [ i ] = dp [ i - 1 ] + 1 ; } else dp [ i ] = 1 ; } for ( let i = 0 ; i < N ; i ++ ) ans = Math . max ( ans , dp [ i ] ) ; return ans ; }
function LongestOddEvenSubarray ( A , N ) { let dp ; dp = 1 ; let ans = 1 ; for ( let i = 1 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 == 0 && A [ i - 1 ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ i - 1 ] % 2 != 0 ) ) { dp = dp + 1 ; ans = Math . max ( ans , dp ) ; } else dp = 1 ; } return ans ; }
function countStrings ( N ) { if ( N == 1 ) return 0 ; if ( dp . has ( N ) ) return dp . get ( N ) ; let ret = 0 ; for ( let div = 1 ; div <= Math . sqrt ( N ) ; div ++ ) { if ( N % div == 0 ) { ret += ( 1 << div ) - countStrings ( div ) ; let div2 = N / div ; if ( div2 != div && div != 1 ) ret += ( 1 << div2 ) - countStrings ( div2 ) ; } } dp [ N ] = ret ; return ret ; }
function countOfNumbers ( N ) { let ans = 1 ; for ( let index = 1 ; index <= N ; ++ index ) { let choices = 0 ; for ( let digit = 1 ; digit <= 9 ; ++ digit ) { if ( index % digit == 0 ) { ++ choices ; } } ans = ( ans * 1 * choices ) % mod ; } document . write ( ans ) ; }
function MaxProfit ( arr , n , transactionFee ) { let buy = - arr [ 0 ] ; let sell = 0 ; for ( let i = 1 ; i < n ; i ++ ) { let temp = buy ; buy = Math . max ( buy , sell - arr [ i ] ) ; sell = Math . max ( sell , temp + arr [ i ] - transactionFee ) ; } return Math . max ( sell , buy ) ; }
function MaximumSum ( a , b , n ) { let dp = new Array ( n ) . fill ( 0 ) . map ( ( ) => new Array ( 2 ) ) ; dp [ 0 ] [ 0 ] = a [ 0 ] ; dp [ 0 ] [ 1 ] = b [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + a [ i ] ; dp [ i ] [ 1 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) ; if ( i - 2 >= 0 ) { dp [ i ] [ 1 ] = Math . max ( dp [ i ] [ 1 ] , Math . max ( dp [ i - 2 ] [ 0 ] , dp [ i - 2 ] [ 1 ] ) + b [ i ] ) ; } else { dp [ i ] [ 1 ] = Math . max ( dp [ i ] [ 1 ] , b [ i ] ) ; } } return Math . max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) ; }
function waysOfDecoding ( s ) { let dp = new Array ( s . length + 1 ) ; for ( let i = 0 ; i < s . length + 1 ; i ++ ) dp [ i ] = 0 ; dp [ 0 ] = 1 ; dp [ 1 ] = s [ 0 ] == ' ' ? 9 : s [ 0 ] == ' ' ? 0 : 1 ; for ( let i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] == ' ' ) { dp [ i + 1 ] = 9 * dp [ i ] ; if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 9 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 6 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 15 * dp [ i - 1 ] ) % M ; } else { dp [ i + 1 ] = s [ i ] != ' ' ? dp [ i ] : 0 ; if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' ' && s [ i ] <= ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + ( s [ i ] <= ' ' ? 2 : 1 ) * dp [ i - 1 ] ) % M ; } } return dp [ s . length ] ; }
function KvisibleFromLeft ( N , K ) { if ( N == K ) return 1 ; if ( K == 1 ) { let ans = 1 ; for ( let i = 1 ; i < N ; i ++ ) ans *= i ; return ans ; } return KvisibleFromLeft ( N - 1 , K - 1 ) + ( N - 1 ) * KvisibleFromLeft ( N - 1 , K ) ; }
function KvisibleFromLeft ( N , K ) { if ( dp [ N ] [ K ] != - 1 ) return dp [ N ] [ K ] ; if ( N == K ) return dp [ N ] [ K ] = 1 ; if ( K == 1 ) { let ans = 1 ; for ( let i = 1 ; i < N ; i ++ ) ans *= i ; return dp [ N ] [ K ] = ans ; } return dp [ N ] [ K ] = KvisibleFromLeft ( N - 1 , K - 1 ) + ( N - 1 ) * KvisibleFromLeft ( N - 1 , K ) ; }
function maximumSum ( A , N , K , D ) { let ans = 0 ; for ( let i = 0 ; i < ( 1 << N ) ; i ++ ) { let sum = 0 ; let c = 0 ; for ( let j = 0 ; j < N ; j ++ ) { if ( i >> j & 1 ) { sum += A [ j ] ; c ++ ; } } if ( sum % D == 0 && c <= K ) ans = Math . max ( ans , sum ) ; } return ans ; }
function maxSumWO3Consec ( A , N ) { if ( N == 1 ) return A [ 0 ] ; if ( N == 2 ) return A [ 0 ] + A [ 1 ] ; let third = A [ 0 ] ; let second = third + A [ 1 ] ; let first = Math . max ( second , A [ 1 ] + A [ 2 ] ) ; let sum = Math . max ( Math . max ( third , second ) , first ) ; for ( let i = 3 ; i < N ; i ++ ) { sum = Math . max ( Math . max ( first , second + A [ i ] ) , third + A [ i ] + A [ i - 1 ] ) ; third = second ; second = first ; first = sum ; } return sum ; }
function longestSubSequence ( A , N ) { let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = 1 ; for ( let j = 0 ; j < i ; j ++ ) { if ( A [ j ] [ 0 ] < A [ i ] [ 0 ] && A [ j ] [ 1 ] > A [ i ] [ 1 ] ) { dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } } } document . write ( dp [ N - 1 ] + " " ) ; }
function countSubset ( arr , n , diff ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } sum += diff ; sum = sum / 2 ; var t = new Array ( n + 1 ) ; for ( var i = 0 ; i < t . length ; i ++ ) { t [ i ] = new Array ( sum + 1 ) ; } for ( var i = 0 ; i < t . length ; i ++ ) { for ( var j = 0 ; j < t [ i ] . length ; j ++ ) { t [ i ] [ j ] = 0 ; } } for ( var j = 0 ; j <= sum ; j ++ ) t [ 0 ] [ j ] = 0 ; for ( var i = 0 ; i <= n ; i ++ ) t [ i ] [ 0 ] = 1 ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 1 ; j <= sum ; j ++ ) { if ( arr [ i - 1 ] > j ) t [ i ] [ j ] = t [ i - 1 ] [ j ] ; else { t [ i ] [ j ] = t [ i - 1 ] [ j ] + t [ i - 1 ] [ j - arr [ i - 1 ] ] ; } } } return t [ n ] [ sum ] ; }
function countSortedArrays ( start , m , size , n ) { if ( size === m ) return 1 ; if ( start > n ) return 0 ; var notTaken = 0 , taken = 0 ; taken = countSortedArrays ( start , m , size + 1 , n ) ; notTaken = countSortedArrays ( start + 1 , m , size , n ) ; return taken + notTaken ; }
function findMinCost ( arr , X , n , i = 0 ) { if ( X <= 0 ) return 0 ; if ( i >= n ) return Number . MAX_SAFE_INTEGER ; let inc = findMinCost ( arr , X - arr [ i ] [ 0 ] , n , i + 1 ) ; if ( inc != Number . MAX_SAFE_INTEGER ) inc += arr [ i ] [ 1 ] ; let exc = findMinCost ( arr , X , n , i + 1 ) ; return Math . min ( inc , exc ) ; }
function NumberOfways ( N , K ) { let dp = Array . from ( { length : N + 1 } , ( _ , i ) => 0 ) ; dp [ 0 ] = 1 ; for ( let row = 1 ; row < K + 1 ; row ++ ) { for ( let col = 1 ; col < N + 1 ; col ++ ) { if ( col >= row ) dp [ col ] = dp [ col ] + dp [ col - row ] ; } } return ( dp [ N ] ) ; }
function MaxSubsetlength ( arr , A , B ) { var dp = Array . from ( Array ( A + 1 ) , ( ) => Array ( B + 1 ) . fill ( 0 ) ) ; arr . forEach ( str => { var zeros = [ ... str ] . filter ( x => x == ' ' ) . length ; var ones = [ ... str ] . filter ( x => x == ' ' ) . length ; for ( var i = A ; i >= zeros ; i -- ) for ( var j = B ; j >= ones ; j -- ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - zeros ] [ j - ones ] + 1 ) ; } ) ; return dp [ A ] [ B ] ; }
function getValue ( arr , N ) { let dp = Array . from ( { length : N } , ( _ , i ) => 0 ) ; dp [ 0 ] = 0 ; for ( let i = 1 ; i < N ; i ++ ) { let min = arr [ i ] ; let max = arr [ i ] ; for ( let j = i ; j >= 0 ; j -- ) { min = Math . min ( arr [ j ] , min ) ; max = Math . max ( arr [ j ] , max ) ; dp [ i ] = Math . max ( dp [ i ] , max - min + ( ( j >= 1 ) ? dp [ j - 1 ] : 0 ) ) ; } } return dp [ N - 1 ] ; }
function maxScore ( s , a ) { if ( dp . has ( s ) ) return dp . get ( s ) ; let n = s . length ; if ( n == 0 ) return 0 ; if ( n == 1 ) return a [ 0 ] ; let head = 0 ; let mx = - 1 ; while ( head < n ) { let tail = head ; while ( tail < n ) { if ( s [ tail ] != s [ head ] ) { head = tail ; break ; } let sub = s . substring ( head , head + tail + 1 ) ; mx = Math . max ( mx , a [ sub . length - 1 ] + maxScore ( s . substring ( 0 , head ) + s . substring ( tail + 1 , tail + 1 + s . length ) , a ) ) ; tail += 1 ; } if ( tail == n ) break ; } dp . set ( s , mx ) ; return mx ; }
function numberOfUniqueOutcomes ( N , S ) { if ( S < N ) return 0 ; if ( N == 1 N == S ) return 1 ; return ( numberOfUniqueOutcomes ( N - 1 , S - 1 ) + numberOfUniqueOutcomes ( N - 1 , S - 2 ) ) ; }
function numOfWays ( a , n , i , blue ) { if ( i == n ) return 1 ; let count = 0 ; for ( let j = 0 ; j < n ; j ++ ) { if ( a [ i ] [ j ] == 1 && ! blue . has ( j ) ) { blue . add ( j ) ; count += numOfWays ( a , n , i + 1 , blue ) ; blue . delete ( j ) ; } } return count ; }
function waysToPaint ( n ) { var same = 6 ; var diff = 6 ; for ( var i = 0 ; i < n - 1 ; i ++ ) { var sameTmp = 3 * same + 2 * diff ; var diffTmp = 2 * same + 2 * diff ; same = sameTmp ; diff = diffTmp ; } document . write ( same + diff ) ; }
function find ( A , B , C , N ) { let arr = new Array ( N ) . fill ( 0 ) ; arr [ 0 ] = A ; arr [ 1 ] = B ; arr [ 2 ] = C ; for ( let i = 3 ; i < N ; i ++ ) { arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] + arr [ i - 3 ] ; } return arr [ N - 1 ] ; }
function minCost ( arr , n ) { if ( n < 3 ) { document . write ( arr [ 0 ] ) ; return ; } let dp = [ ] ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = dp [ 0 ] + arr [ 1 ] + arr [ 2 ] ; for ( let i = 2 ; i < n - 1 ; i ++ ) dp [ i ] = Math . min ( dp [ i - 2 ] + arr [ i ] , dp [ i - 1 ] + arr [ i ] + arr [ i + 1 ] ) ; dp [ n - 1 ] = Math . min ( dp [ n - 2 ] , dp [ n - 3 ] + arr [ n - 1 ] ) ; document . write ( dp [ n - 1 ] ) ; }
function maxSubmatrixSum ( matrix ) { var r = matrix . length ; var c = matrix [ 0 ] . length ; var maxSubmatrix = 0 ; for ( i = 0 ; i < r ; i ++ ) { for ( j = 0 ; j < c ; j ++ ) { for ( k = i ; k < r ; k ++ ) { for ( l = j ; l < c ; l ++ ) { var sumSubmatrix = 0 ; for ( m = i ; m <= k ; m ++ ) { for ( n = j ; n <= l ; n ++ ) { sumSubmatrix += matrix [ m ] [ n ] ; } } maxSubmatrix = Math . max ( maxSubmatrix , sumSubmatrix ) ; } } } } document . write ( maxSubmatrix ) ; }
function minCost ( costs , N ) { if ( N == 0 ) return 0 ; let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( 3 ) ; for ( let j = 0 ; j < 3 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = costs [ 0 ] [ 0 ] ; dp [ 0 ] [ 1 ] = costs [ 0 ] [ 1 ] ; dp [ 0 ] [ 2 ] = costs [ 0 ] [ 2 ] ; for ( let i = 1 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = Math . min ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 0 ] ; dp [ i ] [ 1 ] = Math . min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 1 ] ; dp [ i ] [ 2 ] = Math . min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + costs [ i ] [ 2 ] ; } document . write ( Math . min ( dp [ N - 1 ] [ 0 ] , Math . min ( dp [ N - 1 ] [ 1 ] , dp [ N - 1 ] [ 2 ] ) ) ) ; }
function FindMaxS ( X , Y , Z , n , A , B , C ) { if ( X < 0 Y < 0 Z < 0 ) return - 1000000000 ; if ( n < 0 ) return 0 ; var ch = A [ n ] + FindMaxS ( X - 1 , Y , Z , n - 1 , A , B , C ) ; var ca = B [ n ] + FindMaxS ( X , Y - 1 , Z , n - 1 , A , B , C ) ; var co = C [ n ] + FindMaxS ( X , Y , Z - 1 , n - 1 , A , B , C ) ; var no = FindMaxS ( X , Y , Z , n - 1 , A , B , C ) ; var maximum = Math . max ( ch , Math . max ( ca , Math . max ( co , no ) ) ) ; return maximum ; }
function FindMaxS ( X , Y , Z , n , A , B , C ) { if ( X < 0 Y < 0 Z < 0 ) return Number . MIN_VALUE ; if ( n < 0 ) return 0 ; if ( dp [ n ] [ X ] [ Y ] [ Z ] != - 1 ) { return dp [ n ] [ X ] [ Y ] [ Z ] ; } let ch = A [ n ] + FindMaxS ( X - 1 , Y , Z , n - 1 , A , B , C ) ; let ca = B [ n ] + FindMaxS ( X , Y - 1 , Z , n - 1 , A , B , C ) ; let co = C [ n ] + FindMaxS ( X , Y , Z - 1 , n - 1 , A , B , C ) ; let no = FindMaxS ( X , Y , Z , n - 1 , A , B , C ) ; let maximum = Math . max ( ch , Math . max ( ca , Math . max ( co , no ) ) ) ; dp [ n ] [ X ] [ Y ] [ Z ] = maximum ; return dp [ n ] [ X ] [ Y ] [ Z ] ; } let X = 1 ; let Y = 1 ; let Z = 1 ; let A = [ 10 , 0 , 5 ] ; let B = [ 5 , 10 , 0 ] ; let C = [ 0 , 5 , 10 ] ; let n = B . length ; for ( let i = 0 ; i < 50 ; i ++ ) { dp [ i ] = new Array ( 50 ) ; for ( let j = 0 ; j < 50 ; j ++ ) { dp [ i ] [ j ] = new Array ( 50 ) ; for ( let k = 0 ; k < 50 ; k ++ ) { dp [ i ] [ j ] [ k ] = new Array ( 50 ) ; for ( let l = 0 ; l < 50 ; l ++ ) { dp [ i ] [ j ] [ k ] [ l ] = - 1 ; } } } }
function find ( N , sum ) { if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } let s = 0 ; for ( let i = 1 ; i <= 6 ; i ++ ) s = s + find ( N - 1 , sum - i ) / 6 ; return s ; }
function find ( N , sum ) { if ( N < 0 sum < 0 ) return 0 ; if ( dp [ N ] [ sum ] > 0 ) return dp [ N ] [ sum ] ; if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return ( 1.0 / 6 ) ; else return 0 ; } for ( var i = 1 ; i <= 6 ; i ++ ) dp [ N ] [ sum ] = dp [ N ] [ sum ] + find ( N - 1 , sum - i ) / 6 ; return dp [ N ] [ sum ] ; }
function find ( N , a , b ) { let probability = 0.0 ; for ( let i = 1 ; i <= 6 ; i ++ ) dp [ 1 ] [ i ] = ( 1.0 / 6 ) ; for ( let i = 2 ; i <= N ; i ++ ) { for ( let j = i ; j <= 6 * i ; j ++ ) { for ( let k = 1 ; k <= 6 && k <= j ; k ++ ) { dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - k ] / 6 ; } } } for ( let sum = a ; sum <= b ; sum ++ ) probability = probability + dp [ N ] [ sum ] ; return probability ; }
function minAtEachIndex ( n , arr ) { var dp1 = Array ( n ) ; var dp2 = Array ( n ) ; var i ; dp1 [ 0 ] = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) dp1 [ i ] = Math . min ( arr [ i ] , dp1 [ i - 1 ] + 1 ) ; dp2 [ n - 1 ] = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) dp2 [ i ] = Math . min ( arr [ i ] , dp2 [ i + 1 ] + 1 ) ; var v = [ ] ; for ( i = 0 ; i < n ; i ++ ) v . push ( Math . min ( dp1 [ i ] , dp2 [ i ] ) ) ; v . forEach ( x => { document . write ( x + " " ) ; } ) ; }
function totalArrays ( N , M ) { var end_with_one = Array ( N + 1 ) ; var end_not_with_one = Array ( N + 1 ) ; end_with_one [ 0 ] = 1 ; end_not_with_one [ 0 ] = 0 ; end_with_one [ 1 ] = 0 ; end_not_with_one [ 1 ] = M - 1 ; for ( var i = 2 ; i < N ; i ++ ) { end_with_one [ i ] = end_not_with_one [ i - 1 ] ; end_not_with_one [ i ] = end_with_one [ i - 1 ] * ( M - 1 ) + end_not_with_one [ i - 1 ] * ( M - 2 ) ; } return end_with_one [ N - 1 ] ; }
function countTriplets ( A ) { var cnt = 0 ; var tuples = new Map ( ) ; A . forEach ( a => { A . forEach ( b => { if ( tuples . has ( a & b ) ) tuples . set ( a & b , tuples . get ( a & b ) + 1 ) else tuples . set ( a & b , 1 ) } ) ; } ) ; A . forEach ( a => { tuples . forEach ( ( value , key ) => { if ( ( key & a ) == 0 ) cnt += value ; } ) ; } ) ; return cnt ; }
function countWaysToTileBoard ( N ) { let dp = [ ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; for ( let i = 2 ; i <= N ; i ++ ) { dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 2 ] ) ; } document . write ( dp [ N ] ) ; }
function FindSub ( str , res , i ) { if ( i === str . length ) { if ( res . length > 0 ) { document . write ( res + " " ) ; } return ; } var ch = str [ i ] ; FindSub ( str , res , i + 1 ) ; FindSub ( str , res + ch , i + 1 ) ; FindSub ( str , res + ch . charCodeAt ( 0 ) , i + 1 ) ; }
function MinOp ( N ) { if ( N <= 1 ) return N ; let bit = ( Math . log ( N ) / Math . log ( 2 ) ) + 1 ; return ( ( 1 << bit ) - 1 ) - MinOp ( N - ( 1 << ( bit - 1 ) ) ) ; }
function findNumberOfStrings ( n ) { let DP = new Array ( n + 1 ) ; for ( var i = 0 ; i < DP . length ; i ++ ) { DP [ i ] = new Array ( 2 ) ; } for ( var i = 0 ; i < DP . length ; i ++ ) { for ( var j = 0 ; j < DP . length ; j ++ ) { DP [ i ] [ j ] = 0 ; } } DP [ 1 ] [ 1 ] = 1 ; for ( let i = 1 ; i < n + 1 ; i ++ ) { for ( let j = 1 ; j < 6 ; j ++ ) { if ( i == 1 ) { DP [ i ] [ j ] = DP [ i ] [ j - 1 ] + 1 ; } else { DP [ i ] [ j ] = DP [ i ] [ j - 1 ] + DP [ i - 1 ] [ j ] ; } } } return DP [ n ] [ 5 ] ; }
function findNumberOfStrings ( n ) { return ( n + 1 ) * ( n + 2 ) * ( n + 3 ) * ( n + 4 ) / 24 ; }
function maxSum ( arr , n ) { var r1 = 0 , r2 = 0 ; for ( i = 0 ; i < n ; i ++ ) { var temp = r1 ; r1 = Math . max ( r1 , r2 + arr [ 0 ] [ i ] ) ; r2 = Math . max ( r2 , temp + arr [ 1 ] [ i ] ) ; } document . write ( Math . max ( r1 , r2 ) ) ; }
function numberOfPermWithKInversion ( N , K ) { let dp = new Array ( 2 ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } let mod = 1000000007 ; for ( let i = 1 ; i <= N ; i ++ ) { for ( let j = 0 ; j <= K ; j ++ ) { if ( i == 1 ) { dp [ i % 2 ] [ j ] = ( j == 0 ) ? 1 : 0 ; } else if ( j == 0 ) dp [ i % 2 ] [ j ] = 1 ; else dp [ i % 2 ] [ j ] = ( dp [ i % 2 ] [ j - 1 ] % mod + ( dp [ 1 - i % 2 ] [ j ] - ( ( Math . max ( j - ( i - 1 ) , 0 ) == 0 ) ? 0 : dp [ 1 - i % 2 ] [ Math . max ( j - ( i - 1 ) , 0 ) - 1 ] ) + mod ) % mod ) % mod ; } } document . write ( dp [ N % 2 ] [ K ] ) ; }
function maxScore ( arr ) { var N = arr . length ; N ++ ; var dp = Array . from ( Array ( N + 1 ) , ( ) => Array ( 2 * N ) . fill ( - 10000000 ) ) ; dp [ 0 ] [ 0 ] = 0 ; for ( var i = 1 ; i <= N ; i ++ ) { for ( var s = 1 ; s <= 2 * ( N - 1 ) ; s ++ ) { for ( var j = 1 ; j <= N - 1 && j <= s ; j ++ ) { dp [ i ] [ s ] = Math . max ( dp [ i ] [ s ] , arr [ j - 1 ] + dp [ i - 1 ] [ s - j ] ) ; } } } return dp [ N ] [ 2 * ( N - 1 ) ] ; }
function minimumCost ( cost , n , x ) { let dp = [ ] ; dp [ 0 ] = cost [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( i == 1 ) dp [ i ] = cost [ i ] + dp [ i - 1 ] ; if ( i == 2 ) dp [ i ] = cost [ i ] + Math . min ( dp [ i - 1 ] , x + dp [ i - 2 ] ) ; if ( i >= 3 ) dp [ i ] = cost [ i ] + Math . min ( dp [ i - 1 ] , Math . min ( x + dp [ i - 2 ] , 2 * x + dp [ i - 3 ] ) ) ; } document . write ( dp [ n - 1 ] ) ; }
function maxSum ( a , n , k ) { if ( n <= 0 ) return 0 ; let option = maxSum ( a , n - 1 , k ) ; if ( k >= a [ n - 1 ] ) option = Math . max ( option , a [ n - 1 ] + maxSum ( a , n - 2 , k - a [ n - 1 ] ) ) ; return option ; }
function maxCount ( arr , m , V ) { let table = [ ] ; table [ 0 ] = 0 ; for ( let i = 1 ; i <= V ; i ++ ) table [ i ] = - 1 ; for ( let i = 1 ; i <= V ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { if ( arr [ j ] <= i ) { let sub_res = table [ i - arr [ j ] ] ; if ( sub_res != - 1 && sub_res + 1 > table [ i ] ) table [ i ] = sub_res + 1 ; } } } return table [ V ] ; }
function longestPalSubstr ( str ) { var n = str . length ; var maxLength = 1 , start = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { for ( var j = i ; j < str . length ; j ++ ) { var flag = 1 ; for ( var k = 0 ; k < ( j - i + 1 ) / 2 ; k ++ ) if ( str [ i + k ] != str [ j - k ] ) flag = 0 ; if ( flag && ( j - i + 1 ) > maxLength ) { start = i ; maxLength = j - i + 1 ; } } } return maxLength ; }
function lastRemaining ( n , dp ) { if ( dp . hasOwnProperty ( n ) ) return dp [ n ] ; if ( n === 1 ) return 1 ; else dp [ n ] = 2 * ( 1 + parseInt ( n / 2 ) - lastRemaining ( parseInt ( n / 2 ) , dp ) ) ; return dp [ n ] ; } var N = 5 ; var dp = { }
function findWays ( N ) { let dp = new Array ( N + 1 ) ; dp [ 0 ] = 1 ; for ( let i = 1 ; i <= N ; i ++ ) { dp [ i ] = 0 ; for ( let j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 ) { dp [ i ] = dp [ i ] + dp [ i - j ] ; } } } document . write ( dp [ N ] ) ; }
function FindNoOfFullVessels ( n , t ) { var Matrix = Array . from ( Array ( n ) , ( ) => Array ( n ) . fill ( 0 ) ) ; Matrix [ 0 ] [ 0 ] = t * 1.0 ; var ans = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j <= i ; j ++ ) { var exceededwater = Matrix [ i ] [ j ] - 1 ; if ( exceededwater < 0 ) continue ; ans ++ ; if ( i + 1 < n ) Matrix [ i + 1 ] [ j ] += ( exceededwater / 2 ) ; if ( i + 1 < n && j + 1 < n ) Matrix [ i + 1 ] [ j + 1 ] += ( exceededwater / 2 ) ; } } return ans ; }
function minSteps ( m , n ) { if ( n == m ) return 0 ; if ( m > n ) return inf ; let min_cost = inf ; for ( let i = 2 ; i < m ; i += 2 ) { if ( m % i == 0 ) { min_cost = Math . min ( min_cost , m / i + minSteps ( m + i , n ) ) ; } } return min_cost ; }
function minCountOfNumbers ( N ) { let k = N % 10 ; let z = N - ( 9 * ( 9 - k ) ) ; if ( z >= 9 && z % 10 == 9 ) { return 10 - k ; } else { return - 1 ; } }
function solve ( a ) { let n = a . length ; let dp = new Array ( n + 1 ) . fill ( 0 ) ; let val = new Array ( n + 1 ) . fill ( 0 ) ; for ( let i = n - 1 ; i >= 0 ; i -- ) { let sum = a [ i ] ; let j = i ; while ( j + 1 < n && sum < val [ j + 1 ] ) { j ++ ; sum += a [ j ] ; } dp [ i ] = ( j - i ) + dp [ j + 1 ] ; val [ i ] = sum ; } return dp [ 0 ] ; }
function minDays ( n ) { if ( n < 1 ) return n ; var cnt = 1 + Math . min ( n % 2 + minDays ( parseInt ( n / 2 ) ) , n % 3 + minDays ( parseInt ( n / 3 ) ) ) ; return cnt ; }
function count ( n ) { var dp = new Map ( ) ; dp . set ( 0 , 0 ) ; dp . set ( 1 , 1 ) ; if ( ! dp . has ( n ) ) dp . set ( n , 1 + Math . min ( n % 2 + count ( parseInt ( n / 2 ) ) , n % 3 + count ( parseInt ( n / 3 ) ) ) ) ; return dp . get ( n ) ; }
function maxValue ( a , n , pos , moves , left , dp ) { if ( moves == 0 || ( pos > n - 1 pos < 0 ) ) return 0 ; if ( dp [ pos ] [ left ] != - 1 ) return dp [ pos ] [ left ] ; let value = 0 ; if ( left > 0 && pos >= 1 ) value = Math . max ( value , a [ pos ] + maxValue ( a , n , pos - 1 , moves - 1 , left - 1 , dp ) ) ; if ( pos <= n - 1 ) value = Math . max ( value , a [ pos ] + maxValue ( a , n , pos + 1 , moves - 1 , left , dp ) ) ; return dp [ pos ] [ left ] = value ; } let n = 5 ; let a = [ 1 , 5 , 4 , 3 , 2 ] ; let k = 1 ; let m = 4 ; let dp = new Array ( n + 1 ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } for ( var i = 0 ; i < dp . length ; i ++ ) { for ( var j = 0 ; j < dp . length ; j ++ ) { dp [ i ] [ j ] = - 1 ; } }
function maximumSum ( a , count , index , n , dp ) { if ( index == n ) return 0 ; if ( dp [ index ] [ count ] != - 1 ) return dp [ index ] [ count ] ; var take_element = a [ index ] * count + maximumSum ( a , count + 1 , index + 1 , n , dp ) ; var dont_take = maximumSum ( a , count , index + 1 , n , dp ) ; return dp [ index ] [ count ] = Math . max ( take_element , dont_take ) ; }
function countNums ( N ) { let l = Math . floor ( Math . pow ( 10 , N - 1 ) ) ; let r = Math . floor ( Math . pow ( 10 , N ) ) - 1 ; let count = 0 ; for ( let i = l ; i <= r ; i ++ ) { let xorr = 0 , temp = i ; while ( temp > 0 ) { xorr = xorr ^ ( temp % 10 ) ; temp = Math . floor ( temp / 10 ) ; } if ( xorr <= 9 ) count ++ ; } document . write ( count ) ; }
function countNums ( N ) { var dp = Array ( N ) ; for ( var i = 0 ; i < N ; i ++ ) dp [ i ] = Array ( 16 ) . fill ( 0 ) ; for ( i = 1 ; i <= 9 ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( i = 1 ; i < N ; i ++ ) { for ( j = 0 ; j < 10 ; j ++ ) { for ( k = 0 ; k < 16 ; k ++ ) { var xor = j ^ k ; dp [ i ] [ xor ] += dp [ i - 1 ] [ k ] ; } } } var count = 0 ; for ( i = 0 ; i < 10 ; i ++ ) count += dp [ N - 1 ] [ i ] ; document . write ( count ) ; }
function count ( a , M , N ) { let cnt = 0 ; for ( let i = 1 ; i <= M ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { if ( i % a [ j ] == 0 ) { cnt ++ ; break ; } } } return cnt ; }
function minSum ( n , num , price ) { let dp = Array . from ( { length : n } , ( _ , i ) => Number . MAX_VALUE ) ; let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( num [ j ] > num [ i ] ) { dp [ j ] = Math . min ( dp [ j ] , price [ i ] + price [ j ] ) ; ans = Math . min ( ans , dp [ i ] + price [ j ] ) ; } } } return ans != Number . MAX_VALUE ? ans : - 1 ; }
function solve ( n , k , mod , dp ) { if ( n < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; let cnt = 0 ; for ( let i = 2 ; i <= k ; i += 2 ) { cnt = ( cnt % mod + solve ( n - i , k , mod , dp ) % mod ) % mod ; } dp [ n ] = cnt ; return cnt ; }
function maxProfit ( price , n ) { var buy1 , profit1 , buy2 , profit2 ; buy1 = buy2 = Number . MAX_VALUE ; profit1 = profit2 = 0 ; for ( i = 0 ; i < n ; i ++ ) { buy1 = Math . min ( buy1 , price [ i ] ) ; profit1 = Math . max ( profit1 , price [ i ] - buy1 ) ; buy2 = Math . min ( buy2 , price [ i ] - profit1 ) ; profit2 = Math . max ( profit2 , price [ i ] - buy2 ) ; } return profit2 ; }
function findMaximumScore ( a , n ) { let freq = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( freq . has ( a [ i ] ) ) { freq . set ( a [ i ] , freq . get ( a [ i ] ) + 1 ) ; } else { freq . set ( a [ i ] , 1 ) ; } } let dp = new Array ( Math . max ( ... a ) + 1 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = freq . get ( 1 ) ; for ( let i = 2 ; i < dp . length ; i ++ ) dp [ i ] = Math . max ( dp [ i - 1 ] , dp [ i - 2 ] + freq . get ( i ) * i ) ; return dp [ dp . length - 1 ] ; }
function reduceZero ( N ) { var dp = Array ( N + 1 ) . fill ( 1000000000 ) ; dp [ 0 ] = 0 ; for ( var i = 0 ; i <= N ; i ++ ) { for ( var j = 0 ; j < i . toString ( ) . length ; j ++ ) { dp [ i ] = Math . min ( dp [ i ] , dp [ i - ( i . toString ( ) [ j ] - ' ' ) ] + 1 ) ; } } return dp [ N ] ; }
function printpenta ( n ) { if ( n < 0 ) return ; let first = 0 ; let second = 0 ; let third = 0 ; let fourth = 0 ; let fifth = 1 ; let curr = 0 ; if ( n == 0 n == 1 n == 2 n == 3 ) document . write ( first + " " ) ; else if ( n == 5 ) document . write ( fifth + " " ) ; else { for ( let i = 5 ; i < n ; i ++ ) { curr = first + second + third + fourth + fifth ; first = second ; second = third ; third = fourth ; fourth = fifth ; fifth = curr ; } document . write ( curr + " " ) ; } }
function possibleBinaries ( pos , ones , sum , k ) { if ( ones == k ) return 0 ; if ( pos == 0 ) return ( sum == 0 ) ? 1 : 0 ; if ( dp [ pos ] [ ones ] [ sum ] != - 1 ) return dp [ pos ] [ ones ] [ sum ] ; let ret = possibleBinaries ( pos - 1 , ones + 1 , ( sum + 1 ) % 2 , k ) + possibleBinaries ( pos - 1 , 0 , sum , k ) ; dp [ pos ] [ ones ] [ sum ] = ret ; return dp [ pos ] [ ones ] [ sum ] ; }
function smallestNum ( n ) { res = 1 ; for ( var i = 2 ; ; i *= 2 ) { var length = parseInt ( Math . log ( i ) / Math . log ( 10 ) ) + 1 ; if ( length == n ) return parseInt ( Math . log ( i ) / Math . log ( 2 ) ) ; } }
function isKPartitionPossible ( arr , N , K ) { if ( K == 1 ) return true ; if ( N < K ) return false ; let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % K != 0 ) return false ; let target = sum / K ; let dp = Array . from ( { length : ( 1 << 15 ) } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < ( 1 << N ) ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; for ( let mask = 0 ; mask < ( 1 << N ) ; mask ++ ) { if ( dp [ mask ] == - 1 ) continue ; for ( let i = 0 ; i < N ; i ++ ) { if ( ( ( mask & ( 1 << i ) ) == 0 ) && dp [ mask ] + arr [ i ] <= target ) { dp [ mask ( 1 << i ) ] = ( dp [ mask ] + arr [ i ] ) % target ; } } } if ( dp [ ( 1 << N ) - 1 ] == 0 ) return true ; else return false ; } let arr = [ 2 , 1 , 4 , 5 , 3 , 3 ] ; let N = arr . length ; let K = 3 ; if ( isKPartitionPossible ( arr , N , K ) ) { document . write ( " " ) ; document . write ( " " ) ; } else { document . write ( " " ) ; document . write ( " " ) ; }
function minOperation ( k ) { let dp = Array . from ( { length : k + 1 } , ( _ , i ) => 0 ) ; for ( let i = 1 ; i <= k ; i ++ ) { dp [ i ] = dp [ i - 1 ] + 1 ; if ( i % 2 == 0 ) { dp [ i ] = Math . min ( dp [ i ] , dp [ i / 2 ] + 1 ) ; } } return dp [ k ] ; }
function count ( n ) { if ( n == 2 ) return 1 ; else if ( n == 4 ) return 2 ; else if ( n == 6 ) return 4 ; let table = Array . from ( { length : n + 1 } , ( _ , i ) => 0 ) ; let i ; for ( i = 0 ; i < n + 1 ; i ++ ) table [ i ] = 0 ; table [ 0 ] = 0 ; table [ 2 ] = 1 ; table [ 4 ] = 2 ; table [ 6 ] = 4 ; for ( i = 8 ; i <= n ; i = i + 2 ) { table [ i ] = table [ i - 2 ] + table [ i - 4 ] + table [ i - 6 ] ; } return table [ n ] ; }
function findX ( targetValue ) { var start = 0 , end = targetValue ; var mid , result ; while ( start <= end ) { mid = start + parseInt ( ( end - start ) / 2 ) ; if ( mid * mid <= targetValue ) { result = mid ; start = mid + 1 ; } else { end = mid - 1 ; } } document . write ( result ) ; }
function differentStrings ( s ) { var n = s . length ; var dp = Array ( n + 1 ) ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( var i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] && ( s [ i ] == ' ' s [ i ] == ' ' ) ) dp [ i + 1 ] = dp [ i ] + dp [ i - 1 ] ; else dp [ i + 1 ] = dp [ i ] ; } document . write ( dp [ n ] + " " ) ; }
function solve ( n , k , m ) { if ( n == 0 && k == 0 ) return 1 ; if ( n == 0 && k != 0 ) return 0 ; if ( n != 0 && k == 0 ) { return 0 ; } if ( n < 0 k < 0 ) return 0 ; if ( dp [ n ] [ k ] > 0 ) return dp [ n ] [ k ] ; var ans = 0 ; for ( var j = 1 ; j <= m ; j ++ ) { ans += solve ( n - j , k - 1 , m ) ; } return dp [ n ] [ k ] = ans ; }
function largestSquare ( matrix , R , C , q_i , q_j , K , Q ) { for ( var q = 0 ; q < Q ; q ++ ) { var i = q_i [ q ] ; var j = q_j [ q ] ; var min_dist = Math . min ( Math . min ( i , j ) , Math . min ( R - i - 1 , C - j - 1 ) ) ; var ans = - 1 ; for ( var k = 0 ; k <= min_dist ; k ++ ) { var count = 0 ; for ( var row = i - k ; row <= i + k ; row ++ ) for ( var col = j - k ; col <= j + k ; col ++ ) count += matrix [ row ] [ col ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } document . write ( ans + " " ) ; } }
function largestSquare ( matrix , R , C , q_i , q_j , K , Q ) { let countDP = new Array ( R ) ; for ( let i = 0 ; i < R ; i ++ ) { countDP [ i ] = new Array ( C ) ; for ( let j = 0 ; j < C ; j ++ ) countDP [ i ] [ j ] = 0 ; } countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( let i = 1 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( let j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( let i = 1 ; i < R ; i ++ ) for ( let j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ; for ( let q = 0 ; q < Q ; q ++ ) { let i = q_i [ q ] ; let j = q_j [ q ] ; let min_dist = Math . min ( Math . min ( i , j ) , Math . min ( R - i - 1 , C - j - 1 ) ) ; let ans = - 1 ; for ( let k = 0 ; k <= min_dist ; k ++ ) { let x1 = i - k , x2 = i + k ; let y1 = j - k , y2 = j + k ; let count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } document . write ( ans + " " ) ; } }
function largestSquare ( matrix , R , C , q_i , q_j , K , Q ) { let countDP = new Array ( R ) ; for ( let i = 0 ; i < R ; i ++ ) { countDP [ i ] = new Array ( C ) ; for ( let j = 0 ; j < C ; j ++ ) countDP [ i ] [ j ] = 0 ; } countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( let i = 1 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( let j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( let i = 1 ; i < R ; i ++ ) for ( let j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ; for ( let q = 0 ; q < Q ; q ++ ) { let i = q_i [ q ] ; let j = q_j [ q ] ; let min_dist = Math . min ( Math . min ( i , j ) , Math . min ( R - i - 1 , C - j - 1 ) ) ; let ans = - 1 , l = 0 , u = min_dist ; while ( l <= u ) { let mid = Math . floor ( ( l + u ) / 2 ) ; let x1 = i - mid , x2 = i + mid ; let y1 = j - mid , y2 = j + mid ; let count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ; if ( count <= K ) { ans = 2 * mid + 1 ; l = mid + 1 ; } else u = mid - 1 ; } document . write ( ans + " " ) ; } }
function numberOfArithmeticSequences ( L , N ) { if ( N <= 2 ) return 0 ; var count = 0 ; var res = 0 ; for ( var i = 2 ; i < N ; ++ i ) { if ( L [ i ] - L [ i - 1 ] == L [ i - 1 ] - L [ i - 2 ] ) { ++ count ; } else { count = 0 ; } res += count ; } return res ; }
function count_special ( n ) { var fib = [ ... Array ( n + 1 ) ] ; fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( var i = 2 ; i <= n ; i ++ ) { fib [ i ] = ( ( fib [ i - 1 ] % mod ) + ( fib [ i - 2 ] % mod ) ) % mod ; } return fib [ n ] ; }
function divisorGame ( N , A , dp ) { if ( N == 1 N == 3 ) return false ; if ( N == 2 ) return true ; if ( dp [ N ] [ A ] != - 1 ) return dp [ N ] [ A ] ; let ans = ( A == 1 ) ? 0 : 1 ; for ( let i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { if ( A ) ans |= divisorGame ( N - i , 0 , dp ) ; else ans &= divisorGame ( N - i , 1 , dp ) ; } } return dp [ N ] [ A ] = ans ; } let N = 3 ; let dp = [ ] ; for ( let i = 0 ; i < N + 1 ; i ++ ) { let temp = [ - 1 ] for ( let j = 0 ; j < 2 ; j ++ ) { temp . push ( [ - 1 ] ) } dp . push ( temp ) }
function findCost ( cost_mat , N , M ) { var dp = Array ( N ) ; for ( i = 0 ; i < N ; i ++ ) dp [ i ] = Array ( M ) . fill ( 0 ) ; for ( i = 0 ; i < M ; i ++ ) dp [ 0 ] [ i ] = cost_mat [ 0 ] [ i ] ; for ( row = 1 ; row < N ; row ++ ) { for ( curr_col = 0 ; curr_col < M ; curr_col ++ ) { var val = 999999999 ; for ( prev_col = 0 ; prev_col < M ; prev_col ++ ) { if ( curr_col != prev_col ) val = Math . min ( val , dp [ row - 1 ] [ prev_col ] ) ; } dp [ row ] [ curr_col ] = val + cost_mat [ row ] [ curr_col ] ; } } var ans = Number . MAX_VALUE ; for ( i = 0 ; i < M ; i ++ ) ans = Math . min ( ans , dp [ N - 1 ] [ i ] ) ; return ans ; }
function k_nonzero_numbers ( s , n , k ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = new Array ( k + 1 ) ; for ( let x = 0 ; x <= k ; x ++ ) dp [ i ] [ j ] [ x ] = 0 ; } } dp [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( let i = 0 ; i < n ; ++ i ) { let sm = 0 ; while ( sm < 2 ) { for ( let j = 0 ; j < k + 1 ; ++ j ) { let x = 0 ; while ( x <= ( sm != 0 ? 9 : s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ) { if ( j + ( x > 0 ? 1 : 0 ) < k + 1 ) { dp [ i + 1 ] [ ( sm != 0 || x < ( s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ) ? 1 : 0 ] [ j + ( x > 0 ? 1 : 0 ) ] += dp [ i ] [ sm ] [ j ] ; } ++ x ; } } ++ sm ; } } return dp [ n ] [ 0 ] [ k ] + dp [ n ] [ 1 ] [ k ] ; }
function maxSum ( p0 , p1 , a , pos , n ) { if ( pos == n ) { if ( p0 == p1 ) return p0 ; else return 0 ; } var ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ; ans = Math . max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ; ans = Math . max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; return ans ; }
function TotalWays ( n , s , k ) { let dp = new Array ( n ) ; dp . fill ( 0 ) ; dp [ s - 1 ] = 1 ; for ( let i = s ; i < n ; i ++ ) { let idx = Math . max ( s - 1 , i - k ) ; for ( let j = idx ; j < i ; j ++ ) { dp [ i ] += dp [ j ] ; } } return dp [ n - 1 ] ; }
function find_max ( i , sum , v , k ) { if ( i == v . length ) return 0 ; if ( dp [ i ] [ sum ] != - 1 ) return dp [ i ] [ sum ] ; let ans = 0 ; if ( ( sum + find_max ( i + 1 , sum , v , k ) ) % k == 0 ) ans = find_max ( i + 1 , sum , v , k ) ; if ( ( sum + v [ i ] + find_max ( i + 1 , ( sum + v [ i ] ) % k , v , k ) ) % k == 0 ) ans = Math . max ( ans , v [ i ] + find_max ( i + 1 , ( sum + v [ i ] ) % k , v , k ) ) ; return dp [ i ] [ sum ] = ans ; } let arr = [ 43 , 1 , 17 , 26 , 15 ] ; let k = 16 ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } for ( var i = 0 ; i < dp . length ; i ++ ) { for ( var j = 0 ; j < dp . length ; j ++ ) { dp [ i ] [ j ] = - 1 ; } }
function cntSubSeq ( arr , n ) { var pos_count = 0 ; var neg_count = 0 ; var result ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos_count ++ ; if ( arr [ i ] < 0 ) neg_count ++ ; } result = Math . pow ( 2 , pos_count ) ; if ( neg_count > 0 ) result *= Math . pow ( 2 , neg_count - 1 ) ; else result = 0 ; return result ; }
function minSteps ( str , n , k ) { if ( str [ n - 1 ] == ' ' ) return - 1 ; if ( n == 1 ) return 0 ; if ( n < 4 ) return 1 ; var dp = Array ( n ) ; dp [ n - 1 ] = 0 ; dp [ n - 2 ] = 1 ; dp [ n - 3 ] = 1 ; for ( var i = n - 4 ; i >= 0 ; i -- ) { if ( str [ i ] == ' ' ) continue ; var steps = 1000000000 ; if ( i + k < n && str [ i + k ] == ' ' ) steps = Math . min ( steps , dp [ i + k ] ) ; if ( str [ i + 1 ] == ' ' ) steps = Math . min ( steps , dp [ i + 1 ] ) ; if ( str [ i + 2 ] == ' ' ) steps = Math . min ( steps , dp [ i + 2 ] ) ; dp [ i ] = ( steps == 1000000000 ) ? steps : 1 + steps ; } if ( dp [ 0 ] == 1000000000 ) return - 1 ; return dp [ 0 ] ; }
function eggDrop ( n , k ) { let dp = new Array ( ) ; for ( let i = 0 ; i < k + 1 ; i ++ ) { dp . push ( new Array ( n + 1 ) . fill ( 0 ) ) } let x = 0 ; while ( dp [ x ] [ n ] < k ) { x ++ ; for ( let i = 1 ; i <= n ; i ++ ) dp [ x ] [ i ] = dp [ x - 1 ] [ i - 1 ] + dp [ x - 1 ] [ i ] + 1 ; } return x ; }
function countWays ( n ) { if ( n == 0 ) return 1 ; if ( n <= 2 ) return n ; let f0 = 1 , f1 = 1 , f2 = 2 ; let ans = 0 ; for ( let i = 3 ; i <= n ; i ++ ) { ans = f0 + f1 + f2 ; f0 = f1 ; f1 = f2 ; f2 = ans ; } return ans ; }
function countStr ( N ) { var dp = Array . from ( Array ( N + 1 ) , ( ) => Array ( 3 ) . fill ( 0 ) ) ; dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ; dp [ 1 ] [ 2 ] = 0 ; for ( var i = 2 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD ; } var ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD ; return ans ; }
function countSquareMatrices ( a , N , M ) { var count = 0 ; for ( var i = 1 ; i < N ; i ++ ) { for ( var j = 1 ; j < M ; j ++ ) { if ( a [ i ] [ j ] == 0 ) continue ; a [ i ] [ j ] = Math . min ( Math . min ( a [ i - 1 ] [ j ] , a [ i ] [ j - 1 ] ) , a [ i - 1 ] [ j - 1 ] ) + 1 ; } } for ( var i = 0 ; i < N ; i ++ ) for ( var j = 0 ; j < M ; j ++ ) count += a [ i ] [ j ] ; return count ; }
function maxLengthSquare ( row , column , arr , k ) { let sum = new Array ( ) ; [ row + 1 ] [ column + 1 ] ; for ( let i = 0 ; i < row + 1 ; i ++ ) { let temp = new Array ( ) ; for ( let j = 0 ; j < column + 1 ; j ++ ) { temp . push ( [ ] ) } sum . push ( temp ) } for ( let i = 1 ; i <= row ; i ++ ) for ( let j = 0 ; j <= column ; j ++ ) sum [ i ] [ j ] = 0 ; let cur_max = 1 ; let max = 0 ; for ( let i = 1 ; i <= row ; i ++ ) { for ( let j = 1 ; j <= column ; j ++ ) { sum [ i ] [ j ] = sum [ i - 1 ] [ j ] + sum [ i ] [ j - 1 ] + arr [ i - 1 ] [ j - 1 ] - sum [ i - 1 ] [ j - 1 ] ; if ( i >= cur_max && j >= cur_max && sum [ i ] [ j ] - sum [ i - cur_max ] [ j ] - sum [ i ] [ j - cur_max ] + sum [ i - cur_max ] [ j - cur_max ] <= k ) { max = cur_max ++ ; } } } return max ; }
function findLargestString ( s , i , r ) { if ( i == s . length ) { if ( r == 0 ) return 0 ; else return - 1000000000 ; } if ( v [ i ] [ r ] ) return dp [ i ] [ r ] ; v [ i ] [ r ] = 1 ; dp [ i ] [ r ] = Math . max ( 1 + findLargestString ( s , i + 1 , ( r * 2 + ( s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ) % 3 ) , findLargestString ( s , i + 1 , r ) ) ; return dp [ i ] [ r ] ; }
function findCnt ( s , i , r ) { if ( i == s . length ) { if ( r == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ r ] ) return dp [ i ] [ r ] ; v [ i ] [ r ] = 1 ; dp [ i ] [ r ] = findCnt ( s , i + 1 , ( r * 2 + ( s [ i ] - ' ' ) ) % 3 ) + findCnt ( s , i + 1 , r ) ; return dp [ i ] [ r ] ; }
function findMax ( a , n ) { var dp = Array ( n ) . fill ( ) . map ( ( ) => Array ( 2 ) . fill ( 0 ) ) ; var i , j ; for ( i = 0 ; i < n ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) dp [ i ] [ j ] = 0 ; dp [ 0 ] [ 0 ] = a [ 0 ] + a [ 1 ] ; dp [ 0 ] [ 1 ] = a [ 0 ] * a [ 1 ] ; for ( i = 1 ; i <= n - 2 ; i ++ ) { dp [ i ] [ 0 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + a [ i + 1 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] - a [ i ] + a [ i ] * a [ i + 1 ] ; } document . write ( Math . max ( dp [ n - 2 ] [ 0 ] , dp [ n - 2 ] [ 1 ] ) ) ; }
function minCount ( arr , n , k ) { var ans = 0 ; var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum -= k ; var l = 0 ; var r = 0 ; var tot = 0 ; while ( l < n ) { if ( tot <= sum ) { ans = Math . max ( ans , r - l ) ; if ( r == n ) break ; tot += arr [ r ++ ] ; } else { tot -= arr [ l ++ ] ; } } return ( n - ans ) ; }
function minMergeCost ( i , j , arr ) { if ( i == j ) return 0 ; if ( v [ i ] [ j ] ) return dp [ i ] [ j ] ; v [ i ] [ j ] = 1 ; var x = dp [ i ] [ j ] ; x = 1000000000 ; var tot = 0 ; for ( var k = i ; k <= j ; k ++ ) tot += arr [ k ] ; for ( var k = i + 1 ; k <= j ; k ++ ) { x = Math . min ( x , tot + minMergeCost ( i , k - 1 , arr ) + minMergeCost ( k , j , arr ) ) ; } return x ; }
function expectedSteps ( x ) { if ( x == 0 ) return 0 ; if ( x <= 5 ) return 6 ; if ( v [ x ] ) return dp [ x ] ; v [ x ] = 1 ; dp [ x ] = 1 + ( expectedSteps ( x - 1 ) + expectedSteps ( x - 2 ) + expectedSteps ( x - 3 ) + expectedSteps ( x - 4 ) + expectedSteps ( x - 5 ) + expectedSteps ( x - 6 ) ) / 6 ; return dp [ x ] ; }
function minDifference ( x , y , k , b , c ) { if ( x >= n y >= m ) return INT_MAX ; if ( x == n - 1 && y == m - 1 ) { let diff = b [ x ] [ y ] - c [ x ] [ y ] ; return Math . min ( Math . abs ( k - diff ) , Math . abs ( k + diff ) ) ; } let ans = dp [ x ] [ y ] [ k ] ; if ( ans != - 1 ) return ans ; ans = INT_MAX ; let diff = b [ x ] [ y ] - c [ x ] [ y ] ; ans = Math . min ( ans , minDifference ( x + 1 , y , Math . abs ( k + diff ) , b , c ) ) ; ans = Math . min ( ans , minDifference ( x , y + 1 , Math . abs ( k + diff ) , b , c ) ) ; ans = Math . min ( ans , minDifference ( x + 1 , y , Math . abs ( k - diff ) , b , c ) ) ; ans = Math . min ( ans , minDifference ( x , y + 1 , Math . abs ( k - diff ) , b , c ) ) ; return ans ; } n = 2 ; m = 2 ; let b = [ [ 1 , 4 ] , [ 2 , 4 ] ] ; let c = [ [ 3 , 2 ] , [ 3 , 1 ] ] ; for ( let i = 0 ; i < MAXI ; i ++ ) { dp [ i ] = new Array ( MAXI ) ; for ( let j = 0 ; j < MAXI ; j ++ ) { dp [ i ] [ j ] = new Array ( MAXI * MAXI ) ; for ( let k = 0 ; k < MAXI * MAXI ; k ++ ) { dp [ i ] [ j ] [ k ] = - 1 ; } } }
function countSubSeq ( str , len ) { var ans = 0 ; var mul = 1 ; for ( var i = 0 ; i < len ; i ++ ) { if ( str [ i ] == ' ' ) ans += mul ; mul *= 2 ; } return ans ; }
function max_sum ( a , n ) { var dp = Array ( n + 1 ) . fill ( ) . map ( ( ) => Array ( 2 ) . fill ( 0 ) ) ; dp [ 0 ] [ 0 ] = 0 ; dp [ 0 ] [ 1 ] = - 999999 ; for ( i = 0 ; i <= n - 1 ; i ++ ) { dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] + a [ i ] , dp [ i ] [ 1 ] - a [ i ] ) ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] - a [ i ] , dp [ i ] [ 1 ] + a [ i ] ) ; } return dp [ n ] [ 0 ] ; }
function subsequence ( S , T , n , m ) { let dp = new Array ( ) for ( let i = 0 ; i < n + 1 ; i ++ ) { let temp = [ ] ; for ( let j = 0 ; j < m + 1 ; j ++ ) { temp . push ( [ ] ) } dp . push ( temp ) } for ( let i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( let j = 0 ; j <= m ; j ++ ) dp [ 0 ] [ j ] = 1 ; for ( let i = 1 ; i <= n ; ++ i ) { for ( let j = 1 ; j <= m ; ++ j ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] - dp [ i - 1 ] [ j - 1 ] ; if ( S [ i - 1 ] == T [ j - 1 ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ j - 1 ] ; dp [ i ] [ j ] += mod ; dp [ i ] [ j ] %= mod ; } } return dp [ n ] [ m ] ; }
function number_of_ways ( arr , n , k ) { if ( k == 1 ) return 1 ; let dp = new Array ( k + 1 ) ; let i ; for ( i = 0 ; i < k + 1 ; i ++ ) dp [ i ] = - 1 ; for ( i = 0 ; i < n ; i ++ ) dp [ arr [ i ] ] = 0 ; dp [ 0 ] = 1 ; dp [ 1 ] = ( dp [ 1 ] == - 1 ) ? 1 : dp [ 1 ] ; for ( i = 2 ; i <= k ; ++ i ) { if ( dp [ i ] == 0 ) continue ; dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; dp [ i ] %= MOD ; } return dp [ k ] ; }
function findCount ( n ) { return parseInt ( Math . log ( n ) / Math . log ( 2 ) , 10 ) + 1 ; }
function findMax ( arr , n ) { var res = 0 ; var i , j ; for ( i = 0 ; i < n ; i ++ ) { var count = 0 ; for ( j = 0 ; j < i ; j ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) count += 1 ; } res = Math . max ( count , res ) ; } return res ; }
function findCnt ( arr , i , curr , n , m ) { if ( i == n ) { if ( curr == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; dp [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; return dp [ i ] [ curr ] ; }
function findSetBits ( n ) { let dp = new Array ( n + 1 ) ; dp . fill ( 0 ) ; document . write ( dp [ 0 ] + " " ) ; for ( let i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { dp [ i ] = dp [ parseInt ( i / 2 , 10 ) ] ; } else { dp [ i ] = dp [ parseInt ( i / 2 , 10 ) ] + 1 ; } document . write ( dp [ i ] + " " ) ; } }
function findLen ( arr , i , curr , n , m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; var l = findLen ( arr , i + 1 , curr , n , m ) ; var r = findLen ( arr , i + 1 , curr arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }
function findLen ( arr , i , curr , n , m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; var l = findLen ( arr , i + 1 , curr , n , m ) ; var r = findLen ( arr , i + 1 , curr & arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }
function findLen ( arr , i , curr , n , m ) { if ( i == n ) { if ( ! curr ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; var l = findLen ( arr , i + 1 , curr , n , m ) ; var r = findLen ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }
function findCnt ( arr , i , required_sum , n ) { if ( i == n ) { if ( required_sum == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ required_sum + base ] ) return dp [ i ] [ required_sum + base ] ; v [ i ] [ required_sum + base ] = 1 ; dp [ i ] [ required_sum + base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; return dp [ i ] [ required_sum + base ] ; }
function findCnt ( arr , i , curr , n , m ) { if ( i == n ) { return ( curr == m ) ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; dp [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr arr [ i ] ) , n , m ) ; return dp [ i ] [ curr ] ; }
function findCnt ( arr , i , curr , n , m ) { if ( i == n ) { return ( curr == m ) ; } if ( v1 [ i ] [ curr ] ) return dp1 [ i ] [ curr ] ; v1 [ i ] [ curr ] = 1 ; dp1 [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr & arr [ i ] ) , n , m ) ; return dp1 [ i ] [ curr ] ; }
function countWays ( n ) { let dp = new Array ( n + 1 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 1 ; for ( let i = 3 ; i <= n ; i ++ ) { dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 ; } return dp [ n ] ; }
function LISusingLCS ( seq ) { let n = seq . length ; let L = new Array ( n + 1 ) ; for ( let i = 0 ; i < ( n + 1 ) ; i ++ ) { L [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < ( n + 1 ) ; j ++ ) { L [ i ] [ j ] = 0 ; } } let sortedseq = [ ... seq ] ; sortedseq . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( seq [ i - 1 ] == sortedseq [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ n ] [ n ] ; }
function count_numbers ( k , n , flag ) { if ( n == 1 ) { if ( flag ) { return ( k - 1 ) ; } else { return 1 ; } } if ( flag ) return ( k - 1 ) * ( count_numbers ( k , n - 1 , 0 ) + count_numbers ( k , n - 1 , 1 ) ) ; else return count_numbers ( k , n - 1 , 1 ) ; }
function count_numbers ( k , n ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) dp [ i ] = new Array ( 2 ) ; dp [ 1 ] [ 0 ] = 0 ; dp [ 1 ] [ 1 ] = k - 1 ; for ( let i = 2 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) ; } return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] ; }
function cntSubsets ( arr , n ) { var max = Math . pow ( 2 , n ) ; var result = 0 ; for ( var i = 0 ; i < max ; i ++ ) { var counter = i ; if ( counter & ( counter >> 1 ) ) continue ; result ++ ; } return result ; }
function cntSubsets ( arr , n ) { var a = Array ( n ) ; var b = Array ( n ) ; a [ 0 ] = b [ 0 ] = 1 ; for ( var i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } var result = a [ n - 1 ] + b [ n - 1 ] ; return result ; }
function ways ( i , arr , n ) { if ( i == n - 1 ) return 1 ; let sum = 0 ; for ( let j = 1 ; j + i < n && j <= arr [ i ] ; j ++ ) { sum += ( ways ( i + j , arr , n ) ) % mod ; sum %= mod ; } return sum % mod ; }
function ways ( arr , n ) { let dp = new Array ( n + 1 ) ; dp . fill ( 0 ) ; dp [ n - 1 ] = 1 ; for ( let i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] = 0 ; for ( let j = 1 ; ( ( j + i ) < n && j <= arr [ i ] ) ; j ++ ) { dp [ i ] += dp [ i + j ] ; dp [ i ] %= mod ; } } return dp [ 0 ] % mod ; }
function minJumps ( arr , N ) { let fib = new Array ( 30 ) ; fib [ 0 ] = 0 ; fib [ 1 ] = 1 ; for ( let i = 2 ; i < 30 ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; let DP = new Array ( N + 2 ) ; DP [ 0 ] = 0 ; for ( let i = 1 ; i <= N + 1 ; i ++ ) DP [ i ] = MAX ; for ( let i = 1 ; i <= N + 1 ; i ++ ) { for ( let j = 1 ; j < 30 ; j ++ ) { if ( ( arr [ i - 1 ] == 1 i == N + 1 ) && i - fib [ j ] >= 0 ) DP [ i ] = Math . min ( DP [ i ] , 1 + DP [ i - fib [ j ] ] ) ; } } if ( DP [ N + 1 ] != MAX ) return DP [ N + 1 ] ; else return - 1 ; }
function Max_Sum ( arr1 , arr2 , n ) { let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { dp [ i ] [ 0 ] = arr1 [ i ] ; dp [ i ] [ 1 ] = arr2 [ i ] ; continue ; } dp [ i ] [ 0 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] + arr1 [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] + arr2 [ i ] ) ; } return Math . max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) ; }
function Probability ( p , n ) { var dp = Array ( n + 1 ) . fill ( 0 ) . map ( x => Array ( n + 1 ) . fill ( 0 ) ) ; dp [ 0 ] [ 0 ] = 1.0 ; for ( var i = 1 ; i <= n ; i += 1 ) { for ( var j = 0 ; j <= i ; j += 1 ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] * ( 1.0 - p [ i ] ) ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] * ( 1.0 - p [ i ] ) + dp [ i - 1 ] [ j - 1 ] * p [ i ] ; } } var ans = 0.0 ; for ( var i = parseInt ( ( n + 1 ) / 2 ) ; i <= n ; i += 1 ) ans += dp [ n ] [ i ] ; return ans ; }
function count_required_sequence ( n , arr ) { var total_required_subsequence = 0 ; var total_n_required_subsequence = 0 ; var dp = Array . from ( Array ( N ) , ( ) => Array ( 2 ) . fill ( 0 ) ) ; for ( var i = 0 ; i < n ; i ++ ) { var turn_required = 0 ; for ( var j = - 1 ; j <= 1 ; j ++ ) turn_required += dp [ arr [ i ] + j ] [ 0 ] ; var required_end_i = ( total_required_subsequence + turn_required ) ; var n_required_end_i = ( 1 + total_n_required_subsequence - turn_required ) ; total_required_subsequence += required_end_i ; total_n_required_subsequence += n_required_end_i ; dp [ arr [ i ] ] [ 1 ] += required_end_i ; dp [ arr [ i ] ] [ 0 ] += n_required_end_i ; } return total_required_subsequence ; }
function maxSum ( arr , i , n , k ) { if ( i >= n ) return 0 ; if ( visit [ i ] ) return dp [ i ] ; visit [ i ] = true ; let tot = 0 ; dp [ i ] = maxSum ( arr , i + 1 , n , k ) ; for ( let j = i ; j < ( i + k ) && ( j < n ) ; j ++ ) { tot += arr [ j ] ; dp [ i ] = Math . max ( dp [ i ] , tot + maxSum ( arr , j + 2 , n , k ) ) ; } return dp [ i ] ; }
function minSum ( A , B , C , i , n , curr , dp ) { if ( n <= 0 ) return 0 ; if ( dp [ n ] [ curr ] != - 1 ) return dp [ n ] [ curr ] ; if ( curr == 0 ) { return dp [ n ] [ curr ] = Math . min ( B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; } if ( curr == 1 ) return dp [ n ] [ curr ] = Math . min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; return dp [ n ] [ curr ] = Math . min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) ) ; } let A = [ 1 , 50 , 1 ] ; let B = [ 50 , 50 , 50 ] ; let C = [ 50 , 50 , 50 ] ; let dp = new Array ( SIZE ) ; for ( let i = 0 ; i < SIZE ; i ++ ) { dp [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = - 1 ; } }
function getChicks ( n ) { let chicks = Math . pow ( 3 , n - 1 ) ; return chicks ; }
function sumMax ( i , arr , n ) { if ( i >= n - 1 ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = true ; dp [ i ] = Math . max ( arr [ i ] + arr [ i + 1 ] + sumMax ( i + 3 , arr , n ) , sumMax ( i + 1 , arr , n ) ) ; return dp [ i ] ; }
function maxSum ( arr , i , n ) { if ( i >= n ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = 1 ; dp [ i ] = Math . max ( maxSum ( arr , i + 1 , n ) , arr [ i ] + maxSum ( arr , i + 2 , n ) ) ; return dp [ i ] ; }
function MinOfCubed ( k ) { if ( k < 8 ) return k ; let res = k ; for ( let i = 1 ; i <= k ; i ++ ) { if ( ( i * i * i ) > k ) return res ; res = Math . min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; } return res ; }
function MinOfCubedDP ( k ) { let DP = new Array ( k + 1 ) ; DP . fill ( 0 ) ; let j = 1 , t = 1 ; DP [ 0 ] = 0 ; for ( let i = 1 ; i <= k ; i ++ ) { DP [ i ] = Number . MAX_VALUE ; while ( j <= i ) { if ( j == i ) DP [ i ] = 1 ; else if ( DP [ i ] > DP [ i - j ] ) DP [ i ] = DP [ i - j ] + 1 ; t ++ ; j = t * t * t ; } t = j = 1 ; } return DP [ k ] ; }
function LIS ( a , n ) { let dp = new Array ( ) ; let d = new Array ( ) ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { dp [ a [ i ] ] = 1 ; for ( j = 2 ; j * j <= a [ i ] ; j ++ ) { if ( a [ i ] % j == 0 ) { dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) ; dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ a [ i ] / j ] ] + 1 ) ; d [ j ] = a [ i ] ; d [ a [ i ] / j ] = a [ i ] ; } } ans = Math . max ( ans , dp [ a [ i ] ] ) ; d [ a [ i ] ] = a [ i ] ; } return ans ; }
function maxSum ( a , n ) { let ans = 0 ; let arr = new Array ( n + 1 ) ; for ( let i = 1 ; i <= n ; i ++ ) arr [ i ] = a [ i - 1 ] ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; ++ i ) { dp [ i ] = new Array ( 3 ) ; for ( let j = 0 ; j < 3 ; ++ j ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= n ; ++ i ) { dp [ i ] [ 0 ] = Math . max ( arr [ i ] , dp [ i - 1 ] [ 0 ] + arr [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( 0 , dp [ i - 1 ] [ 0 ] ) - arr [ i ] ; if ( i >= 2 ) dp [ i ] [ 1 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 1 ] + arr [ i ] ) ; if ( i >= 2 ) dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] - arr [ i ] ; if ( i >= 3 ) dp [ i ] [ 2 ] = Math . max ( dp [ i ] [ 2 ] , dp [ i - 1 ] [ 2 ] + arr [ i ] ) ; ans = Math . max ( ans , dp [ i ] [ 0 ] ) ; ans = Math . max ( ans , dp [ i ] [ 1 ] ) ; ans = Math . max ( ans , dp [ i ] [ 2 ] ) ; } return ans ; }
function findCount ( mat , i , j , m ) { if ( i == 0 && j == 0 ) { if ( m == mat [ 0 ] [ 0 ] ) return 1 ; else return 0 ; } if ( m < 0 ) return 0 ; if ( i < 0 j < 0 ) return 0 ; if ( v [ i ] [ j ] [ m ] ) return dp [ i ] [ j ] [ m ] ; v [ i ] [ j ] [ m ] = true ; dp [ i ] [ j ] [ m ] = findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i , j - 1 , m - mat [ i ] [ j ] ) ; return dp [ i ] [ j ] [ m ] ; }
function CountWays ( r , b , l , R , B , W , dp ) { if ( l > W ) return 0 ; if ( r > R ) return 0 ; if ( b == B && r == R ) return 1 ; if ( b == B ) return 0 ; if ( dp [ r ] [ b ] [ l ] != - 1 ) return dp [ r ] [ b ] [ l ] ; var ans = 0 ; ans += CountWays ( r , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 1 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 2 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 3 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 4 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 6 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r , b + 1 , l + 1 , R , B , W , dp ) ; ans = ans % mod ; return dp [ r ] [ b ] [ l ] = ans ; }
function FindMinimumCost ( ind , a , n , k , dp ) { if ( ind == ( n - 1 ) ) return 0 ; else if ( dp [ ind ] != - 1 ) return dp [ ind ] ; else { var ans = Number . MAX_VALUE ; for ( var i = 1 ; i <= k ; i ++ ) { if ( ind + i < n ) ans = Math . min ( ans , Math . abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ; else break ; } return dp [ ind ] = ans ; } }
function findWaysToPair ( p ) { var dp = Array ( p + 1 ) ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; for ( var i = 3 ; i <= p ; i ++ ) { dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ p ] ; }
function maxWeight ( arr , n , w1_r , w2_r , i ) { if ( i == n ) return 0 ; if ( dp [ i ] [ w1_r ] [ w2_r ] != - 1 ) return dp [ i ] [ w1_r ] [ w2_r ] ; var fill_w1 = 0 , fill_w2 = 0 , fill_none = 0 ; if ( w1_r >= arr [ i ] ) fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) ; if ( w2_r >= arr [ i ] ) fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) ; fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) ; dp [ i ] [ w1_r ] [ w2_r ] = Math . max ( fill_none , Math . max ( fill_w1 , fill_w2 ) ) ; return dp [ i ] [ w1_r ] [ w2_r ] ; }
function totalSubSets ( n , l , r ) { let zero = Math . floor ( r / 3 ) - Math . ceil ( l / 3 ) + 1 ; let one = Math . floor ( ( r - 1 ) / 3 ) - Math . ceil ( ( l - 1 ) / 3 ) + 1 ; let two = Math . floor ( ( r - 2 ) / 3 ) - Math . ceil ( ( l - 2 ) / 3 ) + 1 ; let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( 3 ) ; for ( let j = 0 ; j < 3 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = zero ; dp [ 0 ] [ 1 ] = one ; dp [ 0 ] [ 2 ] = two ; for ( let i = 1 ; i < n ; ++ i ) { dp [ i ] [ 0 ] = ( ( dp [ i - 1 ] [ 0 ] * zero ) + ( dp [ i - 1 ] [ 1 ] * two ) + ( dp [ i - 1 ] [ 2 ] * one ) ) % MOD ; dp [ i ] [ 1 ] = ( ( dp [ i - 1 ] [ 0 ] * one ) + ( dp [ i - 1 ] [ 1 ] * zero ) + ( dp [ i - 1 ] [ 2 ] * two ) ) % MOD ; dp [ i ] [ 2 ] = ( ( dp [ i - 1 ] [ 0 ] * two ) + ( dp [ i - 1 ] [ 1 ] * one ) + ( dp [ i - 1 ] [ 2 ] * zero ) ) % MOD ; } return dp [ n - 1 ] [ 0 ] ; }
function solve ( idx , diff , N , M , K ) { if ( idx > N ) { if ( diff == K ) return 1 ; return 0 ; } if ( dp [ idx ] [ diff ] != - 1 ) return dp [ idx ] [ diff ] ; let ans = solve ( idx + 1 , diff , N , M , K ) ; ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; dp [ idx ] [ diff ] = ans % MOD ; return dp [ idx ] [ diff ] ; }
function maxPathSum ( tri ) { var ans = 0 ; for ( var i = N - 2 ; i >= 0 ; i -- ) { for ( var j = 0 ; j < N - i ; j ++ ) { if ( j - 1 >= 0 ) tri [ i ] [ j ] += Math . max ( tri [ i + 1 ] [ j ] , tri [ i + 1 ] [ j - 1 ] ) ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; ans = Math . max ( ans , tri [ i ] [ j ] ) ; } } return ans ; }
function get_max_splits ( num_String ) { let count = 0 , current_num ; let running_sum = 0 ; for ( let i = 0 ; i < num_String . length ; i ++ ) { current_num = num_String [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; running_sum += current_num ; if ( current_num % 3 == 0 || ( running_sum != 0 && running_sum % 3 == 0 ) ) { count += 1 ; running_sum = 0 ; } } return count ; }
function countPaths ( sum , get , m , n , dp ) { if ( sum < 0 ) return 0 ; if ( sum == 0 ) return get ; if ( dp [ sum ] [ get ] != - 1 ) return dp [ sum ] [ get ] ; let res = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( i == m ) res += countPaths ( sum - i , 1 , m , n , dp ) ; else res += countPaths ( sum - i , get , m , n , dp ) ; } dp [ sum ] [ get ] = res ; return dp [ sum ] [ get ] ; } let n = 3 , m = 2 , x = 3 ; let dp = new Array ( max + 1 ) ; for ( let i = 0 ; i <= max ; i ++ ) { dp [ i ] = new Array ( 2 ) for ( let j = 0 ; j < 2 ; j ++ ) dp [ i ] [ j ] = - 1 ; }
function solve ( x ) { let ans = 0 , first , last , temp = x ; if ( x < 10 ) return x ; last = x % 10 ; while ( x > 0 ) { first = x % 10 ; x /= 10 ; } if ( first <= last ) ans = 9 + temp / 10 ; else ans = 8 + temp / 10 ; return ans ; }
function findMinimumCost ( n , x , y ) { let dp = new Array ( n + 1 ) ; dp [ 1 ] = x ; for ( let i = 2 ; i <= n ; i ++ ) { if ( ( i & 1 ) != 0 ) { dp [ i ] = Math . min ( dp [ i - 1 ] + x , dp [ parseInt ( ( i + 1 ) / 2 , 10 ) ] + y + x ) ; } else { dp [ i ] = Math . min ( dp [ i - 1 ] + x , dp [ parseInt ( i / 2 , 10 ) ] + y ) ; } } return dp [ n ] ; }
function countWays ( index , cnt , dp , n , m , k ) { if ( index == n ) { if ( cnt == k ) return 1 ; else return 0 ; } if ( dp [ index ] [ cnt ] != - 1 ) return dp [ index ] [ cnt ] ; let ans = 0 ; ans += countWays ( index + 1 , cnt , dp , n , m , k ) ; ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) ; return dp [ index ] [ cnt ] = ans ; } let n = 3 , m = 3 , k = 2 ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] = new Array ( max ) ; for ( let j = 0 ; j < max ; j ++ ) dp [ i ] [ j ] = - 1 ; }
function sumOddFibonacci ( n ) { var Sum = Array ( n + 1 ) . fill ( 0 ) ; Sum [ 0 ] = 0 ; Sum [ 1 ] = 1 ; Sum [ 2 ] = 2 ; Sum [ 3 ] = 5 ; Sum [ 4 ] = 10 ; Sum [ 5 ] = 23 ; for ( i = 6 ; i <= n ; i ++ ) { Sum [ i ] = ( ( Sum [ i - 1 ] + ( 4 * Sum [ i - 2 ] ) % mod - ( 4 * Sum [ i - 3 ] ) % mod + mod ) % mod + ( Sum [ i - 4 ] - Sum [ i - 5 ] + mod ) % mod ) % mod ; } return Sum [ n ] ; }
function MaxProfit ( treasure , color , n , k , col , A , B ) { let sum = 0 ; if ( k == n ) return 0 ; if ( col == color [ k ] ) sum += Math . max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += Math . max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return sum ; }
function MaxProfit ( treasure , color , n , k , col , A , B ) { return dp [ k ] [ col ] = 0 ; if ( dp [ k ] [ col ] != - 1 ) return dp [ k ] [ col ] ; let sum = 0 ; if ( col == color [ k ] ) sum += Math . max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += Math . max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return dp [ k ] [ col ] = sum ; }
function calculateEvenSum ( n ) { if ( n <= 0 ) return 0 ; let fibo = Array ( 2 * n + 1 ) ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; let sum = 0 ; for ( i = 2 ; i <= 2 * n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum += fibo [ i ] ; } return sum ; }
function find ( index , openbrk , n , adj ) { if ( openbrk < 0 ) return MAX_VAL ; if ( index == n ) { if ( openbrk == 0 ) { return 0 ; } return MAX_VAL ; } if ( dp [ index ] [ openbrk ] != - 1 ) return dp [ index ] [ openbrk ] ; dp [ index ] [ openbrk ] = Math . min ( adj [ index ] [ 1 ] + find ( index + 1 , openbrk + 1 , n , adj ) , adj [ index ] [ 0 ] + find ( index + 1 , openbrk - 1 , n , adj ) ) ; return dp [ index ] [ openbrk ] ; }
function gouldSequence ( n ) { for ( var row_num = 1 ; row_num <= n ; row_num ++ ) { var count = 1 ; var c = 1 ; for ( var i = 1 ; i <= row_num ; i ++ ) { c = c * ( row_num - i ) / i ; if ( c % 2 == 1 ) count ++ ; } document . write ( count + " " ) ; } }
function minFallingPathSum ( A ) { for ( let R = n - 2 ; R >= 0 ; -- R ) { for ( let C = 0 ; C < n ; ++ C ) { let best = A [ R + 1 ] [ C ] ; if ( C > 0 ) best = Math . min ( best , A [ R + 1 ] [ C - 1 ] ) ; if ( C + 1 < n ) best = Math . min ( best , A [ R + 1 ] [ C + 1 ] ) ; A [ R ] [ C ] = A [ R ] [ C ] + best ; } } let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; ++ i ) ans = Math . min ( ans , A [ 0 ] [ i ] ) ; return ans ; }
function fun ( marks , n ) { let dp = new Array ( n ) ; let temp ; for ( let i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( marks [ i ] > marks [ i + 1 ] ) { temp = i ; while ( true ) { if ( ( marks [ temp ] > marks [ temp + 1 ] ) && temp >= 0 ) { if ( dp [ temp ] > dp [ temp + 1 ] ) { temp -= 1 ; continue ; } else { dp [ temp ] = dp [ temp + 1 ] + 1 ; temp -= 1 ; } } else break ; } } else if ( marks [ i ] < marks [ i + 1 ] ) dp [ i + 1 ] = dp [ i ] + 1 ; } let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += dp [ i ] ; return sum ; }
function partitions ( n ) { var p = Array ( n + 1 ) . fill ( 0 ) ; p [ 0 ] = 1 ; for ( i = 1 ; i <= n ; ++ i ) { var k = 1 ; while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) { p [ i ] += ( k % 2 != 0 ? 1 : - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) / 2 ] ; if ( k > 0 ) { k *= - 1 ; } else { k = 1 - k ; } } } return p [ n ] ; }
function maxCost ( a , n , l , r ) { var mx = 0 , k ; for ( var i = 0 ; i < n ; ++ i ) mx = Math . max ( mx , a [ i ] ) ; var count = new Array ( mx + 1 ) ; count . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) count [ a [ i ] ] ++ ; var res = new Array ( mx + 1 ) ; res [ 0 ] = 0 ; l = Math . min ( l , r ) ; for ( var num = 1 ; num <= mx ; num ++ ) { k = Math . max ( num - l - 1 , 0 ) ; res [ num ] = Math . max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) ; } return res [ mx ] ; }
function countPaths ( m , n ) { if ( m == 1 n == 1 ) return 1 ; return countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ; }
function countPaths ( m , n ) { let dp = new Array ( m + 1 ) ; for ( let i = 0 ; i <= m ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j <= n ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= m ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { if ( i == 1 j == 1 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; } } return dp [ m ] [ n ] ; }
function MatrixChainOrder ( p , n ) { var dp = Array . from ( Array ( n ) , ( ) => Array ( n ) ) ; for ( var i = 1 ; i < n ; i ++ ) dp [ i ] [ i ] = 0 ; for ( var L = 1 ; L < n - 1 ; L ++ ) for ( var i = 1 ; i < n - L ; i ++ ) dp [ i ] [ i + L ] = Math . min ( dp [ i + 1 ] [ i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i ] [ i + L - 1 ] + p [ i - 1 ] * p [ i + L - 1 ] * p [ i + L ] ) ; return dp [ 1 ] [ n - 1 ] ; }
function lds ( arr , n ) { let lds = new Array ( n ) ; lds [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { lds [ i ] = 1 ; for ( let j = 0 ; j < i ; j ++ ) if ( lds [ j ] != 0 && arr [ i ] % arr [ j ] == 0 ) lds [ i ] = Math . max ( lds [ i ] , lds [ j ] + 1 ) ; } let max = Math . max ( ... lds ) ; return max ; }
function find ( start , adj , n , dp ) { if ( start == n ) return 0 ; if ( dp [ start ] != - 1 ) return dp [ start ] ; dp [ start ] = 0 ; var one = 0 , zero = 0 , k ; for ( k = start ; k < n ; k ++ ) { if ( adj [ k ] == ' ' ) one ++ ; else zero ++ ; if ( one > zero ) dp [ start ] = Math . max ( dp [ start ] , find ( k + 1 , adj , n , dp ) + k - start + 1 ) ; else dp [ start ] = Math . max ( dp [ start ] , find ( k + 1 , adj , n , dp ) ) ; } return dp [ start ] ; }
function alternateFib ( n ) { if ( n < 0 ) return ; var f1 = 0 ; var f2 = 1 ; document . write ( f1 + " " ) ; for ( i = 2 ; i <= n ; i ++ ) { var f3 = f2 + f1 ; if ( i % 2 == 0 ) document . write ( f3 + " " ) ; f1 = f2 ; f2 = f3 ; } }
function printTetra ( n ) { let dp = new Array ( n + 5 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = dp [ 2 ] = 1 ; dp [ 3 ] = 2 ; for ( let i = 4 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] + dp [ i - 4 ] ; document . write ( dp [ n ] ) ; }
function printTetra ( n ) { if ( n < 0 ) return ; var first = 0 , second = 1 ; var third = 1 , fourth = 2 ; var curr ; if ( n == 0 ) cout << first ; else if ( n == 1 n == 2 ) cout << second ; else if ( n == 3 ) cout << fourth ; else { for ( var i = 4 ; i <= n ; i ++ ) { curr = first + second + third + fourth ; first = second ; second = third ; third = fourth ; fourth = curr ; } document . write ( curr ) ; } }
function minimumCost ( cost , n ) { let dp = new Array ( n ) ; if ( n == 1 ) return cost [ 0 ] ; dp [ 0 ] = cost [ 0 ] ; dp [ 1 ] = cost [ 1 ] ; for ( let i = 2 ; i < n ; i ++ ) { dp [ i ] = Math . min ( dp [ i - 1 ] , dp [ i - 2 ] ) + cost [ i ] ; } return Math . min ( dp [ n - 2 ] , dp [ n - 1 ] ) ; }
function minimumCost ( cost , n ) { let dp1 = 0 , dp2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let dp0 = cost [ i ] + Math . min ( dp1 , dp2 ) ; dp2 = dp1 ; dp1 = dp0 ; } return Math . min ( dp1 , dp2 ) ; }
function countPaths ( n ) { let zB = 1 ; let zADC = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let nzB = zADC * 3 ; let nzADC = ( zADC * 2 + zB ) ; zB = nzB ; zADC = nzADC ; } return zB ; }
function fib ( n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
function fib ( n ) { let term = new Array ( 1000 ) ; term . fill ( 0 ) ; if ( n <= 1 ) return n ; if ( term [ n ] != 0 ) return term [ n ] ; else { term [ n ] = fib ( n - 1 ) + fib ( n - 2 ) ; return term [ n ] ; } }
function lds ( arr , n ) { let lds = new Array ( n ) ; let i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] < arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lds [ i ] ) max = lds [ i ] ; return max ; }
function summation ( n ) { return n << ( n - 1 ) ; }
function fib ( n ) { let a = 0 , b = 1 , c ; if ( n >= 0 ) document . write ( a + " " ) ; if ( n >= 1 ) document . write ( b + " " ) ; for ( let i = 2 ; i <= n ; i ++ ) { c = a + b ; document . write ( c + " " ) ; a = b ; b = c ; } }
function largestSumOfAverages ( A , K ) { var n = A . length ; var pre_sum = Array ( n + 1 ) . fill ( - 1 ) ; pre_sum [ 0 ] = 0 ; for ( var i = 0 ; i < n ; i ++ ) pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ; var dp = Array ( n ) . fill ( - 1 ) ; var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) ; for ( k = 0 ; k < K - 1 ; k ++ ) for ( i = 0 ; i < n ; i ++ ) for ( j = i + 1 ; j < n ; j ++ ) dp [ i ] = Math . max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) ; return dp [ 0 ] ; }
function minSumPath ( ) { let memo = [ ] ; let n = A . length - 1 ; for ( let i = 0 ; i < A [ n ] . length ; i ++ ) memo [ i ] = A [ n ] [ i ] ; for ( let i = A . length - 2 ; i >= 0 ; i -- ) for ( let j = 0 ; j < A [ i ] . length ; j ++ ) memo [ j ] = A [ i ] [ j ] + Math . min ( memo [ j ] , memo [ j + 1 ] ) ; return memo [ 0 ] ; }
function findSDSFunc ( n ) { let DP = [ ] ; DP [ 0 ] = 0 ; DP [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) DP [ i ] = DP [ i / 2 ] ; else DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 ] ; } return DP [ n ] ; }
function isPossible ( index , sum ) { if ( index == n ) { if ( ( sum % M ) == 0 ) return true ; return false ; } let placeAdd = isPossible ( index + 1 , sum + arr [ index ] ) ; let placeMinus = isPossible ( index + 1 , sum - arr [ index ] ) ; if ( placeAdd placeMinus ) return true ; return false ; }
function printGolomb ( n ) { let dp = Array ( n + 1 ) . fill ( 0 ) ; dp [ 1 ] = 1 ; document . write ( dp [ 1 ] + " " ) ; for ( i = 2 ; i <= n ; i ++ ) { dp [ i ] = 1 + dp [ i - dp [ dp [ i - 1 ] ] ] ; document . write ( dp [ i ] + " " ) ; } }
function removals ( arr , n , k ) { arr . sort ( ( a , b ) => a - b ) ; var dp = Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) dp [ i ] = - 1 ; var ans = n - 1 ; dp [ 0 ] = 0 ; for ( var i = 1 ; i < n ; i ++ ) { dp [ i ] = i ; var j = dp [ i - 1 ] ; while ( j != i && arr [ i ] - arr [ j ] > k ) { j ++ ; } dp [ i ] = Math . min ( dp [ i ] , j ) ; ans = Math . min ( ans , ( n - ( i - j + 1 ) ) ) ; } return ans ; }
function maximumSegments ( n , a , b , c ) { let dp = [ ] ; for ( let i = 0 ; i < n + 10 ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( dp [ i ] != - 1 ) { dp [ i + a ] = Math . max ( dp [ i ] + 1 , dp [ i + a ] ) ; dp [ i + b ] = Math . max ( dp [ i ] + 1 , dp [ i + b ] ) ; dp [ i + c ] = Math . max ( dp [ i ] + 1 , dp [ i + c ] ) ; } } return dp [ n ] ; }
function sequence ( n ) { let f = [ ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; document . write ( f [ 1 ] + " " + f [ 2 ] + " " ) ; for ( let i = 3 ; i <= n ; i ++ ) { f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; document . write ( f [ i ] + " " ) ; } }
function longestSubsequenceCommonSegment ( k , s1 , s2 ) { var n = s1 . length ; var m = s2 . length ; var lcs = Array . from ( Array ( n + 1 ) , ( ) => Array ( m + 1 ) . fill ( 0 ) ) ; var cnt = Array . from ( Array ( n + 1 ) , ( ) => Array ( m + 1 ) . fill ( 0 ) ) ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 1 ; j <= m ; j ++ ) { lcs [ i ] [ j ] = Math . max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) ; if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 ; if ( cnt [ i ] [ j ] >= k ) { for ( var a = k ; a <= cnt [ i ] [ j ] ; a ++ ) lcs [ i ] [ j ] = Math . max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) ; } } } return lcs [ n ] [ m ] ; }
function findLength ( str , n ) { let current_sum = 0 ; let max_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { current_sum += ( str [ i ] == ' ' ? 1 : - 1 ) ; if ( current_sum < 0 ) { current_sum = 0 ; } max_sum = Math . max ( current_sum , max_sum ) ; } return max_sum == 0 ? - 1 : max_sum ; }
function find_prob ( N , P ) { let dp = [ ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 0 ; dp [ 2 ] = P ; dp [ 3 ] = 1 - P ; for ( let i = 4 ; i <= N ; ++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ; return ( dp [ N ] ) ; }
function maxSubArraySumRepeated ( a , n , k ) { let max_so_far = 0 ; let INT_MIN , max_ending_here = 0 ; for ( let i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
function maximumSumSubarray ( arr , n ) { let min_prefix_sum = 0 ; let res = Number . MIN_VALUE ; let prefix_sum = [ ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) { res = Math . max ( res , prefix_sum [ i ] - min_prefix_sum ) ; min_prefix_sum = Math . min ( min_prefix_sum , prefix_sum [ i ] ) ; } return res ; }
function isPath ( arr ) { arr [ 0 ] [ 0 ] = 1 ; for ( var i = 1 ; i < 5 ; i ++ ) if ( arr [ i ] [ 0 ] != - 1 ) arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] ; for ( var j = 1 ; j < 5 ; j ++ ) if ( arr [ 0 ] [ j ] != - 1 ) arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ] ; for ( var i = 1 ; i < 5 ; i ++ ) for ( var j = 1 ; j < 5 ; j ++ ) if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = Math . max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) ; return ( arr [ 5 - 1 ] [ 5 - 1 ] == 1 ) ; }
function countWays ( n ) { let res = new Array ( n + 2 ) ; res [ 0 ] = 1 ; res [ 1 ] = 1 ; res [ 2 ] = 2 ; for ( let i = 3 ; i <= n ; i ++ ) res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] ; return res [ n ] ; }
function countWays ( n ) { var a = 1 , b = 2 , c = 4 ; var d = 0 ; if ( n == 0 n == 1 n == 2 ) return n ; if ( n == 3 ) return c ; for ( var i = 4 ; i <= n ; i ++ ) { d = c + b + a ; a = b ; b = c ; c = d ; } return d ; }
function numberofways ( n , m ) { let dp = new Array ( n + 2 ) ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( n + 2 ) ; for ( let j = 0 ; j < dp [ i ] . length ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ n + 1 ] = 1 ; for ( let k = n ; k >= m ; k -- ) { for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; }
function zigzag ( n , k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k == 0 ) return 0 ; return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) ; }
function zigzag ( n , k ) { let dp = new Array ( n + 1 ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } dp [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= Math . min ( i , k ) ; j ++ ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ; } return dp [ n ] [ k ] ; }
function preprocess ( list ) { ways [ 0 ] [ 8 ] [ 8 ] = 1 ; for ( let N = 1 ; N <= 14 ; N ++ ) { for ( let i = 1 ; i < depth ; i ++ ) { for ( let j = 1 ; j < depth ; j ++ ) { ways [ N ] [ i ] [ j ] = ways [ N - 1 ] [ i ] [ j + 1 ] + ways [ N - 1 ] [ i ] [ j - 1 ] + ways [ N - 1 ] [ i + 1 ] [ j ] + ways [ N - 1 ] [ i - 1 ] [ j ] + ways [ N - 1 ] [ i + 1 ] [ j - 1 ] + ways [ N - 1 ] [ i - 1 ] [ j + 1 ] ; } } list [ N ] = ways [ N ] [ 8 ] [ 8 ] ; } }
function eulerian ( n , m ) { if ( m >= n n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ; }
function eulerian ( n , m ) { var dp = Array . from ( Array ( n + 1 ) , ( ) => Array ( m + 1 ) . fill ( 0 ) ) ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ; } } } return dp [ n ] [ m ] ; }
function nswp ( n ) { if ( n == 0 n == 1 ) return 1 ; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ; }
function nswp ( n ) { let dp = new Array ( n + 1 ) ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) dp [ i ] = 2 * dp [ i - 1 ] + dp [ i - 2 ] ; return dp [ n ] ; }
function longOddEvenIncSeq ( arr , n ) { let lioes = [ ] ; let maxLen = 0 ; for ( let i = 0 ; i < n ; i ++ ) lioes [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ; return maxLen ; }
function dealnnoy ( n , m ) { if ( m == 0 n == 0 ) return 1 ; return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) ; }
function dealnnoy ( n , m ) { var dp = Array . from ( Array ( m + 1 ) , ( ) => Array ( n + 1 ) ) ; for ( var i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( var i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( var i = 1 ; i <= m ; i ++ ) for ( var j = 1 ; j <= n ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; return dp [ m ] [ n ] ; }
function longestAlternating ( arr , n ) { let count = new Array ( n ) ; count [ n - 1 ] = 1 ; for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( count [ i ] + " " ) ; }
function maxDP ( n ) { let res = [ ] ; res [ 0 ] = 0 ; res [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { res [ i ] = Math . max ( i , ( res [ Math . floor ( i / 2 ) ] + res [ Math . floor ( i / 3 ) ] + res [ Math . floor ( i / 4 ) ] + res [ Math . floor ( i / 5 ) ] ) ) ; } return res [ n ] ; }
function countarray ( n , k , x ) { let dp = [ ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( let i = 2 ; i < n ; i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ; return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) ; }
function largestSubset ( a , n ) { let dp = [ ] ; dp [ n - 1 ] = 1 ; for ( let i = n - 2 ; i >= 0 ; i -- ) { let mxm = 0 ; for ( let j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] % a [ i ] == 0 a [ i ] % a [ j ] == 0 ) { mxm = Math . max ( mxm , dp [ j ] ) ; } } dp [ i ] = 1 + mxm ; } return Math . max ( ... dp ) ; }
function maxSum ( mat , n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ] ; let dp = new Array ( n ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } let maxSum = Number . MIN_VALUE , max ; for ( let j = 0 ; j < n ; j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) { for ( let j = 0 ; j < n ; j ++ ) { max = Number . MIN_VALUE ; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 ] ) ) max = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1 ] ) ) max = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + max ; } } for ( let j = 0 ; j < n ; j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ] ; return maxSum ; }
function answer ( n ) { let dp = new Array ( n + 1 ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } if ( n == 1 ) return 10 ; for ( let j = 0 ; j <= 9 ; j ++ ) dp [ 1 ] [ j ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } } let sum = 0 ; for ( let j = 1 ; j <= 9 ; j ++ ) sum += dp [ n ] [ j ] ; return sum ; }
function isSubSeqDivisible ( str ) { let i , j , k , l = str . length ; let arr = [ ] ; for ( i = 0 ; i < l ; i ++ ) arr [ i ] = str [ i ] - ' ' ; for ( i = 0 ; i < l ; i ++ ) { for ( j = i ; j < l ; j ++ ) { for ( k = j ; k < l ; k ++ ) { if ( arr [ i ] % 8 == 0 ) return true ; else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ; else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ; } } } return false ; }
function maxLength ( s , n ) { let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n - 1 ; i ++ ) if ( s [ i ] == ' ' && s [ i + 1 ] == ' ' ) dp [ i ] [ i + 1 ] = 2 ; for ( let l = 2 ; l < n ; l ++ ) { for ( let i = 0 , j = l ; j < n ; i ++ , j ++ ) { if ( s [ i ] == ' ' && s [ j ] == ' ' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; for ( let k = i ; k < j ; k ++ ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ; } } return dp [ 0 ] [ n - 1 ] ; }
function numberOfWays ( x ) { if ( x == 0 x == 1 ) return 1 ; else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; }
function numberOfWays ( x ) { let dp = Array ( x + 1 ) . fill ( 0 ) ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
function alternateSubarray ( arr , n ) { let len = new Array ( n ) ; len [ n - 1 ] = 1 ; for ( let i = n - 2 ; i >= 0 ; -- i ) { if ( arr [ i ] ^ arr [ i + 1 ] == 1 ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } for ( let i = 0 ; i < n ; ++ i ) document . write ( len [ i ] + " " ) ; }
function productSubSeqCount ( arr , k ) { let n = arr . length ; let dp = new Array ( k + 1 ) ; for ( let i = 0 ; i < k + 1 ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= k ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; if ( arr [ j - 1 ] <= i && arr [ j - 1 ] > 0 ) dp [ i ] [ j ] += dp [ parseInt ( i / arr [ j - 1 ] , 10 ) ] [ j - 1 ] + 1 ; } } return dp [ k ] [ n ] ; }
function minCells ( mat , m , n ) { let dp = new Array ( m ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i < m ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = Number . MAX_VALUE ; dp [ 0 ] [ 0 ] = 1 ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( dp [ i ] [ j ] != Number . MAX_VALUE && ( j + mat [ i ] [ j ] ) < n && ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 ; if ( dp [ i ] [ j ] != Number . MAX_VALUE && ( i + mat [ i ] [ j ] ) < m && ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 ; } } if ( dp [ m - 1 ] [ n - 1 ] != Number . MAX_VALUE ) return dp [ m - 1 ] [ n - 1 ] ; return - 1 ; }
function maxSumBitonicSubArr ( arr , n ) { let msis = new Array ( n ) ; msis . fill ( 0 ) ; let msds = new Array ( n ) ; msds . fill ( 0 ) ; let max_sum = Number . MIN_VALUE ; msis [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ i - 1 ] + arr [ i ] ; else msis [ i ] = arr [ i ] ; msds [ n - 1 ] = arr [ n - 1 ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ i + 1 ] + arr [ i ] ; else msds [ i ] = arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) max_sum = msis [ i ] + msds [ i ] - arr [ i ] ; return max_sum ; }
function countWays ( n ) { let dp = new Array ( 2 ) ; for ( let i = 0 ; i < 2 ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; } dp [ 0 ] [ 1 ] = 1 ; dp [ 1 ] [ 1 ] = 2 ; for ( let i = 2 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ; dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ; } return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ; }
function countways ( n ) { let A = new Array ( n + 1 ) . fill ( 0 ) ; A [ 0 ] = 1 ; A [ 1 ] = 3 ; A [ 2 ] = 7 ; for ( let i = 2 ; i <= n ; i ++ ) { A [ i ] = 2 * A [ i - 1 ] + A [ i - 2 ] ; } return A [ n ] ; }
function maxLenSub ( arr , n ) { let mls = new Array ( n ) . fill ( 1 ) , max = 0 ; for ( let i = 0 ; i < n ; i ++ ) mls [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( Math . abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ; return max ; }
function findWinner ( x , y , n ) { var dp = Array ( n + 1 ) . fill ( 0 ) ; dp [ 0 ] = false ; dp [ 1 ] = true ; for ( var i = 2 ; i <= n ; i ++ ) { if ( i - 1 >= 0 && ! dp [ i - 1 ] ) dp [ i ] = true ; else if ( i - x >= 0 && ! dp [ i - x ] ) dp [ i ] = true ; else if ( i - y >= 0 && ! dp [ i - y ] ) dp [ i ] = true ; else dp [ i ] = false ; } return dp [ n ] ; }
function maxGameByWinner ( N ) { let dp = new Array ( N ) . fill ( 0 ) ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; let i = 2 ; do { dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; } while ( dp [ i ++ ] <= N ) ; return ( i - 2 ) ; }
function isSubsetSum ( arr , n , sum ) { let subset = new Array ( 2 ) ; for ( var i = 0 ; i < subset . length ; i ++ ) { subset [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) subset [ i % 2 ] [ j ] = true ; else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } return subset [ n % 2 ] [ sum ] ; }
function isPossible ( elements , sum ) { var dp = [ sum + 1 ] ; dp [ 0 ] = 1 ; for ( var i = 0 ; i < elements . length ; i ++ ) { for ( var j = sum ; j >= elements [ i ] ; j -- ) { if ( dp [ j - elements [ i ] ] == 1 ) dp [ j ] = 1 ; } } if ( dp [ sum ] == 1 ) return true ; return false ; }
function minRemove ( arr , n ) { let LIS = new Array ( n ) . fill ( 0 ) ; let len = 0 ; for ( let i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) LIS [ i ] = Math . max ( LIS [ i ] , LIS [ j ] + 1 ) ; } len = Math . max ( len , LIS [ i ] ) ; } return n - len ; }
function smallestSumSubarr ( arr , n ) { let min_ending_here = 2147483647 ; let min_so_far = 2147483647 ; for ( let i = 0 ; i < n ; i ++ ) { if ( min_ending_here > 0 ) min_ending_here = arr [ i ] ; else min_ending_here += arr [ i ] ; min_so_far = Math . min ( min_so_far , min_ending_here ) ; } return min_so_far ; }
function nonDecNums ( n ) { let a = new Array ( n + 1 ) for ( let i = 0 ; i < n + 1 ; i ++ ) { a [ i ] = new Array ( 10 ) ; } for ( let i = 0 ; i <= 9 ; i ++ ) a [ 0 ] [ i ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) a [ i ] [ 9 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 8 ; j >= 0 ; j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; return a [ n ] [ 0 ] ; }
function countWays ( n , k ) { let total = k ; let mod = 1000000007 ; let same = 0 , diff = k ; for ( let i = 2 ; i <= n ; i ++ ) { same = diff ; diff = total * ( k - 1 ) ; diff = diff % mod ; total = ( same + diff ) % mod ; } return total ; }
function countBT ( h ) { let dp = new Array ( h + 1 ) ; dp . fill ( 0 ) ; dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( let i = 2 ; i <= h ; ++ i ) dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD ; return dp [ h ] ; }
function minTimeForWritingChars ( N , insert , remove , copy ) { if ( N == 0 ) return 0 ; if ( N == 1 ) return insert ; let dp = new Array ( N + 1 ) ; for ( let i = 0 ; i < N + 1 ; i ++ ) dp [ i ] = 0 ; dp [ 1 ] = insert ; for ( let i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) dp [ i ] = Math . min ( dp [ i - 1 ] + insert , dp [ parseInt ( i / 2 , 10 ) ] + copy ) ; else dp [ i ] = Math . min ( dp [ i - 1 ] + insert , dp [ parseInt ( ( i + 1 ) / 2 , 10 ) ] + copy + remove ) ; } return dp [ N ] ; }
function countPaths ( n , m ) { if ( n == 0 m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; }
function countPaths ( n , m ) { var dp = Array ( n + 1 ) . fill ( 0 ) . map ( x => Array ( m + 1 ) . fill ( 0 ) ) ; for ( i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( i = 1 ; i <= n ; i ++ ) for ( j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; }
function sumOfSubstrings ( num ) { let sum = 0 ; let mf = 1 ; for ( let i = num . length - 1 ; i >= 0 ; i -- ) { sum += ( num [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) * ( i + 1 ) * mf ; mf = mf * 10 + 1 ; } return sum ; }
function countWays ( n , m ) { let count = new Array ( n + 1 ) ; count [ 0 ] = 0 ; let i ; for ( i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m i == 1 ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; }
function maxSum ( grid , n ) { let incl = Math . max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ; let excl = 0 , excl_new ; for ( let i = 1 ; i < n ; i ++ ) { excl_new = Math . max ( excl , incl ) ; incl = excl + Math . max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) ; excl = excl_new ; } return Math . max ( excl , incl ) ; }
function getTotalNumberOfSequences ( m , n ) { if ( m < n ) return 0 ; if ( n == 0 ) return 1 ; return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ; }
function getTotalNumberOfSequences ( m , n ) { let T = new Array ( m + 1 ) ; for ( let i = 0 ; i < m + 1 ; i ++ ) { T [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { if ( i == 0 j == 0 ) T [ i ] [ j ] = 0 ; else if ( i < j ) T [ i ] [ j ] = 0 ; else if ( j == 1 ) T [ i ] [ j ] = i ; else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ parseInt ( i / 2 , 10 ) ] [ j - 1 ] ; } } return T [ m ] [ n ] ; }
function minInsertionStepToSortArray ( arr , N ) { let lis = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { lis [ i ] = 1 ; } for ( let i = 1 ; i < N ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) { lis [ i ] = lis [ j ] + 1 ; } } } let max = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( max < lis [ i ] ) { max = lis [ i ] ; } } return ( N - max ) ; }
function printDistinct ( str ) { let count = new Array ( NO_OF_CHARS ) ; for ( let i = 0 ; i < NO_OF_CHARS ; i ++ ) { count [ i ] = 0 ; } let i ; for ( i = 0 ; i < str . length ; i ++ ) if ( str [ i ] != ' ' ) count [ str [ i ] . charCodeAt ( 0 ) ] ++ ; let n = i ; for ( i = 0 ; i < n ; i ++ ) if ( count [ str [ i ] . charCodeAt ( 0 ) ] == 1 ) document . write ( str [ i ] ) ; }
function countWaysToJump ( arr , n ) { let count_jump = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { count_jump [ i ] = 0 ; } for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ; for ( let j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += count_jump [ j ] ; if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( count_jump [ i ] + " " ) ; }
function minStepToDeleteString ( str ) { let N = str . length ; let dp = new Array ( N + 1 ) ; for ( let i = 0 ; i <= N ; i ++ ) { dp [ i ] = new Array ( N + 1 ) ; for ( let j = 0 ; j <= N ; j ++ ) dp [ i ] [ j ] = 0 ; } for ( let len = 1 ; len <= N ; len ++ ) { for ( let i = 0 , j = len - 1 ; j < N ; i ++ , j ++ ) { if ( len == 1 ) dp [ i ] [ j ] = 1 ; else { dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ; if ( str [ i ] == str [ i + 1 ] ) dp [ i ] [ j ] = Math . min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ; for ( let K = i + 2 ; K <= j ; K ++ ) if ( str [ i ] == str [ K ] ) dp [ i ] [ j ] = Math . min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) ; } } } return dp [ 0 ] [ N - 1 ] ; }
function solve ( i , par , a , n , k , current_ans ) { if ( par > k ) return ; if ( par == k && i == n - 1 ) { ans = Math . min ( ans , current_ans ) ; return ; } for ( let j = i + 1 ; j < n ; j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; }
function minCost ( a , n , k ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( k + 1 ) ; for ( let j = 0 ; j <= k ; j ++ ) dp [ i ] [ j ] = inf ; } dp [ 0 ] [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= k ; j ++ ) for ( let m = i - 1 ; m >= 0 ; m -- ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ; return dp [ n ] [ k ] ; }
function modularSum ( arr , n , m ) { if ( n > m ) return true ; let DP = new Array ( m ) ; for ( let l = 0 ; l < m ; l ++ ) DP [ l ] = false ; for ( let i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; let temp = new Array ( m ) ; for ( let l = 0 ; l < m ; l ++ ) temp [ l ] = false ; for ( let j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( let j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; }
function solve ( n ) { if ( n < 0 ) return 0 ; if ( n == 0 ) return 1 ; return solve ( n - 1 ) + solve ( n - 3 ) + solve ( n - 5 ) ; }
function solve ( n ) { if ( n < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; return dp [ n ] = solve ( n - 1 ) + solve ( n - 3 ) + solve ( n - 5 ) ; }
function countSubsequences ( s ) { let aCount = 0 ; let bCount = 0 ; let cCount = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == ' ' ) aCount = ( 1 + 2 * aCount ) ; else if ( s [ i ] == ' ' ) bCount = ( aCount + 2 * bCount ) ; else if ( s [ i ] == ' ' ) cCount = ( bCount + 2 * cCount ) ; } return cCount ; }
function maximumDifferenceSum ( arr , N ) { let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ; for ( let i = 0 ; i < ( N - 1 ) ; i ++ ) { dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + Math . abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] + Math . abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + Math . abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return Math . max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; }
function countStr ( n , bCount , cCount ) { if ( bCount < 0 cCount < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( bCount == 0 && cCount == 0 ) return 1 ; let res = countStr ( n - 1 , bCount , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount ) ; res += countStr ( n - 1 , bCount , cCount - 1 ) ; return res ; }
function maxRevenue ( m , x , revenue , n , t ) { let maxRev = new Array ( m + 1 ) ; for ( let i = 0 ; i < m + 1 ; i ++ ) maxRev [ i ] = 0 ; let nxtbb = 0 ; for ( let i = 1 ; i <= m ; i ++ ) { if ( nxtbb < n ) { if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] ; else { if ( i <= t ) maxRev [ i ] = Math . max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ; else maxRev [ i ] = Math . max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; nxtbb ++ ; } } else maxRev [ i ] = maxRev [ i - 1 ] ; } return maxRev [ m ] ; }
function getMaxGold ( gold , m , n ) { let goldTable = new Array ( m ) ; for ( let i = 0 ; i < m ; i ++ ) { goldTable [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { goldTable [ i ] [ j ] = 0 ; } } for ( let col = n - 1 ; col >= 0 ; col -- ) { for ( let row = 0 ; row < m ; row ++ ) { let right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; let right_up = ( row == 0 col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; let right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + Math . max ( right , Math . max ( right_up , right_down ) ) ; } } let res = goldTable [ 0 ] [ 0 ] ; for ( let i = 1 ; i < m ; i ++ ) res = Math . max ( res , goldTable [ i ] [ 0 ] ) ; return res ; }
function largestKSubmatrix ( a ) { let dp = new Array ( Row ) ; for ( let i = 0 ; i < Row ; i ++ ) { dp [ i ] = new Array ( Col ) ; for ( let j = 0 ; j < Col ; j ++ ) { dp [ i ] [ j ] = 0 ; } } let result = 0 ; for ( let i = 0 ; i < Row ; i ++ ) { for ( let j = 0 ; j < Col ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 1 ; else { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] && dp [ i - 1 ] [ j ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i - 1 ] [ j ] : ( dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j ] && dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i ] [ j - 1 ] : dp [ i - 1 ] [ j - 1 ] + 1 ; } else dp [ i ] [ j ] = 1 ; } result = result > dp [ i ] [ j ] ? result : dp [ i ] [ j ] ; } } return result ; }
function countDivisibleSubseq ( str , n ) { let len = str . length ; let dp = new Array ( len ) ; for ( let i = 0 ; i < len ; i ++ ) { dp [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ ( str [ 0 ] - ' ' ) % n ] ++ ; for ( let i = 1 ; i < len ; i ++ ) { dp [ i ] [ ( str [ i ] - ' ' ) % n ] ++ ; for ( let j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; dp [ i ] [ ( j * 10 + ( str [ i ] - ' ' ) ) % n ] += dp [ i - 1 ] [ j ] ; } } return dp [ len - 1 ] [ 0 ] ; }
function MaximumPath ( Mat ) { let result = 0 ; let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( N + 2 ) ; for ( let j = 0 ; j < N + 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < N ; i ++ ) dp [ 0 ] [ i + 1 ] = Mat [ 0 ] [ i ] ; for ( let i = 1 ; i < N ; i ++ ) for ( let j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j - 1 ] , Math . max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] ; for ( let i = 0 ; i <= N ; i ++ ) result = Math . max ( result , dp [ N - 1 ] [ i ] ) ; return result ; }
function countStrings ( n , k ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] = new Array ( k + 1 ) ; for ( let j = 0 ; j < k + 1 ; j ++ ) { dp [ i ] [ j ] = new Array ( 2 ) ; for ( let l = 0 ; l < 2 ; l ++ ) { dp [ i ] [ j ] [ l ] = 0 ; } } } dp [ 1 ] [ 0 ] [ 0 ] = 1 ; dp [ 1 ] [ 0 ] [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { for ( let j = 0 ; j < i && j < k + 1 ; j ++ ) { dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ; dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ; if ( j - 1 >= 0 ) { dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ; } } } return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ; }
function canVote ( a , n , x ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] = new Array ( x + 1 ) ; for ( let j = 0 ; j < x + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += a [ i ] ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= x ; j ++ ) if ( a [ i ] <= j ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , a [ i ] + dp [ i - 1 ] [ j - a [ i ] ] ) ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; return ( sum - dp [ n ] [ x ] <= x ) ; } let n = 3 , x = 4 ; let a = [ 2 , 4 , 2 ] ; if ( canVote ( a , n , x ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function countFriendsPairings ( n ) { let dp = [ ] ; for ( let i = 0 ; i <= n ; i ++ ) { if ( i <= 2 ) dp [ i ] = i ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; }
function countFriendsPairings ( n ) { if ( dp [ n ] != - 1 ) return dp [ n ] ; if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ; else return dp [ n ] = n ; }
function maxPathSum ( tri , m , n ) { for ( let i = m - 1 ; i >= 0 ; i -- ) { for ( let j = 0 ; j <= i ; j ++ ) { if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; } } return tri [ 0 ] [ 0 ] ; }
function findMaxPoints ( A ) { let P1S = new Array ( M + 2 ) ; let P1E = new Array ( M + 2 ) ; let P2S = new Array ( M + 2 ) ; let P2E = new Array ( M + 2 ) ; for ( let i = 0 ; i < M + 2 ; i ++ ) { P1S [ i ] = new Array ( N + 2 ) ; P1E [ i ] = new Array ( N + 2 ) ; P2S [ i ] = new Array ( N + 2 ) ; P2E [ i ] = new Array ( N + 2 ) ; for ( let j = 0 ; j < N + 2 ; j ++ ) { P1S [ i ] [ j ] = 0 ; P1E [ i ] [ j ] = 0 ; P2S [ i ] [ j ] = 0 ; P2E [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= N ; i ++ ) for ( let j = 1 ; j <= M ; j ++ ) P1S [ i ] [ j ] = Math . max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( let i = N ; i >= 1 ; i -- ) for ( let j = M ; j >= 1 ; j -- ) P1E [ i ] [ j ] = Math . max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( let i = N ; i >= 1 ; i -- ) for ( let j = 1 ; j <= M ; j ++ ) P2S [ i ] [ j ] = Math . max ( P2S [ i + 1 ] [ j ] , P2S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( let i = 1 ; i <= N ; i ++ ) for ( let j = M ; j >= 1 ; j -- ) P2E [ i ] [ j ] = Math . max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; let ans = 0 ; for ( let i = 2 ; i < N ; i ++ ) { for ( let j = 2 ; j < M ; j ++ ) { let op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] + P2S [ i + 1 ] [ j ] + P2E [ i - 1 ] [ j ] ; let op2 = P1S [ i - 1 ] [ j ] + P1E [ i + 1 ] [ j ] + P2S [ i ] [ j - 1 ] + P2E [ i ] [ j + 1 ] ; ans = Math . max ( ans , Math . max ( op1 , op2 ) ) ; } } return ans ; }
function MaxDotProduct ( A , B , m , n ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < ( n + 1 ) ; i ++ ) { dp [ i ] = new Array ( m + 1 ) ; for ( let j = 0 ; j < m + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= n ; i ++ ) for ( let j = i ; j <= m ; j ++ ) dp [ i ] [ j ] = Math . max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) ; return dp [ n ] [ m ] ; }
function lcsOf3 ( X , Y , Z , m , n , o ) { let L = new Array ( m + 1 ) ; for ( let i = 0 ; i < m + 1 ; i ++ ) { L [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { L [ i ] [ j ] = new Array ( o + 1 ) ; for ( let k = 0 ; k < o + 1 ; k ++ ) { L [ i ] [ j ] [ k ] = 0 ; } } } for ( let i = 0 ; i <= m ; i ++ ) { for ( let j = 0 ; j <= n ; j ++ ) { for ( let k = 0 ; k <= o ; k ++ ) { if ( i == 0 j == 0 k == 0 ) L [ i ] [ j ] [ k ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] == Z [ k - 1 ] ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; else L [ i ] [ j ] [ k ] = Math . max ( Math . max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ; } } } return L [ m ] [ n ] [ o ] ; }
function printDistSum ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; var dp = Array . from ( Array ( n + 1 ) , ( ) => Array ( sum + 1 ) . fill ( 0 ) ) ; for ( var i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = true ; for ( var i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i - 1 ] ] = true ; for ( var j = 1 ; j <= sum ; j ++ ) { if ( dp [ i - 1 ] [ j ] == true ) { dp [ i ] [ j ] = true ; dp [ i ] [ j + arr [ i - 1 ] ] = true ; } } } for ( var j = 0 ; j <= sum ; j ++ ) if ( dp [ n ] [ j ] == true ) document . write ( j + " " ) ; }
function printMaxSum ( arr , n ) { let dp = new Array ( n ) ; dp . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; let maxi = 0 ; for ( let j = 1 ; j <= Math . sqrt ( i + 1 ) ; j ++ ) { if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) { if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ] ; if ( dp [ parseInt ( ( i + 1 ) / j , 10 ) - 1 ] > maxi && j != 1 ) maxi = dp [ parseInt ( ( i + 1 ) / j , 10 ) - 1 ] ; } } dp [ i ] += maxi ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( dp [ i ] + " " ) ; }
function minSum ( arr , n ) { let dp = [ ] ; if ( n == 1 ) return arr [ 0 ] ; if ( n == 2 ) return Math . min ( arr [ 0 ] , arr [ 1 ] ) ; if ( n == 3 ) return Math . min ( arr [ 0 ] , Math . min ( arr [ 1 ] , arr [ 2 ] ) ) ; if ( n == 4 ) return Math . min ( Math . min ( arr [ 0 ] , arr [ 1 ] ) , Math . min ( arr [ 2 ] , arr [ 3 ] ) ) ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = arr [ 1 ] ; dp [ 2 ] = arr [ 2 ] ; dp [ 3 ] = arr [ 3 ] ; for ( let i = 4 ; i < n ; i ++ ) dp [ i ] = arr [ i ] + Math . min ( Math . min ( dp [ i - 1 ] , dp [ i - 2 ] ) , Math . min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) ; return Math . min ( Math . min ( dp [ n - 1 ] , dp [ n - 2 ] ) , Math . min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) ; }
function minSum ( ar , n ) { if ( n <= 4 ) return Math . min . apply ( Math , ar ) ; var i ; var sum = Array ( n ) . fill ( n ) ; sum [ 0 ] = ar [ 0 ] ; sum [ 1 ] = ar [ 1 ] ; sum [ 2 ] = ar [ 2 ] ; sum [ 3 ] = ar [ 3 ] ; for ( i = 4 ; i < n ; i ++ ) { var temp = [ ] ; var it ; for ( it = i - 4 ; it < i ; it ++ ) temp . push ( sum [ it ] ) ; sum [ i ] = ar [ i ] + Math . min . apply ( Math , temp ) ; } var temp1 = [ ] ; for ( i = n - 4 ; i < n ; i ++ ) temp1 . push ( sum [ i ] ) ; return Math . min . apply ( Math , temp1 ) ; }
function longestSubseqWithDiffOne ( arr , n ) { let dp = [ ] ; for ( let i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } } let result = 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ; return result ; }
function maxSumWO3Consec ( arr , n ) { let sum = [ ] ; if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ; if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ; if ( n > 2 ) sum [ 2 ] = Math . max ( sum [ 1 ] , Math . max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ; for ( let i = 3 ; i < n ; i ++ ) sum [ i ] = Math . max ( Math . max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ; return sum [ n - 1 ] ; }
function maxSumWO3Consec ( n ) { if ( sum [ n ] != - 1 ) { return sum [ n ] ; } if ( n == 0 ) { return sum [ n ] = 0 ; } if ( n == 1 ) { return sum [ n ] = arr [ 0 ] ; } if ( n == 2 ) { return sum [ n ] = arr [ 1 ] + arr [ 0 ] ; } return sum [ n ] = 500 + Math . max ( Math . max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n ] ) , arr [ n ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ; }
function pad ( n ) { let pPrevPrev = 1 ; let pPrev = 1 ; let pCurr = 1 ; let pNext = 1 ; for ( let i = 3 ; i <= n ; i ++ ) { pNext = pPrevPrev + pPrev ; pPrevPrev = pPrev ; pPrev = pCurr ; pCurr = pNext ; } return pNext ; }
function maxSumPairWithDifferenceLessThanK ( arr , N , K ) { arr . sort ( ) ; let dp = [ ] ; dp [ 0 ] = 0 ; for ( let i = 1 ; i < N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; if ( arr [ i ] - arr [ i - 1 ] < K ) { if ( i >= 2 ) dp [ i ] = Math . max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; else dp [ i ] = Math . max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; } } return dp [ N - 1 ] ; }
function maxSumPairWithDifferenceLessThanK ( arr , N , k ) { var maxSum = 0 ; arr . sort ( ( a , b ) => a - b ) ; for ( i = N - 1 ; i > 0 ; -- i ) { if ( arr [ i ] - arr [ i - 1 ] < k ) { maxSum += arr [ i ] ; maxSum += arr [ i - 1 ] ; -- i ; } } return maxSum ; }
function lucas ( n ) { let a = 2 , b = 1 , c , i ; if ( n == 0 ) return a ; for ( i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return b ; }
function maxAverageOfPath ( cost , N ) { let dp = new Array ( N + 1 ) ; for ( let i = 0 ; i < N + 1 ; i ++ ) { dp [ i ] = new Array ( N + 1 ) ; for ( let j = 0 ; j < N + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( let j = 1 ; j < N ; j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( let i = 1 ; i < N ; i ++ ) for ( let j = 1 ; j < N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; }
function breakSum ( n ) { if ( n == 0 n == 1 ) return n ; return Math . max ( ( breakSum ( Math . floor ( n / 2 ) ) + breakSum ( Math . floor ( n / 3 ) ) + breakSum ( Math . floor ( n / 4 ) ) ) , n ) ; }
function breakSum ( n ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < dp ; i ++ ) { dp [ i ] = 0 ; } dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) dp [ i ] = Math . max ( dp [ Math . floor ( i / 2 ) ] + dp [ Math . floor ( i / 3 ) ] + dp [ Math . floor ( i / 4 ) ] , i ) ; return dp [ n ] ; }
function countPS ( str ) { let N = str . length ; let cps = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { cps [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { cps [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < N ; i ++ ) cps [ i ] [ i ] = 1 ; for ( let L = 2 ; L <= N ; L ++ ) { for ( let i = 0 ; i <= N - L ; i ++ ) { let k = L + i - 1 ; if ( str [ i ] == str [ k ] ) { cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ; } else { cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ; } } } return cps [ 0 ] [ N - 1 ] ; }
function countPS ( i , j ) { if ( i > j ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; if ( i == j ) return dp [ i ] [ j ] = 1 ; else if ( str [ i ] == str [ j ] ) return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ; else return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ; }
function maxCost ( mat , N ) { let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) for ( let j = 1 ; j < i + 1 && j < N ; j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + Math . max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; let result = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 1 ] [ i ] ; return result ; }
function numberOfPermWithKInversion ( N , K ) { if ( N == 0 ) return 0 ; if ( K == 0 ) return 1 ; if ( memo [ N ] [ K ] != 0 ) return memo [ N ] [ K ] ; let sum = 0 ; for ( let i = 0 ; i <= K ; i ++ ) { if ( i <= N - 1 ) sum += numberOfPermWithKInversion ( N - 1 , K - i ) ; } memo [ N ] [ K ] = sum ; return sum ; }
function countGroups ( position , previous_sum , length , num ) { if ( position == length ) return 1 ; let res = 0 ; let sum = 0 ; for ( let i = position ; i < length ; i ++ ) { sum += ( num [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } return res ; }
function countGroups ( position , previous_sum , length , num ) { if ( position == length ) return 1 ; if ( dp [ position ] [ previous_sum ] != - 1 ) return dp [ position ] [ previous_sum ] ; dp [ position ] [ previous_sum ] = 0 ; let res = 0 ; let sum = 0 ; for ( let i = position ; i < length ; i ++ ) { sum += ( num [ i ] - ' ' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } dp [ position ] [ previous_sum ] = res ; return res ; } let num = " " . split ( " " ) ; let len = num . length ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 9 * MAX + 1 ) for ( let j = 0 ; j < 9 * MAX + 1 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } }
function minCost ( cost , n ) { let dp = new Array ( n + 1 ) ; dp [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let min_cost = Number . MAX_VALUE ; for ( let j = 0 ; j < i ; j ++ ) if ( j < n ) min_cost = Math . min ( min_cost , cost [ j ] + dp [ i - j - 1 ] ) ; dp [ i ] = min_cost ; } return dp [ n ] ; }
function KnapSack ( val , wt , n , W ) { let dp = new Array ( W + 1 ) ; for ( let i = 0 ; i < W + 1 ; i ++ ) { dp [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) for ( let j = W ; j >= wt [ i ] ; j -- ) dp [ j ] = Math . max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; return dp [ W ] ; }
function count ( a , b , m , n ) { if ( ( m == 0 && n == 0 ) n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( a [ m - 1 ] == b [ n - 1 ] ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; }
function minAdjustmentCost ( A , n , target ) { let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( n ) ; for ( let j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let j = 0 ; j <= M ; j ++ ) dp [ 0 ] [ j ] = Math . abs ( j - A [ 0 ] ) ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = Number . MAX_VALUE ; let k = Math . max ( j - target , 0 ) ; for ( ; k <= Math . min ( M , j + target ) ; k ++ ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + Math . abs ( A [ i ] - j ) ) ; } } let res = Number . MAX_VALUE ; for ( let j = 0 ; j <= M ; j ++ ) res = Math . min ( res , dp [ n - 1 ] [ j ] ) ; return res ; }
function countIntegralSolutions ( n ) { let result = 0 ; for ( let i = 0 ; i <= n ; i ++ ) for ( let j = 0 ; j <= n - i ; j ++ ) for ( let k = 0 ; k <= ( n - i - j ) ; k ++ ) if ( i + j + k == n ) result ++ ; return result ; }
function countIntegralSolutions ( n ) { return Math . floor ( ( ( n + 1 ) * ( n + 2 ) ) / 2 ) ; }
function LCIS ( arr1 , n , arr2 , m ) { let table = [ ] ; for ( let j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let current = 0 ; for ( let j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ; if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } } let result = 0 ; for ( let i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; }
function minTime ( arr , n ) { if ( n <= 0 ) return 0 ; let incl = arr [ 0 ] ; let excl = 0 ; for ( let i = 1 ; i < n ; i ++ ) { let incl_new = arr [ i ] + Math . min ( excl , incl ) ; let excl_new = incl ; incl = incl_new ; excl = excl_new ; } return Math . min ( incl , excl ) ; }
function lcs ( X , Y ) { let m = X . length , n = Y . length ; let L = new Array ( 2 ) ; for ( let i = 0 ; i < 2 ; i ++ ) { L [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { L [ i ] [ j ] = 0 ; } } let bi = 0 ; for ( let i = 0 ; i <= m ; i ++ ) { bi = i & 1 ; for ( let j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ bi ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ; else L [ bi ] [ j ] = Math . max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) ; } } return L [ bi ] [ n ] ; }
function count ( n ) { let dp = [ ] ; dp [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( i >= 1 && i <= 3 ) dp [ i ] = 1 ; else if ( i == 4 ) dp [ i ] = 2 ; else { dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ; } } return dp [ n ] ; }
function subsetXOR ( arr , n , k ) { let max_ele = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; let m = ( 1 << parseInt ( Math . log ( max_ele ) / Math . log ( 2 ) + 1 , 10 ) ) - 1 ; if ( k > m ) { return 0 ; } let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( m + 1 ) ; for ( let j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 0 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] ; return dp [ n ] [ k ] ; }
function permutationCoeff ( n , k ) { let fact = new Array ( n + 1 ) ; fact [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; return parseInt ( fact [ n ] / fact [ n - k ] , 10 ) ; }
function countDer ( n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ; }
function countDer ( n ) { let der = new Array ( n + 1 ) ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( let i = 3 ; i <= n ; ++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; }
function countP ( n , k ) { if ( n == 0 k == 0 k > n ) return 0 ; if ( k == 1 k == n ) return 1 ; return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) ; }
function countP ( n , k ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] = new Array ( k + 1 ) ; for ( let j = 0 ; j < k + 1 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } for ( let i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( let i = 0 ; i <= k ; i ++ ) dp [ 0 ] [ k ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= k ; j ++ ) if ( j == 1 i == j ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ; return dp [ n ] [ k ] ; }
function bellNumber ( n ) { let bell = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { bell [ i ] = new Array ( n + 1 ) ; } bell [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] ; for ( let j = 1 ; j <= i ; j ++ ) bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] ; } return bell [ n ] [ 0 ] ; }
function countSol ( coeff , start , end , rhs ) { if ( rhs == 0 ) return 1 ; let result = 0 ; for ( let i = start ; i <= end ; i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; return result ; }
function countSol ( coeff , n , rhs ) { let dp = new Array ( rhs + 1 ) ; dp . fill ( 0 ) ; dp [ 0 ] = 1 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = coeff [ i ] ; j <= rhs ; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ; return dp [ rhs ] ; }
function printCountRec ( dist ) { if ( dist < 0 ) return 0 ; if ( dist == 0 ) return 1 ; return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ; }
function printCountDP ( dist ) { let count = new Array ( dist + 1 ) ; count [ 0 ] = 1 ; if ( dist >= 1 ) count [ 1 ] = 1 ; if ( dist >= 2 ) count [ 2 ] = 2 ; for ( let i = 3 ; i <= dist ; i ++ ) count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ; return count [ dist ] ; }
function printCountDP ( dist ) { var ways = [ ] , n = dist ; ways . length = 3 ; ways [ 0 ] = 1 ; ways [ 1 ] = 1 ; ways [ 2 ] = 2 ; for ( var i = 3 ; i <= n ; i ++ ) ways [ i % 3 ] = ways [ ( i - 1 ) % 3 ] + ways [ ( i - 2 ) % 3 ] + ways [ ( i - 3 ) % 3 ] ; return ways [ n % 3 ] ; }
function countSeq ( n ) { let nCr = 1 , res = 1 ; for ( let r = 1 ; r <= n ; r ++ ) { nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; } return res ; }
function findLongestRepeatingSubSeq ( str ) { var n = str . length ; var dp = new Array ( n + 1 ) ; for ( var i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; for ( var j = 0 ; j <= n ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 1 ; j <= n ; j ++ ) { if ( ( str [ i - 1 ] == str [ j - 1 ] ) && ( i != j ) ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ n ] ; }
function steps ( source , step , dest ) { if ( Math . abs ( source ) > ( dest ) ) return Number . MAX_SAFE_INTEGER ; if ( source == dest ) return step ; let pos = steps ( source + step + 1 , step + 1 , dest ) ; let neg = steps ( source - step - 1 , step + 1 , dest ) ; return Math . min ( pos , neg ) ; }
function countNumbersWith4 ( n ) { if ( n < 4 ) return 0 ; let d = Math . floor ( Math . log10 ( n ) ) ; let a = new Array ( d + 2 ) ; for ( let i = 0 ; i < d + 2 ; i ++ ) { a [ i ] = 0 ; } a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( let i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 9 + Math . floor ( Math . ceil ( Math . pow ( 10 , i - 1 ) ) ) ; let p = Math . floor ( Math . ceil ( Math . pow ( 10 , d ) ) ) ; let msd = Math . floor ( n / p ) ; if ( msd == 4 ) return ( msd ) * a [ d ] + ( n % p ) + 1 ; if ( msd > 4 ) return ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ; return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) ; }
function numberOfPaths ( m , n ) { if ( m == 1 n == 1 ) return 1 ; return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ; }
function numberOfPaths ( m , n ) { var count = Array ( m ) . fill ( 0 ) . map ( x => Array ( n ) . fill ( 0 ) ) ; for ( i = 0 ; i < m ; i ++ ) count [ i ] [ 0 ] = 1 ; for ( j = 0 ; j < n ; j ++ ) count [ 0 ] [ j ] = 1 ; for ( i = 1 ; i < m ; i ++ ) { for ( j = 1 ; j < n ; j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] + count [ i - 1 ] [ j - 1 ] ; ; } return count [ m - 1 ] [ n - 1 ] ; }
function numberOfPaths ( m , n ) { var path = 1 ; for ( i = n ; i < ( m + n - 1 ) ; i ++ ) { path *= i ; path = parseInt ( path / ( i - n + 1 ) ) ; } return path ; }
function Solution ( A ) { let ans = 2 ; let n = A . length ; if ( n <= 2 ) { return n ; } let llap = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { llap [ i ] = 2 ; } A . sort ( function ( a , b ) { return a - b } ) ; for ( let j = n - 2 ; j >= 0 ; j -- ) { let i = j - 1 ; let k = j + 1 ; while ( i >= 0 && k < n ) { if ( A [ i ] + A [ k ] == ( 2 * A [ j ] ) ) { llap [ j ] = Math . max ( ( llap [ k ] + 1 ) , llap [ j ] ) ; ans = Math . max ( ans , llap [ j ] ) ; i -= 1 ; k += 1 ; } else if ( A [ i ] + A [ k ] < 2 * A [ j ] ) k += 1 ; else i -= 1 ; } } return ans ; }
function optimalStrategyOfGame ( arr , n ) { let table = new Array ( n ) ; let gap , i , j , x , y , z ; for ( let d = 0 ; d < n ; d ++ ) { table [ d ] = new Array ( n ) ; } for ( gap = 0 ; gap < n ; ++ gap ) { for ( i = 0 , j = gap ; j < n ; ++ i , ++ j ) { x = ( ( i + 2 ) <= j ) ? table [ i + 2 ] [ j ] : 0 ; y = ( ( i + 1 ) <= ( j - 1 ) ) ? table [ i + 1 ] [ j - 1 ] : 0 ; z = ( i <= ( j - 2 ) ) ? table [ i ] [ j - 2 ] : 0 ; table [ i ] [ j ] = Math . max ( arr [ i ] + Math . min ( x , y ) , arr [ j ] + Math . min ( y , z ) ) ; } } return table [ 0 ] [ n - 1 ] ; }
function findWays ( m , n , x ) { let table = new Array ( n + 1 ) ; for ( let i = 0 ; i < ( n + 1 ) ; i ++ ) { table [ i ] = new Array ( x + 1 ) ; for ( let j = 0 ; j < ( x + 1 ) ; j ++ ) { table [ i ] [ j ] = 0 ; } } for ( let j = 1 ; j <= m && j <= x ; j ++ ) table [ 1 ] [ j ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= x ; j ++ ) { for ( let k = 1 ; k < j && k <= m ; k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ; } } return table [ n ] [ x ] ; }
function findWays ( f , d , s ) { let mem = new Array ( d + 1 ) ; for ( let i = 0 ; i < ( d + 1 ) ; i ++ ) { mem [ i ] = new Array ( s + 1 ) ; for ( let j = 0 ; j < s + 1 ; j ++ ) { mem [ i ] [ j ] = 0 ; } } mem [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= d ; i ++ ) { for ( let j = i ; j <= s ; j ++ ) { mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] ; if ( j - f - 1 >= 0 ) mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] ; } } return mem [ d ] [ s ] ; }
function LCSubStr ( X , Y , m , n ) { var LCStuff = Array ( m + 1 ) . fill ( ) . map ( ( ) => Array ( n + 1 ) . fill ( 0 ) ) ; var result = 0 ; for ( i = 0 ; i <= m ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) LCStuff [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 ; result = Math . max ( result , LCStuff [ i ] [ j ] ) ; } else LCStuff [ i ] [ j ] = 0 ; } } return result ; }
function LCSubStr ( s , t , n , m ) { var dp = Array ( 2 ) . fill ( ) . map ( ( ) => Array ( m + 1 ) . fill ( 0 ) ) ; var res = 0 ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 1 ; j <= m ; j ++ ) { if ( s . charAt ( i - 1 ) == t . charAt ( j - 1 ) ) { dp [ i % 2 ] [ j ] = dp [ ( i - 1 ) % 2 ] [ j - 1 ] + 1 ; if ( dp [ i % 2 ] [ j ] > res ) res = dp [ i % 2 ] [ j ] ; } else dp [ i % 2 ] [ j ] = 0 ; } } return res ; }
function findMinInsertions ( str , l , h ) { if ( l > h ) return Number . MAX_VALUE ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( Math . min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) }
function isSubsetSum ( set , n , sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
function findPartition ( arr , n ) { var sum = 0 ; var i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; var part = Array ( parseInt ( sum / 2 ) + 1 ) . fill ( ) . map ( ( ) => Array ( n + 1 ) . fill ( 0 ) ) ; for ( i = 0 ; i <= n ; i ++ ) part [ 0 ] [ i ] = true ; for ( i = 1 ; i <= parseInt ( sum / 2 ) ; i ++ ) part [ i ] [ 0 ] = false ; for ( i = 1 ; i <= parseInt ( sum / 2 ) ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { part [ i ] [ j ] = part [ i ] [ j - 1 ] ; if ( i >= arr [ j - 1 ] ) part [ i ] [ j ] = part [ i ] [ j ] || part [ i - arr [ j - 1 ] ] [ j - 1 ] ; } } return part [ parseInt ( sum / 2 ) ] [ n ] ; }
function minCut ( a ) { var cut = new Array ( a . length ) ; var palindrome = new Array ( a . length ) ; for ( var i = 0 ; i < a . length ; i ++ ) { var minCut = i ; for ( var j = 0 ; j <= i ; j ++ ) { if ( a . charAt ( i ) == a . charAt ( j ) && ( i - j < 5 palindrome [ j + 1 ] [ i - 1 ] ) ) { palindrome [ j , i ] = true ; minCut = Math . min ( minCut , j == 0 ? 0 : ( cut [ j - 1 ] + 1 ) ) ; } } cut [ i ] = minCut ; } return cut [ a . length - 1 ] ; }
function lbs ( arr , n ) { let i , j ; let lis = new Array ( n ) for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; let lds = new Array ( n ) ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; let max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }
function maxSumIS ( arr , n ) { let i , j , max = 0 ; let msis = new Array ( n ) ; for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; }
function MatrixChainOrder ( p , i , j ) { if ( i == j ) return 0 ; var min = Number . MAX_VALUE ; var k = 0 ; for ( k = i ; k < j ; k ++ ) { var count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; }
function count ( S , m , n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; }
function checkArray ( arr , N , k ) { if ( N < 3 ) return - 1 ; let i , Sum = 0 , temp = 0 ; for ( i = 0 ; i < N ; i ++ ) Sum += arr [ i ] ; let R = ( k * k + k + 1 ) ; if ( Sum % R != 0 ) return 0 ; let Mid = k * ( Sum / R ) ; for ( i = 1 ; i < N - 1 ; i ++ ) { temp += arr [ i - 1 ] ; if ( arr [ i ] == Mid ) { if ( temp == Mid / k ) return i + 1 ; else return 0 ; } } return 0 ; }
function minumumOperation ( N , arr ) { let sum_arr = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sum_arr = sum_arr + arr [ i ] ; } if ( sum_arr >= N ) document . write ( sum_arr - N + " " ) ; else document . write ( 1 + " " ) ; }
function GenerateArray ( N , X ) { let prev_xor = X ; for ( let i = 1 ; i <= N ; i ++ ) { document . write ( ( i ^ prev_xor ) ) ; if ( i != N ) { document . write ( " " ) ; } prev_xor = i ; } }
function oddLengthPalindrome ( k ) { let palin = k ; k = Math . floor ( k / 10 ) ; while ( k > 0 ) { let rev = k % 10 ; palin = ( palin * 10 ) + rev ; k = Math . floor ( k / 10 ) ; } return palin ; }
function maxSubsequenceLen ( s , K ) { var N = s . length ; var start = 0 , end = 0 ; var S = s . split ( ' ' ) ; S . sort ( ) ; var ans = Number . MIN_VALUE , sum = 0 ; for ( end = 0 ; end < N ; end ++ ) { sum = sum + ( S [ end ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ; while ( sum + K < ( S [ end ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) * ( end - start + 1 ) ) { sum = sum - ( S [ start ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ; start ++ ; } ans = Math . max ( ans , end - start + 1 ) ; } document . write ( ans ) ; }
function findEquation ( A , B , C ) { document . write ( " " + C + " " + " " + B + " " + A + " " ) }
function findMinMoves ( arr , N ) { let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % N != 0 ) return - 1 ; let avg = sum / N ; let total = 0 ; let needCount = 0 ; for ( let i = 0 ; i < N ; i ++ ) { needCount += ( arr [ i ] - avg ) ; total = Math . max ( Math . max ( Math . abs ( needCount ) , arr [ i ] - avg ) , total ) ; } return total ; }
function totalCombination ( L , R ) { let count = 0 ; let K = R - L ; if ( K < L ) return 0 ; let ans = K - L ; count = ( ( ans + 1 ) * ( ans + 2 ) ) / 2 ; return count ; }
function checkPattern ( arr , m , k , n ) { let count = 1 , t = 0 ; for ( let i = 0 ; i < n - m ; i ++ ) { if ( arr [ i ] == arr [ i + m ] ) { t ++ ; if ( t == m ) { t = 0 ; count ++ ; if ( count == k ) { return " " ; } } } else { t = 0 ; count = 1 ; } } return " " ; }
function flipBitsOfAandB ( A , B ) { for ( i = 0 ; i < 32 ; i ++ ) { if ( ( ( A & ( 1 << i ) ) & ( B & ( 1 << i ) ) ) != 0 ) { A = A ^ ( 1 << i ) ; B = B ^ ( 1 << i ) ; } } document . write ( A + " " + B ) ; }
function flipBitsOfAandB ( A , B ) { A = A ^ ( A & B ) ; B = B ^ ( A & B ) ; document . write ( A + " " + B ) ; }
function isValid ( s ) { let n = Math . sqrt ( s . length ) ; let check = s [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) { let x = i , y = i ; while ( x >= 0 && y < n ) { if ( s [ ( n * x ) + y ] != check || s [ ( n * y ) + x ] != check ) { document . write ( " " ) ; return ; } x -- ; y ++ ; } } document . write ( " " ) ; }
function sumOfSubarrayProd ( arr , n ) { let ans = 0 ; let res = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { let incr = arr [ i ] * ( 1 + res ) ; ans += incr ; res = incr ; } document . write ( ans ) ; }
function OddLengthSum ( arr ) { var sum = 0 ; var l = arr . length ; for ( var i = 0 ; i < l ; i ++ ) { for ( var j = i ; j < l ; j += 2 ) { for ( var k = i ; k <= j ; k ++ ) { sum += arr [ k ] ; } } } return sum ; }
function OddLengthSum ( arr ) { let sum = 0 ; let l = arr . length ; for ( let i = 0 ; i < l ; i ++ ) { sum += Math . floor ( ( ( i + 1 ) * ( l - i ) + 1 ) / 2 ) * arr [ i ] ; } return sum ; }
function sameEulerTotient ( N ) { return ( N & 1 ) ; }
function evenSubMatrix ( N ) { let even = 1 ; let odd = 2 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { if ( ( i + j ) % 2 == 0 ) { document . write ( even + " " ) ; even += 2 ; } else { document . write ( odd + " " ) ; odd += 2 ; } } document . write ( " " ) ; } }
function removeLeadingZeros ( str ) { const regex = new RegExp ( " " , ' ' ) ; str = str . replaceAll ( regex , " " ) ; document . write ( str ) ; }
function TotalHammingDistance ( n ) { let i = 1 , sum = 0 ; while ( Math . floor ( n / i ) > 0 ) { sum = sum + Math . floor ( n / i ) ; i = i * 2 ; } return sum ; }
function maximum_inversion ( n , k ) { var answer = 0 ; k = Math . min ( k , parseInt ( n / 2 ) ) ; var left = 1 ; var right = n ; while ( k > 0 ) { k -- ; answer += 2 * ( right - left ) - 1 ; left ++ ; right -- ; } document . write ( answer + " " ) ; }
function possibleToReach ( x , y , z ) { if ( z < Math . abs ( x ) + Math . abs ( y ) || ( z - Math . abs ( x ) - Math . abs ( y ) ) % 2 == 1 ) { document . write ( " " + " " ) ; } else document . write ( " " + " " ) ; }
function nCycle ( N ) { return ( N ) * ( N - 1 ) + 1 ; }
function solve ( n ) { let s = 0 ; for ( let l = 1 ; l <= n ; ) { let r = ( n / Math . floor ( n / l ) ) ; let x = Math . floor ( ( ( r % m ) * ( ( r + 1 ) % m ) ) / 2 ) % m ; let y = Math . floor ( ( ( l % m ) * ( ( l - 1 ) % m ) ) / 2 ) % m ; let p = ( Math . floor ( n / l ) % m ) ; s = ( s + ( ( ( x - y ) % m ) * p ) % m + m ) % m ; s %= m ; l = r + 1 ; } document . write ( ( s + m ) % m ) ; }
function smallestNum ( N ) { x = Math . pow ( 10.0 , ( N - 1 ) / 2.0 ) ; return Math . ceil ( x ) ; }
function solve ( N ) { if ( N % 2 == 0 ) { document . write ( N / 2 + " " + N + " " ) ; } else { document . write ( ( N - 1 ) / 2 + " " + ( N - 1 ) + " " ) ; } }
function makeArray ( n ) { for ( var i = 1 ; i <= n ; i ++ ) document . write ( i * n + " " ) ; }
function printOddFactorNumber ( n , m ) { for ( let i = n ; i <= m ; i ++ ) { if ( ( i > 0 ) && ( ( i & ( i - 1 ) ) != 0 ) ) document . write ( i + " " ) ; } return 0 ; }
function printSeries ( n ) { let k = 2 ; for ( let i = 0 ; i < n ; i ++ ) { document . write ( ( k * ( 2 * k - 1 ) ) + " " ) ; k += 2 ; } document . writeln ( " " ) ; }
function min_time_to_cut ( N ) { if ( N == 0 ) return 0 ; return Math . ceil ( Math . log ( N ) / Math . log ( 2 ) ) ; }
function HogbenNumber ( a ) { let p = ( Math . pow ( a , 2 ) - a + 1 ) ; return p ; }
function countKCountdown ( arr , N , K ) { var flag = - 1 ; var count = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == K ) flag = K ; if ( arr [ i ] == flag ) flag -- ; else flag = - 1 ; if ( flag == 0 ) count ++ ; } return count ; }
function findDistinctSums ( n ) { s = new Set ( ) ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = i ; j <= n ; j ++ ) { s . add ( i + j ) ; } } return s . size ; }
function findDistinctSums ( N ) { return ( 2 * N - 1 ) ; }
function check_string_exist ( S ) { var size = S . length ; var check = true ; for ( var i = 0 ; i < size ; i ++ ) { if ( S [ i ] != S [ ( i + 2 ) % size ] ) { check = false ; break ; } } if ( check ) document . write ( " " ) ; else document . write ( " " ) ; }
function fib ( n ) { var f0 = 0 ; var f1 = 1 ; if ( n == 0 ) return 0 ; if ( n == 1 ) return 1 ; else { var rem = parseInt ( ( n % 60 ) ) ; if ( rem == 0 ) return 0 ; for ( i = 2 ; i < rem + 3 ; i ++ ) { var f = ( f0 + f1 ) % 60 ; f0 = f1 ; f1 = f ; } var s = f1 - 1 ; return s ; } }
function printSinX ( N ) { let Xi = 0 ; let num = 1 ; while ( N -- > 0 ) { document . write ( " " + num + " " + Xi ) ; document . write ( " " + num + " " ) ; document . write ( Math . sin ( Xi ) . toFixed ( 6 ) ) ; document . write ( " " ) ; num += 1 ; Xi += 710 ; } }
function nthTerm ( N ) { if ( N == 1 ) { return 2 ; } return ( ( N - 1 ) * 13 ) + nthTerm ( N - 1 ) ; }
function distinctSubstring ( P , Q , K , N ) { let S = new Set ( ) ; for ( let i = 0 ; i < N ; ++ i ) { let sum = 0 ; let s = " " ; for ( let j = i ; j < N ; ++ j ) { let pos = P [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ; sum += Q [ pos ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ; s += P [ j ] ; if ( sum <= K ) { S . add ( s ) ; } else { break ; } } } return S . size ; }
function distinctSubString ( P , Q , K , N ) { let S = new Set ( ) ; for ( let i = 0 ; i < N ; ++ i ) { let sum = 0 ; let s = " " ; for ( let j = i ; j < N ; ++ j ) { let pos = P [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ; sum += Q [ pos ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ; s += P [ j ] ; if ( sum <= K ) { S . add ( s ) ; } else { break ; } } } return S . size ; }
function isKAlternating ( s , k ) { if ( s . length < k ) return false ; var checker = 0 ; for ( var i = 0 ; i < k ; i ++ ) { var bitAtIndex = s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) { return false ; } checker = checker | ( 1 << bitAtIndex ) ; } for ( var i = k ; i < s . length ; i ++ ) if ( s [ i - k ] != s [ i ] ) return false ; return true ; }
function findNumbers ( n ) { let i = 1 ; while ( i <= n ) { document . write ( ( 3 * i * ( i - 1 ) + 1 ) + " " ) ; i ++ ; } }
function nthTerm ( N ) { let nth = 0 ; if ( N % 2 == 1 ) nth = ( N * N ) + 1 ; else nth = ( N * N ) - 1 ; return nth ; }
function nthTerm ( N ) { let nth = 0 , first_term = 12 ; nth = ( first_term * ( Math . pow ( 2 , N - 1 ) ) ) + 11 * ( ( Math . pow ( 2 , N - 1 ) ) - 1 ) ; return nth ; }
function nthTerm ( N ) { let nth = 0 , first_term = 4 ; let pi = 1 , po = 1 ; let n = N ; while ( n > 1 ) { pi *= n - 1 ; n -- ; po *= 2 ; } nth = ( first_term * pi ) / po ; return nth ; }
function findSum ( arr , n , k ) { if ( k <= n - 2 ) return ( arr [ n - 1 ] - arr [ 0 ] ) ; return 0 ; }
function squareDigitSum ( s ) { let lengthN = s . length ; let result = parseInt ( lengthN / 9 ) * 81 + Math . pow ( ( lengthN % 9 ) , 2 ) ; return result ; }
function getElement ( N , r , c ) { if ( r > c ) return 0 ; if ( r == 1 ) { return c ; } let a = ( r + 1 ) * parseInt ( Math . pow ( 2 , ( r - 2 ) ) ) ; let d = parseInt ( Math . pow ( 2 , ( r - 1 ) ) ) ; c = c - r ; let element = a + d * c ; return element ; }
function checkSequence ( a , b ) { if ( b . length == 0 ) return true ; if ( a . length == 0 ) return false ; if ( a [ 0 ] == b [ 0 ] ) return checkSequence ( a . substring ( 1 ) , b . substring ( 1 ) ) ; else return checkSequence ( a . substring ( 1 ) , b ) ; }
function updateString ( S , A , B ) { let l = A . length ; for ( let i = 0 ; i + l <= S . length ; i ++ ) { let curr = S . substring ( i , i + l ) ; if ( curr == A ) { let new_string = S . substring ( 0 , i ) + B + S . substring ( i + l ) ; S = new_string ; i += l - 1 ; } else { let new_string = S . substring ( 0 , i ) + A + S . substring ( i + l ) ; S = new_string ; i += l - 1 ; } } return S ; }
function findCount ( str1 , str2 ) { var len = str1 . length ; var len2 = str2 . length ; var ans = 21474836473 ; var hash1 = new Array ( 26 ) . fill ( 0 ) ; var hash2 = new Array ( 26 ) . fill ( 0 ) ; for ( var i = 0 ; i < len ; i ++ ) hash1 [ str1 [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < len2 ; i ++ ) hash2 [ str2 [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < 26 ; i ++ ) if ( hash2 [ i ] ) ans = Math . min ( ans , hash1 [ i ] / hash2 [ i ] ) ; return ans ; }
function getCount ( a , b ) { if ( b . length % a . length != 0 ) return - 1 ; var count = parseInt ( b . length / a . length ) ; var str = " " ; for ( i = 0 ; i < count ; i ++ ) { str = str + a ; } if ( str == ( b ) ) return count ; return - 1 ; }
function getSum ( n , d ) { if ( n < d ) return 0 ; while ( n % 10 != d ) n -- ; k = parseInt ( n / 10 ) ; return ( k + 1 ) * d + ( k * 10 + 10 * k * k ) / 2 ; }
function countDecreasing ( A , n ) { var len = 1 ; for ( var i = 0 ; i < n - 1 ; ++ i ) { if ( A [ i + 1 ] < A [ i ] ) len ++ ; else { cnt += parseInt ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += parseInt ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; }
function doMatch ( A , B ) { for ( i = 0 ; i < A . length ; i ++ ) { if ( A . charAt ( i ) != ' ' && B . charAt ( i ) != ' ' ) { if ( A . charAt ( i ) != B . charAt ( i ) ) return 0 ; } } return 1 ; }
function minimumChar ( S1 , S2 ) { let n = S1 . length ; let m = S2 . length ; let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < m - n + 1 ; i ++ ) { let minRemovedChar = 0 ; for ( let j = 0 ; j < n ; j ++ ) { if ( S1 [ j ] != S2 [ i + j ] ) { minRemovedChar ++ ; } } ans = Math . min ( minRemovedChar , ans ) ; } return ans ; }
function isSubstring ( s1 , s2 ) { var M = s1 . length ; var N = s2 . length ; for ( var i = 0 ; i <= N - M ; i ++ ) { var j ; for ( j = 0 ; j < M ; j ++ ) if ( s2 [ i + j ] != s1 [ j ] ) break ; if ( j == M ) return i ; } return - 1 ; }
function patternCount ( str ) { var last = str . charAt ( 0 ) ; var i = 1 , counter = 0 ; while ( i < str . length ) { if ( str . charAt ( i ) == ' ' && last == ' ' ) { while ( str . charAt ( i ) == ' ' ) i ++ ; if ( str . charAt ( i ) == ' ' ) counter ++ ; } last = str . charAt ( i ) ; i ++ ; } return counter ; }
function maxPrefix ( s , t ) { let count = 0 ; for ( let i = 0 ; i < t . length ; i ++ ) { if ( count == s . length ) break ; if ( t [ i ] == s [ count ] ) count ++ ; } return count ; }
function translate ( str ) { for ( let i = 1 ; i < str . length ; i ++ ) { if ( str [ i - 1 ] == ' ' && str [ i ] == ' ' ) { str [ i - 1 ] = ' ' ; let j ; for ( j = i ; j < str . length - 1 ; j ++ ) str [ j ] = str [ j + 1 ] ; str [ j ] = ' ' ; } } return ; }
function search ( pat , txt ) { let M = pat . length ; let N = txt . length ; let i = 0 ; while ( i <= N - M ) { let j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) { document . write ( " " + i + " " ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } }
function generateNumber ( number ) { let temp = 0 , adding_number = 0 ; let result = " " ; let len = number . length ; for ( let i = len - 1 ; i >= 0 ; i -- ) { let digit = parseInt ( number [ i ] ) ; if ( temp % 2 == 0 ) { adding_number += 1 ; digit += adding_number ; if ( digit >= 10 ) { digit %= 9 ; if ( digit == 0 ) digit = 9 ; } } result = ( digit ) . toString ( ) + result ; temp += 1 ; } return result ; }
function findString ( arr , N ) { let ans = " " ; for ( let i = 0 ; i < N ; i ++ ) { ans += arr [ i ] [ i ] == ' ' ? ' ' : ' ' ; } return ans ; }
function commonSubstring ( s ) { let n = s . length ; let i = 0 ; let j = n - 1 ; let ans = " " ; while ( j >= 0 ) { if ( s [ i ] == s [ j ] ) { ans += s [ i ] ; i ++ ; j -- ; } else { break ; } } if ( ans . length == 0 ) document . write ( " " ) ; else { document . write ( " " + " " + ans ) ; } }
function number_of_tower ( house , range , n ) { house . sort ( function ( a , b ) { return a - b ; } ) ; let numOfTower = 0 ; let i = 0 ; while ( i < n ) { numOfTower ++ ; let loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }
function maxlength ( s ) { let n = s . length , i , j ; let ans = 0 ; for ( i = 0 ; i <= n - 1 ; i ++ ) { if ( s [ i ] == ' ' ) { let count = 1 ; for ( j = i + 1 ; j <= n - 1 && s [ j ] == ' ' ; j ++ ) count ++ ; ans = Math . max ( ans , count ) ; } } return ans ; }
function maximumK ( S ) { let N = S . length ; let ans = N ; let flag = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { if ( S [ i ] != S [ i + 1 ] ) { flag = 1 ; ans = Math . min ( ans , Math . max ( i + 1 , N - i - 1 ) ) ; } } if ( flag == 0 ) return 0 ; return ans ; }
function generateLetters ( S , P , M ) { if ( P == S . length ) { document . write ( S + " " ) ; return ; } generateLetters ( S , P + 1 , M ) ; S = S . replace ( S . charAt ( P ) , M . get ( S [ P ] ) ) generateLetters ( S , P + 1 , M ) ; return ; }
function FindKthChar ( str , K , X ) { var ans = " " ; var sum = 0 ; for ( i = 0 ; i < str . length ; i ++ ) { var digit = parseInt ( str [ i ] ) ; var range = parseInt ( Math . pow ( digit , X ) ) ; sum += range ; if ( K <= sum ) { ans = str [ i ] ; break ; } } return ans ; }
function minimumHammingDistance ( S , K ) { let n = S . length ; let pref = new Array ( n ) ; pref [ 0 ] = S [ 0 ] - ' ' ; for ( let i = 1 ; i < n ; i ++ ) pref [ i ] = pref [ i - 1 ] + ( S [ i ] - ' ' ) ; let cnt = pref [ n - 1 ] ; let ans = cnt ; for ( let i = 0 ; i < n - K ; i ++ ) { let value = pref [ i + K - 1 ] - ( i - 1 >= 0 ? pref [ i - 1 ] : 0 ) ; ans = Math . min ( ans , cnt - value + ( K - value ) ) ; } return ans ; }
function isEqualSubstring ( str , x ) { let n = str . length ; let i = 0 ; while ( i < n && i < x ) { if ( str [ i ] !== str [ n - i - 1 ] ) { document . write ( " " ) ; return ; } i ++ ; } document . write ( " " ) ; }
function minimumOperations ( S , N ) { let ans = 0 ; let cntOne = 0 ; for ( let i = N - 1 ; i >= 0 ; i -- ) { if ( S [ i ] == ' ' ) { ans += cntOne ; cntOne *= 2 ; } else cntOne ++ ; } document . write ( ans ) ; }
function minOpsToEmptyString ( s ) { var ans = Number . MIN_VALUE ; var cn0 = 0 ; var cn1 = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( s . charAt ( i ) == ' ' ) { if ( cn1 > 0 ) cn1 -- ; cn0 ++ ; } else { if ( cn0 > 0 ) cn0 -- ; cn1 ++ ; } ans = Math . max ( ans , Math . max ( cn0 , cn1 ) ) ; } document . write ( ans ) ; }
function prefixDivisble ( n ) { let i = 1 ; while ( n > 0 ) { if ( n % i != 0 ) return false ; n = parseInt ( n / 10 ) ; i ++ ; } return true ; }
function zigzag ( s , rows ) { let interval = 2 * rows - 2 ; for ( let i = 0 ; i < rows ; i ++ ) { let step = interval - 2 * i ; for ( let j = i ; j < s . length ; j = j + interval ) { document . write ( s [ j ] ) ; if ( step > 0 && step < interval && step + j < s . length ) { for ( let k = 0 ; k < ( interval - rows - i ) ; k ++ ) document . write ( " " ) ; document . write ( s [ j + step ] ) ; for ( let k = 0 ; k < i - 1 ; k ++ ) document . write ( " " ) ; } else { for ( let k = 0 ; k < ( interval - rows ) ; k ++ ) document . write ( " " ) ; } } document . write ( " " ) ; } }
function findMinimumCost ( s , N ) { let count_1 = 0 , count_0 = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( s [ i ] == ' ' ) count_1 ++ ; else count_0 ++ ; } let k = Math . abs ( count_0 - count_1 ) ; if ( count_1 == N count_0 == N ) document . write ( - 1 ) ; else document . write ( k / 2 ) ; }
function countOccurrences ( S , X , Y ) { let count = 0 ; let N = S . length , A = X . length ; let B = Y . length ; for ( let i = 0 ; i < N ; i ++ ) { if ( S . substr ( i , B ) == Y ) count ++ ; if ( S . substr ( i , A ) == X ) document . write ( count , " " ) ; } }
function canMakeEqual ( S ) { var N = S . length ; var weightOfString = 0 ; for ( var i = 0 ; i < N ; i ++ ) { weightOfString += S . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) + 1 ; } if ( weightOfString % N == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function minLength ( S ) { var st = [ ] ; S . split ( ' ' ) . forEach ( ch => { if ( st . length == 0 ) st . push ( ch ) ; else { var top = st [ st . length - 1 ] ; if ( Math . abs ( ch - top ) == 1 ) st . pop ( ) ; else { st . push ( ch ) ; } } } ) ; return st . length ; }
function findMinimumTime ( tasks , K ) { var map = new Map ( ) ; var curr_time = 0 ; tasks . split ( ' ' ) . forEach ( c => { if ( map . has ( c ) ) { if ( curr_time - map . get ( c ) <= K ) { curr_time += K - ( curr_time - map . get ( c ) ) + 1 ; } } map . set ( c , curr_time ) ; curr_time ++ ; } ) ; document . write ( curr_time ) ; }
function getString ( N ) { let ans = " " while ( N >= 26 ) { ans += ' ' N -= 26 } ans += String . fromCharCode ( N + ' ' . charCodeAt ( 0 ) - 1 ) return ans }
function subString ( s , n ) { let hash = new Map ( ) ; hash . set ( 0 , 1 ) ; let pre = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { pre ^= ( 1 << s [ i ] . charCodeAt ( 0 ) - 97 ) ; if ( ! hash . has ( pre ) ) hash . set ( pre , 0 ) ; count += ( hash . get ( pre ) ) ; hash . set ( pre , hash . get ( pre ) == null ? 0 : hash . get ( pre ) + 1 ) ; } return count ; }
function countSamePrefixSuffix ( s , n ) { var prefix = " " ; for ( let i = 0 ; i < n - 1 ; i ++ ) { prefix += s . charAt ( i ) ; var suffix = s . substring ( n - 1 - i , n ) ; if ( prefix == suffix ) { document . write ( prefix . length + " " ) ; } } }
function atleastkDistinctChars ( s , k ) { let n = s . length ; let mp = new Map ( ) ; let begin = 0 , end = 0 ; let ans = 0 ; while ( end < n ) { let c = s [ end ] ; if ( mp . has ( c ) ) mp . set ( c , mp . get ( c ) + 1 ) ; else mp . set ( c , 1 ) ; end ++ ; while ( mp . size >= k ) { let pre = s [ begin ] ; mp . set ( pre , mp . get ( pre ) - 1 ) ; if ( mp . get ( pre ) == 0 ) { mp . delete ( pre ) ; } ans += s . length - end + 1 ; begin ++ ; } } document . write ( ans ) ; }
function canSplit ( S ) { let frequency = new Array ( 26 ) . fill ( 0 ) let cnt_singles = 0 let k = 0 for ( let i = 0 ; i < S . length ; i ++ ) { frequency [ S . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ] += 1 } let odd = 0 let eve = 0 for ( let i = 0 ; i < 26 ; i ++ ) { if ( frequency [ i ] ) { odd += ( frequency [ i ] & 1 ) } } if ( eve >= odd ) { document . write ( " " ) } else { document . write ( " " ) } }
function addASCII ( S , N ) { var newStr = new Array ( S . length ) ; for ( var i = 0 ; i < S . length ; i ++ ) { var a = N [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ; var b = S [ i ] . charCodeAt ( 0 ) + a ; if ( b > 122 ) b -= 26 ; newStr [ i ] = String . fromCharCode ( b ) ; } document . write ( newStr . join ( " " ) ) ; }
function countOperations ( X , Y , K ) { var count = 0 ; for ( var i = 0 ; i < X . length ; i ++ ) { var c = 0 ; if ( X [ i ] === Y [ i ] ) continue ; else if ( X [ i ] . charCodeAt ( 0 ) < Y [ i ] . charCodeAt ( 0 ) ) { if ( Y [ i ] . charCodeAt ( 0 ) - X [ i ] . charCodeAt ( 0 ) >= K ) { c = ( Y [ i ] . charCodeAt ( 0 ) - X [ i ] . charCodeAt ( 0 ) ) / K ; } c += ( Y [ i ] . charCodeAt ( 0 ) - X [ i ] . charCodeAt ( 0 ) ) % K ; } else { var t = 90 - X [ i ] . charCodeAt ( 0 ) ; t += Y [ i ] . charCodeAt ( 0 ) - 65 + 1 ; if ( t >= K ) { c = parseInt ( t / K ) ; } c += parseInt ( t % K ) ; } count = parseInt ( count + c ) ; } document . write ( count + " " ) ; }
function pendulumArrangement ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; var op = [ ... Array ( n ) ] ; var mid = parseInt ( ( n - 1 ) / 2 ) ; var j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; } if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ; document . write ( " " ) ; for ( i = 0 ; i < n ; i ++ ) document . write ( op [ i ] + " " ) ; document . write ( " " ) ; }
function countTotalFrequencies ( S1 , S2 ) { var bset = new Set ( ) ; for ( var i = 0 ; i < S1 . length ; i ++ ) { bset . add ( S1 [ i ] ) ; } var count = 0 ; for ( var i = 0 ; i < S2 . length ; i ++ ) { if ( bset . has ( S2 [ i ] ) ) count += 1 ; } document . write ( count ) ; }
function scoreOfParentheses ( s ) { var stack = [ ] ; stack . push ( 0 ) ; s . split ( ' ' ) . forEach ( c => { if ( c == ' ' ) stack . push ( 0 ) ; else { var tmp = stack [ stack . length - 1 ] ; stack . pop ( ) ; var val = 0 ; if ( tmp > 0 ) val = tmp * 2 ; else val = 1 ; stack [ stack . length - 1 ] += val ; } } ) ; document . write ( stack [ stack . length - 1 ] ) ; }
function make_palindrome ( S1 , S2 , S3 ) { let maskA = 0 , maskC = 0 ; for ( let i = 0 ; i < S1 . length ; i ++ ) maskA |= ( 1 << ( S1 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ) ; for ( let i = 0 ; i < S3 . length ; i ++ ) maskC |= ( 1 << ( S3 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ) ; if ( ( maskA & maskC ) > 0 ) return " " ; return " " ; }
function maximum_pallindromic ( arr ) { var res = 0 ; var c1 = 0 , c2 = 0 ; for ( var i = 0 ; i < 26 ; i ++ ) { res += parseInt ( arr [ i ] / 3 ) ; arr [ i ] = ( arr [ i ] % 3 ) ; if ( arr [ i ] == 1 ) c1 ++ ; else if ( arr [ i ] == 2 ) c2 ++ ; } res += Math . min ( c1 , c2 ) ; var t = Math . min ( c1 , c2 ) ; c1 -= t ; c2 -= t ; res += 2 * parseInt ( c2 / 3 ) ; c2 %= 3 ; res += parseInt ( c2 / 2 ) ; document . write ( res ) ; }
function minLength ( str , N , K , M ) { var stackOfChar = [ ] ; for ( var i = 0 ; i < N ; i ++ ) { stackOfChar . push ( str [ i ] ) ; if ( stackOfChar . length >= M ) { var l = " " ; for ( var j = M - 1 ; j >= 0 ; j -- ) { if ( K [ j ] != stackOfChar [ stackOfChar . length - 1 ] ) { var f = 0 ; while ( f != l . length ) { stackOfChar . push ( l [ f ] ) ; f ++ ; } break ; } else { l = stackOfChar [ stackOfChar . length - 1 ] + l ; stackOfChar . pop ( ) ; } } } } return stackOfChar . length ; }
function power ( x , y , p ) { let res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } let N = 3 ; let flag , k , m = 0 ; if ( ( N == 1 ) || ( N == 2 ) ) document . write ( 62 ) ; else m = 1000000000 + 7 ; if ( N % 2 == 0 ) { k = N / 2 ; flag = 1 ; } else { k = ( N - 1 ) / 2 ; flag = 0 ; } if ( flag != 0 ) { let a = power ( 62 , k , m ) ; document . write ( a ) ; } else { let a = power ( 62 , ( k + 1 ) , m ) ; document . write ( a ) ; }
function lenOfLongestReqSubstr ( s , N ) { var ind = new Map ( ) ; var mask = 0 ; ind [ 0 ] = - 1 ; var ans = 0 ; for ( var i = 0 ; i < N ; i ++ ) { var val = s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; mask ^= ( 1 << val ) ; if ( ind . has ( mask ) ) { ans = Math . max ( ans , i - ind . get ( mask ) ) ; } else ind . set ( mask , i ) ; } return ans ; }
function findFreq ( str , N ) { let freq = new Array ( 256 ) . fill ( 0 ) ; let max = 0 ; let charMax = ' ' ; for ( let i = 0 ; i < N ; i ++ ) { let ch = str [ i ] . charCodeAt ( 0 ) ; freq [ ch ] ++ ; if ( freq [ ch ] >= max ) { max = freq [ ch ] ; charMax = ch ; } document . write ( String . fromCharCode ( charMax ) + " " + max + " " ) ; } }
function minCost ( s , n ) { var minValue = 100000000 ; for ( var i = 0 ; i <= 25 ; i ++ ) { var cnt = 0 ; for ( var j = 0 ; j < n ; j ++ ) { cnt += Math . min ( Math . abs ( i - ( s [ j ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ) ) , 26 - Math . abs ( i - ( s [ j ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ) ) ) ; } minValue = Math . min ( minValue , cnt ) ; } return minValue ; }
function countSubString ( s ) { let res = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { let x = 0 ; for ( let j = i ; j < s . length ; j ++ ) { let temp = 1 << s [ j ] - ' ' ; x ^= temp ; if ( ( x & ( x - 1 ) ) == 0 ) res ++ ; } } document . write ( res ) ; }
function countSubstring ( s ) { var answer = 0 ; var m = new Map ( ) ; m . set ( 0 , 1 ) ; var x = 0 ; for ( var j = 0 ; j < s . length ; j ++ ) { x ^= 1 << ( s [ j ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ; answer += m . has ( x ) ? m . get ( x ) : 0 ; for ( var i = 0 ; i < 26 ; ++ i ) { answer += m . has ( x ^ ( 1 << i ) ) ? m . get ( x ^ ( 1 << i ) ) : 0 ; } if ( m . has ( x ) ) m . set ( x , m . get ( x ) + 1 ) else m . set ( x , 1 ) } document . write ( answer ) ; }
function min_cost ( S ) { let cost = 0 ; let F = 0 ; let B = 0 ; let count = 0 ; for ( let i in S ) if ( S [ i ] == ' ' ) count ++ ; let n = S . length - count ; if ( n == 1 ) return cost ; for ( let i in S ) { if ( S [ i ] != ' ' ) { if ( B != 0 ) { cost += Math . min ( n - F , F ) * B ; B = 0 ; } F += 1 ; } else { B += 1 ; } } return cost ; }
function countOfSubstringWithOnlyOnes ( s ) { var res = 0 , count = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) { count = s [ i ] == ' ' ? count + 1 : 0 ; res = ( res + count ) ; } return res ; }
function charactersCount ( str , n ) { let count = 0 ; while ( n > 0 ) { let cur = str [ 0 ] . charCodeAt ( ) ; let ind = 0 ; for ( let j = 1 ; j < n ; j ++ ) { if ( str [ j ] . charCodeAt ( ) < cur ) { cur = str [ j ] . charCodeAt ( ) ; ind = j ; } } str = str . substring ( 0 , ind ) + str . substring ( ind + 1 ) ; n -- ; count += ind + 1 ; } document . write ( count + " " ) ; }
function printMiddleCharacter ( str ) { let len = str . length ; let middle = parseInt ( len / 2 , 10 ) ; document . write ( str [ middle ] ) ; }
function is_rtol ( s ) { let tmp = ( Math . sqrt ( s . length ) ) - 1 ; let first = s [ tmp ] ; for ( let pos = tmp ; pos < s . length - 1 ; pos += tmp ) { if ( s [ pos ] != first ) { return false ; } } return true ; } let str = " " ; if ( is_rtol ( str ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function count_minimum ( s ) { var n = s . length ; var ans = 0 ; var i = 0 ; while ( i < n ) { var j = i ; while ( s [ j ] === s [ i ] && j < n ) { j ++ ; } var diff = j - i ; ans += parseInt ( diff / 2 ) ; i = j ; } document . write ( ans + " " ) ; }
function polynomialRollingHash ( str ) { let p = 31 ; let m = ( 1e9 + 9 ) ; let power_of_p = 1 ; let hash_val = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { hash_val = ( hash_val + ( str [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) + 1 ) * power_of_p ) % m ; power_of_p = ( power_of_p * p ) % m ; } return hash_val ; }
function count_Strings ( n ) { var x = 1 ; for ( i = 1 ; i < n ; i ++ ) { x = ( 1 << x ) ; } return x - 1 ; }
function decrypt ( Str , Start , End ) { if ( Start > End ) { return ; } let mid = ( Start + End ) >> 1 ; document . write ( Str [ mid ] ) ; decrypt ( Str , mid + 1 , End ) ; decrypt ( Str , Start , mid - 1 ) ; }
function decode_String ( str , K ) { let ans = " " ; for ( let i = 0 ; i < str . length ; i += K ) ans += str [ i ] ; for ( let i = str . length - ( K - 1 ) ; i < str . length ; i ++ ) ans += str [ i ] ; document . write ( ans ) ; }
function BalancedNumber ( s ) { let Leftsum = 0 ; let Rightsum = 0 ; for ( let i = 0 ; i < s . length / 2 ; i ++ ) { Leftsum += ( s [ i ] - ' ' ) ; Rightsum += ( s [ s . length - 1 - i ] - ' ' ) ; } if ( Leftsum == Rightsum ) document . write ( " " ) ; else document . write ( " " ) ; }
function minFlips ( target ) { let curr = ' ' ; let count = 0 ; for ( let i = 0 ; i < target . length ; i ++ ) { if ( target [ i ] == curr ) { count ++ ; curr = String . fromCharCode ( 48 + ( curr . charCodeAt ( ) + 1 ) % 2 ) ; } } return count ; }
function minDel ( s1 , s2 ) { var i = s1 . length ; var j = s2 . length ; while ( i > 0 && j > 0 ) { if ( s1 [ i - 1 ] != s2 [ j - 1 ] ) { break ; } i -- ; j -- ; } return i + j ; }
function checkWord ( board , word , index , row , col ) { if ( row < 0 col < 0 row >= board . length col >= board [ 0 ] . length ) return false ; if ( board [ row ] [ col ] !== word [ index ] ) return false ; else if ( index === word . length - 1 ) return true ; var temp = board [ row ] [ col ] ; board [ row ] [ col ] = " " ; if ( checkWord ( board , word , index + 1 , row + 1 , col ) || checkWord ( board , word , index + 1 , row - 1 , col ) || checkWord ( board , word , index + 1 , row , col + 1 ) || checkWord ( board , word , index + 1 , row , col - 1 ) ) { board [ row ] [ col ] = temp ; return true ; } board [ row ] [ col ] = temp ; return false ; } var board = [ [ " " , " " , " " , " " ] , [ " " , " " , " " , " " ] , [ " " , " " , " " , " " ] , ] ; var word = " " ; var f = 0 ; for ( var i = 0 ; i < board . length ; i ++ ) { for ( var j = 0 ; j < board [ 0 ] . length ; j ++ ) { if ( board [ i ] [ j ] === word [ 0 ] && checkWord ( board , word , 0 , i , j ) ) { document . write ( " " ) ; f = 1 ; } } if ( f === 1 ) { i = board . length + 1 ; } } if ( f === 0 ) { document . write ( " " ) ; }
function count ( N , X , subStr , index , n ) { if ( index == n ) return 0 ; let a = subStr + N [ index ] ; let b = 0 ; if ( parseInt ( a ) % X == 0 ) b = 1 ; let m1 = count ( N , X , a , index + 1 , n ) ; let m2 = b + count ( N , X , " " , index + 1 , n ) ; return Math . max ( m1 , m2 ) ; }
function checkSuffix ( A , B ) { let s1 = A . toString ( ) ; let s2 = B . toString ( ) ; let result ; result = s1 . endsWith ( s2 ) ; if ( result ) { document . write ( " " ) ; } else { document . write ( " " ) ; } }
function checkSuffix ( A , B ) { let digit_B = parseInt ( Math . log10 ( B ) + 1 , 10 ) ; A -= B ; return ( A % ( Math . pow ( 10 , digit_B ) ) > 0 ) ; } let A = 12345 , B = 45 ; let result = checkSuffix ( A , B ) ; if ( ! result ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function count_min_length ( s ) { var hash = new Array ( 26 ) . fill ( 0 ) ; var ans = 2147483648 ; for ( var i = 0 ; i < 26 ; i ++ ) hash [ i ] = - 1 ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( hash [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] == - 1 ) hash [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] = i ; else { if ( hash [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] == i - 1 || hash [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] == i - 2 ) return 0 ; ans = Math . min ( ans , i - hash [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] - 1 ) ; hash [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] = i ; } } if ( ans === 2147483648 ) return - 1 ; return ans ; }
function countStrings ( s ) { let cnt = 0 ; for ( let i = 1 ; s [ i ] ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { cnt ++ ; } } return cnt ; }
function RemoveHTMLTags ( s ) { const pattern = new RegExp ( " \\ \\ " ) ; s = new String ( s ) . replace ( pattern , " " ) ; document . write ( s ) ; return ; }
function removeRepeating ( s1 , s2 ) { let s3 = s1 + " " + s2 + " " ; let words = " " ; let i = 0 ; let temp = s3 . split ( " " ) for ( let x = 0 ; x < temp . length ; x ++ ) { if ( temp [ x ] == ' ' ) { if ( ! s1 . includes ( words ) || ! s2 . includes ( words ) ) document . write ( words ) ; words = " " ; } else { words = words + temp [ x ] ; } } }
function findStr ( S ) { var n = S . length ; for ( var i = 0 ; i < n / 2 ; ++ i ) { if ( S [ i ] != ' ' ) { S [ i ] = ' ' ; return S . join ( " " ) ; ; } } S [ n - 1 ] = ' ' ; return n < 2 ? " " : S . join ( " " ) ; ; }
function kth_String ( n , k ) { for ( i = n - 2 ; i >= 0 ; i -- ) { if ( k <= ( n - i - 1 ) ) { for ( j = 0 ; j < n ; j ++ ) { if ( j == i j == n - k ) document . write ( ' ' ) ; else document . write ( ' ' ) ; } break ; } k -= ( n - i - 1 ) ; } }
function decodeStr ( str , len ) { var c = Array ( len ) . fill ( " " ) ; var med , pos = 1 , k ; if ( len % 2 == 1 ) med = parseInt ( len / 2 ) ; else med = parseInt ( len / 2 ) - 1 ; c [ med ] = str [ 0 ] ; if ( len % 2 == 0 ) c [ med + 1 ] = str [ 1 ] ; if ( len & 1 ) k = 1 ; else k = 2 ; for ( var i = k ; i < len ; i += 2 ) { c [ med - pos ] = str [ i ] ; if ( len % 2 == 1 ) c [ med + pos ] = str [ i + 1 ] ; else c [ med + pos + 1 ] = str [ i + 1 ] ; pos ++ ; } for ( var i = 0 ; i < len ; i ++ ) { document . write ( c [ i ] ) ; } }
function GeberateDefangIP ( str ) { var defangIP = " " ; str . split ( ' ' ) . forEach ( function ( letter ) { ( letter == ' ' ) ? defangIP += " " : defangIP += letter ; } ) return defangIP ; }
function flip ( s ) { for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == ' ' ) { while ( s [ i ] == ' ' ) { s [ i ] = ' ' ; i ++ ; } break ; } } return s . join ( " " ) ; }
function distinct ( S , M , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let set1 = new Set ( ) ; for ( let j = 0 ; j < S [ i ] . length ; j ++ ) { if ( ! set1 . has ( S [ i ] [ j ] ) ) set1 . add ( S [ i ] [ j ] ) ; } let c = set1 . size ; if ( c <= M ) count += 1 ; } document . write ( count ) ; }
function moveAtEnd ( s , i , l ) { if ( i >= l ) return ; let curr = s [ i ] ; if ( curr != ' ' ) document . write ( curr ) ; moveAtEnd ( s , i + 1 , l ) ; if ( curr == ' ' ) document . write ( curr ) ; return ; }
function string ( l , x , y ) { var p = 97 ; for ( var j = 0 ; j < l ; j ++ ) { var ans = String . fromCharCode ( p + ( j % y ) ) ; document . write ( ans ) ; } }
function removeDuplicates ( str ) { let n = str . length ; let res = " " ; for ( let i = 0 ; i < n ; i ++ ) { let j ; for ( j = i + 1 ; j < n ; j ++ ) if ( str [ i ] == str [ j ] ) break ; if ( j == n ) res = res + str [ i ] ; } return res ; }
function contain ( L , U , M ) { let count = 0 ; for ( let j = L ; j < U ; j ++ ) { let num = new Set ( ) ; let str = String ( j ) ; num . add ( str ) ; if ( j % M == 0 && ! num . has ( String ( M ) ) ) { count += 1 ; } } document . write ( count - 2 ) ; }
function group_formed ( S ) { let count = 1 ; for ( let i = 0 ; i < S . length - 1 ; i ++ ) { if ( S [ i ] != S [ i + 1 ] ) count += 1 ; } document . write ( count ) ; }
function solve ( a , b ) { var l = a . length ; var min = 0 , max = 0 ; for ( var i = 0 ; i < l ; i ++ ) { if ( a [ i ] == ' ' b [ i ] == ' ' a [ i ] != b [ i ] ) max ++ ; if ( a [ i ] != ' ' && b [ i ] != ' ' && a [ i ] != b [ i ] ) min ++ ; } document . write ( min + max ) ; }
function xoring ( a , b , n ) { let ans = " " ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == b [ i ] ) ans += " " ; else ans += " " ; } return ans ; }
function isPerfectCubeString ( str ) { var sum = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { sum += str . charCodeAt ( i ) ; } var cr = Math . round ( Math . cbrt ( sum ) ) ; return cr * cr * cr == sum ; }
function XorAscii ( str , len ) { let ans = str . codePointAt ( 0 ) ; for ( let i = 1 ; i < len ; i ++ ) { ans = ( ans ^ ( str . codePointAt ( i ) ) ) ; } return ans ; }
function countSticks ( str ) { var cnt = 0 ; for ( var i = 0 ; str [ i ] ; i ++ ) { var ch = str [ i ] ; if ( ch >= ' ' && ch <= ' ' ) { cnt += sticks [ ch . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ; } else { cnt += number [ ch . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ; } } return cnt ; }
function productAtKthLevel ( tree , k , level ) { if ( tree [ i ++ ] == ' ' ) { if ( tree [ i ] == ' ' ) return 1 ; var product = 1 ; if ( level == k ) product = tree [ i ] - ' ' ; ++ i ; var leftproduct = productAtKthLevel ( tree , k , level + 1 ) ; ++ i ; var rightproduct = productAtKthLevel ( tree , k , level + 1 ) ; ++ i ; return product * leftproduct * rightproduct ; } return int . MinValue ; }
function count ( str1 , str2 ) { var c = 0 ; for ( var i = 0 ; i < str1 . length ; i ++ ) { if ( str2 . includes ( str1 [ i ] ) ) c += 1 ; } document . write ( " " + + parseInt ( c ) ) ; }
function smallest ( s ) { var a = Array ( s . length ) ; for ( var i = 0 ; i < s . length ; i ++ ) a [ i ] = s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; var b = [ ] ; for ( var i = 0 ; i < a . length ; i ++ ) { if ( ( a [ i ] ) % 2 != 0 ) b . push ( a [ i ] ) ; } b . sort ( ( a , b ) => a - b ) ; if ( b . length > 1 ) return ( b [ 0 ] ) * 10 + ( b [ 1 ] ) ; return - 1 ; }
function findNthOccur ( str , ch , N ) { var occur = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] == ch ) { occur += 1 ; } if ( occur == N ) return i ; } return - 1 ; }
function converthenumber ( n ) { var s = n . toString ( ) ; var res = " " ; var i ; for ( i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' ) res += s [ i ] ; if ( res . length == 2 ) break ; } if ( res . length == 2 ) document . write ( res ) ; else document . write ( " " ) ; }
function isWordPresent ( sentence , word ) { let s = sentence . split ( " " ) ; for ( let temp = 0 ; temp < s . length ; temp ++ ) { if ( s [ temp ] == ( word ) ) { return true ; } } return false ; }
function canMake ( s ) { var o = 0 , z = 0 ; for ( i = 0 ; i < s . length ; i ++ ) { if ( s . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) == 1 ) o ++ ; else z ++ ; } if ( o % 2 == 1 && z % 2 == 1 ) return " " ; else return " " ; }
function countChars ( str , n ) { let i = 0 , cnt = 0 ; while ( i < n ) { if ( str [ i ] == ' ' ) i += 1 ; else i += 2 ; cnt += 1 ; } return cnt ; }
function findMinSwaps ( s , k ) { var ans = 0 ; var c_one = 0 , c_zero = 0 ; for ( var i = s . length - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == ' ' ) c_one ++ ; if ( s [ i ] == ' ' ) c_zero ++ , ans += c_one ; if ( c_zero == k ) break ; } if ( c_zero < k ) return - 1 ; return ans ; }
function sub_segments ( str , n ) { let l = str . length ; for ( let x = 0 ; x < l ; x += n ) { let newlist = str . substr ( x , n ) ; let arr = [ ] ; for ( let y of newlist ) { if ( ! arr . includes ( y ) ) arr . push ( y ) ; } for ( let y of arr ) document . write ( y ) ; document . write ( " " ) ; } }
function countSubStr ( str , len ) { var ans = 0 ; for ( var i = 0 ; i < len ; i ++ ) { if ( str [ i ] == ' ' ) ans += ( i + 1 ) ; } return ans ; }
function findLength ( s , k ) { var ans = 1000000000 ; var l = 0 ; var r = 0 ; var cnt_zero = 0 , cnt_one = 0 ; while ( l < s . length && r <= s . length ) { if ( cnt_zero >= k && cnt_one >= 1 ) { ans = Math . min ( ans , r - l ) ; l ++ ; if ( s [ l - 1 ] == ' ' ) cnt_zero -- ; else cnt_one -- ; } else { if ( r == s . length ) break ; if ( s [ r ] == ' ' ) cnt_zero ++ ; else cnt_one ++ ; r ++ ; } } if ( ans == 1000000000 ) return - 1 ; return ans ; }
function largestSubStr ( s ) { while ( s . length && s [ s . length - 1 ] == ' ' ) s = s . substring ( 0 , s . length - 1 ) ; ; if ( s . length == 0 ) return " " ; else return s ; }
function findPhoneNumber ( n ) { let temp = n ; let sum = 0 ; while ( temp != 0 ) { sum += temp % 10 ; temp = Math . floor ( temp / 10 ) ; } if ( sum < 10 ) document . write ( n + " " + sum ) ; else document . write ( n + " " + sum ) ; }
function findMidAlphabet ( s1 , s2 , n ) { for ( var i = 0 ; i < n ; i ++ ) { var mid = ( s1 [ i ] . charCodeAt ( 0 ) + s2 [ i ] . charCodeAt ( 0 ) ) / 2 ; document . write ( String . fromCharCode ( mid ) ) ; } }
function cntSplits ( s ) { if ( s [ s . length - 1 ] == ' ' ) return 0 ; var c_zero = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) c_zero += ( s [ i ] == ' ' ) ; return Math . pow ( 2 , c_zero - 1 ) ; }
function cntSplits ( s ) { if ( s [ s . length - 1 ] == ' ' ) return - 1 ; var ans = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) ans += ( s [ i ] == ' ' ) ; return ans ; }
function isPalindrome ( num ) { var s = num . toString ( ) ; var low = 0 ; var high = s . length - 1 ; while ( low < high ) { if ( s [ low ] != s [ high ] ) return false ; low ++ ; high -- ; } return true ; }
function cntWays ( str , n ) { var x = n + 1 ; var ways = x * x * ( x * x - 1 ) / 12 ; return ways ; }
function Count ( s , pos ) { let c = s [ pos - 1 ] ; let counter = 0 ; for ( let i = 0 ; i < pos - 1 ; i ++ ) { if ( s [ i ] == c ) counter = counter + 1 ; } return counter ; } let s = " " ; let pos ; let n = s . length ; let query = [ 9 , 3 , 2 ] ; let Q = query . length ; for ( let i = 0 ; i < Q ; i ++ ) { pos = query [ i ] ; document . write ( Count ( s , pos ) + " " ) ; }
function countSticks ( str , n ) { var cnt = 0 ; for ( var i = 0 ; i < n ; i ++ ) { cnt += ( sticks [ str [ i ] - ' ' ] ) ; } return cnt ; }
function getCount ( str , n ) { var cnt = 0 ; var i = 0 ; while ( i < n - 2 ) { if ( str [ i ] === str [ i + 1 ] && str [ i ] === str [ i + 2 ] ) { cnt ++ ; i = i + 2 ; } else { i ++ ; } } return cnt ; }
function getChar ( str ) { let sum = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { sum += ( str [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) + 1 ) ; } if ( sum % 26 == 0 ) return ' ' ; else { sum = sum % 26 ; return String . fromCharCode ( ' ' . charCodeAt ( ) + sum - 1 ) ; } }
function findNumbers ( s ) { var n = s . length ; var count = 1 ; var result = 0 ; var left = 0 ; var right = 1 ; while ( right < n ) { if ( s [ left ] == s [ right ] ) { count ++ ; } else { result += parseInt ( count * ( count + 1 ) / 2 ) ; left = right ; count = 1 ; } right ++ ; } result += parseInt ( count * ( count + 1 ) / 2 ) ; document . write ( result ) ; }
function canBeBalanced ( s , n ) { if ( n % 2 == 1 ) return false ; let k = " " ; k += s + " " ; let d = [ ] ; for ( let i = 0 ; i < k . length ; i ++ ) { if ( k [ i ] == ' ' ) d . push ( " " ) ; else { if ( d . length != 0 ) d . pop ( ) ; else return false ; } } if ( d . length == 0 ) return true ; return false ; }
function maxLenSubStr ( s ) { if ( s . length < 3 ) return s . length ; let temp = 2 ; let ans = 2 ; for ( let i = 2 ; i < s . length ; i ++ ) { if ( s [ i ] != s [ i - 1 ] s [ i ] != s [ i - 2 ] ) temp ++ ; else { ans = Math . max ( temp , ans ) ; temp = 2 ; } } ans = Math . max ( temp , ans ) ; return ans ; }
function find_winner ( str , n ) { var str1 = " " , str2 = " " ; for ( var i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { str1 += str [ i ] ; } else { str2 += str [ i ] ; } } str1 = str1 . split ( ' ' ) . sort ( ) ; str2 = str2 . split ( ' ' ) . sort ( ) ; if ( str1 < str2 ) document . write ( " " ) ; else if ( str2 < str1 ) document . write ( " " ) ; else document . write ( " " ) ; }
function printChar ( str , n ) { let freq = new Array ( SIZE ) ; for ( let i = 0 ; i < freq . length ; i ++ ) { freq [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) { freq [ str . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ] ++ ; } for ( let i = 0 ; i < n ; i ++ ) { if ( freq [ str . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ] % 2 == 0 ) { document . write ( str [ i ] ) ; } } }
function reverse ( str , len , l , r ) { if ( l < 0 r >= len l > r ) return " " ; while ( l < r ) { let c = str [ l ] ; str [ l ] = str [ r ] ; str [ r ] = c ; l ++ ; r -- ; } return str . join ( " " ) ; }
function findPrefix ( str1 , str2 ) { var pos = - 1 ; while ( str1 . length != 0 ) { if ( ! str2 . includes ( str1 ) ) str1 = str1 . substring ( 0 , str1 . length - 1 ) else { pos = str2 . includes ( str1 ) ; break ; } } if ( pos == - 1 ) return " " ; return str1 ; }
function encrypt ( input ) { let evenPos = ' ' , oddPos = ' ' ; let repeat , ascii ; for ( let i = 0 ; i < input . length ; i ++ ) { ascii = input [ i ] . charCodeAt ( ) ; repeat = ascii >= 97 ? ascii - 96 : ascii - 64 ; for ( let j = 0 ; j < repeat ; j ++ ) { if ( i % 2 == 0 ) document . write ( oddPos ) ; else document . write ( evenPos ) ; } } }
function IsRedundantBraces ( A ) { let a = 0 , b = 0 ; for ( let i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] == ' ' && A [ i + 2 ] == ' ' ) return true ; if ( A [ i ] == ' ' A [ i ] == ' ' A [ i ] == ' ' A [ i ] == ' ' ) a ++ ; if ( A [ i ] == ' ' ) b ++ ; } if ( b > a ) return true ; return false ; } let A = " " ; if ( IsRedundantBraces ( A ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function minOperations ( str , n ) { var count = 0 ; for ( var i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] != str [ i + 1 ] ) count ++ ; } return ( count + 1 ) / 2 ; }
function stringToInt ( str ) { if ( str . length == 1 ) return ( str [ 0 ] - ' ' ) ; var y = stringToInt ( str . substring ( 1 ) ) ; var x = str [ 0 ] - ' ' ; x = x * Math . pow ( 10 , str . Length - 1 ) + y ; return ( x ) ; }
function Occurrence ( s , position ) { let count = 0 ; for ( let i = 0 ; i < position - 1 ; i ++ ) if ( s [ i ] == s [ position - 1 ] ) count ++ ; return count ; }
function generateStr ( a , b , s , count , len ) { if ( count == len ) { document . write ( s + " " ) ; return ; } generateStr ( a . substring ( 1 ) , b . substring ( 1 ) , s + a [ 0 ] , count + 1 , len ) ; generateStr ( a . substring ( 1 ) , b . substring ( 1 ) , s + b [ 0 ] , count + 1 , len ) ; }
function countTotalDistinct ( str ) { let cnt = 0 ; let items = new Set ( ) ; for ( let i = 0 ; i < str . length ; ++ i ) { let temp = " " ; let ans = new Set ( ) ; for ( let j = i ; j < str . length ; ++ j ) { temp = temp + str [ j ] ; ans . add ( str [ j ] ) ; if ( ! items . has ( temp ) ) { items . add ( temp ) ; cnt += ans . size ; } } } return cnt ; }
function removeDuplicates ( S ) { var ans = " " ; for ( i = 0 ; i < S . length ; i ++ ) { if ( ans . length == 0 || ans . charAt ( ans . length - 1 ) != S . charAt ( i ) ) ans += S . charAt ( i ) ; else if ( ans . charAt ( ans . length - 1 ) == S . charAt ( i ) ) ans = ans . substring ( 0 , ans . length - 1 ) ; } return ans ; }
function getOrgString ( s ) { document . write ( s [ 0 ] ) ; var i = 1 ; while ( i < s . length ) { if ( s [ i ] . charCodeAt ( 0 ) >= " " . charCodeAt ( 0 ) && s [ i ] . charCodeAt ( 0 ) <= " " . charCodeAt ( 0 ) ) document . write ( " " + s [ i ] . toLowerCase ( ) ) ; else document . write ( s [ i ] ) ; i ++ ; } }
function canConvert ( str1 , str2 ) { var i = 0 , j = 0 ; while ( i < str1 . length && j < str2 . length ) { if ( str1 [ i ] !== str2 [ j ] ) { if ( str1 [ i ] === " " && str2 [ j ] === " " && i + 1 < str1 . length && str1 [ i + 1 ] === " " ) { i += 2 ; j ++ ; } else { return false ; } } else { i ++ ; j ++ ; } } if ( i === str1 . length && j === str2 . length ) return true ; return false ; }
function isPossible ( str ) { let freq = new Map ( ) ; let max_freq = 0 ; for ( let j = 0 ; j < ( str . length ) ; j ++ ) { if ( freq . has ( str [ j ] ) ) { freq . set ( str [ j ] , freq . get ( str [ j ] ) + 1 ) ; if ( freq . get ( str [ j ] ) > max_freq ) max_freq = freq . get ( str [ j ] ) ; } else { freq . set ( str [ j ] , 1 ) ; if ( freq . get ( str [ j ] ) > max_freq ) max_freq = freq . get ( str [ j ] ) ; } } if ( max_freq <= ( str . length - max_freq + 1 ) ) return true ; return false ; }
function isPossible ( l , m , x , y ) { if ( l * m == x + y ) return true ; return false ; }
function isValid ( s ) { if ( ( s . indexOf ( " " ) != - 1 ) && ( s . indexOf ( " " , s . indexOf ( " " ) + 4 ) != - 1 ) ) return true ; return false ; }
function isTwoAlter ( s ) { for ( let i = 0 ; i < s . length - 2 ; i ++ ) { if ( s [ i ] != s [ i + 2 ] ) { return false ; } } if ( s [ 0 ] == s [ 1 ] ) return false ; return true ; }
function findCount ( s , n , a , b ) { var res = 0 ; for ( var i = 0 ; i < b ; i ++ ) { if ( i == a ) res += ( s [ n - i - 1 ] != ' ' ) ; else res += ( s [ n - i - 1 ] != ' ' ) ; } return res ; }
function positions ( str , n ) { for ( i = 0 ; i < n ; i ++ ) { document . write ( ( str [ i ] . charCodeAt ( 0 ) & NUM ) + " " ) ; } }
function lenoflongestnonpalindrome ( s ) { let max1 = 1 , len = 0 ; for ( let i = 0 ; i < s . length - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) len = 0 ; else if ( s [ i + 1 ] == s [ i - 1 ] && i > 0 ) len = 1 ; len ++ ; } if ( max1 == 1 ) return 0 ; else return max1 ; }
function printChar ( str , n ) { let freq = [ ] ; for ( let i = 0 ; i < SIZE ; i ++ ) { freq . push ( 0 ) ; } for ( let i = 0 ; i < n ; i ++ ) freq [ str . charCodeAt ( i ) - 97 ] ++ ; for ( let i = 0 ; i < n ; i ++ ) { if ( freq [ str . charCodeAt ( i ) - 97 ] % 2 == 1 ) { document . write ( str [ i ] ) ; } } }
function calcScore ( str ) { var score = 0 ; var len = str . length ; for ( var i = 0 ; i < len ; ) { var chunkSize = 1 ; var currentChar = str [ i ++ ] ; while ( i < len && str [ i ] == currentChar ) { chunkSize ++ ; i ++ ; } if ( currentChar == ' ' ) score += Math . pow ( chunkSize , 2 ) ; else score -= Math . pow ( chunkSize , 2 ) ; } return score ; }
function check ( s ) { let n = s . length ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] > s [ i + 1 ] ) return true ; } return false ; }
function countSubStr ( str , n , x ) { let res = 0 , count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == x ) { res += ( ( count + 1 ) * ( n - i ) ) ; count = 0 ; } else count ++ ; } return res ; }
function isValid ( str , n ) { if ( ! ( ( str [ 0 ] >= ' ' && str [ 0 ] <= ' ' ) || ( str [ 0 ] >= ' ' && str [ 0 ] <= ' ' ) str [ 0 ] == ' ' ) ) return false ; for ( let i = 1 ; i < str . length ; i ++ ) { if ( ! ( ( str [ i ] >= ' ' && str [ i ] <= ' ' ) || ( str [ i ] >= ' ' && str [ i ] <= ' ' ) || ( str [ i ] >= ' ' && str [ i ] <= ' ' ) str [ i ] == ' ' ) ) return false ; } return true ; }
function countSubStr ( str , n ) { var len = str . length ; return len - n + 1 ; }
function countSubstrings ( s , c ) { var n = s . length ; var cnt = 0 ; var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) != c ) cnt ++ ; else { sum += ( cnt * ( cnt + 1 ) ) / 2 ; cnt = 0 ; } } sum += ( cnt * ( cnt + 1 ) ) / 2 ; return sum ; }
function FirstAndLast ( str ) { var ch = str . split ( ' ' ) ; for ( var i = 0 ; i < ch . length ; i ++ ) { var k = i ; while ( i < ch . length && ch [ i ] != ' ' ) i ++ ; ch [ k ] = String . fromCharCode ( ch [ k ] >= ' ' && ch [ k ] <= ' ' ? ( ch [ k ] . charCodeAt ( 0 ) - 32 ) : ch [ k ] . charCodeAt ( 0 ) ) ; ch [ i - 1 ] = String . fromCharCode ( ch [ i - 1 ] >= ' ' && ch [ i - 1 ] <= ' ' ? ( ch [ i - 1 ] . charCodeAt ( 0 ) - 32 ) : ch [ i - 1 ] . charCodeAt ( 0 ) ) ; } return ch . join ( ' ' ) ; }
function findM ( s , x ) { var cnt = 0 ; for ( i = 0 ; i < s . length ; i ++ ) { if ( s . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) != x ) cnt ++ ; } return cnt ; }
function FirstAndLast ( str ) { for ( var i = 0 ; i < str . length ; i ++ ) { if ( i == 0 ) document . write ( str [ i ] ) ; if ( i == str . length - 1 ) document . write ( str [ i ] ) ; if ( str [ i ] === " " ) { document . write ( str [ i - 1 ] + " " + str [ i + 1 ] ) ; } } }
function printLastChar ( str ) { str = str + " " ; for ( var i = 1 ; i < str . length ; i ++ ) { if ( str [ i ] === " " ) document . write ( str [ i - 1 ] + " " ) ; } }
function asciiToSentence ( str , len ) { var num = 0 ; for ( var i = 0 ; i < len ; i ++ ) { num = num * 10 + ( str [ i ] - ' ' ) ; if ( num >= 32 && num <= 122 ) { var ch = String . fromCharCode ( num ) ; document . write ( ch ) ; num = 0 ; } } }
function countDistinctCode ( str ) { var codes = new Set ( ) ; for ( var i = 0 ; i < str . length - 1 ; i ++ ) codes . add ( str . substr ( i , 2 ) ) ; return codes . size ; }
function countKeyPressed ( str , len ) { var count = 0 ; for ( var i = 0 ; i < len ; i ++ ) count = count + arr [ str . charCodeAt ( i ) - 97 ] ; return count ; }
function minLettersNeeded ( n ) { if ( n % 26 == 0 ) return parseInt ( n / 26 ) ; else return ( parseInt ( n / 26 ) + 1 ) ; }
function countMinReversals ( expr ) { var len = expr . length ; if ( len % 2 ) return - 1 ; var ans = 0 ; var i ; var open = 0 ; var close = 0 ; for ( i = 0 ; i < len ; i ++ ) { if ( expr [ i ] == ' ' ) open ++ ; else { if ( ! open ) close ++ ; else open -- ; } } ans = ( close / 2 ) + ( open / 2 ) ; close %= 2 ; open %= 2 ; if ( close ) ans += 2 ; return ans ; }
function minReplacement ( s , len ) { var ans = 0 ; for ( var i = 0 ; i < len ; i ++ ) { if ( i % 2 == 0 && s [ i ] == ' ' ) ans ++ ; if ( i % 2 == 1 && s [ i ] == ' ' ) ans ++ ; } return Math . min ( ans , len - ans ) ; }
function substrDeletion ( str , len ) { let count0 = 0 , count1 = 0 ; for ( let i = 0 ; i < len ; i ++ ) { if ( str [ i ] == ' ' ) count0 ++ ; else count1 ++ ; } return Math . min ( count0 , count1 ) ; }
function maxBalancedStr ( s ) { var open1 = 0 , close1 = 0 ; var open2 = 0 , close2 = 0 ; var open3 = 0 , close3 = 0 ; for ( i = 0 ; i < s . length ; i ++ ) { switch ( s . charAt ( i ) ) { case ' ' : open1 ++ ; break ; case ' ' : close1 ++ ; break ; case ' ' : open2 ++ ; break ; case ' ' : close2 ++ ; break ; case ' ' : open3 ++ ; break ; case ' ' : close3 ++ ; break ; } } var maxLen = 2 * Math . min ( open1 , close1 ) + 2 * Math . min ( open2 , close2 ) + 2 * Math . min ( open3 , close3 ) ; return maxLen ; }
function findCost ( s1 , s2 , a , b , c , d , n ) { var cost = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( s1 [ i ] == s2 [ i ] ) continue ; else { if ( ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) || ( s2 [ i ] == ' ' && s1 [ i ] == ' ' ) ) cost += Math . min ( d , Math . min ( a , b + c ) ) ; else if ( ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) || ( s2 [ i ] == ' ' && s1 [ i ] == ' ' ) ) cost += Math . min ( d , Math . min ( b , a + c ) ) ; else if ( ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) || ( s2 [ i ] == ' ' && s1 [ i ] == ' ' ) ) cost += Math . min ( d , Math . min ( c , a + b ) ) ; } } return cost ; }
function prefixOccurrences ( str ) { var c = str . charAt ( 0 ) ; var countc = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( str . charAt ( i ) == c ) countc ++ ; } return countc ; }
function Preprocess ( A , B ) { let n = A . length ; let ans = 0 ; for ( let i = 0 ; i < n / 2 ; i ++ ) { let mp = new Map ( ) ; if ( mp . has ( A [ i ] ) ) mp . set ( A [ i ] , mp . get ( A [ i ] ) + 1 ) ; else mp . set ( A [ i ] , 1 ) ; if ( mp . has ( A [ n - i - 1 ] ) ) mp . set ( A [ n - i - 1 ] , mp . get ( A [ n - i - 1 ] ) + 1 ) ; else mp . set ( A [ n - i - 1 ] , 1 ) ; if ( mp . has ( B [ i ] ) ) mp . set ( B [ i ] , mp . get ( B [ i ] ) + 1 ) ; else mp . set ( B [ i ] , 1 ) ; if ( mp . has ( B [ n - i - 1 ] ) ) mp . set ( B [ n - i - 1 ] , mp . get ( B [ n - i - 1 ] ) + 1 ) ; else mp . set ( B [ n - i - 1 ] , 1 ) ; let sz = mp . size ; if ( sz == 4 ) ans += 2 ; else if ( sz == 3 ) ans += 1 + ( A [ i ] == A [ n - i - 1 ] ? 1 : 0 ) ; else if ( sz == 2 ) ans += mp . get ( A [ i ] ) != 2 ? 1 : 0 ; } if ( n % 2 == 1 && A [ Math . floor ( n / 2 ) ] != B [ Math . floor ( n / 2 ) ] ) ans ++ ; return ans ; }
function countStrings ( n , m , s ) { let ind = new Set ( ) ; for ( let j = 0 ; j < m ; j ++ ) { let mx = 0 ; for ( let i = 0 ; i < n ; i ++ ) mx = Math . max ( mx , ( s [ i ] [ j ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ) ; for ( let i = 0 ; i < n ; i ++ ) if ( s [ i ] [ j ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) == mx ) ind . add ( i ) ; } return ind . size ; }
function minOperations ( s , t , n ) { var ct0 = 0 , ct1 = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] === t [ i ] ) continue ; if ( s [ i ] === " " ) ct0 ++ ; else ct1 ++ ; } return Math . max ( ct0 , ct1 ) ; }
function maxValue ( a , b ) { b . sort ( function ( x , y ) { return x - y ; } ) ; let n = a . length ; let m = b . length ; let j = m - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( j < 0 ) break ; if ( b [ j ] > a [ i ] ) { a [ i ] = b [ j ] ; j -- ; } } return ( a ) . join ( " " ) ; }
function largestPalinSub ( s ) { let res = " " ; let mx = s [ 0 ] ; for ( let i = 1 ; i < s . length ; i ++ ) mx = String . fromCharCode ( Math . max ( mx . charCodeAt ( ) , s [ i ] . charCodeAt ( ) ) ) ; for ( let i = 0 ; i < s . length ; i ++ ) if ( s [ i ] == mx ) res += s [ i ] ; return res ; }
function isValid ( str , len ) { for ( let i = 1 ; i < len ; i ++ ) { if ( str [ i ] == str [ i - 1 ] ) return false ; } return true ; }
function decryptString ( str , n ) { let i = 0 , jump = 1 ; let decryptedStr = " " ; while ( i < n ) { decryptedStr += str [ i ] ; i += jump ; jump ++ ; } return decryptedStr ; }
function countSubStr ( str , len , k ) { let count = 0 ; for ( let i = 0 ; i < len ; i ++ ) { let n = 0 ; for ( let j = i ; j < len ; j ++ ) { n = n * 10 + ( str [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; if ( n % k == 0 ) count ++ ; } } return count ; }
function printString ( str , n ) { let ones = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( str [ i ] == ' ' ) ones ++ ; let used = false ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' && ! used ) { used = true ; for ( let j = 0 ; j < ones ; j ++ ) document . write ( " " ) ; } if ( str [ i ] != ' ' ) document . write ( str [ i ] ) ; } if ( ! used ) for ( let j = 0 ; j < ones ; j ++ ) document . write ( " " ) ; }
function Colour_Combination ( s ) { let temp = s [ 0 ] ; for ( let i = 1 ; i < s . length ; i ++ ) { if ( temp != s [ i ] ) { if ( ( temp == ' ' temp == ' ' ) && ( s [ i ] == ' ' s [ i ] == ' ' ) ) temp = ' ' ; else if ( ( temp == ' ' temp == ' ' ) && ( s [ i ] == ' ' s [ i ] == ' ' ) ) temp = ' ' ; else temp = ' ' ; } } return temp ; }
function reverse ( str , x ) { var n = ( str . length - x ) / 2 ; for ( i = 0 ; i < n ; i ++ ) document . write ( str . charAt ( i ) ) ; for ( i = n + x - 1 ; i >= n ; i -- ) document . write ( str . charAt ( i ) ) ; for ( i = n + x ; i < str . length ; i ++ ) document . write ( str . charAt ( i ) ) ; }
function removeChars ( s ) { let modifiedStr = " " ; modifiedStr += s [ 0 ] ; for ( let i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] == ( s [ i ] ) . toUpperCase ( ) && ( s [ i - 1 ] ) == ( s [ i - 1 ] ) . toLowerCase ( ) || s [ i ] == s [ i ] . toLowerCase ( ) && ( s [ i - 1 ] ) == ( s [ i - 1 ] ) . toUpperCase ( ) ) modifiedStr += s [ i ] ; } return modifiedStr ; }
function pairStar ( input , i ) { output = output + input [ i ] ; if ( i == input . length - 1 ) return ; if ( input [ i ] == input [ i + 1 ] ) output = output + ' ' ; pairStar ( input , i + 1 ) ; }
function binarySearch ( arr , x ) { let l = 0 , r = arr . length - 1 ; while ( l <= r ) { let m = l + Math . floor ( ( r - l ) / 2 ) ; let res = x . localeCompare ( arr [ m ] ) ; if ( res == 0 ) return m ; if ( res > 0 ) l = m + 1 ; else r = m - 1 ; } return - 1 ; }
function printExpansion ( str ) { var size = 0 ; for ( var i = str . length - 1 ; i >= 0 ; i -- ) { var subStr = str . substring ( i , i + ++ size ) ; document . write ( subStr ) ; } }
function printExpansion ( str ) { var suff = " " ; for ( var i = str . length - 1 ; i >= 0 ; i -- ) { suff = suff + str [ i ] ; document . write ( suff ) ; } }
function count ( s , k ) { var n = s . length ; var d = 0 , i ; var count = 0 ; for ( i = 0 ; i < n ; i ++ ) d += s [ i ] . charCodeAt ( 0 ) ; if ( d % k === 0 ) { count += 1 ; } for ( i = k ; i < n ; i ++ ) { var prev = s [ i - k ] ; d -= prev . charCodeAt ( 0 ) ; d += s [ i ] . charCodeAt ( 0 ) ; if ( d % k === 0 ) count += 1 ; } return count ; }
function maxFreq ( s , a , b ) { var fre = new Array ( 10 ) . fill ( 0 ) ; var n = s . length ; if ( a > b ) { var temp = a ; a = b ; b = temp ; } for ( var i = 0 ; i < n ; i ++ ) fre [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] ++ ; if ( fre [ a ] === 0 && fre [ b ] === 0 ) return - 1 ; else if ( fre [ a ] >= fre [ b ] ) return a ; else return b ; }
function findSubstringCount ( str ) { var result = 0 ; var n = str . length ; for ( var i = 0 ; i < n - 1 ; i ++ ) { if ( String . fromCharCode ( str [ i ] . charCodeAt ( 0 ) + 1 ) == str [ i + 1 ] ) { result ++ ; while ( String . fromCharCode ( str [ i ] . charCodeAt ( 0 ) + 1 ) === str [ i + 1 ] ) { i ++ ; } } } return result ; }
function CountCharacters ( str , l , r ) { let cnt = 0 ; let m = new Map ( ) ; let len = str . length ; for ( let i = 0 ; i < len ; i ++ ) { if ( ! ( l <= str [ i ] . charCodeAt ( 0 ) && str [ i ] . charCodeAt ( 0 ) <= r ) ) { cnt ++ ; if ( ! m . has ( str [ i ] ) ) { m . set ( str [ i ] , 0 ) ; document . write ( str [ i ] + " " ) ; } m . set ( str [ i ] , m . get ( str [ i ] + 1 ) ) ; } } return cnt ; }
function strScore ( str , s , n ) { var score = 0 , index = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( str [ i ] == s ) { for ( j = 0 ; j < s . length ; j ++ ) { score += s . charAt ( j ) . charCodeAt ( 0 ) - ( ' ' ) . charCodeAt ( 0 ) + 1 ; } index = i + 1 ; break ; } } score = score * index ; return score ; }
function countChar ( str , x ) { let count = 0 ; let n = 10 ; for ( let i = 0 ; i < str . length ; i ++ ) if ( str [ i ] == x ) count ++ ; let repetitions = n / str . length ; count = count * repetitions ; for ( let i = 0 ; i < n % str . length ; i ++ ) { if ( str [ i ] == x ) count ++ ; } return count ; }
function separateChar ( str ) { var n = str . length , digitSum = 0 ; var alphabetSum = 0 , j = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( str [ i ] >= ' ' && str [ i ] <= ' ' ) digitSum += ( str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ; else { alphabetSum += ( str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) + 1 ) ; alphabetSum %= 26 ; } } var sumStr = digitSum . toString ( ) ; var alphabetStr = String . fromCharCode ( alphabetSum + ' ' . charCodeAt ( 0 ) - 1 ) ; sumStr += alphabetStr ; return sumStr ; }
function maxProductSum ( str , m ) { let n = str . length ; let maxProd = Number . MIN_VALUE , maxSum = Number . MIN_VALUE ; for ( let i = 0 ; i <= n - m ; i ++ ) { let product = 1 , sum = 0 ; for ( let j = i ; j < m + i ; j ++ ) { product = product * ( str [ j ] - ' ' ) ; sum = sum + ( str [ j ] - ' ' ) ; } maxProd = Math . max ( maxProd , product ) ; maxSum = Math . max ( maxSum , sum ) ; } document . write ( " " + maxProd + " " ) ; document . write ( " " + maxSum ) ; }
function countConsecutive ( s ) { let count = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) i ++ ; else count ++ ; } return count ; }
function CountCharacters ( str , l , r ) { let cnt = 0 ; let len = str . length ; for ( let i = 0 ; i < len ; i ++ ) { if ( l <= str [ i ] . charCodeAt ( 0 ) && str [ i ] . charCodeAt ( 0 ) <= r ) { cnt ++ ; document . write ( str [ i ] + " " ) ; } } return cnt ; }
function minSteps ( str ) { let count = 0 ; for ( let i = 0 ; i < str . length - 2 ; i ++ ) { if ( ( str [ i ] ) == ' ' ) { if ( str [ i + 1 ] == ' ' ) { if ( str [ i + 2 ] == ' ' ) { count ++ ; i += 2 ; } } } } return count ; }
function CountCharacters ( str , k ) { let cnt = 0 ; let len = str . length ; for ( let i = 0 ; i < len ; i ++ ) { if ( str [ i ] . charCodeAt ( 0 ) < k ) cnt ++ ; } return cnt ; }
function countWords ( str ) { let count = 1 ; for ( let i = 1 ; i < str . length - 1 ; i ++ ) { if ( str [ i ] >= ' ' && str [ i ] <= ' ' ) count ++ ; } return count ; }
function smallest ( s ) { let l = s . length ; let ans = " " ; for ( let i = 0 ; i < l - 1 ; i ++ ) { if ( s [ i ] > s [ i + 1 ] ) { for ( let j = 0 ; j < l ; j ++ ) { if ( i != j ) { ans += s [ j ] ; } } return ans ; } } ans = s . substring ( 0 , l - 1 ) ; return ans ; }
function replacingConsonants ( s ) { var nVowel = " " ; for ( var i = 0 ; i < s . length ; i ++ ) s [ i ] = nVowel [ s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ; return s . join ( ' ' ) ; }
function maxLength ( s , n ) { var right = 0 , left = 0 ; var coun = 0 , max_length = Number . MIN_VALUE ; s = s + ' ' ; for ( var i = 0 ; i <= n ; i ++ ) { if ( s [ i ] == ' ' ) coun ++ ; else { if ( coun > max_length ) { right = 0 ; left = 0 ; if ( s [ i ] == ' ' ) right = 1 ; if ( ( ( i - coun ) > 0 ) && ( s [ i - coun - 1 ] == ' ' ) ) left = 1 ; coun = Math . ceil ( coun / ( right + left ) ) ; max_length = Math . max ( max_length , coun ) ; } coun = 0 ; } } return max_length ; }
function is_possible ( s ) { let l = s . length ; let one = 0 , zero = 0 ; for ( let i = 0 ; i < l ; i ++ ) { if ( s [ i ] == ' ' ) zero ++ ; else one ++ ; } if ( l % 2 == 0 ) return ( one == zero ) ; else return ( Math . abs ( one - zero ) == 1 ) ; }
function count ( S , X ) { var count = 0 ; var N = S . length ; for ( var i = 0 ; i < N ; ++ i ) { if ( S [ i ] != ' ' ) { for ( var len = 1 ; ( i + len ) <= N ; ++ len ) { if ( parseInt ( S . substring ( i , i + len ) ) > X ) count ++ ; } } } return count ; }
function areVowelsInOrder ( s ) { var n = s . length ; var c = String . fromCharCode ( 64 ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' ) { if ( s [ i ] < c ) return false ; else { c = s [ i ] ; } } } return true ; }
function solve ( s , k ) { var count = 0 , length = 0 , pos = 0 ; var m = new Map ( ) ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( ! m . has ( s [ i ] ) ) { m . set ( s [ i ] , 0 ) ; } m . set ( s [ i ] , m . get ( s [ i ] ) + 1 ) ; length ++ ; if ( length > k ) { if ( ! m . has ( s [ pos ] ) ) { m . set ( s [ pos ] , 0 ) ; } m . set ( s [ pos ] , m [ s [ pos ] ] - 1 ) ; pos += 1 ; length -- ; } if ( length == k && m . get ( s [ i ] ) == length ) count ++ ; } document . write ( count ) ; }
function minParentheses ( p ) { var bal = 0 ; var ans = 0 ; for ( var i = 0 ; i < p . length ; ++ i ) { bal += p [ i ] == ' ' ? 1 : - 1 ; if ( bal == - 1 ) { ans += 1 ; bal += 1 ; } } return bal + ans ; }
function isAnyNotPalindrome ( s ) { var unique = new Set ( ) ; for ( var i = 0 ; i < s . length ; i ++ ) unique . add ( s [ i ] ) ; if ( unique . size > 1 ) return true ; else return false ; }
function Remainder ( str , R ) { var len = str . length ; var Num , Rem = 0 ; for ( var i = 0 ; i < len ; i ++ ) { Num = Rem * 10 + ( str [ i ] - ' ' ) ; Rem = Num % R ; } return Rem ; }
function Solve ( N , M ) { let temp = ( N - 1 ) * ( M - 1 ) ; let ans = ( Math . pow ( 2 , temp ) ) ; if ( ( N + M ) % 2 != 0 ) document . write ( ans ) ; else document . write ( 2 * ans ) ; }
function productAscii ( str ) { var prod = 1 ; for ( i = 0 ; i < str . length ; i ++ ) { prod *= str . charAt ( i ) . charCodeAt ( 0 ) ; } return prod ; }
function isCheck ( str ) { var len = str . length ; var lowerStr = " " , upperStr = " " ; for ( var i = 0 ; i < len ; i ++ ) { if ( str [ i ] >= ' ' && str [ i ] < ' ' ) upperStr = upperStr + str [ i ] ; else lowerStr = lowerStr + str [ i ] ; } lowerStr = lowerStr . toUpperCase ( ) ; console . log ( lowerStr ) ; return lowerStr === upperStr ; }
function minimumLength ( s ) { var maxOcc = 0 , n = s . length ; var arr = Array ( 26 ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) arr [ s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] > maxOcc ) maxOcc = arr [ i ] ; return ( n - maxOcc ) ; }
function oddEquivalent ( s , n ) { var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' ) count ++ ; } return count ; }
function minOperation ( s , i , j , count ) { if ( ( i >= s . length && j < 0 ) || ( i == j ) ) return MAX ; if ( s [ i ] == s [ j ] ) return count ; if ( i >= s . length ) return minOperation ( s , i , j - 1 , count + 1 ) ; else if ( j < 0 ) return minOperation ( s , i + 1 , j , count + 1 ) ; else return Math . min ( minOperation ( s , i , j - 1 , count + 1 ) , minOperation ( s , i + 1 , j , count + 1 ) ) ; }
function countStrings ( s ) { let sum = 1 ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( i % 2 == 0 && s [ i ] == ' ' ) sum *= 21 ; else if ( s [ i ] == ' ' ) sum *= 5 ; } return sum ; }
function removeDuplicatesFromString ( string ) { let counter = 0 ; let str = string . split ( " " ) ; let i = 0 ; let size = str . length ; let x ; let length = 0 ; while ( i < size ) { x = str [ i ] . charCodeAt ( 0 ) - 97 ; if ( ( counter & ( 1 << x ) ) == 0 ) { str [ length ] = String . fromCharCode ( ' ' . charCodeAt ( 0 ) + x ) ; counter = counter | ( 1 << x ) ; length ++ ; } i ++ ; } return str . join ( " " ) . slice ( 0 , length ) ; }
function removeDuplicatesFromString ( string ) { let table = new Array ( 256 ) ; for ( let i = 0 ; i < table . length ; i ++ ) table [ i ] = 0 ; let chars = string . split ( " " ) ; let endIndex = 0 ; for ( let i = 0 ; i < chars . length ; i ++ ) { if ( table [ chars [ i ] . charCodeAt ( 0 ) ] == 0 ) { table [ chars [ i ] . charCodeAt ( 0 ) ] = - 1 ; chars [ endIndex ++ ] = chars [ i ] ; } } let ans = " " ; for ( let i = 0 ; i < endIndex ; i ++ ) ans += chars [ i ] return ans ; }
function countFreq ( arr , n ) { let visited = new Array ( n ) ; visited . fill ( false ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( visited [ i ] == true ) continue ; let count = 1 ; for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { visited [ j ] = true ; count ++ ; } } document . write ( arr [ i ] + " " + count + " " ) ; } }
function countFreq ( arr , n , limit ) { let count = new Array ( limit + 1 ) ; count . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; for ( let i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) document . write ( i + " " + count [ i ] + " " ) ; }
function countFreq ( str ) { let count = new Array ( limit + 1 ) ; for ( let i = 0 ; i < count . length ; i ++ ) { count [ i ] = 0 ; } for ( let i = 0 ; i < str . length ; i ++ ) count [ str [ i ] . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i <= limit ; i ++ ) { if ( count [ i ] > 0 ) document . write ( String . fromCharCode ( i ) + " " + count [ i ] + " " ) ; } }
function isInGivenBase ( str , bas ) { if ( bas > 16 ) return false ; else if ( bas <= 10 ) { for ( let i = 0 ; i < str . length ; i ++ ) if ( ! ( str [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str [ i ] . charCodeAt ( ) < ( ' ' . charCodeAt ( ) + bas ) ) ) return false ; } else { for ( let i = 0 ; i < str . length ; i ++ ) if ( ! ( ( str [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str [ i ] . charCodeAt ( ) < ( ' ' . charCodeAt ( ) + bas ) ) || ( str [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str [ i ] . charCodeAt ( ) < ( ' ' . charCodeAt ( ) + bas - 10 ) ) ) ) return false ; } return true ; }
function arePermutation ( str1 , str2 ) { let n1 = str1 . length ; let n2 = str2 . length ; if ( n1 != n2 ) return false ; let ch1 = str1 . split ( ' ' ) ; let ch2 = str2 . split ( ' ' ) ; ch1 . sort ( ) ; ch2 . sort ( ) ; for ( let i = 0 ; i < n1 ; i ++ ) if ( ch1 [ i ] != ch2 [ i ] ) return false ; return true ; }
function powerOfJump ( s ) { let count = 1 ; let max_so_far = Number . MIN_VALUE ; let ch = s [ s . length - 1 ] ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == ch ) { if ( count > max_so_far ) { max_so_far = count ; } count = 1 ; } else count ++ ; } return max_so_far ; }
function averageValue ( s ) { let sum_char = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { sum_char += ( s [ i ] ) . charCodeAt ( 0 ) ; } return Math . floor ( sum_char / s . length ) ; }
function solve ( s1 , s2 ) { let flag1 = 0 , flag2 = 0 ; if ( s1 . length != s2 . length ) return false ; let l = s1 . length ; for ( let i = 0 ; i < l ; i ++ ) { if ( s1 [ i ] == ' ' ) flag1 = 1 ; if ( s2 [ i ] == ' ' ) flag2 = 1 ; if ( flag1 && flag2 ) return true ; } if ( ! flag1 && ! flag2 ) return true ; return false ; }
function firstNonRepeating ( str ) { let NO_OF_CHARS = 256 ; let arr = new Array ( NO_OF_CHARS ) ; for ( let i = 0 ; i < NO_OF_CHARS ; i ++ ) arr [ i ] = - 1 ; for ( let i = 0 ; i < str . length ; i ++ ) { if ( arr [ str [ i ] . charCodeAt ( 0 ) ] == - 1 ) arr [ str [ i ] . charCodeAt ( 0 ) ] = i ; else arr [ str [ i ] . charCodeAt ( 0 ) ] = - 2 ; } let res = Number . MAX_VALUE ; for ( let i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( arr [ i ] >= 0 ) res = Math . min ( res , arr [ i ] ) ; return res ; }
function multiply ( num1 , num2 ) { let n1 = num1 . length ; let n2 = num2 . length ; if ( n1 == 0 n2 == 0 ) return " " ; let result = new Array ( n1 + n2 ) ; for ( let i = 0 ; i < result . length ; i ++ ) { result [ i ] = 0 ; } let i_n1 = 0 ; let i_n2 = 0 ; for ( let i = n1 - 1 ; i >= 0 ; i -- ) { let carry = 0 ; let n_1 = num1 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; i_n2 = 0 ; for ( let j = n2 - 1 ; j >= 0 ; j -- ) { let n_2 = num2 [ j ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; let sum = n_1 * n_2 + result [ i_n1 + i_n2 ] + carry ; carry = Math . floor ( sum / 10 ) ; result [ i_n1 + i_n2 ] = sum % 10 ; i_n2 ++ ; } if ( carry > 0 ) result [ i_n1 + i_n2 ] += carry ; i_n1 ++ ; } let i = result . length - 1 ; while ( i >= 0 && result [ i ] == 0 ) i -- ; if ( i == - 1 ) return " " ; let s = " " ; while ( i >= 0 ) s += ( result [ i -- ] ) . toString ( ) ; return s ; }
function countDigits ( st , n ) { if ( n > 0 ) { let cnt = 1 , i ; let st2 = " " ; for ( i = 1 ; i < st . length ; i ++ ) { if ( st [ i ] == st [ i - 1 ] ) cnt ++ ; else { st2 += String . fromCharCode ( ' ' . charCodeAt ( ) + cnt ) ; st2 += st [ i - 1 ] ; cnt = 1 ; } } st2 += String . fromCharCode ( ' ' . charCodeAt ( ) + cnt ) ; st2 += st [ i - 1 ] ; countDigits ( st2 , -- n ) ; } else document . write ( st ) ; }
function countSubstrig ( str1 , str2 ) { let n1 = str1 . length ; let n2 = str2 . length ; if ( n1 == 0 n1 < n2 ) return 0 ; if ( str1 . substr ( 0 , n2 ) == ( str2 ) ) return countSubstrig ( str1 . substr ( n2 - 1 ) , str2 ) + 1 ; return countSubstrig ( str1 . substr ( n2 - 1 ) , str2 ) ; }
function check ( s , m ) { let l = s . length ; let c1 = 0 ; let c2 = 0 ; for ( let i = 0 ; i < l ; i ++ ) { if ( s [ i ] == ' ' ) { c2 = 0 ; c1 ++ ; } else { c1 = 0 ; c2 ++ ; } if ( c1 == m c2 == m ) return true ; } return false ; }
function nextGreatestAlphabet ( alphabets , K ) { var l = 0 , r = alphabets . length - 1 ; var ans = - 1 ; while ( l <= r ) { var mid = ( l + r ) / 2 ; if ( alphabets [ mid ] > K ) { ans = mid ; r = mid - 1 ; } else l = mid + 1 ; } return alphabets [ ans ] ; }
function hasAllcodes ( s , k ) { let us = new Set ( ) ; for ( let i = 0 ; i + k <= s . length ; i ++ ) { us . add ( s . substring ( i , i + k ) ) ; } return ( us . size == ( 1 << k ) ) ; } let s = " " ; let k = 2 ; if ( hasAllcodes ( s , k ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function possibleToSort ( arr , n , str ) { let max_element = - 1 ; for ( let i = 0 ; i < str . length ; i ++ ) { max_element = Math . max ( max_element , arr [ i ] ) ; if ( str [ i ] == ' ' ) { if ( max_element > i + 1 ) return " " ; } } return " " ; }
function countSubsequence ( s , n ) { var cntG = 0 , cntF = 0 , result = 0 , C = 0 ; for ( var i = 0 ; i < n ; i ++ ) { switch ( s [ i ] ) { case ' ' : cntG ++ ; result += C ; break ; case ' ' : cntF ++ ; C += cntG ; break ; default : continue ; } } document . write ( result ) ; }
function LexicographicalMaxString ( str ) { var mx = " " ; for ( var i = 0 ; i < str . length ; ++ i ) { if ( mx . localeCompare ( str . substring ( i ) ) <= 0 ) { mx = str . substring ( i ) ; } } return mx ; }
function isDivisible ( str , k ) { let n = str . length ; let c = 0 ; for ( let i = 0 ; i < k ; i ++ ) if ( str [ n - i - 1 ] == ' ' ) c ++ ; return ( c == k ) ; }
function countNonEmptySubstr ( str ) { let n = str . length ; return n * ( n + 1 ) / 2 ; }
function countWays ( s ) { let count = new Array ( 26 ) ; count . fill ( 0 ) ; for ( let i = 0 ; i < s . length ; i ++ ) count [ s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ++ ; count [ s [ 0 ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] = 1 ; let ans = 1 ; for ( let i = 0 ; i < 26 ; ++ i ) if ( count [ i ] != 0 ) ans *= count [ i ] ; return ans ; }
function isPerfectSquareString ( str ) { var sum = 0 ; var len = str . length ; for ( var i = 0 ; i < len ; i ++ ) sum += str . charCodeAt ( i ) ; var squareRoot = Math . sqrt ( sum ) ; return squareRoot - Math . floor ( squareRoot ) == 0 ; }
function findSubstrings ( s , k ) { var ans = 0 ; var cnt = Array ( 26 ) ; var i , j , n = s . length ; for ( i = 0 ; i < n ; i ++ ) { cnt = Array ( 26 ) . fill ( 0 ) ; for ( j = i ; j < n ; j ++ ) { cnt [ ( s [ j ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ] ++ ; if ( cnt [ ( s [ j ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ] <= k ) ans ++ ; else break ; } } return ans ; }
function findExtraCharcter ( strA , strB ) { let m1 = new Array ( 256 ) ; for ( let i = 0 ; i < 256 ; i ++ ) m1 [ i ] = 0 ; for ( let i = 0 ; i < strB . length ; i ++ ) m1 [ strB [ i ] . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < strA . length ; i ++ ) m1 [ strA [ i ] . charCodeAt ( 0 ) ] -- ; for ( let i = 0 ; i < m1 . length ; i ++ ) { if ( m1 [ i ] == 1 ) return String . fromCharCode ( i ) ; } return Number . MIN_VALUE ; }
function transformString ( ) { var ch = ' ' ; if ( s . length < 26 ) return false ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( ch . charCodeAt ( 0 ) > 122 ) break ; if ( s [ i ] . charCodeAt ( 0 ) <= ch . charCodeAt ( 0 ) ) { s [ i ] = ch ; ch = String . fromCharCode ( ch . charCodeAt ( 0 ) + 1 ) ; } } s = s . join ( ' ' ) if ( ch . charCodeAt ( 0 ) <= ' ' . charCodeAt ( 0 ) ) return false ; return true ; }
function myCopy ( s1 , s2 ) { let i = 0 ; for ( i = 0 ; i < s1 . length ; i ++ ) s2 [ i ] = s1 [ i ] ; }
function numofstring ( n , m ) { if ( n == 1 ) return m ; if ( n == 2 ) return m * ( m - 1 ) ; return m * ( m - 1 ) * Math . pow ( m - 2 , n - 2 ) ; }
function calculateSum ( arr , n ) { if ( n == 0 ) return 0 ; let s = arr [ 0 ] ; let value = parseInt ( s ) ; let sum = value ; for ( let i = 2 ; i < n ; i = i + 2 ) { s = arr [ i ] ; value = parseInt ( s ) ; let operation = arr [ i - 1 ] [ 0 ] ; if ( operation == ' ' ) sum += value ; else sum -= value ; } return sum ; }
function productAtKthLevel ( tree , k ) { let level = - 1 ; let product = 1 ; let n = tree . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( tree [ i ] == ' ' ) level ++ ; else if ( tree [ i ] == ' ' ) level -- ; else { if ( level == k ) product *= ( tree [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; } } return product ; }
function LargestString ( na ) { let N = na . length ; let c = new Array ( N ) ; let m = 1 ; for ( let j = 0 ; j < N ; j ++ ) { let character = new Array ( 26 , 0 ) ; for ( let k = 0 ; k < na [ j ] . length ; k ++ ) { let x = na [ j ] [ k ] . charCodeAt ( 0 ) - 65 ; if ( ( na [ j ] [ k ] != ' ' ) && ( character [ x ] == 0 ) ) { c [ j ] ++ ; character [ x ] = 1 ; } } if ( c [ j ] > c [ m ] ) m = j ; } document . write ( na [ m ] ) ; }
function isCornerPresent ( str , corner ) { var n = str . length ; var cl = corner . length ; if ( n < cl ) return false ; return ( str . substring ( 0 , cl ) . localeCompare ( corner ) === 0 && str . substring ( n - cl , n ) . localeCompare ( corner ) === 0 ) ; }
function minRemoval ( str ) { var hash = Array ( MAX_CHAR ) . fill ( 0 ) ; for ( var i = 0 ; str [ i ] ; i ++ ) hash [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; var count = 0 ; for ( var i = 0 ; i < MAX_CHAR ; i ++ ) if ( hash [ i ] % 2 ) count ++ ; return ( count == 0 ) ? 0 : count - 1 ; }
function printSequence ( arr , input ) { let output = " " ; let n = input . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( input [ i ] == ' ' ) output = output + " " . charCodeAt ( 0 ) ; else { let position = input [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; output = output + arr [ position ] ; } } return output ; }
function findSubsequence ( str , k ) { var a = Array ( MAX_CHAR ) . fill ( 0 ) ; for ( var i = 0 ; i < str . length ; i ++ ) a [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < str . length ; i ++ ) if ( a [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] >= k ) document . write ( str [ i ] ) ; }
function isConvertible ( str1 , str2 , k ) { if ( ( str1 . length + str2 . length ) < k ) return true ; var commonLength = 0 ; for ( var i = 0 ; i < Math . min ( str1 . length , str2 . length ) ; i ++ ) { if ( str1 [ i ] == str2 [ i ] ) commonLength ++ ; else break ; } if ( ( k - str1 . length - str2 . length + 2 * commonLength ) % 2 == 0 ) return true ; return false ; }
function checkPalindrome ( str ) { let n = str . length ; let count = 0 ; for ( let i = 0 ; i < parseInt ( n / 2 , 10 ) ; ++ i ) if ( str [ i ] != str [ n - i - 1 ] ) ++ count ; return ( count <= 1 ) ; }
function findLUSlength ( a , b ) { if ( a === b ) return 0 ; return Math . max ( a . length , b . length ) ; }
function convert ( str ) { var w = " " , z = " " ; str = str . toUpperCase ( ) + " " ; for ( i = 0 ; i < str . length ; i ++ ) { var ch = str [ i ] ; if ( ch != ' ' ) w = w + ch ; else { z = z + ( w [ 0 ] . toLowerCase ( ) ) + w . substring ( 1 ) + " " ; w = " " ; } } return z ; }
function convert ( s ) { var n = s . length ; var s1 = " " ; s1 = s1 + s . charAt ( 0 ) . toLowerCase ( ) ; for ( i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' ' && i < n ) { s1 = s1 + " " + s . charAt ( i + 1 ) . toLowerCase ( ) ; i ++ ; } else s1 = s1 + s . charAt ( i ) . toUpperCase ( ) ; } return s1 ; }
function first ( str ) { for ( var i = 0 ; i < str . length ; i ++ ) if ( str [ i ] === str [ i ] . toUpperCase ( ) ) return str [ i ] ; return 0 ; } var str = " " ; var res = first ( str ) ; if ( res == 0 ) document . write ( " " ) ; else { document . write ( res ) ; document . write ( " " ) ; }
function evenDecimalValue ( str , n ) { var result = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i ; j < n ; j ++ ) { var decimalValue = 0 ; var powerOf2 = 1 ; for ( var k = i ; k <= j ; k ++ ) { decimalValue += ( ( str [ k ] - ' ' ) * powerOf2 ) ; powerOf2 *= 2 ; } if ( decimalValue % 2 == 0 ) result ++ ; } } return result ; }
function swapTwoHalves ( a , b ) { var la = a . length ; var lb = b . length ; var c = a . substring ( 0 , la / 2 ) + b . substring ( lb / 2 , lb ) ; var d = b . substring ( 0 , lb / 2 ) + a . substring ( la / 2 , la ) ; document . write ( c + " " + " " + d ) ; }
function recLen ( str ) { if ( str == " " ) return 0 ; else return recLen ( str . substring ( 1 ) ) + 1 ; }
function lexNext ( s , n ) { for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] != ' ' ) { let code = s . charCodeAt ( i ) + 1 ; let str = String . fromCharCode ( code ) ; return s . substr ( 0 , i ) + str + s . substr ( i + 1 ) ; } s [ i ] = ' ' ; } }
function longCommomAnagramSubseq ( str1 , str2 , n1 , n2 ) { let freq1 = new Array ( SIZE ) ; let freq2 = new Array ( SIZE ) ; for ( let i = 0 ; i < SIZE ; i ++ ) { freq1 [ i ] = 0 ; freq2 [ i ] = 0 ; } let len = 0 ; for ( let i = 0 ; i < n1 ; i ++ ) freq1 [ str1 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < n2 ; i ++ ) freq2 [ str2 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < SIZE ; i ++ ) len += Math . min ( freq1 [ i ] , freq2 [ i ] ) ; return len ; }
function isPanalphabeticWindow ( s , n ) { var ch = ' ' ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ch ) ch = String . fromCharCode ( ch . charCodeAt ( 0 ) + 1 ) ; if ( ch == String . fromCharCode ( ' ' . charCodeAt ( 0 ) + 1 ) ) return true ; } return false ; }
function round ( n ) { let a = parseInt ( n / 10 , 10 ) * 10 ; let b = a + 10 ; return ( n - a > b - n ) ? b : a ; }
function ASCIISentence ( str ) { let l = str . length ; let convert ; for ( let i = 0 ; i < l ; i ++ ) { convert = str [ i ] . charCodeAt ( 0 ) ; document . write ( convert ) ; } }
function convert ( str ) { let n = str . length ; let str1 = " " ; for ( i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) str1 = str1 + ' ' ; else str1 = str1 + ( str [ i ] ) . toLowerCase ( ) ; } document . write ( str1 ) ; }
function findOccurrences ( str1 , substr1 ) { let counter = 0 ; for ( let i = 0 ; i < str1 . length ; i ++ ) { if ( str1 [ i ] == substr1 [ 0 ] ) { for ( let j = i + 1 ; j < str1 . length ; j ++ ) { if ( str1 [ j ] == substr1 [ 1 ] ) { for ( let k = j + 1 ; k < str1 . length ; k ++ ) { if ( str1 [ k ] == substr1 [ 2 ] ) counter ++ ; } } } } } return counter ; }
function isEven ( s ) { let l = s . length ; let dotSeen = false ; for ( let i = l - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == ' ' && dotSeen == false ) continue ; if ( s [ i ] == ' ' ) { dotSeen = true ; continue ; } if ( ( s [ i ] - ' ' ) % 2 == 0 ) return true ; return false ; } }
function largestAnagramSet ( arr , n ) { var maxSize = 0 ; var count = new Map ( ) ; for ( var i = 0 ; i < n ; ++ i ) { var temp = arr [ i ] . split ( ' ' ) ; temp . sort ( ) ; arr [ i ] = temp . join ( ' ' ) ; if ( count . has ( arr [ i ] ) ) { count . set ( arr [ i ] , count . get ( arr [ i ] ) + 1 ) ; } else { count . set ( arr [ i ] , 1 ) ; } maxSize = Math . max ( maxSize , count . get ( arr [ i ] ) ) ; } return maxSize ; }
function countCharacterType ( str ) { var vowels = 0 , consonant = 0 , specialChar = 0 , digit = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { var ch = str [ i ] ; if ( ( ch >= " " && ch <= " " ) || ( ch >= " " && ch <= " " ) ) { ch = ch . toLowerCase ( ) ; if ( ch == " " ch == " " ch == " " ch == " " ch == " " ) vowels ++ ; else consonant ++ ; } else if ( ch >= " " && ch <= " " ) digit ++ ; else specialChar ++ ; } document . write ( " " + vowels + " " ) ; document . write ( " " + consonant + " " ) ; document . write ( " " + digit + " " ) ; document . write ( " " + specialChar + " " ) ; }
function finalPosition ( move ) { let l = move . length ; let countUp = 0 , countDown = 0 ; let countLeft = 0 , countRight = 0 ; for ( let i = 0 ; i < l ; i ++ ) { if ( move [ i ] == ' ' ) countUp ++ ; else if ( move [ i ] == ' ' ) countDown ++ ; else if ( move [ i ] == ' ' ) countLeft ++ ; else if ( move [ i ] == ' ' ) countRight ++ ; } document . write ( " " + ( countRight - countLeft ) + " " + ( countUp - countDown ) + " " ) ; }
function replace ( s , c1 , c2 ) { let l = s . length ; let arr = s . split ( " " ) ; for ( let i = 0 ; i < l ; i ++ ) { if ( arr [ i ] == c1 ) arr [ i ] = c2 ; else if ( arr [ i ] == c2 ) arr [ i ] = c1 ; } return arr . join ( " " ) ; }
function maxbalancedprefix ( str , n ) { var sum = 0 ; var maxi = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) sum += 1 ; else sum -= 1 ; if ( sum < 0 ) break ; if ( sum == 0 ) maxi = i + 1 ; } return maxi ; }
function fibWord ( n ) { var Sn_1 = " " ; var Sn = " " ; var tmp ; for ( var i = 2 ; i <= n ; i ++ ) { tmp = Sn ; Sn += Sn_1 ; Sn_1 = tmp ; } return Sn ; }
function countOccurrences ( str , word ) { let a = str . split ( " " ) ; let count = 0 ; for ( let i = 0 ; i < a . length ; i ++ ) { if ( word == ( a [ i ] ) ) count ++ ; } return count ; }
function compute ( str , n ) { let reverseAlphabet = " " ; let l = str . length ; let answer = " " ; for ( let i = 0 ; i < n ; i ++ ) answer = answer + str [ i ] ; for ( let i = n ; i < l ; i ++ ) answer = answer + reverseAlphabet [ str [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ; return answer ; }
function generateString ( n ) { var s = " " ; for ( var i = 0 ; i < n ; i ++ ) s += ( ( i & 2 ) > 1 ? ' ' : ' ' ) ; document . write ( s + " " ) ; }
function cost ( str ) { let len = str . length ; let res = 0 ; for ( let i = 0 , j = len - 1 ; i < j ; i ++ , j -- ) { if ( str [ i ] != str [ j ] ) { res += Math . min ( str [ i ] . charCodeAt ( ) , str [ j ] . charCodeAt ( ) ) - ' ' . charCodeAt ( ) + 1 ; } } return res ; }
function isValidISBN ( isbn ) { let n = isbn . length ; if ( n != 10 ) return false ; let sum = 0 ; for ( let i = 0 ; i < 9 ; i ++ ) { let digit = isbn [ i ] - ' ' ; if ( 0 > digit 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } let last = isbn [ 9 ] ; if ( last != ' ' && ( last < ' ' last > ' ' ) ) return false ; sum += ( ( last == ' ' ) ? 10 : ( last - ' ' ) ) ; return ( sum % 11 == 0 ) ; }
function remainder ( str ) { let len = str . length ; let num ; let rem = 0 ; for ( let i = 0 ; i < len ; i ++ ) { num = rem * 10 + ( str [ i ] - ' ' ) ; rem = num % 11 ; } return rem ; }
function longestSubseq ( s ) { let n = s . length ; let pre_count_0 = new Array ( n + 2 ) ; let pre_count_1 = new Array ( n + 1 ) ; let post_count_0 = new Array ( n + 2 ) ; pre_count_0 [ 0 ] = 0 ; post_count_0 [ n + 1 ] = 0 ; pre_count_1 [ 0 ] = 0 ; for ( let j = 1 ; j <= n ; j ++ ) { pre_count_0 [ j ] = pre_count_0 [ j - 1 ] ; pre_count_1 [ j ] = pre_count_1 [ j - 1 ] ; post_count_0 [ n - j + 1 ] = post_count_0 [ n - j + 2 ] ; if ( s [ j - 1 ] == ' ' ) pre_count_0 [ j ] ++ ; else pre_count_1 [ j ] ++ ; if ( s [ n - j ] == ' ' ) post_count_0 [ n - j + 1 ] ++ ; } if ( pre_count_0 [ n ] == n pre_count_0 [ n ] == 0 ) return n ; let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = i ; j <= n ; j ++ ) ans = Math . max ( pre_count_0 [ i - 1 ] + pre_count_1 [ j ] - pre_count_1 [ i - 1 ] + post_count_0 [ j + 1 ] , ans ) ; return ans ; }
function removeSpecialCharacter ( s ) { for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] < ' ' s [ i ] > ' ' && s [ i ] < ' ' s [ i ] > ' ' ) { s = s . substring ( 0 , i ) + s . substring ( i + 1 ) ; i -- ; } } document . write ( s ) ; }
function removeSpecialCharacter ( str ) { let s = str . split ( " " ) ; let j = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( ( s [ i ] >= ' ' && s [ i ] <= ' ' ) || ( s [ i ] >= ' ' && s [ i ] <= ' ' ) ) { s [ j ] = s [ i ] ; j ++ ; } } document . write ( ( s ) . join ( " " ) . substring ( 0 , j ) ) ; }
function maximumChars ( str ) { let n = str . length ; let res = - 1 ; for ( let i = 0 ; i < n - 1 ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( str [ i ] == str [ j ] ) res = Math . max ( res , Math . abs ( j - i - 1 ) ) ; return res ; }
function maximumChars ( str ) { let n = str . length ; let res = - 1 ; let firstInd = new Array ( MAX_CHAR ) ; for ( let i = 0 ; i < MAX_CHAR ; i ++ ) firstInd [ i ] = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { let first_ind = firstInd [ str [ i ] . charCodeAt ( 0 ) ] ; if ( first_ind == - 1 ) firstInd [ str [ i ] . charCodeAt ( 0 ) ] = i ; else res = Math . max ( res , Math . abs ( i - first_ind - 1 ) ) ; } return res ; }
function isUnique ( a , n , k ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += a [ i ] ; sum += n - 1 ; return ( sum == k ) ; }
function findString ( n , k ) { let res = " " ; for ( let i = 0 ; i < k ; i ++ ) res = res + String . fromCharCode ( ' ' . charCodeAt ( 0 ) + i ) ; let count = 0 ; for ( let i = 0 ; i < n - k ; i ++ ) { res = res + String . fromCharCode ( ' ' . charCodeAt ( 0 ) + count ) ; count ++ ; if ( count == k ) count = 0 ; } return res ; }
function countReduce ( str ) { let n = str . length ; let res = 0 ; for ( let i = 0 ; i < parseInt ( n / 2 , 10 ) ; i ++ ) res += Math . abs ( str [ i ] . charCodeAt ( ) - str [ n - i - 1 ] . charCodeAt ( ) ) ; return res ; }
function calculate ( s ) { let ans = 6 ; for ( let i = 0 ; i < 10 ; ++ i ) { for ( let j = 0 ; j < 10 ; ++ j ) { for ( let k = 0 ; k < 10 ; ++ k ) { for ( let l = 0 ; l < 10 ; ++ l ) { for ( let m = 0 ; m < 10 ; ++ m ) { for ( let n = 0 ; n < 10 ; ++ n ) { if ( i + j + k == l + m + n ) { let c = 0 ; if ( i != s [ 0 ] - ' ' ) c ++ ; if ( j != s [ 1 ] - ' ' ) c ++ ; if ( k != s [ 2 ] - ' ' ) c ++ ; if ( l != s [ 3 ] - ' ' ) c ++ ; if ( m != s [ 4 ] - ' ' ) c ++ ; if ( n != s [ 5 ] - ' ' ) c ++ ; if ( c < ans ) ans = c ; } } } } } } } return ans ; }
function makeAndCheckString ( words , str ) { let n = words . length ; let first = false , second = false ; for ( let i = 0 ; i < n ; i ++ ) { if ( words [ i ] == str ) return true ; if ( str [ 0 ] == words [ i ] [ 1 ] ) first = true ; if ( str [ 1 ] == words [ i ] [ 0 ] ) second = true ; if ( first && second ) return true ; } return false ; }
function checkLuhn ( cardNo ) { let nDigits = cardNo . length ; let nSum = 0 ; let isSecond = false ; for ( let i = nDigits - 1 ; i >= 0 ; i -- ) { let d = cardNo [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ; if ( isSecond == true ) d = d * 2 ; nSum += parseInt ( d / 10 , 10 ) ; nSum += d % 10 ; isSecond = ! isSecond ; } return ( nSum % 10 == 0 ) ; }
function findRepeatFirstN2 ( s ) { let p = - 1 , i , j ; for ( i = 0 ; i < s . length ; i ++ ) { for ( j = i + 1 ; j < s . length ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } } if ( p != - 1 ) break ; } return p ; }
function countSubstrs ( str , i , j , n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; let res = countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ; if ( str [ i ] == str [ j ] ) res ++ ; return res ; }
function stringPalindrome ( A , B ) { var countA = Array . from ( { length : MAX_CHAR } , ( _ , i ) => 0 ) ; var countB = Array . from ( { length : MAX_CHAR } , ( _ , i ) => 0 ) ; var l1 = A . length ; var l2 = B . length ; for ( var i = 0 ; i < l1 ; i ++ ) countA [ A . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < l2 ; i ++ ) countB [ B . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < 26 ; i ++ ) if ( ( countA [ i ] > 1 && countB [ i ] == 0 ) ) return ' ' ; return ' ' ; }
function printCharWithFreq ( str ) { let n = str . length ; let freq = new Array ( SIZE ) ; for ( let i = 0 ; i < freq . length ; i ++ ) { freq [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] != 0 ) { document . write ( str [ i ] ) ; document . write ( freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] + " " ) ; freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] = 0 ; } } }
function FirstRepeated ( str ) { let checker = 0 ; for ( let i = 0 ; i < str . length ; ++ i ) { let val = ( str [ i ] - ' ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return i ; checker |= ( 1 << val ) ; } return - 1 ; }
function printSubsequences ( s ) { let str = s . split ( ' ' ) ; let n = str . length ; let opsize = Math . pow ( 2 , n - 1 ) ; for ( let counter = 0 ; counter < opsize ; counter ++ ) { for ( let j = 0 ; j < n ; j ++ ) { document . write ( str [ j ] ) ; if ( ( counter & ( 1 << j ) ) > 0 ) document . write ( " " ) ; } document . write ( " " ) ; } }
function sentencePalindrome ( str ) { let l = 0 ; let h = str . length - 1 ; str = str . toLowerCase ( ) ; while ( l <= h ) { let getAtl = str [ l ] ; let getAth = str [ h ] ; if ( ! ( getAtl >= ' ' && getAtl <= ' ' ) ) l ++ ; else if ( ! ( getAth >= ' ' && getAth <= ' ' ) ) h -- ; else if ( getAtl == getAth ) { l ++ ; h -- ; } else return false ; } return true ; }
function substringConversions ( str , k , b ) { for ( let i = 0 ; i + k <= str . length ; i ++ ) { let sub = str . substring ( i , i + k ) ; let sum = 0 , counter = 0 ; for ( let j = sub . length - 1 ; j >= 0 ; j -- ) { sum = ( sum + ( ( sub [ j ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) * Math . pow ( b , counter ) ) ) ; counter ++ ; } document . write ( sum + " " ) ; } }
function permute ( input ) { var n = input . length ; var max = 1 << n ; input = input . toLowerCase ( ) ; for ( var i = 0 ; i < max ; i ++ ) { var combination = input . split ( ' ' ) ; for ( var j = 0 ; j < n ; j ++ ) { if ( ( ( i >> j ) & 1 ) == 1 ) combination [ j ] = String . fromCharCode ( combination [ j ] . charCodeAt ( 0 ) - 32 ) ; } document . write ( combination . join ( ' ' ) ) ; document . write ( " " ) ; } }
function xorZero ( s ) { let one_count = 0 , zero_count = 0 ; let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) if ( s [ i ] == ' ' ) one_count ++ ; else zero_count ++ ; if ( one_count % 2 == 0 ) return zero_count ; return one_count ; }
function findFlips ( str , n ) { var last = ' ' ; var res = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( last != str . charAt ( i ) ) res ++ ; last = str . charAt ( i ) ; } return parseInt ( res / 2 ) ; }
function isNumber ( s ) { for ( let i = 0 ; i < s . length ; i ++ ) if ( s [ i ] < ' ' s [ i ] > ' ' ) return false ; return true ; }
function allCharactersSame ( s ) { let s1 = new Set ( ) ; for ( let i = 0 ; i < s . length ; i ++ ) { s1 . add ( s [ i ] ) ; } if ( s1 . size == 1 ) document . write ( " " ) ; else document . write ( " " ) ; }
function evenlength ( n ) { let res = n ; for ( let j = n . length - 1 ; j >= 0 ; -- j ) res += n [ j ] ; return res ; }
function possibleStrings ( n , r , b , g ) { let fact = new Array ( n + 1 ) ; fact [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; let left = n - ( r + g + b ) ; let sum = 0 ; for ( let i = 0 ; i <= left ; i ++ ) { for ( let j = 0 ; j <= left - i ; j ++ ) { let k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; }
function splitString ( str ) { let alpha = " " ; let num = " " ; let special = " " ; for ( let i = 0 ; i < str . length ; i ++ ) { if ( ! isNaN ( String ( str [ i ] ) * 1 ) ) num += str [ i ] ; else if ( ( str [ i ] >= ' ' && str [ i ] <= ' ' ) || ( str [ i ] >= ' ' && str [ i ] <= ' ' ) ) alpha += str [ i ] ; else special += str [ i ] ; } document . write ( alpha + " " ) ; document . write ( num + " " ) ; document . write ( special + " " ) ; }
function subString ( str , n ) { for ( let len = 1 ; len <= n ; len ++ ) { for ( let i = 0 ; i <= n - len ; i ++ ) { let j = i + len - 1 ; for ( let k = i ; k <= j ; k ++ ) { document . write ( str [ k ] ) ; } document . write ( " " ) ; } } }
function SubString ( str , n ) { for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j <= n ; j ++ ) document . write ( str . substring ( i , j ) + " " ) ; }
function printAllSubStrings ( s , n ) { for ( let i = 0 ; i < n ; i ++ ) { let temp = new Array ( n - i + 1 ) ; let tempindex = 0 ; for ( let j = i ; j < n ; j ++ ) { temp [ tempindex ++ ] = s [ j ] ; temp [ tempindex ] = ' \0 ' ; document . write ( temp . join ( " " ) + " " ) ; } } }
function printSubstrings ( str ) { var n = str . length ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i ; j < n ; j ++ ) { for ( var k = i ; k <= j ; k ++ ) { document . write ( str . charAt ( k ) ) ; } document . write ( " " ) ; } } }
function processWords ( input ) { var s = input . split ( ' ' ) ; s . forEach ( element => { charBuffer += element [ 0 ] ; } ) ; return charBuffer ; }
function amendSentence ( sstr ) { let str = sstr . split ( ' ' ) ; for ( let i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str [ i ] . charCodeAt ( ) <= ' ' . charCodeAt ( ) ) { str [ i ] = String . fromCharCode ( str [ i ] . charCodeAt ( ) + 32 ) ; if ( i != 0 ) document . write ( " " ) ; document . write ( str [ i ] ) ; } else document . write ( str [ i ] ) ; } }
function repeat ( s , n ) { let s1 = s ; for ( let i = 1 ; i < n ; i ++ ) return s ; }
function lengthOfLastWord ( a ) { let len = 0 ; x = a . trim ( ) ; for ( let i = 0 ; i < x . length ; i ++ ) { if ( x [ i ] == ' ' ) { len = 0 ; } else { len ++ ; } } return len ; }
function toggleCase ( a ) { for ( i = 0 ; i < a . length ; i ++ ) { a [ i ] = String . fromCharCode ( a [ i ] . charCodeAt ( 0 ) ^ 32 ) ; } return a . join ( " " ) ; ; }
function uniqueCharacters ( str ) { for ( let i = 0 ; i < str . length ; i ++ ) for ( let j = i + 1 ; j < str . length ; j ++ ) if ( str [ i ] == str [ j ] ) return false ; return true ; }
function uniqueCharacters ( str ) { let checker = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { let bitAtIndex = str [ i ] - ' ' ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) { return false ; } checker = checker | ( 1 << bitAtIndex ) ; } return true ; } let input = " " ; if ( uniqueCharacters ( input ) ) { document . write ( " " + input + " " ) ; } else { document . write ( " " + input + " " ) ; }
function printRotatedString ( str ) { var n = str . length ; var sb = str ; sb += ( str ) ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j != n ; j ++ ) document . write ( sb . charAt ( i + j ) ) ; document . write ( ' ' ) ; } }
function solve ( i , X , Y , a , b , n ) { if ( i == n ) return 0 ; if ( X <= 0 ) return b [ i ] + solve ( i + 1 , X , Y - 1 , a , b , n ) ; if ( Y <= 0 ) return a [ i ] + solve ( i + 1 , X - 1 , Y , a , b , n ) ; else return Math . max ( a [ i ] + solve ( i + 1 , X - 1 , Y , a , b , n ) , b [ i ] + solve ( i + 1 , X , Y - 1 , a , b , n ) ) ; }
function moveSpaceInFront ( str ) { var i = str . length - 1 ; for ( var j = i ; j >= 0 ; j -- ) if ( str [ j ] !== " " ) str [ i -- ] = str [ j ] ; while ( i >= 0 ) str [ i -- ] = " " ; }
function titleToNumber ( s ) { let result = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { result *= 26 ; result += s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) + 1 ; } return result ; }
function isKthBitSet ( n , k ) { if ( ( n & ( 1 << ( k - 1 ) ) ) > 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function isKthBitSet ( n , k ) { if ( ( ( n >> ( k - 1 ) ) & 1 ) > 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function reversingString ( str , start , end ) { while ( start < end ) { str [ start ] = String . fromCharCode ( str [ start ] . charCodeAt ( 0 ) ^ str [ end ] . charCodeAt ( 0 ) ) ; str [ end ] = String . fromCharCode ( str [ end ] . charCodeAt ( 0 ) ^ str [ start ] . charCodeAt ( 0 ) ) ; str [ start ] = String . fromCharCode ( str [ start ] . charCodeAt ( 0 ) ^ str [ end ] . charCodeAt ( 0 ) ) ; ++ start ; -- end ; } return ( str ) . join ( " " ) ; }
function isAnBn ( str ) { let n = str . length ; if ( ( n & 1 ) != 0 ) return " " ; let i ; for ( i = 0 ; i < n / 2 ; i ++ ) if ( str [ i ] != ' ' str [ n - i - 1 ] != ' ' ) return " " ; return " " ; }
function evenNumSubstring ( str ) { let len = str . length ; let count = 0 ; for ( let i = 0 ; i < len ; i ++ ) { let temp = str [ i ] - ' ' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
function countSubstringWithEqualEnds ( s ) { var result = 0 ; var n = s . length ; for ( i = 0 ; i < n ; i ++ ) for ( j = i ; j < n ; j ++ ) if ( s . charAt ( i ) == s . charAt ( j ) ) result ++ ; return result ; }
function countSubstringWithEqualEnds ( s ) { var result = 0 ; var n = s . length ; var count = Array . from ( { length : MAX_CHAR } , ( _ , i ) => 0 ) ; for ( var i = 0 ; i < n ; i ++ ) count [ s . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < MAX_CHAR ; i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; return result ; }
function maxRepeating ( str ) { var n = str . length ; var count = 0 ; var res = str [ 0 ] ; var cur_count = 1 ; for ( var i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str [ i ] == str [ i + 1 ] ) cur_count ++ ; else { if ( cur_count > count ) { count = cur_count ; res = str [ i ] ; } cur_count = 1 ; } } return res ; }
function check ( str ) { let n = str . length ; let oddDigSum = 0 , evenDigSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) oddDigSum += ( str [ i ] - ' ' ) ; else evenDigSum += ( str [ i ] - ' ' ) ; } return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ; }
function print ( str1 ) { let str = str1 . split ( " " ) ; document . write ( str [ 0 ] ) ; for ( let i = 1 ; i < str . length ; i ++ ) { if ( ( str [ i ] . charCodeAt ( 0 ) == str [ i - 1 ] . charCodeAt ( 0 ) + 1 ) || ( str [ i ] . charCodeAt ( 0 ) == str [ i - 1 ] . charCodeAt ( 0 ) - 1 ) ) { document . write ( str [ i ] ) ; } else { document . write ( " " + str [ i ] ) ; } } }
function areChractersUnique ( str ) { let checker = 0 ; for ( let i = 0 ; i < str . length ; ++ i ) { let val = ( str [ i ] - ' ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return false ; checker |= ( 1 << val ) ; } return true ; }
function unique ( s ) { for ( var i = 0 ; i < s . length ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) { return false ; } } return true ; } if ( unique ( " " ) == true ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function countWords ( str , len ) { let count = 1 ; if ( len == 1 ) return count ; if ( str [ 0 ] == str [ 1 ] ) count *= 1 ; else count *= 2 ; for ( let j = 1 ; j < len - 1 ; j ++ ) { if ( str [ j ] == str [ j - 1 ] && str [ j ] == str [ j + 1 ] ) count *= 1 ; else if ( str [ j ] == str [ j - 1 ] str [ j ] == str [ j + 1 ] str [ j - 1 ] == str [ j + 1 ] ) count *= 2 ; else count *= 3 ; } if ( str [ len - 1 ] == str [ len - 2 ] ) count *= 1 ; else count *= 2 ; return count ; }
function hammingDist ( str1 , str2 ) { let i = 0 , count = 0 ; while ( i < str1 . length ) { if ( str1 [ i ] != str2 [ i ] ) count ++ ; i ++ ; } return count ; }
function query ( s , i , j ) { let n = s . length ; i %= n ; j %= n ; if ( s [ i ] == s [ j ] ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; }
function isequal ( str ) { let n = str . length ; let num = 0 , x = 1 , i = n - 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( ' ' <= str [ i ] && str [ i ] <= ' ' ) { num = ( str [ i ] - ' ' ) * x + num ; x = x * 10 ; if ( num >= n ) return false ; } else break ; } return num == i + 1 ; }
function arekAnagrams ( str1 , str2 , k ) { let n = str1 . length ; if ( str2 . length != n ) return false ; let count1 = new Array ( MAX_CHAR ) ; let count2 = new Array ( MAX_CHAR ) ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) count1 [ str1 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < n ; i ++ ) count2 [ str2 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] > count2 [ i ] ) count = count + Math . abs ( count1 [ i ] - count2 [ i ] ) ; return ( count <= k ) ; }
function countToMake0lternate ( s ) { let result = 0 ; for ( let i = 0 ; i < ( s . length - 1 ) ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return result ; }
function countPairs ( str ) { let result = 0 ; let n = str . length ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( str [ i ] . charCodeAt ( ) - str [ j ] . charCodeAt ( ) ) == Math . abs ( i - j ) ) result ++ ; return result ; }
function ispalindrome ( s ) { let l = s . length ; let j ; for ( let i = 0 , j = l - 1 ; i <= j ; i ++ , j -- ) { if ( s [ i ] != s [ j ] ) return false ; } return true ; } let s = " " ; let cnt = 0 ; let flag = 0 ; while ( s . length > 0 ) { if ( ispalindrome ( s ) ) { flag = 1 ; break ; } else { cnt ++ ; s = s . substring ( 0 , s . length - 1 ) ; } }
function findCount ( str ) { var result = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) if ( i === str [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) || i === str [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ) result ++ ; return result ; }
function remAnagram ( str1 , str2 ) { var count1 = Array . from ( { length : 26 } , ( _ , i ) => 0 ) ; var count2 = Array . from ( { length : 26 } , ( _ , i ) => 0 ) ; for ( i = 0 ; i < str1 . length ; i ++ ) count1 [ str1 . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( i = 0 ; i < str2 . length ; i ++ ) count2 [ str2 . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; var result = 0 ; for ( i = 0 ; i < 26 ; i ++ ) result += Math . abs ( count1 [ i ] - count2 [ i ] ) ; return result ; }
function canBecomeEmpty ( str , sub_str ) { while ( str . length > 0 ) { let idx = str . indexOf ( sub_str ) ; if ( idx == - 1 ) { break ; } str = str . replace ( sub_str , " " ) ; } return ( str . length == 0 ) ; } let str = " " , sub_str = " " ; if ( canBecomeEmpty ( str , sub_str ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function waysToPaint ( n ) { var same = 6 ; var diff = 6 ; for ( var i = 0 ; i < n - 1 ; i ++ ) { var sameTmp = 3 * same + 2 * diff ; var diffTmp = 2 * same + 2 * diff ; same = sameTmp ; diff = diffTmp ; } document . write ( same + diff ) ; }
function isReversible ( str ) { var i = 0 , j = str . length - 1 ; while ( i < j ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; j -- ; } return true ; }
function findSum ( str ) { let temp = " " ; let sum = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { let ch = str [ i ] ; if ( ! isNaN ( String ( ch ) * 1 ) ) temp += ch ; else { sum += parseInt ( temp ) ; temp = " " ; } } return sum + parseInt ( temp ) ; }
function intToRoman ( num ) { let m = [ " " , " " , " " , " " ] ; let c = [ " " , " " , " " , " " , " " , " " , " " , " " , " " , " " ] ; let x = [ " " , " " , " " , " " , " " , " " , " " , " " , " " , " " ] ; let i = [ " " , " " , " " , " " , " " , " " , " " , " " , " " , " " ] ; let thousands = m [ Math . floor ( num / 1000 ) ] ; let hundereds = c [ Math . floor ( ( num % 1000 ) / 100 ) ] ; let tens = x [ Math . floor ( ( num % 100 ) / 10 ) ] ; let ones = i [ num % 10 ] ; let ans = thousands + hundereds + tens + ones ; return ans ; }
function countkDist ( str , k ) { var res = 0 ; var n = str . length ; var cnt = Array . from ( { length : 26 } , ( _ , i ) => 0 ) ; for ( i = 0 ; i < n ; i ++ ) { var dist_count = 0 ; for ( j = i ; j < n ; j ++ ) { if ( cnt [ str . charAt ( j ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] == 0 ) dist_count ++ ; cnt [ str . charAt ( j ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; if ( dist_count == k ) res ++ ; } } return res ; }
function to_upper ( input ) { var result = new Array ( input . length ) ; for ( var i = 0 ; i < input . length ; i ++ ) if ( " " . charCodeAt ( 0 ) <= input [ i ] . charCodeAt ( 0 ) <= " " . charCodeAt ( 0 ) ) result [ i ] = String . fromCharCode ( input [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) + " " . charCodeAt ( 0 ) ) ; return result . join ( " " ) . toString ( ) ; }
function to_upper ( In ) { let n = In . length ; for ( let i = 0 ; i < In . length ; i ++ ) if ( ' ' <= In [ i ] && In [ i ] <= ' ' ) In [ i ] = String . fromCharCode ( In [ i ] . charCodeAt ( 0 ) & ( ~ ( 1 << 5 ) ) ) ; return ( In ) . join ( " " ) ; }
function countTriplets ( A ) { var cnt = 0 ; var tuples = new Map ( ) ; A . forEach ( a => { A . forEach ( b => { if ( tuples . has ( a & b ) ) tuples . set ( a & b , tuples . get ( a & b ) + 1 ) else tuples . set ( a & b , 1 ) } ) ; } ) ; A . forEach ( a => { tuples . forEach ( ( value , key ) => { if ( ( key & a ) == 0 ) cnt += value ; } ) ; } ) ; return cnt ; }
function isEditDistanceOne ( s1 , s2 ) { let m = s1 . length , n = s2 . length ; if ( Math . abs ( m - n ) > 1 ) return false ; let count = 0 ; let i = 0 , j = 0 ; while ( i < m && j < n ) { if ( s1 [ i ] != s2 [ j ] ) { if ( count == 1 ) return false ; if ( m > n ) i ++ ; else if ( m < n ) j ++ ; else { i ++ ; j ++ ; } count ++ ; } else { i ++ ; j ++ ; } } if ( i < m j < n ) count ++ ; return count == 1 ; }
function removeRecurringDigits ( num ) { let len = num . length ; let s = " " ; for ( let i = 0 ; i < len ; i ++ ) { s += ( num [ i ] ) ; while ( i + 1 < len && num [ i ] == num [ i + 1 ] ) { i ++ ; } } return s ; }
function maxSubarrayXOR ( arr , n ) { let ans = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { let curr_xor = 0 ; for ( let j = i ; j < n ; j ++ ) { curr_xor = curr_xor ^ arr [ j ] ; ans = Math . max ( ans , curr_xor ) ; } } return ans ; }
function pattern ( str , len ) { for ( var i = 0 ; i < len ; i ++ ) { var j = len - 1 - i ; for ( var k = 0 ; k < len ; k ++ ) { if ( k == i k == j ) document . write ( str . charAt ( k ) ) ; else document . write ( " " ) ; } document . write ( ' ' ) ; } }
function printPattern ( str , len ) { for ( var i = 0 ; i < len ; i ++ ) { for ( var j = 0 ; j < len ; j ++ ) { if ( ( i == j ) || ( i + j == len - 1 ) ) document . write ( str . charAt ( j ) ) ; else document . write ( " " ) ; } document . write ( ' ' ) ; } }
function removeRecur ( n ) { let prev_digit = n % 10 ; let pow = 10 ; let res = prev_digit ; while ( n > 0 ) { let curr_digit = n % 10 ; if ( curr_digit != prev_digit ) { res += curr_digit * pow ; prev_digit = curr_digit ; pow *= 10 ; } n = parseInt ( n / 10 , 10 ) ; } return res ; }
function removeSpace ( str ) { str = str . replace ( / \s / g , ' ' ) return str ; }
function countSubStr ( str , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( str [ j ] == ' ' ) res ++ ; } } } return res ; }
function countSubStr ( str , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) m ++ ; } return m * Math . floor ( ( m - 1 ) / 2 ) ; }
function canFormPalindrome ( a ) { var bitvector = 0 , mask = 0 ; for ( var i = 0 ; i < a . length ; i ++ ) { var x = a . charCodeAt ( i ) - 97 ; mask = 1 << x ; bitvector = bitvector ^ mask ; } return ( ( bitvector & ( bitvector - 1 ) ) == 0 ) ; }
function count9s ( number ) { let count = 0 ; let n = ( number . length ) ; for ( let i = 0 ; i < n ; i ++ ) { let sum = number [ i ] - ' ' ; if ( number [ i ] == ' ' ) { count ++ ; } for ( let j = i + 1 ; j < n ; j ++ ) { sum = ( sum + number [ j ] - ' ' ) % 9 ; if ( sum == 0 ) { count ++ ; } } } return count ; }
function countWords ( str ) { var state = OUT ; var wc = 0 ; var i = 0 ; while ( i < str . length ) { if ( str [ i ] == ' ' str [ i ] == ' ' str [ i ] == ' ' ) state = OUT ; else if ( state == OUT ) { state = IN ; ++ wc ; } ++ i ; } return wc ; }
function longestUniqueSubsttr ( str ) { var n = str . length ( ) ; var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) { var visited = new [ 256 ] ; for ( var j = i ; j < n ; j ++ ) { if ( visited [ str . charAt ( j ) ] == true ) break ; else { res = Math . max ( res , j - i + 1 ) ; visited [ str . charAt ( j ) ] = true ; } } visited [ str . charAt ( i ) ] = false ; } return res ; }
function printRLE ( str ) { let n = str . length ; for ( let i = 0 ; i < n ; i ++ ) { let count = 1 ; while ( i < n - 1 && str [ i ] == str [ i + 1 ] ) { count ++ ; i ++ ; } document . write ( str [ i ] ) ; document . write ( count ) ; } }
function reverse ( str , len ) { if ( len == str . length ) { return ; } reverse ( str , len + 1 ) ; document . write ( str [ len ] ) ; }
function removeDuplicate ( str , n ) { var s = new Set ( ) ; for ( var i = 0 ; i < n ; i ++ ) s . add ( str [ i ] ) ; for ( const v of s ) { document . write ( v ) ; } }
function unique ( s ) { let str = " " ; let len = s . length ; for ( let i = 0 ; i < len ; i ++ ) { let c = s [ i ] ; if ( str . indexOf ( c ) < 0 ) { str += c ; } } return str ; }
function maximumXOR ( arr , n , K ) { K ++ ; let maxXor = Number . MIN_SAFE_INTEGER ; for ( let i = 0 ; i < ( 1 << n ) ; i ++ ) { if ( ( i ) . toString ( 2 ) . split ( ' ' ) . filter ( x => x == ' ' ) . length == K ) { let cur_xor = 0 ; for ( let j = 0 ; j < n ; j ++ ) { if ( i & ( 1 << j ) ) cur_xor = cur_xor ^ arr [ j ] ; } maxXor = Math . max ( maxXor , cur_xor ) ; } } return maxXor ; }
function TowerOfHanoi ( N ) { for ( let x = 1 ; x <= Math . pow ( 2 , N ) - 1 ; x ++ ) { document . write ( " " + ( ( x & x - 1 ) % 3 + 1 ) + " " + ( ( ( x x - 1 ) + 1 ) % 3 + 1 ) + " " ) ; } }
function printpairs ( arr , sum ) { let s = new Set ( ) ; for ( let i = 0 ; i < arr . length ; ++ i ) { let temp = sum - arr [ i ] ; if ( s . has ( temp ) ) { document . write ( " " + sum + " " + arr [ i ] + " " + temp + " " ) ; } s . add ( arr [ i ] ) ; } }
function numPairs ( a , n ) { let ans , i , index ; ans = 0 ; for ( i = 0 ; i < n ; i ++ ) a [ i ] = Math . abs ( a [ i ] ) ; a . sort ( ) ; for ( i = 0 ; i < n ; i ++ ) { index = 2 ; ans += index - i - 1 ; } return ans ; }
function count ( arr , low , high , x ) { if ( ( low > high ) || ( low == high && arr [ low ] != x ) ) return 0 ; if ( low == high && arr [ low ] == x ) return 1 ; return count ( arr , low , Math . floor ( ( low + high ) / 2 ) , x ) + count ( arr , 1 + Math . floor ( ( low + high ) / 2 ) , high , x ) ; }
function F ( A , B ) { if ( A == 1 ) return ( 4 % B ) ; else { var temp = F ( A - 1 , B ) ; return ( temp * temp ) % B ; } }
function rangeSum ( l , r ) { var a = 1 , b = 9 , res = 0 ; for ( var i = 1 ; i <= 10 ; i ++ ) { var L = Math . max ( l , a ) ; var R = Math . min ( r , b ) ; if ( L <= R ) { var sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += ( i * i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; }
function exponentMod ( A , B , C ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; var y ; if ( B % 2 == 0 ) { y = exponentMod ( A , B / 2 , C ) ; y = ( y * y ) % C ; } else { y = A % C ; y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C ; } return parseInt ( ( ( y + C ) % C ) ) ; }
function minDaysToEmpty ( C , l ) { if ( l >= C ) return C ; let eq_root = ( Math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 ; return ( Math . ceil ( eq_root ) + l ) ; }
function shuffleArray ( a , n ) { for ( let i = 0 , q = 1 , k = n ; i < n ; i ++ , k ++ , q ++ ) for ( let j = k ; j > i + q ; j -- ) { let temp = a [ j - 1 ] ; a [ j - 1 ] = a [ j ] ; a [ j ] = temp ; } }
function kth ( arr1 , arr2 , m , n , k ) { var sorted1 = Array ( m + n ) . fill ( 0 ) ; var i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; else sorted1 [ d ++ ] = arr2 [ j ++ ] ; } while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ; return sorted1 [ k - 1 ] ; }
function binarySearch ( arr , left , right ) { if ( left <= right ) { var mid = parseInt ( ( left + right ) / 2 ) ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] < arr [ mid + 1 ] ) return binarySearch ( arr , mid + 1 , right ) ; else return binarySearch ( arr , left , mid - 1 ) ; } return - 1 ; }
function findRepeatingElement ( arr , low , high ) { if ( low > high ) return - 1 ; var mid = parseInt ( ( low + high ) / 2 ) ; if ( arr [ mid ] != mid + 1 ) { if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid ; return findRepeatingElement ( arr , low , mid - 1 ) ; } return findRepeatingElement ( arr , mid + 1 , high ) ; }
function power ( x , y ) { let res = 1 ; while ( y > 0 ) { if ( y & 1 ) res = res * x ; y = y >> 1 ; x = x * x ; } return res ; }
function power ( x , y , p ) { let res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = $y / 2 y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
function floorSqrt ( x ) { if ( x == 0 x == 1 ) return x ; let i = 1 ; let result = 1 ; while ( result <= x ) { i ++ ; result = i * i ; } return i - 1 ; }
function countDirectPath ( N ) { return N + Math . floor ( ( N * ( N - 3 ) ) / 2 ) ; }
function findArea ( a , b , c ) { let area = 4 * 3.141592653 * Math . pow ( ( Math . pow ( a * b , 1.6 ) + Math . pow ( a * c , 1.6 ) + Math . pow ( b * c , 1.6 ) ) / 3 , 1 / 1.6 ) ; document . write ( area . toPrecision ( 6 ) ) ; }
function findRadius ( r1 , r2 , r3 ) { let r4 = ( r1 * r2 * r3 ) / ( r1 * r2 + r2 * r3 + r1 * r3 + 2.0 * Math . sqrt ( r1 * r2 * r3 * ( r1 + r2 + r3 ) ) ) ; return r4 . toFixed ( 6 ) ; }
function findSides ( A , C , c ) { let B = 180 - ( A + C ) ; A = A * ( 3.14159 / 180 ) ; C = C * ( 3.14159 / 180 ) ; B = B * ( 3.14159 / 180 ) ; let a = ( c / Math . sin ( C ) ) * Math . sin ( A ) ; let b = ( c / Math . sin ( C ) ) * Math . sin ( B ) ; document . write ( a . toPrecision ( 4 ) + " " ) ; document . write ( b . toPrecision ( 4 ) + " " ) ; }
function minimumRectangleArea ( A , N ) { let ans ; A . sort ( ) ; ans = ( A [ N - 1 ] - A [ 0 ] ) * ( A [ 2 * N - 1 ] - A [ N ] ) ; for ( let i = 1 ; i < N ; i ++ ) ans = Math . min ( ans , ( A [ 2 * N - 1 ] - A [ 0 ] ) * ( A [ i + N - 1 ] - A [ i ] ) ) ; return ans ; }
function closestsAngle ( N , A ) { let mi = Number . MAX_VALUE ; let ans = 0 ; for ( let i = 1 ; i < N - 1 ; i ++ ) { let angle = 180.0 * i / N ; if ( Math . abs ( angle - A ) < Math . abs ( mi - A ) ) { mi = angle ; ans = i ; } } document . write ( 2 + ' ' + 1 + ' ' + parseInt ( 2 + ans ) ) ; }
function areaOftriangle ( side ) { let a = Math . sqrt ( Math . pow ( side / 2 , 2 ) + Math . pow ( side / 2 , 2 ) ) ; let b = Math . sqrt ( Math . pow ( side , 2 ) + Math . pow ( side / 2 , 2 ) ) ; let c = Math . sqrt ( Math . pow ( side , 2 ) + Math . pow ( side / 2 , 2 ) ) ; let s = ( a + b + c ) / 2 ; let area = Math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; return area . toFixed ( 1 ) ; }
function lengthOfLatusRectum ( A , B ) { var major = 2.0 * A ; var minor = 2.0 * B ; var latus_rectum = ( minor * minor ) / major ; return latus_rectum ; }
function check_position ( a , b , c , d , x1 , y1 , z1 , x2 , y2 , z2 ) { var value_1 = a * x1 + b * y1 + c * z1 + d ; var value_2 = a * x2 + b * y2 + c * z2 + d ; if ( ( value_1 > 0 && value_2 > 0 ) || ( value_1 < 0 && value_2 < 0 ) ) document . write ( " " ) ; if ( ( value_1 > 0 && value_2 < 0 ) || ( value_1 < 0 && value_2 > 0 ) ) document . write ( " " ) ; if ( value_1 == 0 && value_2 == 0 ) document . write ( " " ) ; if ( value_1 == 0 && value_2 != 0 ) document . write ( " " ) ; if ( value_1 != 0 && value_2 == 0 ) document . write ( " " ) ; }
function findLine ( distance , degree ) { let x = degree * 3.14159 / 180 ; if ( degree > 90 ) { document . write ( " " ) ; return ; } let result_1 = Math . sin ( x ) ; let result_2 = Math . cos ( x ) ; document . write ( result_2 . toPrecision ( 2 ) + " " + result_1 . toPrecision ( 2 ) + " " + distance ) ; }
function AreaFactor ( n ) { let pi = 3.14159265 ; let areaf = ( 1 / ( Math . cos ( pi / n ) * Math . cos ( pi / n ) ) ) ; document . write ( areaf . toFixed ( 6 ) ) ; }
function eccHyperbola ( A , B ) { let r = B * B / A * A ; r += 1 ; return Math . sqrt ( r ) ; }
function findAngle ( M1 , M2 ) { var angle = Math . abs ( ( M2 - M1 ) / ( 1 + M1 * M2 ) ) ; var ret = Math . atan ( angle ) ; var val = ( ret * 180 ) / PI ; document . write ( val . toFixed ( 4 ) ) ; }
function calculateArea ( A , B , C , D ) { let S = ( A + B + C + D ) / 2 let area = Math . sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) return area ; }
function angle ( R1 , R2 , D ) { var ans = ( R1 * R1 + R2 * R2 - D * D ) / ( 2 * R1 * R2 ) ; return ans ; }
function triangleArea ( a , b ) { ratio = b / a document . write ( ratio ) }
function minimumTriangleArea ( a , b ) { var area = a * b console . log ( area ) }
function findAngles ( a , b , c , d ) { var numerator = a * a + d * d - b * b - c * c var denominator = 2 * ( a * b + c * d ) var x = numerator / denominator document . write ( " " , Math . round ( ( ( Math . acos ( x ) * 180 ) / 3.141592 ) * 100 ) / 100.0 , " " ) ; document . write ( " " ) ; numerator = a * a + b * b - c * c - d * d x = numerator / denominator document . write ( " " , Math . round ( ( ( Math . acos ( x ) * 180 ) / 3.141592 ) * 100 ) / 100.0 , " " ) ; document . write ( " " ) ; numerator = c * c + b * b - a * a - d * d x = numerator / denominator document . write ( " " , Math . round ( ( ( Math . acos ( x ) * 180 ) / 3.141592 ) * 100 ) / 100.0 , " " ) ; document . write ( " " ) ; numerator = d * d + c * c - a * a - b * b x = numerator / denominator document . write ( " " , Math . round ( ( ( Math . acos ( x ) * 180 ) / 3.141592 ) * 100 ) / 100.0 , " " ) ; }
function countInscribed ( R1 , R2 ) { if ( R2 > R1 ) return 0 ; let angle ; let ratio ; let number_of_circles = 0 ; ratio = R2 / ( R1 - R2 ) ; if ( R1 < 2 * R2 ) { number_of_circles = 1 ; } else { angle = Math . abs ( Math . asin ( ratio ) * 180 ) / 3.14159265 ; number_of_circles = 360 / ( 2 * Math . floor ( angle ) ) ; } return number_of_circles ; }
function findPairs ( x , y , K ) { let n = x . length ; let ans = 0 ; for ( let i = 0 ; i < n ; ++ i ) { for ( let j = i + 1 ; j < n ; ++ j ) { if ( K * Math . abs ( x [ i ] - x [ j ] ) >= Math . abs ( y [ i ] - y [ j ] ) ) { ++ ans ; } } } document . write ( ans ) ; }
function lengthOfLatusRectum ( A , B ) { var major = 2.0 * A ; var minor = 2.0 * B ; var latus_rectum = ( minor * minor ) / major ; return latus_rectum ; }
function totalCircles ( L , B ) { if ( L > B ) { var temp = L ; L = B ; B = temp ; } return B / L ; }
function secondary_polygon ( Angle ) { var edges_primary = 360 / Angle ; if ( edges_primary >= 6 ) { var edges_max_secondary = edges_primary / 2 ; document . write ( edges_max_secondary + 3 ) ; } else document . write ( " " ) ; }
function findSquareSum ( Coordinates , N ) { let xq = 0 , yq = 0 ; let xs = 0 , ys = 0 ; let res = 0 ; for ( let i = 0 ; i < N ; i ++ ) { let a , b ; a = Coordinates [ i ] [ 0 ] ; b = Coordinates [ i ] [ 1 ] ; res += xq ; res -= 2 * xs * a ; res += i * ( a * a ) ; xq += a * a ; xs += a ; res += yq ; res -= 2 * ys * b ; res += i * b * b ; yq += b * b ; ys += b ; } document . write ( res ) ; }
function findDiagonal ( s ) { return Math . sqrt ( 2 ) * s ; }
function triangleArea ( a , b ) { if ( a < 0 b < 0 ) { document . write ( - 1 ) ; return ; } var area = ( 3 * Math . sqrt ( 3 ) * a * b ) / ( 4 ) ; document . write ( area . toFixed ( 5 ) ) ; }
function parallel ( a1 , b1 , c1 , a2 , b2 , c2 ) { if ( ( - ( a1 / b1 ) ) == ( - ( a2 / b2 ) ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; } }
function findRadius ( r1 , r2 ) { let a1 , a2 , a3 , r3 ; a1 = 3.14 * r1 * r1 ; a2 = 3.14 * r2 * r2 ; a3 = a1 + a2 ; r3 = Math . sqrt ( a3 / 3.14 ) ; return r3 ; }
function cntRect ( points , N , rectangle ) { var cntHor = new Set ( ) ; var cntVer = new Set ( ) ; cntHor . add ( 0 ) ; cntVer . add ( 0 ) ; cntHor . add ( rectangle [ 3 ] [ 0 ] ) ; cntVer . add ( rectangle [ 3 ] [ 1 ] ) ; for ( var i = 0 ; i < N ; i ++ ) { cntHor . add ( points [ i ] [ 0 ] ) ; cntVer . add ( points [ i ] [ 1 ] ) ; } return ( cntHor . size - 1 ) * ( cntVer . size - 1 ) ; }
function noOfTriangles ( n ) { return Math . floor ( n * ( n + 2 ) * ( 2 * n + 1 ) / 8 ) ; }
function No_of_squares ( N , K ) { let no_of_squares = 0 ; no_of_squares = ( N - K + 1 ) * ( N - K + 1 ) ; return no_of_squares ; }
function No_of_cubes ( N , K ) { let No = 0 ; No = ( N - K + 1 ) ; No = Math . pow ( No , 3 ) ; return No ; }
function No_of_rectangles ( L , B , l , b ) { if ( ( l > L ) || ( b > B ) ) { return - 1 ; } else { return ( L - l + 1 ) * ( B - b + 1 ) ; } }
function checkTriangle ( x , y , z ) { if ( x == y && y == z ) document . write ( " " ) ; else if ( x == y y == z z == x ) document . write ( " " ) ; else document . write ( " " ) ; }
function Circumradius ( a , b , c , d ) { var s = ( a + b + c + d ) / 2.0 ; var radius = Math . sqrt ( ( ( a * b ) + ( c * d ) ) * ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( s - a ) * ( s - b ) * ( s - c ) * ( s - d ) ) ) ; return radius / 4 ; }
function Area_of_Rhombus ( a , theta ) { var area = ( a ** 2 ) * Math . sin ( theta * Math . PI / 180 ) ; return area ; }
function calculateTriangles ( sides ) { let count = Math . pow ( sides [ 0 ] + sides [ 1 ] + sides [ 2 ] , 2 ) ; count -= Math . pow ( sides [ 0 ] , 2 ) ; count -= Math . pow ( sides [ 2 ] , 2 ) ; count -= Math . pow ( sides [ 4 ] , 2 ) ; return ( count ) ; }
function Length_Diagonal ( a , b , theta ) { var diagonal = Math . sqrt ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) - 2 * a * b * Math . cos ( theta * ( Math . PI / 180 ) ) ) ; return diagonal ; }
function maximumTiles ( n , m ) { document . write ( ( m * n ) / 2 ) ; }
function Length_Diagonal ( a , b , d ) { let diagonal = Math . sqrt ( 2 * ( ( a * a ) + ( b * b ) ) - ( d * d ) ) ; return diagonal ; }
function Diagonals ( a , b , c , d ) { var p = parseFloat ( Math . sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( a * b ) + ( c * d ) ) ) ) ; var q = parseFloat ( Math . sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * b ) + ( c * d ) ) / ( ( a * d ) + ( b * c ) ) ) ) ; return [ p , q ] ; }
function det ( d ) { let Sum = d [ 0 ] [ 0 ] * ( ( d [ 1 ] [ 1 ] * d [ 2 ] [ 2 ] ) - ( d [ 2 ] [ 1 ] * d [ 1 ] [ 2 ] ) ) ; Sum -= d [ 0 ] [ 1 ] * ( ( d [ 1 ] [ 0 ] * d [ 2 ] [ 2 ] ) - ( d [ 1 ] [ 2 ] * d [ 2 ] [ 0 ] ) ) ; Sum += d [ 0 ] [ 2 ] * ( ( d [ 0 ] [ 1 ] * d [ 1 ] [ 2 ] ) - ( d [ 0 ] [ 2 ] * d [ 1 ] [ 1 ] ) ) ; return Sum ; }
function distance ( r , R ) { let d = Math . sqrt ( Math . pow ( R , 2 ) - ( 2 * r * R ) ) ; return d ; }
function areaOfSquare ( S ) { let area = S * S ; return area ; }
function checkRightAngled ( X1 , Y1 , X2 , Y2 , X3 , Y3 ) { var A = Math . pow ( X2 - X1 , 2 ) + Math . pow ( Y2 - Y1 , 2 ) ; var B = Math . pow ( X3 - X2 , 2 ) + Math . pow ( Y3 - Y2 , 2 ) ; var C = Math . pow ( X3 - X1 , 2 ) + Math . pow ( Y3 - Y1 , 2 ) ; if ( A > 0 && B > 0 && C > 0 && ( A === B + C B === A + C C === A + B ) ) document . write ( " " ) ; else document . write ( " " ) ; }
function checkValidPolygon ( arr , N ) { var sum = 0 ; for ( var i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } if ( sum == 180 * ( N - 2 ) ) document . write ( " " ) ; else document . write ( " " ) ; }
function minAnglRot ( N ) { let res ; res = 360 / N ; return res ; }
function maxPointOfIntersection ( x , y ) { let k = y * ( y - 1 ) / 2 ; k = k + x * ( 2 * y + x - 1 ) ; return k ; }
function Area_of_Triangle ( a , b , c ) { var s = ( a + b + c ) / 2 ; var x = s * ( s - a ) ; x = x * ( s - b ) ; x = x * ( s - c ) ; var area = ( 4 / 3 ) * Math . sqrt ( x ) ; return area ; }
function Area_of_Triangle ( a , b , k ) { var area = ( ( 1 / 2.0 ) * a * b * Math . sin ( k ) ) ; return area ; }
function findEquation ( x1 , y1 , z1 , x2 , y2 , z2 , d , e , f ) { var a = x2 - x1 ; var b = y2 - y1 ; var c = z2 - z1 ; var A = parseInt ( ( b * f - c * e ) ) ; var B = parseInt ( ( a * f - c * d ) ) ; var C = parseInt ( ( a * e - b * d ) ) ; var D = - parseInt ( ( A * d - B * e + C * f ) ) ; document . write ( A + " " + B + " " + C + " " + D + " " ) ; }
function count_rectangles ( N , M ) { let p_x = ( N * ( N - 1 ) ) / 2 ; let p_y = ( M * ( M - 1 ) ) / 2 ; return p_x * p_y ; }
function median ( a , b , c ) { let n = ( Math . sqrt ( 2 * b * b + 2 * c * c - a * a ) / 2 ) ; return n ; }
function findSide ( a , B , C ) { var A = 180 - C - B ; var radA = Math . PI * ( A / 180 ) ; var radB = Math . PI * ( B / 180 ) ; var radC = Math . PI * ( C / 180 ) ; var b = a / Math . sin ( radA ) * Math . sin ( radB ) ; var c = a / Math . sin ( radA ) * Math . sin ( radC ) ; document . write ( b + " " ) ; document . write ( c ) ; }
function areaSquare ( L , B ) { let large = Math . max ( L , B ) ; let small = Math . min ( L , B ) ; if ( large >= 2 * small ) { return large * large ; } else { return ( 2 * small ) * ( 2 * small ) ; } }
function calculateAngle ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) { var ABx = x1 - x2 ; var ABy = y1 - y2 ; var ABz = z1 - z2 ; var BCx = x3 - x2 ; var BCy = y3 - y2 ; var BCz = z3 - z2 ; var dotProduct = ABx * BCx + ABy * BCy + ABz * BCz ; var magnitudeAB = ABx * ABx + ABy * ABy + ABz * ABz ; var magnitudeBC = BCx * BCx + BCy * BCy + BCz * BCz ; var angle = dotProduct ; angle /= Math . sqrt ( magnitudeAB * magnitudeBC ) ; angle = ( angle * 180 ) / PI ; document . write ( Math . abs ( angle ) . toFixed ( 4 ) ) ; }
function triacontagonalNum ( n ) { return ( 28 * n * n - 26 * n ) / 2 ; }
function heptacontagonNum ( n ) { return ( 68 * n * n - 66 * n ) / 2 ; }
function hexacontagonNum ( n ) { return ( 58 * n * n - 56 * n ) / 2 ; }
function isicositetragonal ( N ) { var n = ( 10 + Math . sqrt ( 44 * N + 100 ) ) / 22 ; return ( n - parseInt ( n ) ) == 0 ; } var i = 24 ; if ( isicositetragonal ( i ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function enneacontagonNum ( n ) { return ( 88 * n * n - 86 * n ) / 2 ; }
function triacontakaidigonNum ( n ) { return ( 30 * n * n - 28 * n ) / 2 ; }
function isTridecagon ( N ) { var n = ( 9 + Math . sqrt ( 88 * N + 81 ) ) / 22 ; return ( n - parseInt ( n ) ) == 0 ; } var i = 13 ; if ( isTridecagon ( i ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function isicosihenagonal ( N ) { var n = ( 17 + Math . sqrt ( 152 * N + 289 ) ) / 38 ; return ( n - parseInt ( n ) ) == 0 ; } var i = 21 ; if ( isicosihenagonal ( i ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function isicositrigonal ( N ) { var n = ( 19 + Math . sqrt ( 168 * N + 361 ) ) / 42 ; return ( n - parseInt ( n ) ) == 0 ; } var i = 23 ; if ( isicositrigonal ( i ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function IcosihexagonalNum ( n ) { return ( 24 * n * n - 22 * n ) / 2 ; }
function icosikaioctagonalNum ( n ) { return ( 26 * n * n - 24 * n ) / 2 ; }
function octacontagonNum ( n ) { return ( 78 * n * n - 76 * n ) / 2 ; }
function hectagonNum ( n ) { return ( 98 * n * n - 96 * n ) / 2 ; }
function tetracontagonNum ( n ) { return ( 38 * n * n - 36 * n ) / 2 ; }
function Tridecagonal_num ( n ) { return ( 11 * n * n - 9 * n ) / 2 ; }
function Pentadecagonal_num ( n ) { return ( 13 * n * n - 11 * n ) / 2 ; }
function Octadecagonal_num ( n ) { return ( 16 * n * n - 14 * n ) / 2 ; }
function Icositrigonal_num ( n ) { return ( 21 * n * n - 19 * n ) / 2 ; }
function Icositetragonal_num ( n ) { return ( 22 * n * n - 20 * n ) / 2 ; }
function Icosihenagonal_num ( n ) { return ( 19 * n * n - 17 * n ) / 2 ; }
function checkTriangle ( x1 , y1 , x2 , y2 , x3 , y3 ) { let a = x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ; if ( a == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function checkOverlap ( R , Xc , Yc , X1 , Y1 , X2 , Y2 ) { let Xn = Math . max ( X1 , Math . min ( Xc , X2 ) ) ; let Yn = Math . max ( Y1 , Math . min ( Yc , Y2 ) ) ; let Dx = Xn - Xc ; let Dy = Yn - Yc ; return ( Dx * Dx + Dy * Dy ) <= R * R ; } let R = 1 ; let Xc = 0 , Yc = 0 ; let X1 = 1 , Y1 = - 1 ; let X2 = 3 , Y2 = 1 ; if ( checkOverlap ( R , Xc , Yc , X1 , Y1 , X2 , Y2 ) ) { document . write ( " " + " " ) ; } else { document . write ( " " ) ; }
function area_of_circle ( m , n ) { var square_of_radius = ( m * n ) / 4 ; var area = ( 3.141 * square_of_radius ) ; return area ; }
function check ( n , m ) { if ( m % n == 0 ) { document . write ( " " ) ; } else { document . write ( " " ) ; } return 0 ; }
function solve ( s ) { let area = ( 1.732 * Math . pow ( s , 2 ) ) / 8 ; return area ; }
function area ( R ) { var base = 1.732 * R ; var height = ( 1.5 ) * R ; var area = 0.5 * base * height ; return area ; }
function circlearea ( R ) { if ( R < 0 ) return - 1 ; var a = 3.14 * R * R / 4 ; return a ; }
function find_Area ( a ) { var R = a * ( 2.0 - Math . sqrt ( 2 ) ) ; var area = 3.14 * R * R / 2.0 ; return area ; }
function times ( steps , n ) { let current_level = 0 ; let previous_level = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { previous_level = current_level ; current_level = current_level + steps [ i ] ; if ( ( previous_level < 0 && current_level >= 0 ) || ( previous_level > 0 && current_level <= 0 ) ) { count ++ ; } } return count ; }
function countPairs ( P , Q , N , M ) { var A = [ 0 , 0 ] , B = [ 0 , 0 ] ; for ( var i = 0 ; i < N ; i ++ ) A [ P [ i ] % 2 ] ++ ; for ( var i = 0 ; i < M ; i ++ ) B [ Q [ i ] % 2 ] ++ ; return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) ; }
function find_angle ( x , y , z ) { var volume = x * x * y ; var ans = 0 ; if ( z < volume / 2 ) { var d = ( ( x * y * y ) / ( 2.0 * z ) ) ; ans = Math . atan ( d ) ; } else { z = volume - z ; var d = ( 2 * z ) / ( x * x * x ) ; ans = Math . atan ( d ) ; } ans = ( ( ans * 180 ) / 3.14159265 ) ; return ans ; }
function findsolution ( d , h , m , n ) { var k = ( 4 * m ) / ( pie * d * d ) ; if ( n > k ) return - 1 ; var ans = ( h / ( k - n ) ) ; return ans ; }
function sumOfInternalAngles ( n ) { if ( n < 3 ) return 0 ; return ( n - 2 ) * 180 ; }
function cntWays ( n ) { if ( n % 2 == 1 ) { return 0 ; } else { return ( n - 2 ) / 4 ; } }
function noOfTriangles ( n ) { var y = 4 * n ; return ( ( y * ( y - 2 ) * ( y - 1 ) ) - ( 4 * n * ( n - 2 ) * ( n - 1 ) ) ) / 6 ; }
function angle ( n ) { return 2 * n ; }
function countIntersections ( n ) { return n * ( n - 1 ) / 2 ; }
function orthogonality ( x1 , y1 , x2 , y2 , r1 , r2 ) { let dsquare = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; if ( dsquare == r1 * r1 + r2 * r2 ) return true ; else return false ; }
function area ( d1 , a ) { var d2 = Math . sqrt ( 4 * ( a * a ) - d1 * d1 ) ; var area = 0.5 * d1 * d2 ; return area ; }
function maxRegions ( n ) { let num ; num = parseInt ( n * ( n + 1 ) / 2 ) + 1 ; document . write ( num ) ; }
function pointsAreOnSameSideOfLine ( a , b , c , x1 , y1 , x2 , y2 ) { fx1 = a * x1 + b * y1 - c ; fx2 = a * x2 + b * y2 - c ; if ( ( fx1 * fx2 ) > 0 ) return true ; return false ; }
function Area ( d , h1 , h2 ) { let area ; area = 0.5 * d * ( h1 + h2 ) ; return area ; }
function diagonal_length ( a ) { let L ; L = a * Math . sqrt ( 3 ) ; return L ; }
function concentric_Haxagon ( n ) { return parseInt ( 3 * Math . pow ( n , 2 ) / 2 ) ; }
function find_area ( r , d ) { let R = d / PI ; R += Math . pow ( r , 2 ) ; R = Math . sqrt ( R ) ; let area = PI * Math . pow ( R , 2 ) ; return area ; }
function Valid ( a , b , c , d ) { if ( a + b + c + d == 360 ) return 1 ; return 0 ; }
function Valid ( a , b , c ) { if ( a + b + c == 180 && a != 0 && b != 0 && c != 0 ) return 1 ; else return 0 ; } var a = 60 , b = 40 , c = 80 ; if ( ( Valid ( a , b , c ) ) == 1 ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function Perimeter ( a , b ) { var Perimeter ; Perimeter = 2 * 3.14 * Math . sqrt ( ( a * a + b * b ) / ( 2 * 1.0 ) ) ; document . write ( " " + Perimeter ) ; }
function calculate_angle ( n ) { var total_angle = 360 ; return total_angle / n ; }
function areaOfKite ( d1 , d2 ) { var area = ( d1 * d2 ) / 2 ; return area ; }
function areaOfKite ( a , b , angle ) { angle = angle * PI ; var area = a * b * Math . sin ( angle ) ; return area . toFixed ( 4 ) ; }
function angleOncirCumference ( z ) { return ( z / 2 ) ; }
function newvol ( x ) { document . write ( " " + " " + ( Math . pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . pow ( x , 2 ) ) / 100 ) + " " ) ; }
function newvol ( x ) { document . write ( " " + " " + ( Math . pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . pow ( x , 2 ) ) / 100 ) + " " ) ; }
function newvol ( x ) { document . write ( " " + " " + x + " " ) ; }
function radius ( n , d ) { document . write ( " " + ( d / ( ( n - 1 ) * Math . sqrt ( 2 ) ) ) . toFixed ( 5 ) ) ; }
function findTriangles ( n ) { var num = n ; document . write ( num + " " ) ; document . write ( num * ( num - 4 ) * ( num - 5 ) / 6 ) ; }
function radius ( n , d ) { document . write ( " " + d / ( 2 * n - 2 ) ) ; }
function radius ( n , d ) { document . write ( " " + d / ( n - 1 ) ) ; }
function findTriangles ( n ) { var num ; num = n * ( n - 4 ) ; document . write ( num ) ; }
function innerCirclearea ( radius ) { if ( radius < 0 ) { return - 1 ; } let r = radius / 2 ; let Area = ( 3.14 * Math . pow ( r , 2 ) ) ; return Area ; }
function angleequichord ( z ) { document . write ( " " + z + " " + " " ) ; }
function lengequichord ( z ) { document . write ( " " + " " + z + " " ) ; }
function lengperpbisect ( r1 , r2 ) { var z = 2 * Math . sqrt ( ( r1 * r1 ) - ( ( r1 - r2 ) * ( r1 - r2 ) / 4 ) ) ; document . write ( " " + " " + z . toFixed ( 5 ) ) ; }
function anglequichord ( z ) { document . write ( " " + z + " " ) ; }
function lengchord ( z ) { document . write ( " " + z ) ; }
function angleextcycquad ( z ) { document . write ( " " + " " + z + " " ) ; }
function anglechordtang ( z ) { document . write ( " " + " " + z + " " ) ; }
function circle ( x1 , y1 , x2 , y2 , r1 , r2 ) { var distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; var radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }
function Regions ( Vertices , Edges ) { var R = Edges + 2 - Vertices ; return R ; }
function lengthOfTangent ( r1 , r2 , d ) { document . write ( " " + " " + Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 + r2 ) , 2 ) ) ) ; }
function remainingArea ( N , M , K ) { while ( K -- && N && M ) { if ( N > M ) N = N - M ; else M = M - N ; } if ( N > 0 && M > 0 ) return N * M ; else return 0 ; }
function lengtang ( r1 , r2 , d ) { document . write ( " " + " " + ( Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 - r2 ) , 2 ) ) ) . toFixed ( 5 ) ) ; }
function rad ( d , h ) { document . write ( " " + ( ( d * d ) / ( 8 * h ) + h / 2 ) ) ; }
function shortdis ( r , d ) { document . write ( " " + " " + Math . sqrt ( ( r * r ) - ( ( d * d ) / 4 ) ) + " " ) ; }
function lengtang ( r1 , r2 ) { document . write ( " " + " " + ( 2 * Math . sqrt ( r1 * r2 ) ) . toFixed ( 5 ) ) ; }
function dist ( x1 , y1 , x2 , y2 , r ) { document . write ( " " + " " + ( Math . sqrt ( ( Math . pow ( ( x2 - x1 ) , 2 ) ) + ( Math . pow ( ( y2 - y1 ) , 2 ) ) ) - r ) . toFixed ( 5 ) ) ; }
function lengtang ( r1 , r2 , d ) { document . write ( " " + Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 - r2 ) , 2 ) ) ) ; }
function length_of_chord ( r , x ) { document . write ( " " + " " + 2 * r * Math . sin ( x * ( 3.14 / 180 ) ) + " " ) ; }
function diameter ( r ) { document . write ( " " + " " + 2 * r ) ; }
function normal ( m , n ) { var N = ( ( Math . abs ( m ) * Math . abs ( n ) ) / Math . sqrt ( ( Math . abs ( m ) * Math . abs ( m ) ) + ( Math . abs ( n ) * Math . abs ( n ) ) ) ) ; return N ; }
function getSlope ( m ) { return m ; }
function totalTriangles ( h , v ) { if ( h == 0 && v == 0 ) return 1 ; if ( h == 0 ) return ( ( v + 1 ) * ( v + 2 ) / 2 ) ; if ( v == 0 ) return ( h + 1 ) ; var total = ( h + 1 ) * ( ( v + 1 ) * ( v + 2 ) / 2 ) ; return total ; }
function ellipse ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; var x = ( 3.14 * l * b ) / 4 ; return x ; }
function isPossible ( a , n ) { let sum = 0 , maxS = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; maxS = Math . max ( a [ i ] , maxS ) ; } if ( ( sum - maxS ) > maxS ) return true ; return false ; }
function findAreaShaded ( a ) { let sqArea = a * a ; let semiCircleArea = ( 3.14 * ( a * a ) / 8 ) ; let ShadedArea = 4 * semiCircleArea - sqArea ; return ShadedArea ; }
function countSteps ( x , y ) { if ( x < y ) { return x + y + 2 * parseInt ( ( y - x ) / 2 ) ; } else { return x + y + 2 * parseInt ( ( ( x - y ) + 1 ) / 2 ) ; } }
function pointIsOnLine ( m , c , x , y ) { if ( y == ( ( m * x ) + c ) ) return true ; return false ; }
function sph ( r , R , h ) { if ( r < 0 && R < 0 && h < 0 ) return - 1 ; var x = r ; var V = ( ( 4 * 3.14 * Math . pow ( r , 3 ) ) / 3 ) ; return V ; }
function Area ( a , b ) { if ( a < 0 && b < 0 ) return - 1 ; let h = Math . sqrt ( ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) / ( Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) ) ) ; let A = 0.70477 * Math . pow ( h , 2 ) ; return A ; }
function cone ( a ) { if ( a < 0 ) return - 1 ; var r = ( a * Math . sqrt ( 2 ) ) / 3 ; var h = ( 2 * a ) / 3 ; var V = ( 3.14 * Math . pow ( r , 2 ) * h ) ; return V ; }
function Area ( a ) { if ( a < 0 ) return - 1 ; let h = 1.268 * a ; let A = 0.70477 * Math . pow ( h , 2 ) ; return A ; }
function Area ( r ) { if ( r < 0 ) return - 1 ; var x = ( 2 * r ) / ( Math . sqrt ( 5 ) ) ; var A = 0.70477 * ( Math . pow ( x , 2 ) ) ; return A ; }
function Area ( a ) { if ( a < 0 ) return - 1 ; let x = 0.464 * a ; let A = 0.70477 * Math . pow ( x , 2 ) ; return A ; }
function areaCircle ( b ) { let area = 3.1415926 * b * b ; return area ; }
function areaSquare ( side , fold ) { var area = side * side ; return ( area * 1.0 ) / ( Math . pow ( 2 , fold ) ) ; }
function square ( a ) { if ( a < 0 ) return - 1 ; var x = 0.464 * a ; return x ; }
function ReuleauxArea ( r ) { if ( r < 0 ) return - 1 ; var A = 0.70477 * 2 * Math . pow ( r , 2 ) ; return A ; }
function cyl ( a ) { if ( a < 0 ) return - 1 ; var r = ( 2 * a * ( Math . sqrt ( 2 ) ) / 3 ) ; var h = ( 2 * a ) / 3 ; var V = ( 3.14 * ( Math . pow ( r , 2 ) * h ) ) ; return V ; }
function Area ( l , b , h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; let x = ( l * b ) / ( l + b ) ; let A = 0.70477 * Math . pow ( x , 2 ) ; return A ; }
function squareSide ( a ) { if ( a < 0 ) return - 1 ; var x = ( 0.423 * a ) ; return x ; }
function isPossible ( x , y , z ) { let a = Math . round ( x * x + y * y + z * z ) ; if ( Math . ceil ( a ) == 1 && Math . floor ( a ) == 1 ) return true ; return false ; }
function polyapothem ( n , a ) { if ( a < 0 && n < 0 ) return - 1 ; return ( a / ( 2 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ) ; }
function polydiagonal ( n , a ) { if ( a < 0 && n < 0 ) { return - 1 ; } return ( 2 * a * Math . sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ) ; }
function polyarea ( n , r ) { if ( r < 0 && n < 0 ) return - 1 ; var A = ( ( r * r * n ) * Math . sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ; return A ; }
function polyarea ( n , a ) { if ( a < 0 && n < 0 ) return - 1 ; var A = ( a * a * n ) / ( 4 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; return A ; }
function decdiagonal ( a ) { if ( a < 0 ) return - 1 ; var d = 1.902 * a ; return d ; }
function heptdiagonal ( a ) { if ( a < 0 ) return - 1 ; var d = 1.802 * a ; return d ; }
function ReuleauxArea ( a ) { if ( a < 0 ) return - 1 ; var A = 0.70477 * Math . pow ( a , 2 ) ; return A ; }
function hexagonside ( a ) { if ( a < 0 ) return - 1 ; let x = 0.5176 * a ; return x ; }
function hexagonside ( a ) { if ( a < 0 ) return - 1 ; var x = a / 3 ; return x ; }
function hexDiagonal ( a ) { if ( a < 0 ) return - 1 ; var d = 1.73 * a ; return d ; }
function pentdiagonal ( a ) { if ( a < 0 ) return - 1 ; let d = 1.22 * a ; return d ; }
function ReuleauxArea ( a ) { if ( a < 0 ) return - 1 ; var A = 0.70477 * Math . pow ( a , 2 ) ; return A ; }
function calculateSide ( n , r ) { var theta , theta_in_radians ; theta = 360 / n ; theta_in_radians = theta * 3.14 / 180 ; return 2 * r * Math . sin ( theta_in_radians / 2 ) ; }
function squareArea ( a ) { if ( a < 0 ) return - 1 ; var area = ( Math . pow ( 1.268 , 2 ) * Math . pow ( a , 2 ) ) ; return area ; }
function trianglearea ( a ) { if ( a < 0 ) return - 1 ; var area = ( 3 * Math . sqrt ( 3 ) * Math . pow ( a , 2 ) ) / 4 ; return area . toFixed ( 4 ) ; }
function CubeVolume ( d ) { let Volume ; Volume = ( Math . sqrt ( 3 ) * Math . pow ( d , 3 ) ) / 9 ; return Volume ; }
function hexagonArea ( d ) { return ( 3 * Math . sqrt ( 3 ) * Math . pow ( d , 2 ) ) / 8 ; }
function cyl ( r , R , h ) { if ( h < 0 && r < 0 && R < 0 ) return - 1 ; var r1 = r ; var h1 = h ; var V = ( 3.14 * Math . pow ( r1 , 2 ) * h1 ) ; return V ; }
function findVolume ( a ) { if ( a < 0 ) return - 1 ; var r = a / 2 ; var h = a ; var V = ( 3.14 * Math . pow ( r , 2 ) * h ) ; return V ; }
function length_rope ( r ) { return ( ( 2 * PI * r ) + 6 * r ) ; }
function area_cicumscribed ( c ) { return ( c * c * ( PI / 4 ) ) ; }
function cyl ( r , h ) { if ( r < 0 && h < 0 ) return - 1 ; var R = ( 2 * r ) / 3 ; var H = ( 2 * h ) / 3 ; var V = 3.14 * Math . pow ( R , 2 ) * H ; return V ; }
function cube ( h , r ) { if ( h < 0 && r < 0 ) return - 1 ; var a = Math . pow ( h , 3 ) ; return a ; }
function sph ( r , h ) { if ( r < 0 && h < 0 ) return - 1 ; var R = r ; return R ; }
function cyl ( R ) { if ( R < 0 ) return - 1 ; var V = ( ( 2 * 3.14 * Math . pow ( R , 3 ) ) / ( 3 * Math . sqrt ( 3 ) ) ) ; return V ; }
function rod ( h , r ) { if ( h < 0 && r < 0 ) return - 1 ; var l = ( Math . sqrt ( Math . pow ( h , 2 ) + 4 * Math . pow ( r , 2 ) ) ) ; return l ; }
function cube ( h , r ) { if ( h < 0 && r < 0 ) return - 1 ; var a = ( h * r * Math . sqrt ( 2 ) ) / ( h + Math . sqrt ( 2 ) * r ) ; return a ; }
function largestCube ( r ) { if ( r < 0 ) return - 1 ; var a = ( 2 * r ) / Math . sqrt ( 3 ) ; return a ; }
function sphere ( a ) { if ( a < 0 ) return - 1 ; var r = a / 2 ; return r ; }
function numberOfCuts ( M , N ) { var result = 0 ; result = ( M - 1 ) * ( N - 1 ) ; return result ; }
function maxVol ( P , A ) { let l = ( P - Math . sqrt ( P * P - 24 * A ) ) / 12 ; let V = l * ( A / 2.0 - l * ( P / 4.0 - l ) ) ; return V ; }
function rhombusAreaPeri ( d1 , d2 ) { let area , perimeter ; area = Math . floor ( ( d1 * d2 ) / 2 ) ; perimeter = Math . floor ( 2 * Math . sqrt ( Math . pow ( d1 , 2 ) + Math . pow ( d2 , 2 ) ) ) ; document . write ( " " + d1 + " " + d2 + " " + area + " " + " " ) ; document . write ( " " + d1 + " " + d2 + " " + perimeter + " " + " " ) ; }
function equation_ellipse ( x1 , y1 , a , b , c , e ) { var t = a * a + b * b ; var a1 = t - e * ( a * a ) ; var b1 = t - e * ( b * b ) ; var c1 = ( - 2 * t * x1 ) - ( 2 * e * c * a ) ; var d1 = ( - 2 * t * y1 ) - ( 2 * e * c * b ) ; var e1 = - 2 * e * a * b ; var f1 = ( - e * c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; document . write ( " " + " " ) ; document . write ( a1 + " " + b1 + " " + c1 + " " + d1 + " " + e1 + " " + f1 + " " ) ; }
function maxArea ( perimeter ) { let length = Math . ceil ( perimeter / 4 ) ; let breadth = Math . floor ( perimeter / 4 ) ; return length * breadth ; }
function countMaxIntersect ( n ) { return ( n ) * ( n - 1 ) / 2 ; }
function foot ( a , b , c , d , x1 , y1 , z1 ) { var k = ( - a * x1 - b * y1 - c * z1 - d ) / ( a * a + b * b + c * c ) ; var x2 = a * k + x1 ; var y2 = b * k + y1 ; var z2 = c * k + z1 ; document . write ( " " + x2 . toFixed ( 1 ) + " " ) ; document . write ( " " + y2 . toFixed ( 1 ) + " " ) ; document . write ( " " + z2 . toFixed ( 1 ) + " " ) ; }
function equation_parabola ( x1 , y1 , a , b , c ) { var t = a * a + b * b ; var a1 = t - ( a * a ) ; var b1 = t - ( b * b ) ; var c1 = ( - 2 * t * x1 ) - ( 2 * c * a ) ; var d1 = ( - 2 * t * y1 ) - ( 2 * c * b ) ; var e1 = - 2 * a * b ; var f1 = ( - c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; document . write ( " " + a1 + " " + b1 + " " + c1 + " " + d1 + " " + e1 + " " + f1 + " " ) ; }
function circle_equation ( x1 , y1 , r ) { let a = - 2 * x1 ; let b = - 2 * y1 ; let c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; document . write ( " " + a + " " ) ; document . write ( " " + b + " " ) ; document . write ( c + " " ) ; }
function section ( x1 , x2 , y1 , y2 , z1 , z2 , m , n ) { let x = ( ( m * x2 ) + ( n * x1 ) ) / ( m + n ) ; let y = ( ( m * y2 ) + ( n * y1 ) ) / ( m + n ) ; let z = ( ( m * z2 ) + ( n * z1 ) ) / ( m + n ) ; document . write ( " " + x + " " ) ; document . write ( y + " " ) ; document . write ( z + " " ) ; }
function Squares ( n , m , a ) { return parseInt ( ( ( m + a - 1 ) / a ) ) * parseInt ( ( ( n + a - 1 ) / a ) ) ; }
function Perimeter ( s , n ) { var perimeter = 1 ; perimeter = n * s ; return perimeter ; }
function checkEquilibrium ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) { var resx = x1 + x2 + x3 ; var resy = y1 + y2 + y3 ; var resz = z1 + z2 + z3 ; if ( resx == 0 & resy == 0 & resz == 0 ) return true ; else return false ; }
function findTangent ( A , x , y ) { var dif = A - x * 2 ; if ( y == ( 2 * x - x * x ) ) { if ( dif < 0 ) document . write ( " " + dif + " " + ( x * dif + y ) + " " ) ; else if ( dif > 0 ) document . write ( " " + dif + " " + - x * dif + y + " " ) ; else document . write ( " " + " " ) ; } }
function hexadiagonal ( a ) { if ( a < 0 ) return - 1 ; return 2 * a ; }
function octadiagonal ( a ) { if ( a < 0 ) return - 1 ; return a * Math . sqrt ( 4 + ( 2 * Math . sqrt ( 2 ) ) ) ; }
function CalPeri ( ) { var S = 5 , Perimeter ; Perimeter = 10 * S ; document . write ( " " + Perimeter ) ; }
function octaside ( a ) { if ( a < 0 ) return - 1 ; var s = a / ( Math . sqrt ( 2 ) + 1 ) ; return s ; }
function findEdges ( s1 , s2 , s3 ) { let a = Math . sqrt ( s1 * s2 / s3 ) ; let b = Math . sqrt ( s3 * s1 / s2 ) ; let c = Math . sqrt ( s3 * s2 / s1 ) ; let sum = a + b + c ; return 4 * sum ; }
function findRadiusOfcircumcircle ( n , a ) { if ( n < 0 a < 0 ) return - 1 ; var radius = ( a / Math . sqrt ( 2 - ( 2 * Math . cos ( 360 / n ) ) ) ) ; return radius ; }
function rhombusarea ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; return ( l * b ) / 2 ; }
function Move ( a , x , b ) { if ( ( ( ( b - a ) % x == 0 ) || ( ( b - a - 1 ) % x == 0 ) && a + 1 != b ) && b >= a ) return true ; return false ; }
function area ( a , b ) { if ( a < 0 b < 0 ) return - 1 ; var A = a * b ; return A ; }
function circle_inscribed ( a ) { return PI * ( a * a ) / 12 ; }
function findRadiusOfcircumcircle ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; var radius = Math . sqrt ( Math . pow ( l , 2 ) + Math . pow ( b , 2 ) ) / 2 ; return radius ; }
function surfaceArea ( b , s ) { return 2 * b * s + parseInt ( Math . pow ( b , 2 ) ) ; }
function findRadiusOfIncircle ( a , b , c ) { if ( a < 0 b < 0 c < 0 ) return - 1 ; var p = ( a + b + c ) / 2 ; var area = Math . sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ; var radius = area / p ; return radius ; }
function trianglearea ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; let area = ( l * b ) / 2 ; return area ; }
function area ( a ) { if ( a < 0 ) return - 1 ; var area = Math . sqrt ( a ) / 6 ; return area ; }
function halfsquare ( n , x , y ) { let half = n / 2 ; if ( ( half == x half == x - 1 ) && ( half == y half == y - 1 ) ) document . write ( " " ) ; else document . write ( " " ) ; }
function checkpoint ( h , k , x , y , a ) { var p = parseInt ( Math . pow ( ( y - k ) , 2 ) - 4 * a * ( x - h ) ) ; return p ; }
function checkpoint ( h , k , x , y , a , b ) { var p = ( parseInt ( Math . pow ( ( x - h ) , 2 ) ) / parseInt ( Math . pow ( a , 2 ) ) ) + ( parseInt ( Math . pow ( ( y - k ) , 2 ) ) / parseInt ( Math . pow ( b , 2 ) ) ) ; return p ; }
function findVolume ( u , v , w , U , V , W , b ) { let uPow = Math . pow ( u , 2 ) ; let vPow = Math . pow ( v , 2 ) ; let wPow = Math . pow ( w , 2 ) ; let UPow = Math . pow ( U , 2 ) ; let VPow = Math . pow ( V , 2 ) ; let WPow = Math . pow ( W , 2 ) ; let a = 4 * ( uPow * vPow * wPow ) - uPow * Math . pow ( ( vPow + wPow - UPow ) , 2 ) - vPow * Math . pow ( ( wPow + uPow - VPow ) , 2 ) - wPow * Math . pow ( ( uPow + vPow - WPow ) , 2 ) + ( vPow + wPow - UPow ) * ( wPow + uPow - VPow ) * ( uPow + vPow - WPow ) ; let vol = Math . sqrt ( a ) ; vol /= b ; document . write ( vol . toFixed ( 4 ) ) ; }
function trianglearea ( a , b ) { if ( a < 0 b < 0 ) return - 1 ; var area = ( 3 * Math . sqrt ( 3 ) * Math . pow ( a , 2 ) ) / ( 4 * b ) ; return area ; }
function squarearea ( a , b ) { if ( a < 0 b < 0 ) return - 1 ; var area = 4 * ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) / ( Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) ) ; return area ; }
function longestRodInCuboid ( length , breadth , height ) { let result ; let temp ; temp = length * length + breadth * breadth + height * height ; result = Math . sqrt ( temp ) ; return result ; }
function trianglearea ( r ) { if ( r < 0 ) return - 1 ; return r * r ; }
function squarearea ( r ) { if ( r < 0 ) return - 1 ; var a = 4 * ( Math . pow ( r , 2 ) / 5 ) ; return a ; }
function rectanglearea ( a , b ) { if ( a < 0 b < 0 ) return - 1 ; return 2 * a * b ; }
function trapezoidarea ( r ) { if ( r < 0 ) return - 1 ; var a = ( 3 * Math . sqrt ( 3 ) * Math . pow ( r , 2 ) ) / 4 ; return a ; }
function squareArea ( l , b , h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; var a = ( l * b ) / ( l + b ) ; return a * a ; }
function circlearea ( a , b ) { if ( a < 0 b < 0 ) return - 1 ; var A = ( ( 3.14 * Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) / ( 4 * ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) ) ) ; return A ; }
function circlearea ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; if ( l < b ) return ( 3.14 * Math . pow ( l / 2 , 2 ) ) ; else return ( 3.14 * Math . pow ( b / 2 , 2 ) ) ; }
function rectanglearea ( r ) { if ( r < 0 ) return - 1 ; var a = r * r ; return a ; }
function shortestLength ( n , x , y ) { let answer = 0 ; let i = 0 ; while ( n != 0 && i < x . length ) { if ( x [ i ] + y [ i ] > answer ) answer = x [ i ] + y [ i ] ; i ++ ; } document . write ( " " + answer + " " ) ; document . write ( " " + " " + answer + " " + " " + answer + " " ) ; }
function maxLines ( n , x1 , y1 , x2 , y2 ) { var s = [ ] ; var slope = 2147483647 ; for ( let i = 0 ; i < n ; i ++ ) { if ( x1 [ i ] === x2 [ i ] ) slope = 2147483647 ; else slope = ( ( ( y2 [ i ] - y1 [ i ] ) * 1.0 ) / ( x2 [ i ] - x1 [ i ] ) ) * 1.0 ; s . push ( slope ) ; } return s . length ; }
function squares ( l , b , a ) { return parseInt ( Math . ceil ( l / a ) * Math . ceil ( b / a ) ) ; }
function angle_triangle ( x1 , x2 , x3 , y1 , y2 , y3 , z1 , z2 , z3 ) { let num = ( x2 - x1 ) * ( x3 - x1 ) + ( y2 - y1 ) * ( y3 - y1 ) + ( z2 - z1 ) * ( z3 - z1 ) ; let den = Math . sqrt ( Math . pow ( ( x2 - x1 ) , 2 ) + Math . pow ( ( y2 - y1 ) , 2 ) + Math . pow ( ( z2 - z1 ) , 2 ) ) * Math . sqrt ( Math . pow ( ( x3 - x1 ) , 2 ) + Math . pow ( ( y3 - y1 ) , 2 ) + Math . pow ( ( z3 - z1 ) , 2 ) ) ; let angle = Math . acos ( num / den ) * ( 180.0 / 3.141592653589793238463 ) ; return angle ; }
function findMaximumPieces ( n ) { var x = parseInt ( n / 2 ) ; return ( ( x + 1 ) * ( n - x + 1 ) ) ; }
function makePolygon ( a ) { var n = parseFloat ( 360 / ( 180 - a ) ) ; if ( n === parseInt ( n ) ) document . write ( " " ) ; else document . write ( " " ) ; }
function LiesInsieRectangle ( a , b , x , y ) { if ( x - y - b <= 0 && x - y + b >= 0 && x + y - 2 * a + b <= 0 && x + y - b >= 0 ) return true ; return false ; }
function equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x , y , z ) { var a1 = x2 - x1 ; var b1 = y2 - y1 ; var c1 = z2 - z1 ; var a2 = x3 - x1 ; var b2 = y3 - y1 ; var c2 = z3 - z1 ; var a = b1 * c2 - b2 * c1 ; var b = a2 * c1 - a1 * c2 ; var c = a1 * b2 - b1 * a2 ; var d = ( - a * x1 - b * y1 - c * z1 ) ; if ( a * x + b * y + c * z + d == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function solve ( M , N , s ) { let ans = Math . floor ( ( ( Math . ceil ( M / s ) ) * ( Math . ceil ( N / s ) ) ) ) ; return ans ; }
function FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) { var x5 = Math . max ( x1 , x3 ) ; var y5 = Math . max ( y1 , y3 ) ; var x6 = Math . min ( x2 , x4 ) ; var y6 = Math . min ( y2 , y4 ) ; if ( x5 > x6 y5 > y6 ) { document . write ( " " ) ; return ; } document . write ( " " + x5 + " " + y5 + " " ) ; document . write ( " " + x6 + " " + y6 + " " ) ; var x7 = x5 ; var y7 = y6 ; document . write ( " " + x7 + " " + y7 + " " ) ; var x8 = x6 ; var y8 = y5 ; document . write ( " " + x8 + " " + y8 + " " ) ; }
function FindPoint ( x1 , y1 , x2 , y2 , x , y ) { if ( x > x1 && x < x2 && y > y1 && y < y2 ) return true ; return false ; }
function distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) { let x1 , y1 , z1 , d ; if ( a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2 ) { x1 = y1 = 0 ; z1 = - d1 / c1 ; d = Math . abs ( ( c2 * z1 + d2 ) ) / ( Math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) ; document . write ( " " + d ) ; } else document . write ( " " ) ; }
function distance ( a1 , b1 , c1 , a2 , b2 , c2 ) { var d = a1 * a2 + b1 * b2 + c1 * c2 ; var e1 = Math . sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) ; var e2 = Math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ; d = parseFloat ( d / ( e1 * e2 ) ) ; var pi = 3.14159 ; var A = ( 180 / pi ) * Math . acos ( d ) ; document . write ( " " + A . toFixed ( 1 ) + " " ) ; }
function shortest_distance ( x1 , y1 , z1 , a , b , c , d ) { d = Math . abs ( ( a * x1 + b * y1 + c * z1 + d ) ) ; let e = Math . sqrt ( a * a + b * b + c * c ) ; document . write ( " " + ( d / e ) ) ; return ; }
function haversine ( lat1 , lon1 , lat2 , lon2 ) { let dLat = ( lat2 - lat1 ) * Math . PI / 180.0 ; let dLon = ( lon2 - lon1 ) * Math . PI / 180.0 ; lat1 = ( lat1 ) * Math . PI / 180.0 ; lat2 = ( lat2 ) * Math . PI / 180.0 ; let a = Math . pow ( Math . sin ( dLat / 2 ) , 2 ) + Math . pow ( Math . sin ( dLon / 2 ) , 2 ) * Math . cos ( lat1 ) * Math . cos ( lat2 ) ; let rad = 6371 ; let c = 2 * Math . asin ( Math . sqrt ( a ) ) ; return rad * c ; }
function equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) { var a1 = x2 - x1 ; var b1 = y2 - y1 ; var c1 = z2 - z1 ; var a2 = x3 - x1 ; var b2 = y3 - y1 ; var c2 = z3 - z1 ; var a = b1 * c2 - b2 * c1 ; var b = a2 * c1 - a1 * c2 ; var c = a1 * b2 - b1 * a2 ; var d = ( - a * x1 - b * y1 - c * z1 ) ; document . write ( " " + a + " " + b + " " + c + " " + d + " " ) ; }
function mirror_point ( a , b , c , d , x1 , y1 , z1 ) { var k = parseFloat ( ( - a * x1 - b * y1 - c * z1 - d ) / parseFloat ( a * a + b * b + c * c ) ) ; var x2 = parseFloat ( a * k + x1 ) ; var y2 = parseFloat ( b * k + y1 ) ; var z2 = parseFloat ( c * k + z1 ) ; var x3 = parseFloat ( 2 * x2 - x1 ) . toFixed ( 1 ) ; var y3 = parseFloat ( 2 * y2 - y1 ) . toFixed ( 1 ) ; var z3 = parseFloat ( 2 * z2 - z1 ) . toFixed ( 1 ) ; document . write ( " " + x3 ) ; document . write ( " " + y3 ) ; document . write ( " " + z3 ) ; }
function octant ( x , y , z ) { if ( x >= 0 && y >= 0 && z >= 0 ) document . write ( " " + " " ) ; else if ( x < 0 && y >= 0 && z >= 0 ) document . write ( " " + " " ) ; else if ( x < 0 && y < 0 && z >= 0 ) document . write ( " " + " " ) ; else if ( x >= 0 && y < 0 && z >= 0 ) document . write ( " " + " " ) ; else if ( x >= 0 && y >= 0 && z < 0 ) document . write ( " " + " " ) ; else if ( x < 0 && y >= 0 && z < 0 ) document . write ( " " + " " ) ; else if ( x < 0 && y < 0 && z < 0 ) document . write ( " " + " " ) ; else if ( x >= 0 && y < 0 && z < 0 ) document . write ( " " + " " ) ; }
function findVolume ( l , b , h ) { let volume = ( l * b * h ) / 2 ; return volume ; }
function countNumberOfTriangles ( n ) { return n * ( n - 1 ) * ( n - 2 ) / 6 ; }
function countRectangles ( radius ) { let rectangles = 0 ; let diameter = 2 * radius ; let diameterSquare = diameter * diameter ; for ( let a = 1 ; a < 2 * radius ; a ++ ) { for ( let b = 1 ; b < 2 * radius ; b ++ ) { let diagonalLengthSquare = ( a * a + b * b ) ; if ( diagonalLengthSquare <= diameterSquare ) { rectangles ++ ; } } } return rectangles ; }
function centeredDodecagonal ( n ) { return 6 * n * ( n - 1 ) + 1 ; }
function heptagonalNumber ( n ) { return parseInt ( ( ( 5 * n * n ) - ( 3 * n ) ) / 2 ) ; }
function centeredTridecagonalNum ( n ) { return ( 13 * n * ( n - 1 ) + 2 ) / 2 ; }
function pentagon_pyramidal ( n ) { var sum = 0 ; for ( i = 1 ; i <= n ; i ++ ) { var p = ( 3 * i * i - i ) / 2 ; sum = sum + p ; } return sum ; }
function pentagon_pyramidal ( n ) { return n * n * ( n + 1 ) / 2 ; }
function checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) { return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) ; }
function getQuadrant ( X , Y , R , PX , PY ) { if ( PX == X && PY == Y ) return 0 ; let val = Math . pow ( ( PX - X ) , 2 ) + Math . pow ( ( PY - Y ) , 2 ) ; if ( val > Math . pow ( R , 2 ) ) return - 1 ; if ( PX > X && PY >= Y ) return 1 ; if ( PX <= X && PY > Y ) return 2 ; if ( PX < X && PY <= Y ) return 3 ; if ( PX >= X && PY < Y ) return 4 ; }
function center_pentadecagonal_num ( n ) { return ( 15 * n * n - 15 * n + 2 ) / 2 ; }
function icosidigonal_num ( n ) { return parseInt ( ( 20 * n * n - 18 * n ) / 2 ) ; }
function center_nonadecagon_num ( n ) { return ( 19 * n * n - 19 * n + 2 ) / 2 ; }
function center_octadecagon_num ( n ) { return 9 * n * n - 9 * n + 1 ; }
function hendecagonal_num ( n ) { return ( 9 * n * n - 7 * n ) / 2 ; }
function centereddecagonalnum ( n ) { return ( 5 * n * n + 5 * n + 1 ) ; }
function centeredoctagonalNumber ( n ) { return 4 * n * ( n - 1 ) + 1 ; }
function centered_cube ( n ) { return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; }
function nthEnneadecagonal ( n ) { return ( 17 * n * n - 15 * n ) / 2 ; }
function hexadecagonalNum ( n ) { return ( ( 14 * n * n ) - 12 * n ) / 2 ; }
function centered_pentagonal_Num ( n ) { return ( 5 * n * n - 5 * n + 2 ) / 2 ; }
function findPoint ( x1 , y1 , x2 , y2 ) { document . write ( " " + 2 * ( x2 - x1 ) + " " + 2 * ( y2 - y1 ) + " " ) ; }
function intersection ( n ) { return n * ( n - 1 ) ; }
function findPCSlope ( m ) { return - 1.0 / m ; }
function parallel ( n , a ) { let x = true , y = true ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] [ 0 ] != a [ i + 1 ] [ 0 ] ) x = false ; if ( a [ i ] [ 1 ] != a [ i + 1 ] [ 1 ] ) y = false ; } if ( x ) document . write ( " " + " " ) ; else if ( y ) document . write ( " " + " " ) ; else document . write ( " " + " " + " " ) ; }
function otherEndPoint ( x1 , y1 , m1 , m2 ) { let x2 = 2 * m1 - x1 ; let y2 = 2 * m2 - y1 ; document . write ( " " + x2 + " " + " " + y2 ) ; }
function numberOfSticks ( x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }
function printRect ( X , Y , n ) { var Xmax = X . reduce ( ( a , b ) => Math . max ( a , b ) ) ; var Xmin = X . reduce ( ( a , b ) => Math . min ( a , b ) ) ; var Ymax = Y . reduce ( ( a , b ) => Math . max ( a , b ) ) ; var Ymin = Y . reduce ( ( a , b ) => Math . min ( a , b ) ) ; document . write ( " " + Xmin + " " + Ymin + " " + " " ) ; document . write ( " " + Xmin + " " + Ymax + " " + " " ) ; document . write ( " " + Xmax + " " + Ymax + " " + " " ) ; document . write ( " " + Xmax + " " + Ymin + " " + " " ) ; }
function checkOrigin ( x1 , y1 , x2 , y2 ) { return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) ; }
function checkcircle ( r , R , r1 , x1 , y1 ) { let dis = Math . sqrt ( x1 * x1 + y1 * y1 ) ; return ( dis - r1 >= R && dis + r1 <= r ) ; }
function areacircumscribed ( a ) { return ( a * a * ( 3.1415 / 2 ) ) ; }
function surface_area_octahedron ( side ) { return ( 2 * ( Math . sqrt ( 3 ) ) * ( side * side ) ) ; }
function find_Area ( r ) { return ( 2 * r * r ) ; }
function checkValidity ( a , b , c ) { if ( a + b <= c a + c <= b b + c <= a ) return false ; else return true ; }
function isRectangle ( a , b , c , d ) { if ( a == b && a == c && a == d && c == d && b == c && b == d ) return true ; else if ( a == b && c == d ) return true ; else if ( a == d && c == b ) return true ; else if ( a == c && d == b ) return true ; else return false ; }
function pythagorean_quadruple ( a , b , c , d ) { let sum = a * a + b * b + c * c ; if ( d * d == sum ) return true ; else return false ; }
function vol_of_dodecahedron ( side ) { return ( ( ( 15 + ( 7 * ( Math . sqrt ( 5 ) ) ) ) / 4 ) * ( Math . pow ( side , 3 ) ) ) ; }
function center ( x1 , x2 , y1 , y2 ) { document . write ( ( x1 + x2 ) / 2 + " " + ( y1 + y2 ) / 2 ) ; }
function perimeter ( diameter , height ) { return 2 * ( diameter + height ) ; }
function area_of_segment ( radius , angle ) { let area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) ; let area_of_triangle = 1 / 2 * ( radius * radius ) * Math . sin ( ( angle * pi ) / 180 ) ; return area_of_sector - area_of_triangle ; }
function midpoint ( x1 , x2 , y1 , y2 ) { document . write ( ( x1 + x2 ) / 2 + " " + ( y1 + y2 ) / 2 ) ; }
function area_of_tetrahedron ( side ) { return ( Math . sqrt ( 3 ) * ( side * side ) ) ; }
function vol_tetra ( side ) { let volume = ( Math . pow ( side , 3 ) / ( 6 * Math . sqrt ( 2 ) ) ) ; return volume ; }
function overflow ( H , r , h , N , R ) { let tank_cap = 3.14 * r * r * H ; let water_vol = 3.14 * r * r * h ; let balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R ; let vol = water_vol + balls_vol ; if ( vol > tank_cap ) { document . write ( " " ) ; } else { document . write ( " " ) ; } }
function numberOfWays ( x ) { let dp = Array ( x + 1 ) . fill ( 0 ) ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
function maxvolume ( s ) { let maxvalue = 0 ; for ( let i = 1 ; i <= s - 2 ; i ++ ) { for ( let j = 1 ; j <= s - 1 ; j ++ ) { let k = s - i - j ; maxvalue = Math . max ( maxvalue , i * j * k ) ; } } return maxvalue ; }
function maxvolume ( s ) { let length = parseInt ( s / 3 ) ; s -= length ; let breadth = parseInt ( s / 2 ) ; let height = s - breadth ; return length * breadth * height ; }
function volumeOfEllipsoid ( r1 , r2 , r3 ) { let pi = 3.14 ; return 1.33 * pi * r1 * r2 * r3 ; }
function slope ( x1 , y1 , x2 , y2 ) { if ( x1 == x2 ) return Number . MAX_VALUE ; return ( y2 - y1 ) / ( x2 - x1 ) ; }
function areaOctagon ( side ) { return ( 2 * ( 1 + Math . sqrt ( 2 ) ) * side * side ) ; }
function Area ( b1 , b2 , h ) { return ( ( b1 + b2 ) / 2 ) * h ; }
function hexagonArea ( s ) { return ( ( 3 * Math . sqrt ( 3 ) * ( s * s ) ) / 2 ) ; }
function Circumference ( a ) { return 4 * a ; }
function maxArea ( a , b , c , d ) { let semiperimeter = ( a + b + c + d ) / 2 ; return Math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; }
function arcLength ( diameter , angle ) { let pi = 22.0 / 7.0 ; let arc ; if ( angle >= 360 ) { document . write ( " " + " " ) ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } }
function SectorArea ( radius , angle ) { if ( angle >= 360 ) document . write ( " " ) ; else { let sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; document . write ( sector ) ; } }
function minRadius ( k , x , y , n ) { let dis = Array . from ( { length : n } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; dis . sort ( ) ; return dis [ k - 1 ] ; }
function circumference ( r ) { let cir = 2 * 3.1415 * r ; return cir ; }
function areaSquare ( side ) { let area = side * side ; return area ; }
function maxSquare ( b , m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; a }
function minPerimeter ( n ) { let l = Math . sqrt ( n ) ; let sq = l * l ; if ( sq == n ) return l * 4 ; else { let row = n / l ; let perimeter = 2 * ( l + row ) ; if ( n % l != 0 ) perimeter += 2 ; return perimeter ; } }
function checkCollision ( a , b , c , x , y , radius ) { let dist = ( Math . abs ( a * x + b * y + c ) ) / Math . sqrt ( a * a + b * b ) ; if ( radius == dist ) document . write ( " " ) ; else if ( radius > dist ) document . write ( " " ) ; else document . write ( " " ) ; }
function possibleOrNot ( a1 , a2 , b1 , b2 , c1 , c2 ) { var dis1 = Math . pow ( b1 - a1 , 2 ) + Math . pow ( b2 - a2 , 2 ) ; var dis2 = Math . pow ( c1 - b1 , 2 ) + Math . pow ( c2 - b2 , 2 ) ; if ( dis1 != dis2 ) document . write ( " " ) ; else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2 ) / 2.0 ) ) document . write ( " " ) ; else document . write ( " " ) ; }
function fitOrNotFit ( R , r , x , y , rad ) { var val = Math . sqrt ( Math . pow ( x , 2 ) + Math . pow ( y , 2 ) ) ; if ( val + rad <= R && val - rad >= R - r ) document . write ( " " ) ; else document . write ( " " ) ; }
function circle ( x1 , y1 , x2 , y2 , r1 , r2 ) { let distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; let radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }
function rectCount ( n , m ) { return parseInt ( ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 , 10 ) ; }
function countObtuseAngles ( a , b , k ) { var c1 = ( b - a ) - 1 ; var c2 = ( k - b ) + ( a - 1 ) ; if ( c1 == c2 ) return 0 ; return Math . min ( c1 , c2 ) ; }
function countRect ( n ) { let ans = 0 ; for ( let length = 1 ; length <= parseInt ( Math . sqrt ( n ) , 10 ) ; ++ length ) for ( let height = length ; height * length <= n ; ++ height ) ans ++ ; return ans ; }
function bestApproximate ( x , y , n ) { let m , c , sum_x = 0 , sum_y = 0 , sum_xy = 0 , sum_x2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum_x += x [ i ] ; sum_y += y [ i ] ; sum_xy += x [ i ] * y [ i ] ; sum_x2 += Math . pow ( x [ i ] , 2 ) ; } m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - Math . pow ( sum_x , 2 ) ) ; c = ( sum_y - m * sum_x ) / n ; document . write ( " " + m ) ; document . write ( " " + c ) ; }
function minRevolutions ( r , x1 , y1 , x2 , y2 ) { let d = Math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return Math . ceil ( d / ( 2 * r ) ) ; }
function findRightAngle ( A , H ) { let D = Math . pow ( H , 4 ) - 16 * A * A ; if ( D >= 0 ) { let root1 = ( H * H + Math . sqrt ( D ) ) / 2 ; let root2 = ( H * H - Math . sqrt ( D ) ) / 2 ; let a = Math . sqrt ( root1 ) ; let b = Math . sqrt ( root2 ) ; if ( b >= a ) document . write ( a + " " + b + " " + H + " " ) ; else document . write ( b + " " + a + " " + H + " " ) ; } else document . write ( " " ) ; }
function numberOfSquares ( base ) { base = ( base - 2 ) ; base = Math . floor ( base / 2 ) ; return base * ( base + 1 ) / 2 ; }
function findMaximumPieces ( n ) { return 1 + n * ( n + 1 ) / 2 ; }
function findTriangle ( a , n ) { let b = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { b [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) b [ i ] = a [ i ] * a [ i ] ; a . sort ( function ( i , j ) { return i - j ; } ) ; b . sort ( function ( i , j ) { return i - j ; } ) ; let x = 0 , y = 0 , z = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let p = i + 1 ; let q = i + 1 ; for ( let j = i + 1 ; j < n ; j ++ ) { while ( p < n - 1 && b [ i ] + b [ j ] >= b [ p + 1 ] ) p ++ ; q = Math . max ( q , p ) ; while ( q < n - 1 && a [ i ] + a [ j ] > a [ q + 1 ] ) q ++ ; if ( b [ i ] + b [ j ] == b [ p ] ) { x += Math . max ( p - j - 1 , 0 ) ; y ++ ; z += q - p ; } else { x += Math . max ( p - j , 0 ) ; z += q - p ; } } } document . write ( " " + x + " " ) ; document . write ( " " + y + " " ) ; document . write ( " " + z + " " ) ; }
function checkPoint ( radius , x , y , percent , startAngle ) { let endAngle = 360 / percent + startAngle ; let polarradius = Math . sqrt ( x * x + y * y ) ; let Angle = Math . atan ( y / x ) ; if ( Angle >= startAngle && Angle <= endAngle && polarradius < radius ) document . write ( " " + " " + x + " " + y + " " + " " ) ; else document . write ( " " + " " + x + " " + y + " " + " " ) ; }
function countLattice ( r ) { if ( r <= 0 ) return 0 ; var result = 4 ; for ( x = 1 ; x < r ; x ++ ) { var ySquare = r * r - x * x ; var y = parseInt ( Math . sqrt ( ySquare ) ) ; if ( y * y == ySquare ) result += 4 ; } return result ; }
function polygonArea ( X , Y , n ) { let area = 0.0 ; let j = n - 1 ; for ( let i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . abs ( area / 2.0 ) ; }
function polygonArea ( X , Y , n ) { let area = 0.0 ; let j = n - 1 ; for ( let i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; } return Math . abs ( area / 2.0 ) ; }
function minimumAdditionOperation ( N ) { let count = 0 ; while ( N ) { if ( N & ( 1 == 1 ) ) { count ++ ; } N = N >> 1 ; } return count ; }
function minimumSizeArr ( A , B ) { let currXor = 0 ; let reminder = ( A - 1 ) % 4 ; if ( reminder == 0 ) currXor = A - 1 ; else if ( reminder == 1 ) currXor = 1 ; else if ( reminder == 2 ) currXor = A ; let minSize = A ; if ( currXor == B ) return minSize ; else if ( currXor ^ ( B == A ) ) return minSize + 2 ; else return minSize + 1 ; }
function countTriplets ( N ) { let cnt = 0 ; for ( let A = 1 ; A <= N ; ++ A ) { for ( let B = 1 ; B <= N / A ; ++ B ) { cnt += N / ( A * B ) ; } } return cnt ; }
function subfactorial ( N ) { let res = 0 , fact = 1 ; let count = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { fact = fact * i ; if ( count % 2 == 0 ) res = res - 1 / fact ; else res = res + 1 / fact ; count ++ ; } return fact * ( 1 + res ) ; }
function minOperations ( A , B , N ) { let cnt = 0 ; let i = 0 ; while ( i < N ) { let j = 0 ; while ( j < N && i < N ) { if ( B [ i ] == A [ j ] ) { i ++ ; } j ++ ; } cnt ++ ; } return cnt ; }
function countPairs ( N ) { let res = 0 ; for ( let q = 1 ; q * q <= N ; q ++ ) { let maxP = Math . min ( 2 * N - q , N / q ) ; if ( maxP < q ) continue ; let cnt = maxP - q + 1 ; res += Math . floor ( cnt / 2 + ( cnt & 1 ) ) ; } return res ; }
function countDistinctSums ( N , L , R ) { let minSum = L * N ; let maxSum = R * N ; return maxSum - minSum + 1 ; }
function countSubsequences ( arr ) { let odd = 0 ; for ( let x = 0 ; x < arr . length ; x ++ ) { if ( arr [ x ] & 1 ) odd ++ ; } return ( 1 << odd ) - 1 ; }
function maxPlanes ( A , B ) { let St = new Set ( ) ; for ( let i = 0 ; i < A . length ; i ++ ) { let t = ( A [ i ] % B [ i ] > 0 ) ? 1 : 0 ; t += Math . floor ( A [ i ] / B [ i ] ) + t ; St . add ( t ) ; } return St . size ; }
function checkSameDigits ( N ) { var digit = N % 10 ; while ( N != 0 ) { var current_digit = N % 10 ; N = parseInt ( N / 10 ) ; if ( current_digit != digit ) { return " " ; } } return " " ; }
function checkSameDigits ( N ) { var length = ( Math . log10 ( N ) ) + 1 ; var M = ( Math . pow ( 10 , length ) - 1 ) / ( 10 - 1 ) ; M *= N % 10 ; if ( M = N ) return " " ; return " " ; }
function positionAfterKJumps ( X , Y , K ) { let addY = Y * Math . floor ( K / 2 ) ; let reduceX = - 1 * X * ( Math . floor ( K / 2 ) + K % 2 ) ; return addY + reduceX ; }
function find_Numb_ways ( n ) { var odd_indices = n / 2 ; var even_indices = ( n / 2 ) + ( n % 2 ) ; var arr_odd = Math . pow ( 4 , odd_indices ) ; var arr_even = Math . pow ( 5 , even_indices ) ; return arr_odd * arr_even ; }
function predictTheWinner ( K , N ) { if ( N % ( K + 1 ) == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function maxRightmostElement ( N , k , p , arr ) { while ( k ) { for ( let i = N - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= p ) { arr [ i ] = arr [ i ] - p ; arr [ i + 1 ] = arr [ i + 1 ] + p ; break ; } } k -- ; } document . write ( arr [ N - 1 ] + " " ) ; }
function maxRightmostElement ( N , k , p , arr ) { var ans = arr [ N - 1 ] ; for ( var i = N - 2 ; i >= 0 ; i -- ) { var d = Math . min ( arr [ i ] / p , k / ( N - 1 - i ) ) ; k -= d * ( N - 1 - i ) ; ans += d * p ; } return ans ; }
function findMaxK ( N ) { let K = N ; for ( let i = N - 1 ; i >= 0 ; i -- ) { K &= i ; if ( K == 0 ) { return i ; } } return 0 ; }
function findMaxK ( N ) { var p = Math . log ( N ) / Math . log ( 2 ) ; return parseInt ( Math . pow ( 2 , p ) ) ; }
function countPairs ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( ( arr [ j ] % arr [ i ] == 0 ) && ( j + 1 ) % ( i + 1 ) == 0 && ( arr [ j ] / arr [ i ] == ( j + 1 ) / ( i + 1 ) ) ) { count ++ ; } } } return count ; }
function smallestMaximum ( N , K ) { let sum = Math . floor ( ( N + K - 1 ) / K ) * K ; if ( sum % N != 0 ) return Math . floor ( sum / N ) + 1 ; else return Math . floor ( sum / N ) ; }
function findMinMax ( a ) { let min_val = 1000000000 ; for ( let i = 1 ; i < a . length ; ++ i ) { min_val = Math . min ( min_val , a [ i ] * a [ i - 1 ] ) ; } return min_val ; }
function performQueries ( n , q , k , arr , query ) { = for ( let i = 1 ; i <= q ; i ++ ) { let count = 0 ; if ( query [ i - 1 ] [ 0 ] == 1 ) { for ( let j = query [ i - 1 ] [ 1 ] ; j <= query [ i - 1 ] [ 2 ] ; j ++ ) { if ( arr [ j ] == k ) count ++ ; } document . write ( count + " " ) ; } else { arr [ query [ i - 1 ] [ 1 ] ] = query [ i - 1 ] [ 2 ] ; } } }
function isPossible ( arr , n ) { var mini = Number . MAX_VALUE ; for ( var i = 0 ; i < n ; i ++ ) mini = Math . min ( mini , arr [ i ] ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == mini ) continue ; var Max = ( arr [ i ] + 1 ) / 2 - 1 ; if ( mini < 0 mini > Max ) return " " ; } return " " ; }
function performQuery ( arr , Q ) { for ( let i = 0 ; i < Q . length ; i ++ ) { let or = 0 ; let x = Q [ i ] [ 0 ] ; arr [ x - 1 ] = Q [ i ] [ 1 ] ; for ( let j = 0 ; j < arr . length ; j ++ ) { or = or | arr [ j ] ; } document . write ( or + " " ) ; } }
function findSumOfAllSubsets ( arr , n , k ) { let factorial_N = 1 , factorial_d = 1 , factorial_D = 1 ; for ( let i = 1 ; i <= n - 1 ; i ++ ) factorial_N *= i ; for ( let i = 1 ; i <= k - 1 ; i ++ ) factorial_d *= i ; for ( let i = 1 ; i <= n - k ; i ++ ) factorial_D *= i ; let freq = factorial_N / ( factorial_d * factorial_D ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum = sum * freq ; document . write ( " " + k + " " + sum + " " ) ; }
function countQuadruples ( A , N ) { let ans = 0 ; let freq = new Map ( ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( freq . has ( arr [ i ] ) ) { ans += freq . get ( A [ i ] ) ; } for ( let j = 0 ; j < i ; j ++ ) { for ( let k = 0 ; k < j ; k ++ ) { if ( freq . has ( A [ i ] * A [ j ] * A [ k ] ) ) { freq . set ( freq . get ( A [ i ] * A [ j ] * A [ k ] ) , freq . get ( [ A [ i ] * A [ j ] * A [ k ] ] ) + 1 ) ; } else { freq . set ( A [ i ] * A [ j ] * A [ k ] , 1 ) ; } } } } return ans ; }
function countTriplets ( arr , n ) { let odd = 0 , even = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) odd ++ ; else even ++ ; } let c1 = Math . floor ( odd * ( even * ( even - 1 ) ) / 2 ) ; let c2 = Math . floor ( ( odd * ( odd - 1 ) * ( odd - 2 ) ) / 6 ) ; return c1 + c2 ; }
function can_empty ( a , b , c ) { if ( ( a + b + c ) % 4 != 0 ) return false ; else { let m = Math . min ( a , Math . min ( b , c ) ) ; if ( m < Math . floor ( ( a + b + c ) / 4 ) ) return false ; } return true ; }
function minSumDifference ( ar , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += ar [ i ] ; let rem = sum % n ; return rem * ( n - rem ) ; }
function smallest ( k , d ) { let cnt = 1 ; let m = d % k ; let v = new Array ( k ) . fill ( 0 ) ; v [ m ] = 1 ; while ( 1 ) { if ( m == 0 ) return cnt ; m = ( ( ( m * ( 10 % k ) ) % k ) + ( d % k ) ) % k ; if ( v [ m ] == 1 ) return - 1 ; v [ m ] = 1 ; cnt ++ ; } return - 1 ; }
function getPairsCount ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && Math . abs ( arr [ i ] - arr [ j ] ) >= Math . min ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; }
function minSteps ( N ) { let count = 1 , res = 0 ; for ( let i = 1 ; i <= N ; i += count ) { res = Math . max ( res , count ) ; count ++ ; } return res ; }
function minSteps ( N ) { var res = parseInt ( ( Math . sqrt ( 1 + 8 * N ) - 1 ) / 2 ) ; return res ; }
function oppositeFaceOfDice ( N ) { let ans = 7 - N ; document . write ( ans ) ; }
function findAandB ( N ) { let K = Math . log2 ( N ) ; let B = ( 1 << K ) ; let A = B ^ N ; document . write ( A + ' ' + B ) ; }
function minDistance ( start , intend , n , d ) { let left = Number . MIN_SAFE_INTEGER ; let right = Number . MAX_SAFE_INTEGER ; for ( let i = 0 ; i < n ; i ++ ) { left = Math . max ( left , start [ i ] ) ; right = Math . min ( right , end [ i ] ) ; } if ( left > right ) return - 1 ; if ( d >= left && d <= right ) return 0 ; if ( d < left ) return left - d ; if ( d > right ) return d - right ; }
function countPairs ( arr , N ) { let answer = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] + arr [ j ] == i + j ) { answer ++ ; } } } document . write ( answer ) ; }
function checkDistribution ( R , B , D ) { if ( Math . max ( R , B ) <= Math . min ( R , B ) * ( D + 1 ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; } }
function itemType ( n ) { let count = 0 ; for ( let day = 1 ; ; day ++ ) { for ( let type = day ; type > 0 ; type -- ) { count += type ; if ( count >= n ) return type ; } } }
function IsEvenPath ( Source , Destination ) { let x_dif = Math . abs ( Source [ 0 ] - Destination [ 0 ] ) ; let y_dif = Math . abs ( Source [ 1 ] - Destination [ 1 ] ) ; let minsteps = x_dif + y_dif ; if ( minsteps % 2 == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function Avgdifference ( arr , N , K ) { let min = 1000000 , max = - 1 ; for ( let i = 0 ; i <= N - K ; i ++ ) { let sum = 0 ; for ( let j = 0 ; j < K ; j ++ ) { sum += arr [ i + j ] ; } if ( min > sum ) min = sum ; if ( max < sum ) max = sum ; } return ( max - min ) / K ; }
function Avgdifference ( arr , N , K ) { let sum = 0 ; for ( let i = 0 ; i < K ; i ++ ) sum += arr [ i ] ; let min = sum ; let max = sum ; for ( let i = K ; i <= N - K + 1 ; i ++ ) { sum += arr [ i ] - arr [ i - K ] ; if ( min > sum ) min = sum ; if ( max < sum ) max = sum ; } return ( max - min ) / K ; }
function perfectSquare ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) { let p = Math . sqrt ( arr [ i ] ) ; if ( p * p != arr [ i ] ) { return " " ; } } return " " ; }
function countKAverageSubarrays ( arr , n , k ) { let res = 0 ; for ( let L = 0 ; L < n ; L ++ ) { let sum = 0 ; for ( let R = L ; R < n ; R ++ ) { sum += arr [ R ] ; let len = R - L + 1 ; if ( sum % len == 0 ) { let avg = sum / len ; if ( avg == k ) res ++ ; } } } return res ; }
function FractionSplit ( n , d ) { let UnitFactions = [ ] ; while ( n > 0 ) { let x = Math . floor ( ( d + n - 1 ) / n ) ; let s = " " + String ( x ) ; UnitFactions . push ( s ) ; n = n * x - d ; d = d * x ; } return UnitFactions ; }
function rangeSum ( arr , N , L , R ) { let sum = 0 ; for ( let i = L - 1 ; i < R ; i ++ ) { sum += arr [ i % N ] ; } document . write ( sum ) ; }
function rangeSum ( arr , N , L , R ) { let prefix = new Array ( N + 1 ) ; prefix [ 0 ] = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] ; } let leftsum = ( ( L - 1 ) / N ) * prefix [ N ] + prefix [ ( L - 1 ) % N ] ; let rightsum = ( R / N ) * prefix [ N ] + prefix [ R % N ] ; document . write ( rightsum - leftsum ) ; }
function addAP ( A , Q , operations ) { for ( let Q of operations ) { let L = Q [ 0 ] , R = Q [ 1 ] , a = Q [ 2 ] , d = Q [ 3 ] curr = a for ( let i = L - 1 ; i < R ; i ++ ) { A [ i ] += curr curr += d } } for ( let i of A ) { document . write ( i + " " ) } }
function countOfPairs ( arr , N , X ) { let count = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( ( ( arr [ i ] ^ arr [ j ] ) & X ) == 0 ) count ++ ; } } return count ; }
function ConcatenateArr ( arr , N ) { let ans = arr [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) { let l = Math . floor ( Math . log10 ( arr [ i ] ) + 1 ) ; ans = ans * Math . pow ( 10 , l ) ; ans += arr [ i ] ; } return ans ; }
function countXor ( N ) { let cnt = Math . floor ( N / 2 ) + 1 ; return cnt ; }
function ExpoFactorial ( N ) { let res = 1 ; let mod = 1000000007 ; for ( let i = 2 ; i < N + 1 ; i ++ ) res = Math . pow ( i , res ) % mod ; return res ; }
function findkey ( A , B , C ) { let ans = 0 ; let cur = 1 ; while ( A > 0 ) { let a = A % 10 ; let b = B % 10 ; let c = C % 10 ; A = Math . floor ( A / 10 ) ; B = Math . floor ( B / 10 ) ; C = Math . floor ( C / 10 ) ; let m = Math . max ( a , Math . max ( c , b ) ) ; ans += cur * m ; cur = cur * 10 ; } return ans ; }
function printRectPattern ( c1 , c2 , n ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { document . write ( Math . max ( Math . abs ( c1 - i ) , Math . abs ( c2 - j ) ) + " " ) ; } document . write ( " " ) ; } }
function countNumbers ( l , r ) { let count = 0 ; for ( let i = l ; i <= r ; i ++ ) { if ( ( i & 1 ) == 0 ) { count ++ ; } } return count ; }
function countNumbers ( l , r ) { return ( parseInt ( r / 2 ) - parseInt ( ( l - 1 ) / 2 ) ) ; }
function sumOfFirstM ( A , N , M ) { let sum = 0 ; for ( let i = 0 ; i < M ; i ++ ) { sum = sum + A [ i % N ] ; } return sum ; }
function findSmallestNumK ( n ) { let cummAnd = n ; let i = n - 1 ; while ( cummAnd != 0 ) { cummAnd = cummAnd & i ; if ( cummAnd == 0 ) { return i ; } i -- ; } return - 1 ; }
function findMinInsertions ( str , l , h ) { if ( l > h ) return Number . MAX_VALUE ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( Math . min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) }
function maximumTurns ( arr , N ) { let Count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { while ( arr [ i ] % 2 == 0 ) { Count ++ ; arr [ i ] = Math . floor ( arr [ i ] / 2 ) ; } } return Count ; }
function findSet ( N , K ) { let a = [ ] ; for ( let i = 1 ; i <= N ; i ++ ) { if ( i != K ) a . push ( i ) ; } let MaxDistinct = ( N - K ) + parseInt ( K / 2 ) ; a . reverse ( ) ; for ( let i = 0 ; i < MaxDistinct ; i ++ ) document . write ( a [ i ] + " " ) ; }
function isPossible ( W , B , D ) { if ( W > B ) { let temp = W ; W = B ; B = temp ; } if ( B > W * ( D + 1 ) ) document . write ( " " ) ; else document . write ( " " ) ; }
function factorialWithoutMul ( N ) { let ans = N ; for ( let i = N - 1 ; i > 0 ; i -- ) { let sum = 0 ; for ( let j = 0 ; j < i ; j ++ ) sum += ans ; ans = sum ; } return ans ; }
function noOfWays ( N , K ) { let S = N . toString ( ) ; let ans = 1 ; for ( let i = 1 ; i < S . length ; i ++ ) { let count = 1 ; while ( i < S . length && S [ i ] . charCodeAt ( ) - 48 + S [ i - 1 ] . charCodeAt ( ) - 48 == K ) { count ++ ; i ++ ; } if ( count % 2 == 1 ) ans *= Math . floor ( ( count + 1 ) / 2 ) ; } return ans ; }
function tripletAndSum ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { for ( let k = j + 1 ; k < n ; k ++ ) { ans += arr [ i ] & arr [ j ] & arr [ k ] ; } } } document . write ( ans ) ; }
function tripletAndSum ( arr , n ) { let ans = 0 ; for ( let bit = 0 ; bit < 32 ; bit ++ ) { let cnt = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & ( 1 << bit ) ) cnt ++ ; } ans += ( 1 << bit ) * cnt * ( cnt - 1 ) * ( cnt - 2 ) / 6 ; } return ans ; }
function countOfBase ( N ) { let count = 0 ; for ( let i = 2 ; i <= N ; ++ i ) { let highestPower = parseInt ( Math . log ( N ) / Math . log ( i ) ) ; let firstDigit = parseInt ( N / Math . pow ( i , highestPower ) ) ; if ( firstDigit == 1 ) { ++ count ; } } return count ; }
function maximumSubsequenceSum ( A , N ) { var ans = 0 ; var mp = new Map ( ) ; var i ; for ( i = 0 ; i < N ; i ++ ) { if ( mp . has ( A [ i ] - i ) ) mp . set ( A [ i ] - i , mp . get ( A [ i ] - i ) + A [ i ] ) ; else mp . set ( A [ i ] - i , A [ i ] ) ; ans = Math . max ( ans , mp . get ( A [ i ] - i ) ) ; } document . write ( ans ) ; }
function nearestPerfectSquare ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) { let sr = parseInt ( Math . sqrt ( arr [ i ] ) ) ; let a = sr * sr ; let b = ( sr + 1 ) * ( sr + 1 ) ; if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) document . write ( a + " " ) ; else document . write ( b + " " ) ; } }
function countXorPartition ( N ) { let a = Math . pow ( 2 , Math . floor ( N - Math . log ( N + 1 ) / Math . log ( 2 ) ) ) ; document . write ( a ) ; }
function floorDifference ( A , N , X ) { let totalSum = 0 ; let perElementSum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { totalSum += A [ i ] ; perElementSum += Math . floor ( A [ i ] / X ) ; } let totalFloorSum = Math . floor ( totalSum / X ) ; return Math . abs ( totalFloorSum - perElementSum ) ; }
function maximumSum ( arr , N ) { let ans = 0 ; for ( let bit = 0 ; bit < 32 ; bit ++ ) { let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & ( 1 << bit ) ) { sum += arr [ i ] ; } } ans = Math . max ( ans , sum ) ; } return ans ; }
function isDivisibleByDivisor ( S , D ) { S %= D ; var hashMap = [ ] ; hashMap . push ( S ) ; for ( var i = 0 ; i <= D ; i ++ ) { S += S % D ; S %= D ; if ( hashMap . includes ( S ) ) { if ( S == 0 ) { return " " ; } return " " ; } else hashMap . push ( S ) ; } return " " ; }
function EditDistDP ( str1 , str2 ) { let len1 = str1 . length ; let len2 = str2 . length ; let DP = new Array ( 2 ) ; for ( let i = 0 ; i < 2 ; i ++ ) { DP [ i ] = new Array ( len1 + 1 ) ; for ( let j = 0 ; j < len1 + 1 ; j ++ ) DP [ i ] [ j ] = 0 ; } for ( let i = 0 ; i <= len1 ; i ++ ) DP [ 0 ] [ i ] = i ; for ( let i = 1 ; i <= len2 ; i ++ ) { for ( let j = 0 ; j <= len1 ; j ++ ) { if ( j == 0 ) DP [ i % 2 ] [ j ] = i ; else if ( str1 [ j - 1 ] == str2 [ i - 1 ] ) { DP [ i % 2 ] [ j ] = DP [ ( i - 1 ) % 2 ] [ j - 1 ] ; } else { DP [ i % 2 ] [ j ] = 1 + Math . min ( DP [ ( i - 1 ) % 2 ] [ j ] , Math . min ( DP [ i % 2 ] [ j - 1 ] , DP [ ( i - 1 ) % 2 ] [ j - 1 ] ) ) ; } } } document . write ( DP [ len2 % 2 ] [ len1 ] + " " ) ; }
function findWinner ( X , Y ) { let first = ( X ^ Y ) ; let second = ( X + Y ) ; if ( first == second ) { document . write ( " " ) ; } else { document . write ( " " ) ; } }
function maxFrequency ( arr , N , K ) { arr . sort ( ( a , b ) => a - b ) ; let start = 0 , end = 0 ; let sum = 0 , res = 0 ; for ( end = 0 ; end < N ; end ++ ) { sum += arr [ end ] ; while ( ( end - start + 1 ) * arr [ end ] - sum > K ) { sum -= arr [ start ] ; start ++ ; } res = Math . max ( res , end - start + 1 ) ; } document . write ( res + " " ) ; }
function findAverage ( N ) { var S = 0 ; var i ; for ( i = 1 ; i <= N ; i ++ ) { S += i * i * i * i ; } return S / N ; }
function findAverage ( N ) { let avg = ( ( 6 * N * N * N * N ) + ( 15 * N * N * N ) + ( 10 * N * N ) - 1 ) / 30.0 ; return avg ; }
function ToCheckPowerofX ( n , x ) { while ( n > 0 ) { var rem = n % x ; if ( rem >= 2 ) { return false ; } n = n / x ; } return true ; } var N = 10 , X = 3 ; if ( ToCheckPowerofX ( N , X ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function findbitwiseOR ( a , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let curr_sub_array = a [ i ] ; res = res | curr_sub_array ; for ( let j = i ; j < n ; j ++ ) { curr_sub_array = curr_sub_array & a [ j ] ; res = res | curr_sub_array ; } } document . write ( res ) ; }
function findbitwiseOR ( a , n ) { var res = 0 ; var i ; for ( i = 0 ; i < n ; i ++ ) res = res | a [ i ] ; document . write ( res ) ; }
function sumOfDivisors ( N ) { return N ; }
function findDecimal ( arr , N ) { let bit , power = 0 , result = 0 ; for ( let i = N - 1 ; i >= 0 ; i -- ) { bit = Math . abs ( Math . floor ( arr [ i ] ) - Math . round ( arr [ i ] ) ) ; if ( bit != 0 ) result += Math . pow ( 2 , power ) ; power ++ ; } document . write ( result ) ; }
function totalMoney ( N ) { let ans = 0 ; for ( let i = 0 ; i < N ; i ++ ) { ans += Math . floor ( i / 7 ) ; ans += ( i % 7 + 1 ) ; } return ans ; }
function check ( n ) { let sumOfDigit = 0 ; let prodOfDigit = 1 ; while ( n > 0 ) { let rem ; rem = n % 10 ; sumOfDigit += rem ; prodOfDigit *= rem ; n = Math . floor ( n / 10 ) ; } if ( sumOfDigit > prodOfDigit ) document . write ( " " ) ; else document . write ( " " ) ; }
function FindSum ( arr , N ) { let res = 0 ; for ( let i = 0 ; i < N ; i ++ ) { let power = Math . floor ( Math . log2 ( arr [ i ] ) ) ; let LesserValue = Math . pow ( 2 , power ) ; let LargerValue = Math . pow ( 2 , power + 1 ) ; if ( ( arr [ i ] - LesserValue ) == ( LargerValue - arr [ i ] ) ) { res += arr [ i ] ; } } return res ; }
function minOperation ( N ) { if ( N % 2 == 0 ) { return ( N / 2 ) * ( N / 2 ) ; } let k = ( N - 1 ) / 2 ; return k * ( k + 1 ) ; }
function findXORS ( arr1 , arr2 , N , M ) { let res = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) { let temp = arr1 [ i ] & arr2 [ j ] ; res ^= temp ; } } return res ; }
function countNum ( N ) { var ans = parseInt ( Math . log ( N ) / Math . log ( 2 ) ) + 1 ; document . write ( ans ) ; }
function findLast ( mat ) { let m = mat . length ; let n = mat [ 0 ] . length ; let rows = new Set ( ) ; let cols = new Set ( ) ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] ) { rows . add ( i ) ; cols . add ( j ) ; } } } let avRows = m - rows . size ; let avCols = n - cols . size ; let choices = Math . min ( avRows , avCols ) ; if ( choices & 1 ) document . write ( " " ) else document . write ( " " ) }
function ceilDifference ( arr , n , x ) { var totalSum = 0 ; var perElementSum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { totalSum += arr [ i ] ; perElementSum += parseInt ( Math . ceil ( ( arr [ i ] ) / ( x ) ) ) ; } var totalCeilSum = parseInt ( Math . ceil ( ( totalSum ) / ( x ) ) ) ; return Math . abs ( perElementSum - totalCeilSum ) ; }
function countTriplets ( N ) { let ans = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { for ( let j = 1 ; j <= N ; j ++ ) { if ( i * j > N ) break ; ans += Math . floor ( N / ( i * j ) ) ; } } return ans ; }
function findSumOfGP ( a , r ) { if ( Math . abs ( r ) >= 1 ) { document . write ( " " ) ; return ; } let sum = a / ( 1 - r ) ; document . write ( sum ) ; }
function sumOfInfiniteAGP ( a , d , r ) { let ans = a / ( 1 - r ) + ( d * r ) / ( 1 - r * r ) ; document . write ( ans ) }
function countPairs ( arr , N ) { let count = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] % arr [ j ] == 0 arr [ j ] % arr [ i ] == 0 ) { count ++ ; } } } return count ; }
function minStepK ( arr , N , K ) { var E = 0 ; var S = 0 ; for ( var i = 0 ; i < N ; i ++ ) { S += arr [ i ] ; if ( arr [ i ] % 2 === 0 ) E += 1 ; } if ( S >= K ) return 0 ; else if ( S + E < K ) return - 1 ; else return K - S ; }
function minimumDiff ( arr , N ) { let res = arr [ 0 ] , sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; let min_diff = sum ; for ( let i = 0 ; i < N ; i ++ ) { if ( Math . abs ( sum - ( arr [ i ] * N ) ) < min_diff ) { min_diff = Math . abs ( sum - ( arr [ i ] * N ) ) ; res = arr [ i ] ; } } document . write ( res ) ; }
function check ( arr , N ) { var sum = 0 ; for ( i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function expectedValue ( P , a , b , N ) { var expValue = P + ( N * 0.5 * ( a + b ) ) ; return expValue ; }
function findMinSum ( mat , N ) { var sum = 0 ; for ( var i = 0 ; i < N ; i ++ ) { var res = 0 ; for ( var j = 0 ; j < N ; j ++ ) { if ( i != j ) { res |= mat [ i ] [ j ] ; } } sum += res ; } return sum ; }
function findMedian ( Mean , Mode ) { var Median = ( 2 * Mean + Mode ) / 3.0 ; document . write ( Median ) ; }
function vectorMagnitude ( x , y , z ) { var sum = x * x + y * y + z * z ; return Math . sqrt ( sum ) ; }
function sumOfSquaredDifferences ( arr , N ) { let ans = 0 ; let sumA = 0 , sumB = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sumA += ( arr [ i ] * arr [ i ] ) ; sumB += arr [ i ] ; } sumA = N * sumA ; sumB = ( sumB * sumB ) ; ans = sumA - sumB ; document . write ( ans ) ; }
function minimumSteps ( x , y ) { var cnt = 0 ; while ( x != 0 && y != 0 ) { if ( x > y ) { cnt += x / y ; x %= y ; } else { cnt += y / x ; y %= x ; } } cnt -- ; if ( x > 1 y > 1 ) cnt = - 1 ; document . write ( cnt ) ; }
function minimumMEX ( arr , N , K ) { let s = new Set ( ) ; for ( let i = 1 ; i <= N + 1 ; i ++ ) s . add ( i ) ; for ( let i = 0 ; i < K ; i ++ ) s . delete ( arr [ i ] ) ; let entry = s . entries ( ) ; let mex = 1 ; for ( let i = K ; i < N ; i ++ ) { s . delete ( arr [ i ] ) ; s . add ( arr [ i - K ] ) ; let firstElem = entry . next ( ) . value mex = Math . min ( mex , 1 ) ; } document . write ( mex + " " ) ; }
function smallerNumbers ( arr , N ) { var i ; for ( i = 0 ; i < N ; i ++ ) { var count = 0 ; for ( j = 0 ; j < N ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { count += 1 ; } } document . write ( count + " " ) ; } }
function truncMod ( a , n ) { let q = Math . round ( a / n ) ; return a - ( n * q ) ; }
function findXOR ( mat , N ) { let XOR = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { for ( let k = 0 ; k < N ; k ++ ) { if ( ( i == j && j == k ) ) { XOR ^= mat [ i ] [ j ] [ k ] ; XOR ^= mat [ i ] [ j ] [ N - k - 1 ] ; } } } } document . write ( XOR ) ; }
function findXOR ( mat , N ) { let XOR = 0 ; for ( let i = 0 ; i < N ; i ++ ) { XOR ^= mat [ i ] [ i ] [ i ] ; XOR ^= mat [ i ] [ i ] [ N - i - 1 ] ; } document . write ( XOR ) ; }
function countPairs ( arr , N ) { var count = 0 ; var mp = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { var val = 1.0 * arr [ i ] ; var idx = 1.0 * ( i + 1 ) ; count += mp . has ( val / idx ) ? mp . get ( val / idx ) : 0 if ( mp . has ( val / idx ) ) mp . set ( val / idx , mp . get ( val / idx ) + 1 ) else mp . set ( val / idx , 1 ) } document . write ( count ) ; }
function checkEvenPower ( n ) { var x = 0 ; while ( x < n ) { var value = Math . pow ( 2 , x ) ; if ( value == n ) { if ( x % 2 == 0 ) return true ; else return false ; } x ++ ; } return false ; }
function checkEvenPower ( n ) { var low = 0 , high = n ; while ( low <= high ) { var mid = low + ( high - low ) / 2 ; var value = parseInt ( Math . pow ( 2 , mid ) ) ; if ( value == n ) { if ( mid % 2 == 1 ) return " " ; else return " " ; } else if ( value < n ) low = mid + 1 ; else high = mid - 1 ; } return " " ; }
function checkEvenPower ( N ) { if ( ( N & ( N - 1 ) ) != 0 ) return false ; N = N & 0x55555555 ; return ( N > 0 ) ; }
function multiplyByMersenne ( N , M ) { let x = ( Math . log ( M + 1 ) / Math . log ( 2 ) ) ; return ( ( N << x ) - N ) ; }
function findSum ( N , K ) { var ans = 0 ; var i = 1 ; while ( i <= N ) { ans += Math . floor ( N / i ) ; i = i * K ; } document . write ( ans ) ; }
function countAPs ( S , D ) { S = S * 2 ; let answer = 0 ; for ( let i = 1 ; i <= Math . sqrt ( S ) ; i ++ ) { if ( S % i == 0 ) { if ( ( ( S / i ) - D * i + D ) % 2 == 0 ) answer ++ ; if ( ( D * i - ( S / i ) + D ) % 2 == 0 ) answer ++ ; } } return answer ; }
function countSubsequences ( A ) { var odd = 0 ; var even = 0 ; for ( var e1 = 0 ; e1 < A . length ; e1 ++ ) { if ( A [ e1 ] % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd == 0 ) document . write ( 0 ) ; else document . write ( ( 1 << ( A . length - 1 ) ) ) ; }
function maxModProdSubarr ( arr , n , M ) { var ans = 0 ; var length = n ; for ( i = 0 ; i < n ; i ++ ) { var product = 1 ; for ( j = i ; j < n ; j ++ ) { product = ( product * arr [ i ] ) % M ; if ( product > ans ) { ans = product ; if ( length > j - i + 1 ) { length = j - i + 1 ; } } } } document . write ( " " + ans + " " ) ; document . write ( " " + " " + length ) ; }
function lastElement ( arr , n ) { let sum = 0 ; let multiplier = n % 2 == 0 ? - 1 : 1 ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * multiplier ; multiplier = multiplier * ( n - 1 - i ) / ( i + 1 ) * ( - 1 ) ; } return sum ; }
function countPairs ( arr , N ) { let odd = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & 1 ) odd ++ ; } let ans = ( N - odd + Math . floor ( odd / 2 ) - 1 ) + Math . floor ( odd / 2 ) ; return ans ; }
function solve ( A , n , Q , q ) { var one = 0 ; for ( var i = 0 ; i < n ; i ++ ) if ( A [ i ] == 1 ) one ++ ; var glows = 0 , count = 0 ; if ( one >= Math . ceil ( n / 2 ) ) glows = 1 ; for ( var i = 0 ; i < q ; i ++ ) { var prev = glows ; if ( A [ Q [ i ] - 1 ] == 1 ) one -- ; if ( A [ Q [ i ] - 1 ] == 0 ) one ++ ; A [ Q [ i ] - 1 ] ^= 1 ; if ( one >= Math . ceil ( n / 2.0 ) ) { glows = 1 ; } else { glows = 0 ; } if ( prev != glows ) count ++ ; } return count ; }
function minimumDifference ( N ) { var sum1 = ( 1 << N ) , sum2 = 0 ; for ( i = 1 ; i < N / 2 ; i ++ ) sum1 += ( 1 << i ) ; for ( i = N / 2 ; i < N ; i ++ ) sum2 += ( 1 << i ) ; document . write ( sum1 - sum2 ) ; }
function sumOfTwoPerfectCubes ( N ) { var cubes = new Map ( ) ; for ( var i = 1 ; i * i * i <= N ; i ++ ) cubes . set ( i * i * i , i ) ; var ans = false ; cubes . forEach ( ( value , key ) => { var firstNumber = key ; var secondNumber = N - value ; if ( cubes . has ( secondNumber ) ) { document . write ( " " ) ; ans = true ; return ; } } ) ; if ( ans ) { return ; } document . write ( " " ) ; }
function sumOfTwoCubes ( n ) { var lo = 1 , hi = ( n ) ; while ( lo <= hi ) { var curr = ( lo * lo * lo + hi * hi * hi ) ; if ( curr == n ) return true ; if ( curr < n ) lo ++ ; else hi -- ; } return false ; } var N = 28 ; if ( sumOfTwoCubes ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function countPairs ( a , n ) { var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] != 0 && a [ i ] % a [ j ] == 0 ) { if ( ( a [ i ] + a [ j ] ) == ( a [ i ] / a [ j ] ) ) count ++ ; } } } return count ; }
function numberOfTiles ( n , m ) { if ( n % 2 == 1 ) { return - 1 ; } return ( m * n ) / 2 ; }
function findNthNumber ( N ) { let result = 0 ; let p = 1 ; while ( N > 0 ) { result += ( p * ( N % 9 ) ) ; N = parseInt ( N / 9 , 10 ) ; p = p * 10 ; } return result ; }
function checkSamePosition ( arr , n ) { var mp = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { var temp = ( ( i + arr [ i ] ) % n + n ) % n ; if ( mp . has ( temp ) ) { document . write ( " " ) ; return ; } if ( mp . has ( temp ) ) { mp . set ( temp , mp . get ( temp ) + 1 ) } else mp . set ( temp , 1 ) } document . write ( " " ) ; }
function sumFib ( N ) { var num = Math . round ( Math . pow ( ( Math . sqrt ( 5 ) + 1 ) / 2.0 , N + 2 ) / Math . sqrt ( 5 ) ) ; document . write ( num - 1 ) ; }
function sumFib ( N ) { var num = ( ( 1 - Math . sqrt ( 5 ) ) / 2 ) ; var val = Math . round ( Math . abs ( 1 / ( Math . pow ( num , N + 2 ) + Math . pow ( num , N + 1 ) + Math . pow ( num , N ) + Math . pow ( num , N - 1 ) ) ) - 1 ) ; document . write ( val ) ; }
function poorPigs ( buckets , minutesToDie , minutesToTest ) { document . write ( Math . ceil ( Math . log ( buckets ) / Math . log ( ( minutesToTest / minutesToDie ) + 1 ) ) ) ; }
function countTrailingZeroes ( N ) { let res = parseInt ( Math . log ( N ^ ( N - 1 ) ) / Math . log ( 2 ) ) ; return res >= 0 ? res : 0 ; }
function convertToASCII ( N ) { let num = N . toString ( ) ; for ( let ch = 0 ; ch < num . length ; ch ++ ) { document . write ( num [ ch ] + " " + num [ ch ] . charCodeAt ( 0 ) + " " ) ; } }
function sameProductQuadruples ( nums , N ) { var umap = new Array ( 10000 ) . fill ( 0 ) ; var res = 0 ; for ( var i = 0 ; i < N ; ++ i ) { for ( var j = i + 1 ; j < N ; ++ j ) { var prod = nums [ i ] * nums [ j ] ; res += 8 * umap [ prod ] ; ++ umap [ prod ] ; } } document . write ( res ) ; }
function oddDivisors ( arr , N ) { for ( i = 0 ; i < N ; i ++ ) { var powerOfTwo = 2 ; var count = 0 ; while ( powerOfTwo <= arr [ i ] ) { count ++ ; powerOfTwo = 2 * powerOfTwo ; } document . write ( count + " " ) ; } return ; }
function highestPowerOfTwo ( num ) { var s = num . toString ( ) ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] === " " ) { document . write ( " " ) ; continue ; } var lg = parseInt ( Math . log2 ( s [ i ] . charCodeAt ( 0 ) - 48 ) ) ; var p = Math . pow ( 2 , lg ) ; document . write ( String . fromCharCode ( p + 48 ) ) ; } }
function singleDigitSubarrayCount ( arr , N ) { let res = 0 ; let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= 9 ) { count ++ ; res += count ; } else { count = 0 ; } } document . write ( res ) ; }
function maxSumAfterKReverse ( arr , K , N ) { let sum = Number . MIN_VALUE ; if ( K % 2 != 0 ) arr . reverse ( ) ; let currsum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { currsum += arr [ i ] ; sum = Math . max ( sum , currsum ) ; } document . write ( sum ) ; }
function countElements ( N ) { var Cur_Ele = 1 ; var Count = 0 ; while ( Cur_Ele <= N ) { Count ++ ; Cur_Ele = Cur_Ele * 2 ; } document . write ( N - Count ) ; }
function SubMasks ( N ) { for ( let S = N ; S > 0 ; S = ( S - 1 ) & N ) { document . write ( S + " " ) ; } }
function isCycleExists ( arr , N ) { for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { document . write ( " " ) ; return ; } } document . write ( " " ) ; }
function totalInversions ( arr , K , N ) { let inv = 0 ; let X = 0 ; let i , j ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { if ( arr [ i ] > arr [ j ] && i < j ) inv ++ ; if ( arr [ i ] > arr [ j ] ) X ++ ; } } let totalInv = X * K * ( K - 1 ) / 2 + inv * K ; document . write ( totalInv ) ; }
function flippingBits ( N , K ) { let X = ( 1 << ( K - 1 ) ) - 1 ; N = X - N ; document . write ( N ) ; }
function getMax ( arr , N , K ) { for ( i = 1 ; i < N ; i ++ ) { var cur_val = arr [ i ] ; while ( K >= i ) { if ( cur_val > 0 ) { arr [ 0 ] = arr [ 0 ] + 1 ; cur_val = cur_val - 1 ; K = K - i ; } else break ; } } document . write ( arr [ 0 ] ) ; }
function numberOfWays ( n , k ) { if ( n == 0 ) return 1 ; if ( k == 0 ) return 1 ; if ( n >= Math . pow ( 2 , k ) ) { let curr_val = Math . pow ( 2 , k ) ; return numberOfWays ( n - curr_val , k ) + numberOfWays ( n , k - 1 ) ; } else return numberOfWays ( n , k - 1 ) ; }
function possibleTriplets ( arr , N ) { var freq = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( arr [ i ] > 0 ) { freq ++ ; } } return ( freq * 1 * ( freq - 1 ) * ( freq - 2 ) ) / 6 ; }
function findDay ( Y , B ) { let lyear , rest , totaldays , day ; Y = ( Y - 1 ) - B ; lyear = Math . floor ( Y / 4 ) ; rest = Y - lyear ; totaldays = ( rest * 365 ) + ( lyear * 366 ) + 1 ; day = ( totaldays % 7 ) ; if ( day == 0 ) document . write ( " " ) ; else if ( day == 1 ) document . write ( " " ) ; else if ( day == 2 ) document . write ( " " ) ; else if ( day == 3 ) document . write ( " " ) ; else if ( day == 4 ) document . write ( " " ) ; else if ( day == 5 ) document . write ( " " ) ; else if ( day == 6 ) document . write ( " " ) ; else document . write ( " " ) ; }
function findPolet ( n , h ) { for ( let i = 1 ; i < n ; i ++ ) document . write ( Math . sqrt ( i / ( n * 1.0 ) ) * h + " " ) ; }
function isInteger ( N ) { let X = Math . floor ( N ) ; let temp2 = N - X ; if ( temp2 > 0 ) { return false ; } return true ; } let N = 1.5 ; if ( isInteger ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function nearestPowerOfTwo ( arr , N ) { for ( i = 0 ; i < N ; i ++ ) { var lg = parseInt ( ( Math . log ( arr [ i ] ) / Math . log ( 2 ) ) ) ; var a = parseInt ( ( Math . pow ( 2 , lg ) ) ) ; var b = parseInt ( ( Math . pow ( 2 , lg + 1 ) ) ) ; if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) document . write ( a + " " ) ; else document . write ( b + " " ) ; } }
function Conversion ( centi ) { let pixels = ( 96 * centi ) / 2.54 ; document . write ( pixels ) ; return 0 ; }
function maxNumTrailNine ( n , d ) { let res = n ; let cntDigits = parseInt ( Math . log ( n ) / Math . log ( 10 ) ) + 1 ; let p10 = 10 ; for ( let i = 1 ; i <= cntDigits ; i ++ ) { if ( n % p10 >= d ) { break ; } else { res = n - n % p10 - 1 ; } p10 = p10 * 10 ; } document . write ( res ) ; }
function MinimumNoOfWays ( arr , n ) { var mini_no_of_ways ; if ( n % 2 == 0 ) { mini_no_of_ways = n / 2 ; } else { mini_no_of_ways = n / 2 + 1 ; } return parseInt ( mini_no_of_ways ) ; }
function count_setbit ( N ) { let result = 0 ; for ( let i = 0 ; i < 32 ; i ++ ) { if ( ( ( 1 << i ) & N ) > 0 ) { result ++ ; } } document . write ( result ) ; }
function cntWaysConsArray ( A , N ) { var total = 1 ; var oddArray = 1 ; for ( i = 0 ; i < N ; i ++ ) { total = total * 3 ; if ( A [ i ] % 2 == 0 ) { oddArray *= 2 ; } } document . write ( total - oddArray ) ; }
function countNumberHavingKthBitSet ( N , K ) { let numbers_rightmost_setbit_K = 0 ; for ( let i = 1 ; i <= K ; i ++ ) { let numbers_rightmost_bit_i = ( N + 1 ) / 2 ; N -= numbers_rightmost_bit_i ; if ( i == K ) { numbers_rightmost_setbit_K = numbers_rightmost_bit_i ; } } document . write ( numbers_rightmost_setbit_K ) ; }
function countSetBits ( N ) { let count = 0 ; while ( N != 0 ) { N = N & ( N - 1 ) ; count ++ ; } return count ; }
function minMoves ( arr , N ) { var odd_element_cnt = 0 ; var i ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 != 0 ) { odd_element_cnt ++ ; } } var moves = Math . floor ( ( odd_element_cnt ) / 2 ) ; if ( odd_element_cnt % 2 != 0 ) moves += 2 ; document . write ( moves ) ; }
function find_Variance ( n ) { var numerator = n * n - 1 var ans = ( numerator * 1.0 ) / 12 return ans }
function countDigit ( arr ) { for ( let i = 0 ; i < M ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { let X = arr [ i ] [ j ] ; let d = ( Math . floor ( Math . log10 ( X ) * 1.0 ) + 1 ) ; document . write ( d + " " ) ; } document . write ( " " ) ; } }
function noOfArraysPossible ( N , M ) { var ans = 1 ; for ( i = 0 ; i < N ; ++ i ) { ans = ans * ( M - i ) ; } document . write ( ans ) ; }
function TotalAndPair ( arr , N ) { let totalAND = ( 1 << 30 ) - 1 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { totalAND &= arr [ i ] & arr [ j ] ; } } return totalAND ; }
function findTripleSum ( A , B , C ) { let sum = 0 ; for ( let i = 1 ; i <= A ; i ++ ) { for ( let j = 1 ; j <= B ; j ++ ) { for ( let k = 1 ; k <= C ; k ++ ) { let prod = ( ( ( i % M ) * ( j % M ) ) % M * ( k % M ) ) % M ; sum = ( sum + prod ) % M ; } } } return sum ; }
function getMaximum ( N , M , mat ) { let global_max = Number . MIN_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { let row_min = Number . MAX_VALUE ; for ( let k = 0 ; k < M ; k ++ ) { let m = Math . max ( mat [ i ] [ k ] , mat [ j ] [ k ] ) ; row_min = Math . min ( row_min , m ) ; } global_max = Math . max ( global_max , row_min ) ; } } return global_max ; }
function minvalue_y ( x ) { let n = Math . floor ( Math . sqrt ( x ) ) ; if ( n * n == x ) return x + 1 ; return Math . floor ( Math . pow ( n + 1 , 2 ) ) ; }
function alternatingSumOfFirst_N ( N ) { var alternateSum = 0 ; for ( i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) { alternateSum += - i ; } else { alternateSum += i ; } } return alternateSum ; }
function alternatingSumOfFirst_N ( N ) { var alternateSum = 0 ; if ( N % 2 == 0 ) { alternateSum = ( - N ) / 2 ; } else { alternateSum = ( N + 1 ) / 2 ; } return alternateSum ; }
function minStartValue ( nums ) { let minValue = 0 ; let sum = 0 ; for ( let n = 0 ; n < nums . length ; n ++ ) { sum += nums [ n ] ; minValue = Math . min ( minValue , sum ) ; } let startValue = 1 - minValue ; return startValue ; }
function countXORSetBitsAdjElemRange1_N ( N ) { let total_set_bits = 0 ; let bit_Position = 1 ; while ( N ) { total_set_bits += ( Math . floor ( ( N + 1 ) / 2 ) * bit_Position ) ; N -= Math . floor ( ( N + 1 ) / 2 ) ; bit_Position ++ ; } return total_set_bits ; }
function TotalBitwiseORPair ( arr , N ) { let totalOR = 0 ; for ( let i = 0 ; i < N ; i ++ ) { totalOR |= arr [ i ] ; } return totalOR ; }
function checkSolveable ( n , m ) { if ( n == 1 m == 1 ) document . write ( " " ) ; else if ( m == 2 && n == 2 ) document . write ( " " ) ; else document . write ( " " ) ; }
function findNumbers ( n ) { var i = 0 ; while ( i <= n ) { document . write ( 2 * i * i + 4 * i + 1 + i % 2 + " " ) ; i ++ ; } }
function sumOfProd ( arr , N ) { let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } return sum * sum ; }
function xor_operations ( N , arr , M , K ) { if ( M < 0 M >= N ) return - 1 ; if ( K < 0 K >= N - M ) return - 1 ; for ( let p = 0 ; p < M ; p ++ ) { let temp = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { let value = arr [ i ] ^ arr [ i + 1 ] ; temp . push ( value ) ; arr [ i ] = temp [ i ] ; } } let ans = arr [ K ] ; return ans ; }
function checkPalindromeB ( N , B ) { var rev = 0 ; var N1 = N ; while ( N1 ) { rev = rev * B + N1 % B ; N1 = parseInt ( N1 / B ) ; } return N == rev ; } var N = 5 , B = 2 ; if ( checkPalindromeB ( N , B ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function countEqual ( n ) { return parseInt ( ( n + 1 ) / 2 ) ; }
function balancedTernary ( n ) { var output = " " ; while ( n > 0 ) { var rem = n % 3 ; n = parseInt ( n / 3 ) ; if ( rem == 2 ) { rem = - 1 ; n ++ ; } output = ( rem == 0 ? ' ' : ( rem == 1 ) ? ' ' : ' ' ) + output ; } return output ; }
function max_valid_triplet ( A , n ) { let ans = - 1 ; for ( let i = 0 ; i < n - 2 ; i ++ ) { for ( let j = i + 1 ; j < n - 1 ; j ++ ) { for ( let k = j + 1 ; k < n ; k ++ ) { if ( A [ i ] < A [ j ] && A [ j ] < A [ k ] ) { let value = A [ i ] + A [ j ] * A [ k ] ; if ( value > ans ) { ans = value ; } } } } } document . write ( ans ) ; }
function highestPower ( n ) { return parseInt ( Math . log ( n ) / Math . log ( 2 ) ) ; }
function checkFactors ( N ) { let ev_count = 0 , od_count = 0 ; for ( let i = 1 ; i <= Math . sqrt ( N ) + 1 ; i ++ ) { if ( N % i == 0 ) { if ( i == Math . floor ( N / i ) ) { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } else { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; if ( Math . floor ( N / i ) % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } } } if ( ev_count % 2 == 0 && od_count % 2 == 1 ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; }
function countofPermutations ( N ) { return parseInt ( 3 * Math . pow ( 2 , N - 1 ) ) ; }
function answer ( L , R ) { if ( 2 * L <= R ) document . write ( L + " " + 2 * L + " " ) ; else document . write ( - 1 ) ; }
function getProduct ( a , n ) { var p = 1 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { p *= Math . abs ( a [ i ] - a [ j ] ) ; } } return p ; }
function Kmultiples ( n , k ) { var a = n ; for ( i = 1 ; i <= k ; i ++ ) { document . write ( n + " " + i + " " + a + " " ) ; var j = 0 ; while ( n >= ( 1 << j ) ) { a += n & ( 1 << j ) ; j ++ ; } } }
function totalCountDifference ( n ) { if ( n == 1 ) return 1 ; return n + totalCountDifference ( Math . floor ( n / 2 ) ) ; }
function findSum ( arr , n , left , right ) { let k = right - left + 1 ; let d = arr [ 1 ] / arr [ 0 ] ; let ans = arr [ left - 1 ] ; if ( d == 1 ) ans = ans * d * k ; else ans = ans * ( Math . pow ( d , k ) - 1 / ( d - 1 ) ) ; return ans ; }
function nCr ( n , r ) { let res = 1 ; if ( r > n - r ) r = n - r ; for ( let i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
function canBreakN ( n ) { for ( let i = 2 ; ; i ++ ) { let m = parseInt ( i * ( i + 1 ) / 2 , 10 ) ; if ( m > n ) break ; let k = n - m ; if ( k % i != 0 ) continue ; document . write ( i ) ; return ; } document . write ( " " ) ; }
function isTriplet ( ar , n ) { for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { for ( var k = j + 1 ; k < n ; k ++ ) { if ( Math . abs ( ar [ i ] - ar [ j ] ) == 1 || Math . abs ( ar [ j ] - ar [ k ] ) == 1 || Math . abs ( ar [ i ] - ar [ k ] ) == 1 ) { var x = ar [ i ] * ar [ i ] , y = ar [ j ] * ar [ j ] , z = ar [ k ] * ar [ k ] ; if ( x == y + z y == x + z z == x + y ) return true ; } } } } return false ; }
function is_possible ( x , y ) { if ( x < 2 && y != 0 ) return false ; y = y - x + 1 ; if ( y % 2 == 0 && y >= 0 ) return true ; else return false ; }
function findTemperature ( x , y , s ) { let Day1 , Day2 ; let diff = ( x - y ) * 6 ; Day2 = ( diff + s ) / 2 ; Day1 = s - Day2 ; document . write ( " " + Day1 + " " ) ; document . write ( " " + Day2 + " " ) ; }
function MinimumString ( x ) { let b = 1 ; let left_lim = Math . sqrt ( x ) + 1.0 ; let right_lim = Math . sqrt ( x ) + 2.0 ; let r = 0 ; for ( let i = Math . floor ( left_lim ) ; i <= Math . floor ( right_lim ) ; i ++ ) { if ( i > left_lim && i < right_lim ) { r = i ; break ; } } return b + r ; }
function is_distinct ( n , k ) { let s = new Set ( ) ; for ( let i = 1 ; i <= k ; i ++ ) { let tmp = n % i ; if ( s . has ( tmp ) ) { return false ; } s . add ( tmp ) ; } return true ; }
function getDivisors ( min , n ) { var total = 0 ; for ( var i = min ; i < n ; ++ i ) { if ( n % i == 0 && n / i >= i ) { ++ total ; if ( n / i > i ) total += getDivisors ( i , n / i ) ; } } return total ; }
function findMinDenomin ( n ) { return ( Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ) ; }
function calculate ( P , Q ) { let mod = 998244353 , expo ; expo = mod - 2 ; p = 748683265 ; while ( expo != 0 ) { if ( ( expo & 1 ) == 1 ) { P = ( P * Q ) % mod ; } Q = ( Q * Q ) % mod ; expo >>= 1 ; } return p ; }
function powerOptimised ( a , n ) { let ans = 1 ; while ( n > 0 ) { let last_bit = ( n & 1 ) ; if ( last_bit > 0 ) { ans = ans * a ; } a = a * a ; n = n >> 1 ; } return ans ; }
function maxGCD ( N ) { for ( var i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { return N / i ; } } return 1 ; }
function findMaximumGcd ( n ) { let max_gcd = 1 ; for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i > max_gcd ) max_gcd = i ; if ( ( n / i != i ) && ( n / i != n ) && ( ( n / i ) > max_gcd ) ) max_gcd = n / i ; } } return max_gcd ; }
function linearCongruentialMethod ( Xo , m , a , c , randomNums , noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( let i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( ( randomNums [ i - 1 ] * a ) + c ) % m ; } } let Xo = 5 ; let m = 7 ; let a = 3 ; let c = 3 ; let noOfRandomNums = 10 ; let randomNums = new Array ( noOfRandomNums ) . fill ( 0 ) ; linearCongruentialMethod ( Xo , m , a , c , randomNums , noOfRandomNums ) ; for ( let i = 0 ; i < noOfRandomNums ; i ++ ) { document . write ( randomNums [ i ] + " " ) ; }
function multiplicativeCongruentialMethod ( Xo , m , a , randomNums , noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( let i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( randomNums [ i - 1 ] * a ) % m ; } } let Xo = 3 ; let m = 15 ; let a = 7 ; let noOfRandomNums = 10 ; let randomNums = new Array ( noOfRandomNums ) . fill ( 0 ) ; multiplicativeCongruentialMethod ( Xo , m , a , randomNums , noOfRandomNums ) ; for ( let i = 0 ; i < noOfRandomNums ; i ++ ) { document . write ( randomNums [ i ] + " " ) ; }
function additiveCongruentialMethod ( Xo , m , c , randomNums , noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( let i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( randomNums [ i - 1 ] + c ) % m ; } } let Xo = 3 ; let m = 15 ; let c = 2 ; let noOfRandomNums = 20 ; let randomNums = new Array ( noOfRandomNums ) . fill ( 0 ) ; additiveCongruentialMethod ( Xo , m , c , randomNums , noOfRandomNums ) ; for ( let i = 0 ; i < noOfRandomNums ; i ++ ) { document . write ( randomNums [ i ] + " " ) ; }
function numberOfObjects ( N , M ) { let initial = Math . min ( N , M ) ; let final = Math . floor ( ( N + M ) / 3 ) ; return Math . min ( initial , final ) ; }
function SquareRoot ( num ) { let count = 0 ; for ( let n = 1 ; n <= num ; n += 2 ) { num = num - n ; count += 1 ; if ( num == 0 ) break ; } return count ; }
function solve ( X , Y ) { if ( X > Y ) { let temp = X ; X = Y ; Y = temp ; } if ( X == Y ) document . write ( 0 ) ; else if ( Y % X == 0 ) document . write ( 1 ) ; else document . write ( 2 ) ; }
function DiStirngMatch ( Str ) { var N = Str . length ; var arr = Array ( N ) . fill ( 0 ) ; var START = 0 , END = N ; for ( var i = 0 ; i < N ; i ++ ) { if ( Str [ i ] == ' ' ) arr [ i ] = START ++ ; if ( Str [ i ] == ' ' ) arr [ i ] = END -- ; } arr [ N ] = START ; return arr ; }
function IsPrime ( i ) { if ( i % 2 == 0 && i != 2 ) return false ; else { for ( j = 3 ; j <= Math . sqrt ( i ) ; j += 2 ) { if ( i % j == 0 ) return false ; } return true ; } } var c = 0 ; var N = 72 ; for ( i = 2 ; i <= Math . sqrt ( N ) ; i ++ ) { if ( IsPrime ( i ) ) { if ( N % i == 0 ) { c ++ ; if ( IsPrime ( N / i ) && i != ( N / i ) ) c ++ ; } } }
function isEqualFactors ( N ) { let ev_count = 0 , od_count = 0 ; for ( let i = 1 ; i <= Math . sqrt ( N ) + 1 ; i ++ ) { if ( N % i == 0 ) { if ( i == N / i ) { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } else { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; if ( ( N / i ) % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } } } if ( ev_count == od_count ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; }
function isEqualFactors ( N ) { if ( ( N % 2 == 0 ) && ( N % 4 != 0 ) ) document . write ( " " ) ; else document . write ( " " ) ; }
function findNumbers ( n , b ) { let largest = Math . pow ( b , n ) - 1 ; document . write ( largest ) ; }
function compute ( a , N , K ) { let eqVal = new Map ( ) ; let maxX = 0 ; for ( let i = 0 ; i < N ; i ++ ) { let val = a [ i ] % K ; val = ( val == 0 ? 0 : K - val ) ; if ( val == 0 ) continue ; if ( eqVal . has ( val ) ) { let numVal = eqVal . get ( val ) ; maxX = Math . max ( maxX , val + ( K * numVal ) ) ; eqVal . set ( val , eqVal . get ( val ) + 1 ) ; } else { eqVal . set ( val , 1 ) ; maxX = Math . max ( maxX , val ) ; } } document . write ( maxX == 0 ? 0 : maxX + 1 ) ; }
function pen_hex ( n ) { var pn = 1 ; for ( i = 1 ; i < n ; i ++ ) { pn = parseInt ( i * ( 3 * i - 1 ) / 2 ) ; if ( pn > n ) break ; var seqNum = ( 1 + Math . sqrt ( 8 * pn + 1 ) ) / 4 ; if ( seqNum == parseInt ( seqNum ) ) document . write ( pn + " " ) ; } }
function maxOR ( arr , n ) { let max_value = Math . max ( ... arr ) ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { ans = Math . max ( ans , ( max_value arr [ i ] ) ) ; } return ans ; }
function print_product ( a , b , c , d ) { let prod1 = a * c ; let prod2 = b * d ; let prod3 = ( a + b ) * ( c + d ) ; let real = prod1 - prod2 ; let imag = prod3 - ( prod1 + prod2 ) ; document . write ( real + " " + imag + " " ) ; }
function countWays ( N ) { if ( N < 4 ) return 0 ; let ans = ( ( N - 1 ) * ( N - 2 ) ) / 2 ; let s = 0 ; for ( let i = 2 ; i <= N - 3 ; i ++ ) { for ( let j = 1 ; j < i ; j ++ ) { if ( N == 2 * i + j ) s ++ ; } } if ( N % 3 == 0 ) s = 3 * s + 1 ; else s = 3 * s ; return ans - s ; }
function get_concentration ( mass , volume ) { if ( volume == 0 ) return - 1 ; else return ( mass / volume ) * 1000 ; }
function PentacontahenagonNum ( N ) { return ( 49 * N * N - 47 * N ) / 2 ; }
function isInsolite ( n ) { let N = n ; let sum = 0 ; let product = 1 ; while ( n != 0 ) { let r = n % 10 ; sum = sum + r * r ; product = product * r * r ; n = parseInt ( n / 10 ) ; } return ( N % sum == 0 ) && ( N % product == 0 ) ; }
function isSaintExuperyNum ( n ) { for ( i = 1 ; i <= n / 3 ; i ++ ) { for ( j = i + 1 ; j <= n / 2 ; j ++ ) { let k = n / i / j ; if ( i * i + j * j == k * k ) { if ( i * j * k == n ) return true ; } } } return false ; }
function isRepdigit ( num , b ) { let prev = - 1 ; while ( num != 0 ) { let digit = num % b ; num = parseInt ( num / b ) ; if ( prev != - 1 && digit != prev ) return false ; prev = digit ; } return true ; } let num = 2000 , base1 = 7 ; if ( isRepdigit ( num , base1 ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function findNthTerm ( n ) { document . write ( n * ( 3 * n + 1 ) / 2 ) ; }
function isIdoneal ( n ) { for ( var a = 1 ; a <= n ; a ++ ) { for ( var b = a + 1 ; b <= n ; b ++ ) { for ( var c = b + 1 ; c <= n ; c ++ ) { if ( a * b + b * c + c * a == n ) return false ; } } } return true ; }
function printhexa ( n ) { if ( n < 0 ) return ; let first = 0 ; let second = 0 ; let third = 0 ; let fourth = 0 ; let fifth = 0 ; let sixth = 1 ; let curr = 0 ; if ( n < 6 ) document . write ( first ) ; else if ( n == 6 ) document . write ( sixth ) ; else { for ( let i = 6 ; i < n ; i ++ ) { curr = first + second + third + fourth + fifth + sixth ; first = second ; second = third ; third = fourth ; fourth = fifth ; fifth = sixth ; sixth = curr ; } } document . write ( curr ) ; }
function isRepunitNum ( n , b ) { let length = 0 ; let countOne = 0 ; while ( n != 0 ) { let r = n % b ; length ++ ; if ( r == 1 ) countOne ++ ; n = parseInt ( n / b ) ; } return countOne >= 3 && countOne == length ; }
function isPossible ( A , B , N , K , L ) { let needa , needb ; if ( A % K == 0 ) needa = Math . floor ( A / K ) ; else needa = Math . floor ( A / K ) + 1 ; if ( B % L == 0 ) needb = Math . floor ( B / L ) ; else needb = Math . floor ( B / L ) + 1 ; let total = needa + needb ; if ( total > N ) return false ; else return true ; }
function sumOfSumSeries ( N ) { let sum = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { sum = sum + ( i * ( i + 1 ) ) / 2 ; } return sum ; }
function sumOfSumSeries ( n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
function placeValue ( N , num ) { var total = 1 , value = 0 , rem = 0 ; while ( true ) { rem = N % 10 ; N = parseInt ( N / 10 ) ; if ( rem == num ) { value = total * rem ; break ; } total = total * 10 ; } return value ; }
function BeattySequence ( n ) { for ( let i = 1 ; i <= n ; i ++ ) { let ans = parseInt ( Math . floor ( i * Math . sqrt ( 2 ) ) ) ; document . write ( ans + " " ) ; } }
function binomialCoeff ( n , k ) { var C = Array . from ( Array ( n + 1 ) , ( ) => Array ( k + 1 ) ) ; var i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
function icosikaienneagonalNum ( n ) { return ( 27 * n * n - 25 * n ) / 2 ; }
function SubArrayProdct ( arr , n ) { let result = 1 ; for ( let i = 0 ; i < n ; i ++ ) result *= Math . pow ( arr [ i ] , ( i + 1 ) * ( n - i ) ) ; return result ; }
function averageRuns ( runs , matches , notout ) { let out1 ; out1 = matches - notout ; if ( out1 == 0 ) return - 1 ; let avg = parseInt ( ( runs ) / out1 , 10 ) ; return avg ; }
function seriesSum ( n ) { let sum = 0 ; let currProd = 1 ; let currSum = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { currProd *= i ; currSum += i ; sum += currProd - currSum ; } return sum ; }
function solve ( N ) { let ans = 0 ; while ( N != 0 ) { ans += N ; N = parseInt ( N / 2 , 10 ) ; } document . write ( ans ) ; }
function maximumAND ( L , R ) { return R ; }
function count ( a , n ) { let countElements = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let flag = true ; for ( let j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; if ( a [ i ] % a [ j ] == 0 ) { flag = false ; break ; } } if ( flag == true ) ++ countElements ; } return countElements ; }
function countPairs ( A , n ) { let count = 0 , i , j ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( ( A [ i ] % 2 == 0 && A [ j ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ j ] % 2 != 0 ) ) count ++ ; } } return count ; }
function smallestNumber ( N ) { let L = Math . pow ( 10 , N ) - 1 ; let S = Math . pow ( 10 , N - 1 ) ; for ( let i = S ; i <= L ; i ++ ) { if ( i % N == 0 ) { document . write ( i ) ; return ; } } }
function smallestNumber ( N ) { return N * Math . ceil ( Math . pow ( 10 , ( N - 1 ) ) / N ) ; }
function CountPairs ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] % 2 == 0 arr [ j ] % 2 == 0 ) count ++ ; } } return count ; }
function CountPairs ( arr , n ) { let even = 0 , odd = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return ( even * ( even - 1 ) ) / 2 + ( even * odd ) ; }
function isPal ( a , n , m ) { for ( let i = 0 ; i < n / 2 ; i ++ ) { for ( let j = 0 ; j < m - 1 ; j ++ ) { if ( a [ i ] [ j ] != a [ n - 1 - i ] [ m - 1 - j ] ) return false ; } } return true ; } let n = 3 , m = 3 ; let a = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 4 ] , [ 3 , 2 , 1 ] ] ; if ( isPal ( a , n , m ) ) { document . write ( " " + " " ) ; } else { document . write ( " " + " " ) ; }
function smallestNum ( n ) { return parseInt ( n * n % 9 + 1 ) * Math . pow ( 10 , parseInt ( n * n / 9 ) ) - 1 ; }
function smallestNumber ( N ) { document . write ( ( N % 9 + 1 ) * Math . pow ( 10 , parseInt ( N / 9 , 10 ) ) - 1 ) ; }
function findNthTerm ( n ) { document . write ( parseInt ( ( n * ( 5 * n + 3 ) ) / 2 ) ) ; }
function findNthTerm ( n ) { document . write ( n * ( 2 * n + 1 ) ) ; }
function findNthTerm ( n ) { document . write ( n * ( 4 * n + 3 ) ) ; }
function isStraighLineNum ( N ) { if ( N <= 99 ) return false ; let s = N . toString ( ) ; let d = s [ 1 ] - s [ 0 ] ; for ( let i = 2 ; i < s . length ; i ++ ) if ( s [ i ] - s [ i - 1 ] != d ) return false ; return true ; } let n = 135 ; if ( isStraighLineNum ( n ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function findNthTerm ( n ) { document . write ( ( Math . pow ( 2 , n ) ) - ( 2 * n ) ) ; }
function findNthTerm ( n ) { document . write ( n * n - n + 1 ) ; }
function DecakismyriagonNum ( N ) { return ( 99998 * N * N - 99996 * N ) / 2 ; }
function iszygodromeNum ( N ) { let s = N . toString ( ) ; s = ' ' + s + ' ' ; for ( i = 1 ; i < s . length - 1 ; i ++ ) { if ( s [ i ] != s [ i - 1 ] && s [ i ] != s [ i + 1 ] ) { return false ; } } return true ; }
function isLoeschian ( n ) { for ( let x = 1 ; x <= Math . sqrt ( n ) ; x ++ ) { for ( let y = 1 ; y <= Math . sqrt ( n ) ; y ++ ) { if ( x * x + x * y + y * y == n ) return true ; } } return false ; }
function printSeries ( N ) { let ith_term = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { ith_term = ( 13 * i * ( i - 1 ) ) / 2 + 2 ; document . write ( ith_term + " " ) ; } }
function strikerate ( bowls , runs ) { let z ; z = ( runs / bowls ) * 100 ; return z . toFixed ( 3 ) ; }
function checkArray ( n , k , arr ) { var cnt = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) cnt += 1 ; } if ( cnt >= k && cnt % 2 == k % 2 ) return true ; else return false ; }
function check ( n ) { var digits = new Set ( ) ; var temp = n ; var sum = 0 ; var count = 0 ; while ( temp > 0 ) { sum += temp % 10 ; digits . add ( temp % 10 ) ; count ++ ; temp = parseInt ( temp / 10 ) ; } if ( sum % count == 0 && digits . has ( sum / count ) ) document . write ( " " ) ; else document . write ( " " ) ; }
function findPosition ( n ) { var i = 0 ; var pos = 0 ; while ( n > 0 ) { if ( n % 10 == 7 ) { pos = pos + parseInt ( Math . pow ( 2 , i + 1 ) ) ; } else { pos = pos + parseInt ( Math . pow ( 2 , i ) ) ; } i ++ ; n = parseInt ( n / 10 ) ; } document . write ( pos ) ; }
function findAverageOfCube ( n ) { let sum = 0 ; let i ; for ( i = 1 ; i <= n ; i ++ ) { sum += i * i * i ; } return sum / n ; }
function greatestOddFactor ( n ) { let pow_2 = ( Math . log ( n ) ) ; let i = 1 ; while ( i <= pow_2 ) { let fac_2 = ( 2 * i ) ; if ( n % fac_2 == 0 ) { if ( ( n / fac_2 ) % 2 == 1 ) { return ( n / fac_2 ) ; } } i += 1 ; } return 0 ; }
function canReplace ( array , n ) { var i = 0 , count = 0 ; while ( i < n ) { if ( array [ i ] == 0 && ( i == 0 array [ i - 1 ] == 0 ) && ( i == n - 1 array [ i + 1 ] == 0 ) ) { array [ i ] = 1 ; count ++ ; } i ++ ; } return count ; }
function countSmaller ( str ) { var n = str . length ; for ( var i = 0 ; i < n ; i ++ ) { var cnt = 0 ; for ( var j = i + 1 ; j < n ; j ++ ) { if ( str [ j ] < str [ i ] ) { cnt += 1 ; } } document . write ( cnt + " " ) ; } }
function sum_star_num ( n ) { let summ = 2 * n * ( n + 1 ) * ( n - 1 ) + n ; return summ ; }
function gonNum65537 ( n ) { return ( 65535 * n * n - 65533 * n ) / 2 ; }
function EnneacontahexagonNum ( n ) { return ( 94 * n * n - 92 * n ) / 2 ; }
function MegagonNum ( n ) { return ( 999998 * n * n - 999996 * n ) / 2 ; }
function gonNum360 ( n ) { return ( 358 * n * n - 356 * n ) / 2 ; }
function gonNum120 ( n ) { return ( 118 * n * n - 116 * n ) / 2 ; }
function TetracontaoctagonalNum ( n ) { return ( 46 * n * n - 44 * n ) / 2 ; }
function gonNum257 ( n ) { return ( 255 * n * n - 253 * n ) / 2 ; }
function TetracontadigonalNum ( n ) { return ( 40 * n * n - 38 * n ) / 2 ; }
function HexacontatetragonNum ( n ) { return ( 62 * n * n - 60 * n ) / 2 ; }
function findIndex ( n ) { let x = Math . sqrt ( 2 * Math . pow ( 10 , ( n - 1 ) ) ) ; return Math . round ( x ) ; }
function isPossible ( A , B ) { return ( A - B > 1 ) ; }
function smallestSumpair ( arr , n ) { let pair = [ ] ; let min_sum = Number . MAX_VALUE , i ; for ( i = 1 ; i < n ; i ++ ) { if ( min_sum > ( arr [ i ] + arr [ i - 1 ] ) ) { min_sum = arr [ i ] + arr [ i - 1 ] ; if ( pair . length == 0 ) { pair . push ( arr [ i - 1 ] ) ; pair . push ( arr [ i ] ) ; } else { pair [ 0 ] = arr [ i - 1 ] ; pair [ 1 ] = arr [ i ] ; } } } return pair ; }
function findLCMPrime ( a , b ) { if ( a == b ) { return a ; } return a * b ; }
function smallestNumber ( N ) { document . write ( N * parseInt ( Math . ceil ( Math . pow ( 2 , ( N - 1 ) ) / N ) ) ) ; }
function smallestNumber ( N ) { document . write ( N * Math . floor ( ( Math . pow ( 10 , N ) - 1 ) / N ) ) ; }
function icosikaipentagonNum ( N ) { return parseInt ( ( 23 * N * N - 21 * N ) / 2 ) ; }
function icosikaiheptagonalNum ( n ) { return ( 25 * n * n - 23 * n ) / 2 ; }
function istriacontagonal ( N ) { let n = ( ( 26 + Math . sqrt ( 224 * N + 676 ) ) / 56 ) ; return ( n - parseInt ( n ) ) == 0 ; } let N = 30 ; if ( istriacontagonal ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function checkSolution ( a , b , c ) { if ( a == c ) document . write ( " " ) ; else document . write ( " " ) ; }
function getParity ( n , A ) { for ( let x in A ) { if ( ( x & 1 ) == 1 ) { document . write ( " " ) ; return ; } } document . write ( " " ) ; }
function numberOfDigits ( N ) { let nod = Math . floor ( Math . log10 ( N ) + 1 ) ; let toDecrease = ( Math . pow ( 10 , nod ) - 1 ) / 9 ; document . write ( ( N + 1 ) * nod - toDecrease ) ; }
function lastTwoDigits ( N ) { if ( N >= 10 ) { cout << " " ; return ; } let fac = 1 ; for ( let i = 1 ; i <= N ; i ++ ) fac = ( fac * i ) % 100 ; document . write ( fac ) ; }
function productOfGP ( a , r , n ) { let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) { product = product * a ; a = a * r ; } return product ; }
function productOfGP ( a , r , n ) { return Math . pow ( a , n ) * Math . pow ( r , n * ( n - 1 ) / 2 ) ; }
function productOfGP ( a , r , n ) { let an = a * Math . pow ( r , n - 1 ) ; return Math . sqrt ( Math . pow ( a * an , n ) ) ; }
function solve ( n ) { for ( var x = 1 ; x <= Math . sqrt ( n ) ; x ++ ) { if ( n % x == 0 ) { var small = x ; var big = n / x ; if ( small % 2 == big % 2 ) { var a = ( small + big ) / 2 ; var b = ( big - small ) / 2 ; document . write ( a + " " + b ) ; return ; } } } document . write ( - 1 ) ; }
function is_Chiliagon ( N ) { let n = ( 996 + Math . sqrt ( 7984 * N + 992016 ) ) / 1996 ; return ( n - Math . floor ( n ) ) == 0 ; } let N = 1000 ; if ( is_Chiliagon ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function checkDivisbility ( num ) { let digit ; let N = num ; while ( num != 0 ) { digit = num % 10 ; num = Math . floor ( num / 10 ) ; if ( digit == 0 N % digit != 0 ) return false ; } return true ; }
function findArrangement ( N ) { if ( N < 3 ) return 0 ; return ( ( N ) * ( N - 1 ) * ( N - 2 ) ) / 3 ; }
function CheckBinaryEquivalent ( N ) { return ( N - 1 ) % 8 == 0 ; }
function maxDivision ( arr , n ) { arr . sort ( ( a , b ) => b - a ) ; let mxdiv = arr [ 1 ] ; for ( let i = 2 ; i < n ; ++ i ) mxdiv = mxdiv / arr [ i ] ; return arr [ 0 ] / mxdiv ; }
function sumOfProductOfDigits ( n1 , n2 ) { let sum = 0 ; while ( n1 > 0 && n2 > 0 ) { sum += ( ( n1 % 10 ) * ( n2 % 10 ) ) ; n1 = Math . floor ( n1 / 10 ) ; n2 = Math . floor ( n2 / 10 ) ; } return sum ; }
function solve ( n ) { let upper_limit = Math . ceil ( Math . pow ( n , 1.0 / 4 ) ) ; for ( let x = 0 ; x <= upper_limit ; x ++ ) { for ( let y = 0 ; y <= upper_limit ; y ++ ) { let num1 = x * x * x * x ; let num2 = y * y * y * y ; if ( num1 - num2 == n ) { document . write ( " " + x + " " + y ) ; return ; } } } document . write ( - 1 ) ; }
function productPairs ( arr , n ) { let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; product = product % mod ; } } return product % mod ; }
function operation ( arr , N ) { let right = 0 , ans = 0 , num = 0 ; for ( let left = 0 ; left < N ; left ++ ) { while ( right < N && num + arr [ right ] == ( num ^ arr [ right ] ) ) { num += arr [ right ] ; right ++ ; } ans += right - left ; if ( left == right ) right ++ ; else num -= arr [ left ] ; } return ans ; }
function divisorsSame ( n ) { return ( n - 2 ) % 4 == 0 ; } let N = 6 ; if ( divisorsSame ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function Convert ( degree ) { let pi = 3.14159265359 ; return ( degree * ( pi / 180 ) ) ; }
function checkSolution ( a1 , b1 , c1 , a2 , b2 , c2 ) { return ( a1 / a2 ) == ( b1 / b2 ) && ( b1 / b2 ) == ( c1 / c2 ) ; }
function chiliagonNum ( n ) { return ( 998 * n * n - 996 * n ) / 2 ; }
function checkSolution ( a , b , c ) { if ( b == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function pentacontagonNum ( n ) { return ( 48 * n * n - 46 * n ) / 2 ; }
function findPair ( x ) { let lim = 120 ; for ( let i = - lim ; i <= lim ; i ++ ) for ( let j = - lim ; j <= lim ; j ++ ) if ( Math . pow ( i , 5 ) - Math . pow ( j , 5 ) == x ) { document . write ( i + " " + j ) ; return ; } document . write ( " " ) ; }
function checkIsFibonacci ( arr , n ) { if ( n == 1 n == 2 ) return true ; arr . sort ( ( a , b ) => a - b ) ; for ( i = 2 ; i < n ; i ++ ) { if ( ( arr [ i - 1 ] + arr [ i - 2 ] ) != arr [ i ] ) return false ; } return true ; }
function lastDigitFactorial ( n ) { if ( n == 0 ) return 1 ; else if ( n <= 2 ) return n ; else if ( n == 3 ) return 6 ; else if ( n == 4 ) return 4 ; else return 0 ; }
function lastDigit2PowerN ( n ) { if ( n == 0 ) return 1 ; else if ( n % 4 == 1 ) return 2 ; else if ( n % 4 == 2 ) return 4 ; else if ( n % 4 == 3 ) return 8 ; else }
function findSum ( n , k ) { var val = parseInt ( k / ( n - 1 ) ) * n ; var rem = k % ( n - 1 ) ; if ( rem == 0 ) { val = val - 1 ; } else { val = val + rem ; } var sum = parseInt ( ( val * ( val + 1 ) ) / 2 ) ; var x = parseInt ( k / ( n - 1 ) ) ; var sum_of_multiples = parseInt ( ( x * ( x + 1 ) * n ) / 2 ) ; sum -= sum_of_multiples ; return sum ; }
function bToHexaDecimal ( s ) { let len = s . length , check = 0 ; let num = 0 , sum = 0 , mul = 1 ; let ans = new Array ( ) ; for ( let i = len - 1 ; i >= 0 ; i -- ) { sum += ( s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) * mul ; mul *= 2 ; check ++ ; if ( check == 4 i == 0 ) { if ( sum <= 9 ) ans . push ( String . fromCharCode ( sum + ' ' . charCodeAt ( 0 ) ) ) ; else ans . push ( String . fromCharCode ( sum + 55 ) ) ; check = 0 ; sum = 0 ; mul = 1 ; } } len = ans . length ; for ( let i = len - 1 ; i >= 0 ; i -- ) document . write ( ans [ i ] ) ; }
function isMyriagon ( N ) { n = ( 9996 + Math . sqrt ( 79984 * N + 99920016 ) ) / 19996 ; return ( n - parseInt ( n ) ) == 0 ; } N = 10000 ; if ( isMyriagon ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function isdecagonal ( N ) { let n = ( 3 + Math . sqrt ( 16 * N + 9 ) ) / 8 ; return ( n - parseInt ( n ) ) == 0 ; } let N = 10 ; if ( isdecagonal ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function isOctadecagon ( N ) { let n = ( 14 + Math . sqrt ( 128 * N + 196 ) ) / 32 ; return ( n - parseInt ( n ) ) == 0 ; } let N = 18 ; if ( isOctadecagon ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function isoctagonal ( N ) { var n = ( 2 + Math . sqrt ( 12 * N + 4 ) ) / 6 ; return ( n - parseInt ( n ) == 0 ) ; } var N = 8 ; if ( isoctagonal ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function isheptagonal ( N ) { var n = ( 3 + Math . sqrt ( 40 * N + 9 ) ) / 10 ; return ( n - parseInt ( n ) ) == 0 ; } var N = 7 ; if ( isheptagonal ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function isPentadecagon ( N ) { var n = ( 11 + Math . sqrt ( 104 * N + 121 ) ) / 26 ; return ( n - parseInt ( n ) ) == 0 ; } var N = 15 ; if ( isPentadecagon ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function longestEvenOddSubarray ( a , n ) { let longest = 1 ; let cnt = 1 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] + a [ i + 1 ] ) % 2 == 1 ) { cnt ++ ; } else { longest = Math . max ( longest , cnt ) ; cnt = 1 ; } } if ( longest == 1 ) return 0 ; return Math . max ( cnt , longest ) ; }
function ishendecagonal ( N ) { let n = ( 7 + Math . sqrt ( 72 * N + 49 ) ) / 18 ; return ( n - parseInt ( n ) ) == 0 ; } let N = 11 ; if ( ishendecagonal ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function istetradecagonal ( N ) { n = ( 10 + Math . sqrt ( 96 * N + 100 ) ) / 24 ; return ( n - parseInt ( n ) ) == 0 ; } N = 11 ; if ( istetradecagonal ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function ishexadecagonal ( N ) { let n = ( 12 + Math . sqrt ( 112 * N + 144 ) ) / 28 ; return ( n - parseInt ( n ) ) == 0 ; } let N = 16 ; if ( ishexadecagonal ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function isnonagonal ( N ) { let n = ( 5 + Math . sqrt ( 56 * N + 25 ) ) / 14 ; return ( n - parseInt ( n ) ) == 0 ; } let N = 9 ; if ( isnonagonal ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function isenneadecagonal ( N ) { let n = parseFloat ( 15 + Math . sqrt ( 136 * N + 225 ) ) / 34 ; return ( n - parseInt ( n ) ) == 0 } let N = 19 ; if ( isenneadecagonal ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function divParts ( N ) { if ( N % 2 == 0 ) document . write ( ( N / 2 ) - 1 ) ; else document . write ( ( N / 2 ) ) ; }
function getMinSteps ( n , jump ) { let quotient = Math . floor ( n / jump ) ; let remainder = n % jump ; let steps = quotient + remainder ; return steps ; }
function constructArray ( N ) { for ( let i = 1 ; i <= N ; i ++ ) { document . write ( i + " " ) ; } }
function isCenteredtridecagonal ( N ) { let n = ( 13 + Math . sqrt ( 104 * N + 65 ) ) / 26 ; return ( n - parseInt ( n ) ) == 0 ; } let N = 14 ; if ( isCenteredtridecagonal ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function isCenteredpentagonal ( N ) { var n = ( ( 5 + Math . sqrt ( 40 * N - 15 ) ) / 10 ) ; return ( n - parseInt ( n ) == 0 ) ; } var N = 6 ; if ( isCenteredpentagonal ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function isCentereddecagonal ( N ) { let n = ( 5 + Math . sqrt ( 20 * N + 5 ) ) / 10 ; return ( n - parseInt ( n ) ) == 0 ; } let N = 11 ; if ( isCentereddecagonal ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function isdodecagonal ( N ) { let n = ( 4 + Math . sqrt ( 20 * N + 16 ) ) / 10 ; return ( n - parseInt ( n ) ) == 0 ; } let N = 12 ; if ( isdodecagonal ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function nDigitPerfectSquares ( n , b ) { var largest = Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( b , n ) ) ) - 1 , 2 ) ; document . write ( largest ) ; }
function findNum ( n , k ) { let q = parseInt ( k / ( n - 1 ) ) ; let r = k % ( n - 1 ) ; let a ; if ( r != 0 ) a = ( n * q ) + r ; else a = ( n * q ) - 1 ; document . write ( a ) ; }
function cubeRoot ( n ) { let ans = Math . pow ( 3 , ( 1.0 / 3 ) * ( Math . log ( n ) / Math . log ( 3 ) ) ) ; return ans ; }
function floorMax ( A , B , N ) { let x = Math . min ( B - 1 , N ) ; return Math . floor ( ( A * x ) / B ) ; }
function calculateMoves ( n ) { var count = 0 ; var layers = parseInt ( n / 2 ) ; for ( var k = 1 ; k < layers + 1 ; k ++ ) { count += 8 * k * k ; } return count ; }
function countWays ( n ) { if ( n <= 2 ) document . write ( " " ) ; else { var ans = ( n - 1 ) * ( n - 2 ) / 2 ; document . write ( ans ) ; } }
function isSumSquare ( N ) { var n = ( 2 + Math . sqrt ( 8 * N - 4 ) ) / 2 ; return ( n - parseInt ( n ) ) == 0 ; } var i = 13 ; if ( isSumSquare ( i ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function isCenteredheptagonal ( N ) { let n = ( 7 + Math . sqrt ( 56 * N - 7 ) ) / 14 ; return ( n - parseInt ( n ) ) == 0 ; } let n = 8 ; if ( isCenteredheptagonal ( n ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function isCenterednonadecagonal ( N ) { var n = ( 19 + Math . sqrt ( 152 * N + 209 ) ) / 38 ; return ( n - parseInt ( n ) ) == 0 ; } var n = 20 ; if ( isCenterednonadecagonal ( n ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function isCenteredOctadecagonal ( N ) { let n = parseInt ( ( 9 + Math . sqrt ( 36 * N + 45 ) ) / 18 ) ; return ( n - parseInt ( n ) ) == 0 ; } let n = 19 ; if ( isCenteredOctadecagonal ( n ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function isPowerOfTwo ( n ) { return ( Math . ceil ( Math . log ( n ) / Math . log ( 2 ) ) == Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) ) ; } let N = 8 ; if ( isPowerOfTwo ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function kthRoot ( n , k ) { return Math . pow ( k , ( 1.0 / k ) * ( Math . log ( n ) / Math . log ( k ) ) ) ; }
function countDigit ( n ) { return Math . floor ( Math . log10 ( n ) + 1 ) ; }
function isPower ( N , K ) { var res1 = Math . floor ( Math . log ( N ) / Math . log ( K ) ) ; var res2 = Math . log ( N ) / Math . log ( K ) ; return ( res1 == res2 ) ; } var N = 8 ; var K = 2 ; if ( isPower ( N , K ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function subarray ( arr , n ) { var ans = 1 , temp = 1 ; for ( var i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { ++ temp ; } else { ans = Math . max ( ans , temp ) ; temp = 1 ; } } ans = Math . max ( ans , temp ) ; return ans ; }
function first_digit ( x , y ) { var length = parseInt ( Math . log ( x ) / Math . log ( y ) ) + 1 ; var first_digit = parseInt ( x / Math . pow ( y , length - 1 ) ) ; document . write ( first_digit ) ; }
function kthRoot ( n , k ) { return Math . pow ( k , ( ( 1.0 / k ) * ( Math . log ( n ) / Math . log ( k ) ) ) ) ; }
function checksum ( n , k ) { var first_term = ( ( ( 2 * n ) / k + ( 1 - k ) ) / 2.0 ) ; if ( first_term - parseInt ( ( first_term ) ) == 0 ) { for ( i = parseInt ( first_term ) ; i <= first_term + k - 1 ; i ++ ) { document . write ( i + " " ) ; } } else document . write ( " " ) ; }
function distributeN ( A , B , C , n ) { let max1 = Math . max ( A , B ) ; let max2 = Math . max ( B , C ) ; let maximum = Math . max ( max1 , max2 ) ; let sum = A + B + C ; let p = ( 3 * maximum ) - sum ; let diff = n - p ; if ( diff < 0 diff % 3 ) document . write ( " " ) ; else document . write ( " " ) ; }
function minimumSteps ( a , b , c ) { if ( a < 1 b < 1 ) return - 1 ; if ( a == 1 && b == 1 ) return c ; if ( a < b ) { a = a + b ; b = a - b ; a = a - b ; } return minimumSteps ( a - b , b , c + 1 ) ; }
function count_pairs ( x ) { var ans = 1 ; while ( x > 0 ) { if ( x % 2 == 1 ) ans = ans * 3 ; x = parseInt ( x / 2 ) ; } return ans ; }
function countSquares ( n ) { let r = Math . ceil ( Math . sqrt ( Math . pow ( 10 , n ) ) ) ; let l = Math . ceil ( Math . sqrt ( Math . pow ( 10 , n - 1 ) ) ) ; return r - l ; }
function summation ( N ) { var co = parseInt ( ( N + 1 ) / 2 ) ; var ce = parseInt ( ( N ) / 2 ) ; var se = 2 * ( ( ce * ( ce + 1 ) ) * ( ce * ( ce + 1 ) ) ) ; var so = ( co * co ) * ( 2 * ( ( co * co ) ) - 1 ) ; return so - se ; }
function isStar ( N ) { let n = ( 6 + Math . sqrt ( 24 * N + 12 ) ) / 6 ; return ( n - parseInt ( n ) ) == 0 ; } let i = 13 ; if ( isStar ( i ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function sumEvenNumbers ( N , K ) { let check = N - 2 * ( K - 1 ) ; if ( check > 0 && check % 2 == 0 ) { for ( let i = 0 ; i < K - 1 ; i ++ ) { document . write ( " " ) ; } document . write ( check ) ; } else { document . write ( " " ) ; } }
function computeMaxValue ( arr , n ) { var ans = 0 ; for ( var i = 0 ; i < n - 1 ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { var val = Math . max ( arr [ i ] / arr [ j ] , arr [ j ] / arr [ i ] ) ; ans = Math . max ( ans , val ) ; } } return ans ; }
function checkIfCurzonNumber ( N ) { var powerTerm , productTerm ; powerTerm = Math . pow ( 2 , N ) + 1 ; productTerm = 2 * N + 1 ; if ( powerTerm % productTerm == 0 ) { document . write ( " " + " " ) ; } else { document . write ( " " ) ; } }
function kthNonDivisible ( N , K ) { return K + parseInt ( Math . floor ( ( K - 1 ) / ( N - 1 ) ) , 10 ) ; }
function isHexagonal ( N ) { let val = 8 * N + 1 ; let x = 1 + Math . sqrt ( val ) ; let n = ( x ) / 4 ; if ( ( n - parseInt ( n ) ) == 0 ) { return true ; } else { return false ; } } let N = 14 ; if ( isHexagonal ( N ) == true ) { document . write ( " " + " " ) ; } else { document . write ( " " ) ; }
function minCount ( n ) { let hasharr = [ 10 , 3 , 6 , 9 , 2 , 5 , 8 , 1 , 4 , 7 ] ; if ( n > 69 ) return hasharr [ n % 10 ] ; else { if ( n >= hasharr [ n % 10 ] * 7 ) return ( hasharr [ n % 10 ] ) ; else return - 1 ; } }
function Solve ( arr , n ) { let temp = 0 , count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( let j = i ; j < n ; j ++ ) { temp += arr [ j ] ; if ( ( temp + 2 ) % 4 != 0 ) count ++ ; } } return count ; }
function prodSquare ( n ) { for ( i = 2 ; i * i <= n ; i ++ ) for ( j = 2 ; j <= n ; j ++ ) if ( i * i * j * j == n ) return true ; return false ; }
function prodSquare ( n ) { var s = new Map ( ) ; for ( var i = 2 ; i * i <= n ; ++ i ) { s . set ( i * i , 1 ) ; if ( s . has ( n / ( i * i ) ) ) return true ; } return false ; }
function printPair ( n ) { document . write ( 1 + " " + ( n - 1 ) ) ; }
function printArr ( n ) { if ( n % 4 == 0 ) { for ( var i = 1 ; i <= n / 2 ; i ++ ) document . write ( i * 2 + ' ' ) ; for ( var i = 1 ; i < n / 2 ; i ++ ) document . write ( i * 2 - 1 + ' ' ) ; document . write ( n + n / 2 - 1 + ' ' ) ; } else document . write ( " " ) ; }
function maxOR ( arr , n ) { var max_value = Math . max . apply ( Math , arr ) ; var number_of_bits = parseInt ( ( ( Math . log ( max_value ) ) ) ) + 2 ; var complement = ( ( 1 << number_of_bits ) - 1 ) ^ max_value ; var c = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != max_value ) { c = Math . max ( c , ( complement & arr [ i ] ) ) ; } } return ( max_value + c ) ; }
function findNumbers ( N ) { for ( var i = 1 ; i <= N / 2 ; i ++ ) { document . write ( i + " " + - i + " " ) ; } if ( N % 2 == 1 ) document . write ( 0 ) ; }
function sum ( x , n ) { let i , total = 1.0 , multi = x ; document . write ( total + " " ) ; for ( i = 1 ; i < n ; i ++ ) { total = total + multi ; document . write ( multi + " " ) ; multi = multi * x ; } document . write ( " " ) ; return total ; }
function countValues ( n ) { let answer = 0 ; for ( let i = 2 ; i <= n ; i ++ ) { let k = n ; while ( k >= i ) { if ( k % i == 0 ) k /= i ; else k -= i ; } if ( k == 1 ) answer ++ ; } return answer ; }
function factors ( n ) { let i , j ; document . write ( " " ) ; for ( i = 2 ; i <= n ; i ++ ) { document . write ( i + " " ) ; for ( j = 1 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { document . write ( j + " " ) ; if ( parseInt ( i / j ) != j ) document . write ( parseInt ( i / j ) + " " ) ; } } document . write ( " " ) ; } }
function countPalindromic ( n ) { var count ; if ( n % 2 == 1 ) { count = Math . pow ( 9 , ( n - 1 ) / 2 ) ; } else { count = Math . pow ( 9 , ( n - 2 ) / 2 ) ; } return count ; }
function countSubArrayWithOddProduct ( A , N ) { var count = 0 ; var last = - 1 ; var K = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) { K = ( i - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; last = i ; } } K = ( N - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; return count ; }
function findMinXORSubarray ( arr , n , k ) { if ( n < k ) return ; let res_index = 0 ; let curr_xor = 0 ; for ( let i = 0 ; i < k ; i ++ ) curr_xor ^= arr [ i ] ; let min_xor = curr_xor ; for ( let i = k ; i < n ; i ++ ) { curr_xor ^= ( arr [ i ] ^ arr [ i - k ] ) ; if ( curr_xor < min_xor ) { min_xor = curr_xor ; res_index = ( i - k + 1 ) ; } } document . write ( min_xor + " " ) ; }
function printKNumbers ( N , K ) { for ( let i = 0 ; i < K - 1 ; i ++ ) document . write ( 1 + " " ) ; document . write ( N - K + 1 ) ; }
function findProb ( l , r ) { var countOfPS = ( Math . floor ( Math . sqrt ( r ) ) - Math . ceil ( Math . sqrt ( l ) ) + 1 ) ; var total = r - l + 1 ; var prob = countOfPS / total ; return prob ; }
function minNum ( n , k ) { var x = parseInt ( Math . log ( n ) / Math . log ( k ) ) + 1 ; var mn = Math . pow ( k , x ) - n ; return mn ; }
function findCount ( arr , n ) { let res = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] % 2 == 0 ) && ( arr [ j ] % 2 == 1 ) ) { res ++ ; } return res ; }
function findCount ( arr , n ) { let count = 0 , ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count ++ ; else ans = ans + count ; } return ans ; }
function product ( arr ) { let occurrence = Math . pow ( 2 , arr . length - 1 ) ; let product = 1 ; for ( let i = 0 ; i < arr . length ; i ++ ) { product *= Math . pow ( arr [ i ] , occurrence ) ; } return product ; }
function calcCount ( arr , n , k ) { var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( k % arr [ i ] == 0 ) count ++ ; } return count ; }
function modifiedBinaryPattern ( n ) { for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= i ; j ++ ) { if ( j == 1 j == i ) document . write ( 1 ) ; else document . write ( 0 ) ; } document . write ( " " ) ; } }
function maxPointCount ( arr , k , size ) { let curr_points = 0 ; let max_points = 0 ; for ( let i = 0 ; i < K ; i ++ ) curr_points += arr [ i ] ; max_points = curr_points ; let j = size - 1 ; for ( let i = K - 1 ; i >= 0 ; i -- ) { curr_points = curr_points + arr [ j ] - arr [ i ] ; max_points = Math . max ( curr_points , max_points ) ; j -- ; } return max_points ; }
function count ( N , B ) { var sum = 0 ; for ( var i = 1 ; i <= N ; i ++ ) { sum += ( B - 1 ) * Math . pow ( B , i - 1 ) ; } return sum ; }
function SmallestPerfectSquare ( N ) { let X = 1e9 ; let ans ; for ( let i = 1 ; i < Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { let a = i ; let b = N / i ; if ( ( b - a != 0 ) && ( ( b - a ) % 2 == 0 ) ) { X = Math . min ( X , ( b - a ) / 2 ) ; } } } if ( X != 1e9 ) ans = X * X ; else ans = - 1 ; return ans ; }
function CountWays ( N , M ) { var count = 1 ; count = Math . pow ( 3 , M + N ) ; count *= Math . pow ( 2 , M * N ) ; return count ; }
function minCost ( arr , n , circumference ) { arr . sort ( ( a , b ) => a - b ) var arr2 = Array ( 2 * n ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { arr2 [ i ] = arr [ i ] ; arr2 [ i + n ] = arr [ i ] + circumference ; } var res = 1000000000 ; for ( var i = 0 ; i < n ; i ++ ) res = Math . min ( res , arr2 [ i + ( n - 1 ) ] - arr2 [ i ] ) ; return res ; }
function CountWays ( n ) { let ans = Math . floor ( ( n - 1 ) / 2 ) ; return ans ; }
function findNthNumber ( N ) { let arr = new Array ( N + 1 ) ; let q = [ ] ; for ( let i = 1 ; i <= 9 ; i ++ ) q . push ( i ) ; for ( let i = 1 ; i <= N ; i ++ ) { arr [ i ] = q [ 0 ] ; q . shift ( ) ; if ( arr [ i ] % 10 != 0 ) q . push ( arr [ i ] * 10 + arr [ i ] % 10 - 1 ) ; q . push ( arr [ i ] * 10 + arr [ i ] % 10 ) ; if ( arr [ i ] % 10 != 9 ) q . push ( arr [ i ] * 10 + arr [ i ] % 10 + 1 ) ; } document . write ( arr [ N ] + " " ) ; }
function findUniqueElements ( arr , N , K ) { var s = new Set ( arr ) ; var arr_sum = arr . reduce ( ( a , b ) => a + b , 0 ) ; var set_sum = 0 ; s . forEach ( function ( value ) { set_sum += value ; } ) document . write ( Math . floor ( ( K * set_sum - arr_sum ) / ( K - 1 ) ) ) ; }
function stepRequired ( N ) { let cnt = 0 ; while ( N ) { N = N & ( N - 1 ) ; cnt ++ ; } return cnt ; }
function findEquation ( a , b , c ) { let X = ( a + b + c ) ; let Y = ( a * b ) + ( b * c ) + ( c * a ) ; let Z = a * b * c ; document . write ( " " + X + " " + Y + " " + Z + " " ) ; }
function numPrimeArrangements ( n ) { var prime = Array . from ( { length : n + 1 } , ( _ , i ) => true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( var i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( prime [ i ] ) for ( factor = 2 ; factor * i <= n ; factor ++ ) prime [ factor * i ] = false ; } var primeIndices = 0 ; for ( var i = 1 ; i <= n ; i ++ ) if ( prime [ i ] ) primeIndices ++ ; var mod = parseInt ( ( 1e9 + 7 ) ) , res = 1 ; for ( var i = 1 ; i <= primeIndices ; i ++ ) res = ( ( 1 * res * i ) % mod ) ; for ( var i = 1 ; i <= ( n - primeIndices ) ; i ++ ) res = ( ( 1 * res * i ) % mod ) ; return res ; }
function PrintReverseOrder ( N ) { for ( let i = N ; i > 0 ; i -- ) document . write ( i + " " ) ; }
function PrintReverseOrder ( N ) { if ( N <= 0 ) { return ; } else { document . write ( N + " " ) ; PrintReverseOrder ( N - 1 ) ; } }
function XOROfElements ( arr , n ) { var FirstHalfXOR = 0 ; var SecondHalfXOR = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( i < parseInt ( n / 2 ) ) FirstHalfXOR ^= arr [ i ] ; else SecondHalfXOR ^= arr [ i ] ; } document . write ( FirstHalfXOR + " " + SecondHalfXOR + " " ) ; }
function movesRequired ( a , b ) { let total_moves = a % b ; document . write ( total_moves ) ; }
function Volume_of_cone ( R ) { let V = ( ( 1 / 3.0 ) * ( 3.14 ) * ( 2 * ( R * R ) ) * ( 4 * R ) ) ; return V ; }
function check ( X , K ) { var prime , temp , sqr , i ; prime = 0 ; temp = X ; sqr = parseInt ( Math . sqrt ( X ) ) ; for ( i = 2 ; i <= sqr ; i ++ ) { while ( temp % i == 0 ) { temp = parseInt ( temp / i ) ; prime ++ ; } } if ( temp > 2 ) prime ++ ; if ( X == 1 ) return false ; if ( prime == 1 && K == 1 ) return true ; else if ( prime >= K ) return true ; else return false ; }
function maxAlternatingSum ( arr , n ) { var max_sum = 0 ; var i = 0 ; while ( i < n ) { var current_max = arr [ i ] ; var k = i ; while ( k < n && ( ( arr [ i ] > 0 && arr [ k ] > 0 ) || ( arr [ i ] < 0 && arr [ k ] < 0 ) ) ) { current_max = Math . max ( current_max , arr [ k ] ) ; k += 1 ; } max_sum += current_max ; i = k ; } return max_sum ; }
function CntcontSubs ( a , n ) { let c = 0 , d = 0 , i , sum = 1 , j ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 != 0 a [ i ] % 4 == 0 ) d ++ ; sum = a [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { sum = sum * a [ j ] ; if ( sum % 2 != 0 sum % 4 == 0 ) c ++ ; } sum = 1 ; } return c + d ; }
function countSubsets ( a , n ) { let answer = 0 ; for ( let i = 0 ; i < ( 1 << n ) ; i ++ ) { let bitwiseAND = - 1 ; let bitwiseOR = 0 ; let bitwiseXOR = 0 ; for ( let j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) { if ( bitwiseAND == - 1 ) bitwiseAND = a [ j ] ; else bitwiseAND &= a [ j ] ; bitwiseOR |= a [ j ] ; bitwiseXOR ^= a [ j ] ; } } if ( bitwiseAND == bitwiseOR && bitwiseOR == bitwiseXOR ) answer = ( answer + 1 ) % mod ; } return answer ; }
function count ( arr , N , K ) { let count = 0 , ans = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == K ) { count = count + 1 ; } else { ans += ( count * ( count + 1 ) ) / 2 ; count = 0 ; } } ans = ans + ( count * ( count + 1 ) ) / 2 ; return ans ; }
function convertToDecimal ( N ) { document . write ( " " + N + " " ) ; if ( N != 0 ) { let decimalNumber = 0 ; let i = 0 , remainder ; while ( N != 0 ) { remainder = N % 10 ; N = parseInt ( N / 10 , 10 ) ; decimalNumber += remainder * Math . pow ( 3 , i ) ; ++ i ; } document . write ( decimalNumber + " " ) ; } else document . write ( " " + " " ) ; }
function product ( mat , n ) { let d1 = 0 , d2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { d1 += mat [ i ] [ i ] ; d2 += mat [ i ] [ n - i - 1 ] ; } return d1 * d2 ; }
function getPercentile ( rank , students ) { var result = ( students - rank ) / students * 100 ; return result ; }
function findSum ( arr , n , left , right ) { let k = right - left ; let d = arr [ 1 ] - arr [ 0 ] ; let ans = arr [ left - 1 ] * ( k + 1 ) ; ans = ans + ( d * ( k * ( k + 1 ) ) ) / 2 ; return ans ; }
function get ( x , y , z ) { if ( x > z ) return - 1 ; let val = z - x ; let div = Math . floor ( ( z - x ) / y ) ; let ans = div * y + x ; return ans ; }
function findRealAndImag ( s ) { let l = s . length - 1 ; let i ; if ( s . indexOf ( ' ' ) != - 1 ) { i = s . indexOf ( ' ' ) ; } else { i = s . indexOf ( ' ' ) ; } let real = s . substr ( 0 , i ) ; let imaginary = s . substr ( i + 1 , l - 2 ) ; document . write ( " " + real + " " ) ; document . write ( " " + imaginary ) ; }
function sieve ( ) { position [ 0 ] = - 1 , position [ 1 ] = - 1 ; var pos = 0 ; for ( var i = 2 ; i <= limit ; i ++ ) { if ( position [ i ] == 0 ) { position [ i ] = ++ pos ; for ( var j = i * 2 ; j <= limit ; j += i ) position [ j ] = - 1 ; } } }
function rangeSum ( l , r ) { var a = 1 , b = 9 , res = 0 ; for ( var i = 1 ; i <= 10 ; i ++ ) { var L = Math . max ( l , a ) ; var R = Math . min ( r , b ) ; if ( L <= R ) { var sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += Math . pow ( i , i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; }
function TrialDivision ( N ) { let i = 2 ; let k = Math . ceil ( Math . sqrt ( N ) ) ; while ( i <= k ) { if ( N % i == 0 ) return 0 ; i += 1 ; } return 1 ; }
function pairs ( n ) { let c = new Array ( 10 ) ; for ( var i = 0 ; i < c . length ; i ++ ) { c [ i ] = new Array ( 2 ) ; } for ( var i = 0 ; i < c . length ; i ++ ) { for ( var j = 0 ; j < c . length ; j ++ ) { c [ i ] [ j ] = 0 ; } } let tmp = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( i >= tmp * 10 ) tmp *= 10 ; c [ Math . floor ( i / tmp ) ] [ i % 10 ] ++ ; } let ans = 0 ; for ( let i = 1 ; i < 10 ; i ++ ) for ( let j = 1 ; j < 10 ; j ++ ) ans += c [ i ] [ j ] * c [ j ] [ i ] ; return ans ; }
function countWays ( A , B , C ) { var minAddA = Math . max ( 0 , parseInt ( ( C + B - A + 2 ) / 2 ) ) ; var count_ways = Math . max ( C - minAddA + 1 , 0 ) ; return count_ways ; }
function printSeries ( N ) { let ith_term = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { ith_term = i % 2 == 0 ? 2 * i * i + 1 : 2 * i * i - 1 ; document . write ( ith_term + " " ) ; } }
function findNthTerm ( N ) { let ans = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { ans = ans + 6 ; } else { ans = ans + 2 ; } } document . write ( ans + " " ) ; }
function printSeriesSum ( N ) { let sum = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { if ( i & 1 ) { sum += i / ( i + 1 ) ; } else { sum -= i / ( i + 1 ) ; } } document . write ( sum . toFixed ( 6 ) ) ; }
function printSeriesSum ( N ) { let sum = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { sum += Math . pow ( i , i - 1 ) ; } document . write ( sum ) ; }
function printSumSeries ( N ) { let sum = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { sum += 1.0 / ( 2 * i - 1 ) ; } document . write ( sum . toFixed ( 5 ) ) ; }
function printSeriesSum ( N ) { let sum = 0 ; let a = 1 ; let cnt = 0 ; let flag = true ; sum += a ; while ( cnt < N ) { let nextElement ; if ( flag ) { nextElement = a * 2 ; sum += nextElement ; flag = ! flag ; } else { nextElement = a * 3 / 2 ; sum += nextElement ; flag = ! flag ; } a = nextElement ; cnt ++ ; } document . write ( sum ) ; }
function sumBaseB ( a , b , base_var ) { let len_a , len_b ; len_a = a . length ; len_b = b . length ; let sum , s ; s = " " ; sum = " " ; let diff ; diff = Math . abs ( len_a - len_b ) ; for ( let i = 1 ; i <= diff ; i ++ ) s += " " ; if ( len_a < len_b ) a = s + a ; else b = s + b ; let curr , carry = 0 ; for ( let i = Math . max ( len_a , len_b ) - 1 ; i > - 1 ; i -- ) { curr = carry + ( a [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) + ( b [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; carry = parseInt ( curr / base_var , 10 ) ; curr = curr % base_var ; sum = String . fromCharCode ( curr + ' ' . charCodeAt ( ) ) + sum ; } if ( carry > 0 ) sum = String . fromCharCode ( carry + ' ' . charCodeAt ( ) ) + sum ; return sum ; }
function quadrant ( s ) { var l = s . length ; var i = 0 ; if ( s . indexOf ( " " ) != - 1 ) { i = s . indexOf ( " " ) ; } else { i = s . indexOf ( " " ) ; } var real = s . substr ( 0 , i ) ; var imaginary = s . substr ( i + 1 , l - 1 ) ; var x = parseInt ( real ) ; var y = parseInt ( imaginary ) ; if ( x > 0 && y > 0 ) document . write ( " " ) ; else if ( x < 0 && y > 0 ) document . write ( " " ) ; else if ( x < 0 && y < 0 ) document . write ( " " ) ; else if ( x > 0 && y < 0 ) document . write ( " " ) ; else if ( x == 0 && y > 0 ) document . write ( " " + " " ) ; else if ( x == 0 && y < 0 ) document . write ( " " + " " ) ; else if ( y == 0 && x < 0 ) document . write ( " " + " " ) ; else if ( y == 0 && x > 0 ) document . write ( " " + " " ) ; else document . write ( " " ) ; }
function countdigits ( n , k ) { if ( n == 0 ) return 0 ; var digit = n % 10 ; if ( digit == k ) return 1 + countdigits ( n / 10 , k ) ; return countdigits ( n / 10 , k ) ; }
function product_subarrays ( arr , n ) { let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { for ( let k = i ; k <= j ; k ++ ) product *= arr [ k ] ; } } document . write ( product + " " ) ; }
function product_subarrays ( arr , n ) { var res = 1 ; for ( var i = 0 ; i < n ; i ++ ) { var product = 1 ; for ( var j = i ; j < n ; j ++ ) { product = product * arr [ j ] ; res *= product ; } } document . write ( res ) ; }
function printModulus ( X , Y ) { var n = Math . max ( X , Y ) ; for ( var i = 1 ; i <= n ; i ++ ) { if ( X % i == Y % i ) document . write ( i + " " ) ; } }
function printModulus ( X , Y ) { var d = Math . abs ( X - Y ) ; var i = 1 ; while ( i * i <= d ) { if ( d % i == 0 ) { document . write ( i + " " ) ; if ( d / i != i ) document . write ( parseInt ( d / i ) + " " ) ; } i ++ ; } }
function difSquare ( n ) { if ( n % 4 != 2 ) { return true ; } return false ; } var n = 45 ; if ( difSquare ( n ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function makearrayequal ( arr , n ) { var x = 0 ; for ( i = 0 ; i < n ; i ++ ) { x += ( arr [ i ] & 1 ) ; } document . write ( Math . min ( x , n - x ) ) ; }
function countDigit ( n ) { let temp = n , count = 0 ; while ( temp != 0 ) { let d = temp % 10 ; temp = Math . floor ( temp / 10 ) ; if ( d == 2 d == 3 d == 5 d == 7 ) count ++ ; } return count ; }
function check ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) count ++ ; } if ( count & 1 ) return " " ; else return " " ; }
function check ( Arr , n , M , K ) { let flag = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( Arr [ i ] == 0 ) flag = 1 ; } if ( K % 2 != 0 && flag == 0 ) return " " ; else return " " ; }
function even_or_odd ( N ) { var len = N . length ; if ( N [ len - 1 ] == ' ' N [ len - 1 ] == ' ' N [ len - 1 ] == ' ' N [ len - 1 ] == ' ' ) return ( " " ) ; else return ( " " ) ; }
function checkPalindrome ( num ) { let str = num . toString ( ) ; let l = 0 , r = str . length - 1 ; while ( l < r ) { if ( str [ l ] != str [ r ] ) { document . write ( " " ) ; return ; } l ++ ; r -- ; } document . write ( " " ) ; return ; }
function isDivisible ( n ) { let d ; while ( Math . floor ( n / 100 ) > 0 ) { d = n % 10 ; n = Math . floor ( n / 10 ) ; n = Math . abs ( n - ( d * 14 ) ) ; } return ( n % 47 == 0 ) ; }
function even_or_odd ( N ) { let len = N . length ; if ( N [ len - 1 ] == ' ' N [ len - 1 ] == ' ' N [ len - 1 ] == ' ' N [ len - 1 ] == ' ' N [ len - 1 ] == ' ' N [ len - 1 ] == ' ' N [ len - 1 ] == ' ' N [ len - 1 ] == ' ' ) return ( " " ) ; else return ( " " ) ; }
function isDivisible ( n ) { let d ; while ( Math . floor ( n / 100 ) > 0 ) { d = n % 10 ; n = Math . floor ( n / 10 ) ; n = Math . abs ( n - ( d * 3 ) ) ; } return ( n % 31 == 0 ) ; }
function isDivisible ( n ) { let d ; while ( parseInt ( n / 100 ) > 0 ) { d = n % 10 ; n = parseInt ( n / 10 ) n = Math . abs ( n + ( d * 13 ) ) ; } return ( n % 43 == 0 ) ; }
function print ( n , k ) { document . write ( k + " " ) ; for ( var i = 2 ; i <= n ; i ++ ) { var x = Math . pow ( k , i ) - Math . pow ( k , i - 1 ) ; document . write ( x + " " ) ; } }
function isDivisible ( n ) { let d ; while ( Math . floor ( n / 100 ) <= 0 ) { d = n % 10 ; n = Math . floor ( n / 10 ) ; n = Math . abs ( n - ( d * 7 ) ) ; } return ( n % 71 == 0 ) ; }
function countDigit ( n ) { var prime = Array ( 10 ) . fill ( false ) ; prime [ 2 ] = prime [ 3 ] = true ; prime [ 5 ] = prime [ 7 ] = true ; var temp = n , count = 0 ; while ( temp != 0 ) { var d = temp % 10 ; temp = parseInt ( temp / 10 ) ; if ( d > 0 && n % d == 0 && prime [ d ] ) count ++ ; } return count ; }
function findNumbers ( N ) { let i = 1 ; while ( i <= N ) { document . write ( ( i * i * i ) + " " ) ; i ++ ; } }
function properDivisorSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; ++ i ) { for ( let j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } sum = sum - i ; } return sum ; }
function properDivisorSum ( n ) { var sum = 0 ; for ( var i = 1 ; i <= n ; ++ i ) sum += parseInt ( n / i ) * i ; return sum - n * ( ( n + 1 ) / 2 ) ; }
function maxValue ( a ) { var c = a . toString ( 2 ) ; var b = " " ; for ( var i = 0 ; i < c . length ; i ++ ) { if ( ( c [ i ] - ' ' ) == 1 ) b += ' ' ; else b += ' ' ; } document . write ( parseInt ( b , 2 ) ) ; }
function getmax ( arr , n , x ) { let s = 0 ; for ( let i = 0 ; i < n ; i ++ ) { s = s + arr [ i ] ; } document . write ( Math . min ( s , x ) ) ; }
function canBeReduced ( x , y ) { var maxi = Math . max ( x , y ) ; var mini = Math . min ( x , y ) ; if ( ( ( x + y ) % 3 ) == 0 && maxi <= 2 * mini ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; }
function findDigits ( n , b ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; var M_PI = 3.141592 ; var M_E = 2.7182 ; var x = ( ( n * Math . log10 ( n / M_E ) + Math . log10 ( 2 * M_PI * n ) / 2.0 ) ) / ( Math . log10 ( b ) ) ; return Math . floor ( x ) + 1 ; }
function findSum ( N , k ) { let sum = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { sum += Math . pow ( i , k ) ; } return sum ; }
function findDistinctOddSum ( n , k ) { if ( ( k * k ) <= n && ( n + k ) % 2 == 0 ) { var val = 1 ; var sum = 0 ; for ( var i = 1 ; i < k ; i ++ ) { document . write ( val + " " ) ; sum += val ; val += 2 ; } document . write ( n - sum ) ; } else document . write ( " " ) ; }
function countPairsWithProdK ( arr , n , k ) { var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] == k ) count ++ ; } return count ; }
function countCubes ( a , b ) { for ( let i = a ; i <= b ; i ++ ) for ( let j = 1 ; j * j * j <= i ; j ++ ) if ( j * j * j == i ) cnt ++ ; return cnt ; }
function countCubes ( a , b ) { return ( Math . floor ( b ** ( 1. / 3. ) ) - Math . ceil ( a ** ( 1. / 3. ) ) + 1 ) }
function perfectCube ( N ) { let cube_root ; cube_root = Math . round ( Math . cbrt ( N ) ) ; if ( ( cube_root * cube_root * cube_root ) == N ) { document . write ( " " ) ; return ; } else { document . write ( " " ) ; return ; } }
function check ( arr , N ) { let even = 0 ; let odd = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & 1 ) { odd ++ ; } else { even ++ ; } } if ( even == N odd == N ) document . write ( " " ) ; else document . write ( " " ) ; }
function findSum ( N ) { var sum = ( N ) * ( N + 1 ) / 2 ; var r = ( Math . log ( N ) / Math . log ( 2 ) ) + 1 ; var expSum = ( Math . pow ( 2 , r ) ) - 1 ; document . write ( sum - expSum ) ; }
function findNumbers ( n , b ) { var even = 0 , odd = 0 ; if ( b % 2 == 0 ) { even = Math . pow ( b , n ) - 2 ; odd = Math . pow ( b , n ) - 1 ; } else { even = Math . pow ( b , n ) - 1 ; odd = Math . pow ( b , n ) - 2 ; } document . write ( " " + even + " " ) ; document . write ( " " + odd ) ; }
function isPerfectSquare ( x ) { var sr = Math . round ( Math . sqrt ( x ) ) ; if ( sr * sr == x ) document . write ( " " ) ; else document . write ( " " ) ; }
function printPairs ( arr , n ) { for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j < n ; j ++ ) { document . write ( " " + arr [ i ] + " " + arr [ j ] + " " + " " ) ; } } }
function countSteps ( n ) { let steps = 0 ; while ( n ) { let largest = Math . floor ( Math . cbrt ( n ) ) ; n -= ( largest * largest * largest ) ; steps ++ ; } return steps ; }
function product ( N ) { let ans = 1 ; let val = Math . pow ( 2 , N - 1 ) ; for ( let i = 1 ; i <= N ; i ++ ) { ans *= Math . pow ( i , val ) ; } return ans ; }
function nearest ( n ) { var prevSquare = parseInt ( Math . sqrt ( n ) ) ; var nextSquare = prevSquare + 1 ; prevSquare = prevSquare * prevSquare ; nextSquare = nextSquare * nextSquare ; if ( ( n - prevSquare ) < ( nextSquare - n ) ) { ans = parseInt ( ( prevSquare - n ) ) ; } else ans = parseInt ( ( nextSquare - n ) ) ; return ans ; }
function mul_table ( N , i ) { if ( i > 10 ) return ; document . write ( N + " " + i + " " + N * i + " " ) ; return mul_table ( N , i + 1 ) ; }
function printValueOfPi ( N ) { let pi = 2 * Math . acos ( 0.0 ) ; document . write ( pi . toFixed ( 4 ) ) ; }
function summation ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 1 ) sum += ( i * i ) ; else sum -= ( i * i ) ; } return sum ; }
function summation ( n ) { var abs_sum = n * ( n + 1 ) / 2 ; var sign = n + 1 % 2 == 0 ? 1 : - 1 ; var result_sum = sign * abs_sum ; return result_sum ; }
function countPairs ( n ) { let count = 0 ; for ( let x = 1 ; x < n ; x ++ ) { for ( let y = x + 1 ; y <= n ; y ++ ) { if ( ( y + x ) % ( y ^ x ) == 0 ) count ++ ; } } return count ; }
function precompute ( ) { var fact = 1 ; for ( var i = 1 ; i <= 18 ; i ++ ) { fact = fact * i ; m [ fact ] = i ; } }
function sumOfParts ( arr , N ) { var sum_part1 = 0 , sum_part2 = 0 , sum_part3 = 0 , sum_part4 = 0 ; var totalsum = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { if ( i + j < N - 1 ) { if ( i < j && i != j && i + j > 0 ) sum_part1 += arr [ i ] [ j ] ; else if ( i != j ) sum_part2 += arr [ i ] [ j ] ; } else { if ( i > j && i + j != N - 1 ) sum_part3 += arr [ i ] [ j ] ; else { if ( i + j != N - 1 && i != j ) sum_part4 += arr [ i ] [ j ] ; } } } } totalsum = sum_part1 + sum_part2 + sum_part3 + sum_part4 ; return totalsum ; }
function noOfCards ( n ) { return parseInt ( n * ( 3 * n + 1 ) / 2 ) ; }
function subsetSum ( arr , n , i , sum , count ) { if ( i == n ) { if ( sum == 0 ) { count ++ ; } return count ; } count = subsetSum ( arr , n , i + 1 , sum - arr [ i ] , count ) ; count = subsetSum ( arr , n , i + 1 , sum , count ) ; return count ; }
function log_a_to_base_b ( a , b ) { return parseInt ( Math . log ( a ) / Math . log ( b ) ) ; }
function log_a_to_base_b ( a , b ) { var rslt = ( a > b - 1 ) ? 1 + log_a_to_base_b ( parseInt ( a / b ) , b ) : 0 ; return rslt ; }
function count ( N ) { var sum = 0 ; for ( var i = 1 ; i <= N ; i ++ ) { sum += 7 * Math . pow ( 8 , i - 1 ) ; } return sum ; }
function factors ( n , i ) { if ( i <= n ) { if ( n % i == 0 ) { document . write ( i + " " ) ; } factors ( n , i + 1 ) ; } }
function maxValue ( n ) { return n ; }
function solve ( n ) { var ans = ( n * n / 4 ) ; return ans ; }
function printMultiples ( N ) { for ( let i = 1 ; i <= N ; i ++ ) { for ( let j = 1 ; j <= i ; j ++ ) { document . write ( ( i * j ) + " " ) ; } document . write ( " " ) ; } }
function SubarraysWithSumS ( n , k , s ) { for ( let i = 0 ; i < k ; i ++ ) document . write ( s + " " ) ; for ( let i = k ; i < n ; i ++ ) document . write ( s + 1 + " " ) ; }
function pay ( n ) { let cuts = parseInt ( Math . log ( n ) / Math . log ( 2 ) ) ; return cuts ; }
function pairCount ( n , m ) { var cnt = 0 , b , a ; for ( b = 0 ; b <= Math . sqrt ( m ) ; b ++ ) { a = m - b * b ; if ( a * a + b == n ) { cnt ++ ; } } return cnt ; }
function sumOfDigit ( n , b ) { var unitDigit , sum = 0 ; while ( n > 0 ) { unitDigit = n % b ; sum += unitDigit ; n = parseInt ( n / b ) ; } return sum ; }
function nthDigit ( a , n , b ) { for ( var i = 1 ; i < n ; i ++ ) a = parseInt ( a / b ) ; return a % b ; }
function squareRoot ( n , l ) { let x = n ; let root ; let count = 0 ; while ( true ) { count ++ ; root = 0.5 * ( x + ( n / x ) ) ; if ( Math . abs ( root - x ) < l ) break ; x = root ; } return root . toFixed ( 4 ) ; }
function printmaxSubseq ( arr , n ) { let i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i + 1 ] ) document . write ( arr [ i ] + " " ) ; else document . write ( arr [ i ] + " " ) ; } }
function countNumber ( N , S ) { let countElements = 0 ; let currSum = 0 ; while ( currSum <= S ) { currSum += N ; N -- ; countElements ++ ; } return countElements ; }
function usingBinarySearch ( start , end , N , S ) { if ( start >= end ) return start ; let mid = start + ( end - start ) / 2 ; let totalSum = ( N * ( N + 1 ) ) / 2 ; let midSum = ( mid * ( mid + 1 ) ) / 2 ; if ( ( totalSum - midSum ) <= S ) { return usingBinarySearch ( start , mid , N , S ) ; } return usingBinarySearch ( mid + 1 , end , N , S ) ; }
function min_index ( p , n ) { let ans = 0 ; let mini = Number . MAX_SAFE_INTEGER ; for ( let i = 0 ; i < n ; i ++ ) { if ( p [ i ] <= mini ) mini = p [ i ] ; if ( mini == p [ i ] ) ans ++ ; } return ans ; }
function equal_xor_sum ( arr , n ) { let Sum = 0 ; let Xor = 0 ; for ( let i = 0 ; i < n ; i ++ ) { Sum = Sum + arr [ i ] ; Xor = Xor ^ arr [ i ] ; } if ( Sum === Xor ) document . write ( " " ) ; else document . write ( " " ) ; }
function findTrailingZeros ( n ) { if ( n & 1 ) return 0 ; else { let ans = 0 ; n = parseInt ( n / 2 ) ; while ( n ) { ans += parseInt ( n / 5 ) ; n = parseInt ( n / 5 ) ; } return ans ; } }
function maxGCD ( N , K ) { var minSum = ( K * ( K + 1 ) ) / 2 ; if ( N < minSum ) return - 1 ; var i = parseInt ( Math . sqrt ( N ) ) ; var res = 1 ; while ( i >= 1 ) { if ( N % i == 0 ) { if ( i >= minSum ) res = Math . max ( res , N / i ) ; if ( N / i >= minSum ) res = Math . max ( res , i ) ; } i -- ; } return res ; }
function maxHeight ( h1 , h2 ) { return ( ( h1 * h2 ) - h1 - h2 ) ; }
function checkZeroArray ( arr , n ) { let sum = 0 , maximum = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { sum = sum + arr [ i ] ; maximum = Math . max ( maximum , arr [ i ] ) ; } if ( sum % 2 == 0 && maximum <= sum / 2 ) return true ; return false ; }
function getSum ( n ) { var sum = 0 ; if ( n == 1 ) { sum = 45.0 ; } else { sum = ( 99.0 / 2.0 ) * Math . pow ( 10 , n - 1 ) * Math . pow ( 10 , parseInt ( ( n - 1 ) / 2 ) ) ; } return sum ; }
function cntSubSeq ( arr , n ) { let pos_count = 0 ; let neg_count = 0 ; let result ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos_count ++ ; if ( arr [ i ] < 0 ) neg_count ++ ; } result = Math . pow ( 2 , pos_count ) ; if ( neg_count > 0 ) result *= Math . pow ( 2 , neg_count - 1 ) ; result -= 1 ; return result ; }
function CountTriangles ( n ) { var curr = 1 ; var Tri_count = 0 ; for ( i = 1 ; i <= n ; i ++ ) { Tri_count = ( curr * 3 ) + 2 ; curr = Tri_count ; } return Tri_count ; }
function findNums ( arr , n ) { var S = 0 , X = 0 ; for ( i = 0 ; i < n ; i ++ ) { S += arr [ i ] ; X ^= arr [ i ] ; } document . write ( X + " " + ( X + S ) ) ; }
function solve ( A , B ) { let p = B / 2.0 ; let M = Math . ceil ( 4 * p ) ; let N = 1 ; let O = - 2 * A ; let Q = Math . ceil ( A * A + 4 * p * p ) ; document . write ( M + " " + N + " " + O + " " + Q ) ; }
function findMinDel ( arr , n ) { var min_num = 1000000000 ; for ( var i = 0 ; i < n ; i ++ ) min_num = Math . min ( arr [ i ] , min_num ) ; var cnt = 0 ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] == min_num ) cnt ++ ; return n - cnt ; }
function find_composite_nos ( n ) { document . write ( 9 * n + " " + 8 * n ) ; }
function maxXOR ( arr , n ) { let xorArr = 0 ; for ( let i = 0 ; i < n ; i ++ ) xorArr ^= arr [ i ] ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) ans = Math . max ( ans , ( xorArr ^ arr [ i ] ) ) ; return ans ; }
function minOR ( arr , n ) { if ( n == 1 ) return 0 ; var pre = Array ( n ) , suf = Array ( n ) ; pre [ 0 ] = arr [ 0 ] , suf [ n - 1 ] = arr [ n - 1 ] ; for ( var i = 1 ; i < n ; i ++ ) pre [ i ] = ( pre [ i - 1 ] arr [ i ] ) ; for ( var i = n - 2 ; i >= 0 ; i -- ) suf [ i ] = ( suf [ i + 1 ] arr [ i ] ) ; var ans = Math . min ( pre [ n - 2 ] , suf [ 1 ] ) ; for ( var i = 1 ; i < n - 1 ; i ++ ) ans = Math . min ( ans , ( pre [ i - 1 ] suf [ i + 1 ] ) ) ; return ans ; }
function isPossible ( x , y ) { if ( ( x - y ) == 1 ) return false ; return true ; }
function numSeq ( n ) { return Math . floor ( ( Math . pow ( 3 , n ) + 3 * Math . pow ( - 1 , n ) ) / 4 ) ; }
function perfectSquares ( l , r ) { for ( let i = l ; i <= r ; i ++ ) { if ( Math . sqrt ( i ) == parseInt ( Math . sqrt ( i ) ) ) document . write ( i + " " ) ; } }
function perfectSquares ( l , r ) { let number = Math . ceil ( Math . sqrt ( l ) ) ; let n2 = number * number ; number = ( number * 2 ) + 1 ; while ( ( n2 >= l && n2 <= r ) ) { document . write ( n2 + " " ) ; n2 = n2 + number ; number += 2 ; } }
function xorK ( n , k ) { let res = n ; for ( let i = 1 ; i < k ; i ++ ) res = ( res ^ n ) ; return n ; }
function xorK ( n , k ) { if ( k % 2 == 1 ) return n ; return 0 ; }
function findRemainders ( n ) { var vc = new Set ( ) ; for ( var i = 1 ; i <= Math . ceil ( Math . sqrt ( n ) ) ; i ++ ) vc . add ( parseInt ( n / i ) ) ; for ( var i = parseInt ( n / Math . ceil ( Math . sqrt ( n ) ) ) - 1 ; i >= 0 ; i -- ) vc . add ( i ) ; [ ... vc ] . sort ( ( a , b ) => a - b ) . forEach ( it => { document . write ( it + " " ) ; } ) ; }
function findWinner ( n ) { if ( ( n - 1 ) % 6 == 0 ) { document . write ( " " ) ; } else { document . write ( " " ) ; } }
function countIndices ( arr , n ) { var cnt = 0 ; var max = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( max < arr [ i ] ) { max = arr [ i ] ; cnt ++ ; } } return cnt ; }
function min_changes ( a , n ) { let ans_a = 0 , ans_b = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { if ( a [ i ] == 0 ) ans_a ++ ; else ans_b ++ ; } else { if ( a [ i ] == 0 ) ans_b ++ ; else ans_a ++ ; } } return Math . min ( ans_a , ans_b ) ; }
function ans ( n ) { if ( n == 1 ) document . write ( " " ) ; else document . write ( " " ) ; }
function isPossible ( w , h , x , y ) { if ( x * 2 == w && y * 2 == h ) return true ; return false ; }
function findNthDigit ( p , q , N ) { var res ; while ( N > 0 ) { N -- ; p *= 10 ; res = parseInt ( p / q ) ; p %= q ; } return res ; }
function minsteps ( n , m ) { if ( m > n ) { return - 1 ; } else { return ( ( n + 1 ) / 2 + m - 1 ) / m * m ; } }
function findNum ( x ) { for ( let i = 0 ; i < NumUnsignBits - 1 ; i ++ ) { if ( ( ( x >> i ) & 1 ) != ( ( x >> ( i + 1 ) ) & 1 ) ) { x ^= ( 1 << i ) | ( 1 << ( i + 1 ) ) ; return x ; } } return Number . MIN_VALUE ; }
function findPairs ( arr , n ) { let cntEven = 0 , cntOdd = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) cntEven ++ ; else cntOdd ++ ; } let evenPairs = 0 ; evenPairs += ( ( cntEven * ( cntEven - 1 ) ) / 2 ) ; evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) / 2 ) ; let oddPairs = 0 ; oddPairs += ( cntEven * cntOdd ) ; document . write ( " " + oddPairs + " " ) ; document . write ( " " + evenPairs ) ; }
function cntSquares ( n ) { return n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ; }
function findCnt ( arr , n , k ) { var ret = 0 ; var i = 0 ; while ( i < n ) { var j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; var x = Math . max ( 0 , j - i - k + 1 ) ; ret += ( x * ( x + 1 ) ) / 2 ; i = j ; } return ret ; }
function countElements ( p , n ) { var ans = 0 ; for ( i = 1 ; i < n - 1 ; i ++ ) { if ( p [ i - 1 ] > p [ i ] && p [ i ] > p [ i + 1 ] ) ans ++ ; else if ( p [ i - 1 ] < p [ i ] && p [ i ] < p [ i + 1 ] ) ans ++ ; } return ans ; }
function cntSubArrays ( arr , n , k ) { var res = 0 ; var i = 0 ; while ( i < n ) { var j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; res += Math . max ( j - i - k + 1 , 0 ) ; i = j ; } return res ; }
function maxLen ( arr , n ) { var min_val = arr . reduce ( ( a , b ) => Math . min ( a , b ) ) var freq = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == min_val ) freq ++ ; } return freq ; }
function print_primes_till_N ( N ) { let i , j , flag ; document . write ( " " + N + " " ) ; for ( i = 1 ; i <= N ; i ++ ) { if ( i == 1 i == 0 ) continue ; flag = 1 ; for ( j = 2 ; j <= i / 2 ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } } if ( flag == 1 ) document . write ( i + " " ) ; } }
function last_digit ( X , Y ) { document . write ( X % Y ) ; }
function countSquares ( n ) { return ( Math . pow ( n , 2 ) - ( 2 * n ) + 2 ) ; }
function geometricMean ( n ) { return Math . sqrt ( n ) ; }
function two_sets ( a , n ) { a . sort ( ) ; return a [ n / 2 ] - a [ ( n / 2 ) - 1 ] ; }
function min_moves ( n ) { let ans = Number . MAX_VALUE ; for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { ans = Math . min ( ans , i + parseInt ( n / i , 10 ) - 2 ) ; } } return ans ; }
function findX ( A , B ) { var X = 0 ; var MAX = 32 ; for ( var bit = 0 ; bit < MAX ; bit ++ ) { var tempBit = 1 << bit ; var bitOfX = A & B & tempBit ; X += bitOfX ; } return X ; }
function cntPairs ( a , n ) { var odd = 0 , even = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd ++ ; else if ( ( a [ i ] / 2 ) % 2 == 1 ) even ++ ; } var ans = odd * even + ( odd * ( odd - 1 ) ) / 2 ; return ans ; }
function isPossible ( a , n ) { var cur = a [ 0 ] ; cur -- ; for ( var i = 1 ; i < n ; i ++ ) { var nxt = a [ i ] ; if ( nxt > cur ) nxt -- ; else if ( nxt < cur ) return false ; cur = nxt ; } return true ; }
function min_modulo ( l , r ) { if ( r - l >= MOD ) return 0 ; else { let ans = MOD - 1 ; for ( let i = l ; i <= r ; i ++ ) { for ( let j = i + 1 ; j <= r ; j ++ ) { ans = Math . min ( ans , ( i * j ) % MOD ) ; } } return ans ; } }
function max_element ( a , n ) { let pre = new Array ( n ) ; pre [ 0 ] = a [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) pre [ i ] = Math . max ( pre [ i - 1 ] , a [ i ] ) ; let suf = new Array ( n ) ; suf [ n - 1 ] = a [ n - 1 ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) suf [ i ] = Math . max ( suf [ i + 1 ] , a [ i ] ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( i == 0 ) document . write ( suf [ i + 1 ] + " " ) ; else if ( i == n - 1 ) document . write ( pre [ i - 1 ] + " " ) ; else document . write ( Math . max ( pre [ i - 1 ] , suf [ i + 1 ] ) + " " ) ; } }
function kthNum ( n , k ) { var a = ( n + 1 ) / 2 ; if ( k > a ) return ( 2 * ( k - a ) ) ; return ( 2 * k - 1 ) ; }
function find_numbers ( N ) { if ( N == 1 ) { document . write ( - 1 ) ; } else { document . write ( N + " " + ( N + 1 ) + " " + ( N * ( N + 1 ) ) ) ; } }
function find_k ( a , b ) { if ( ( a + b ) % 2 == 0 ) return ( ( a + b ) / 2 ) ; return - 1 ; }
function isPossible ( a , n ) { let k = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] != i + 1 ) k ++ ; } if ( k <= 2 ) return true ; return false ; }
function odd_digits ( n ) { if ( n < 10 ) return n ; else if ( n / 10 < 10 ) return 9 ; else if ( n / 100 < 10 ) return 9 + n - 99 ; else if ( n / 1000 < 10 ) return 9 + 900 ; else if ( n / 10000 < 10 ) return 909 + n - 9999 ; else return 90909 ; }
function nDigitPalindromes ( n ) { return ( 9 * Math . pow ( 10 , parseInt ( ( n - 1 ) / 2 ) ) ) ; }
function maxLCM ( n ) { return ( n * ( n - 1 ) ) ; }
function cntSubSets ( arr , n ) { var maxVal = arr . reduce ( function ( a , b ) { return Math . max ( a , b ) ; } ) ; var cnt = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == maxVal ) cnt ++ ; } return ( Math . pow ( 2 , cnt ) - 1 ) ; }
function getSum ( n ) { return ( ( n - 1 ) + Math . pow ( n , 2 ) ) ; }
function cntEdges ( n ) { var edges = Math . pow ( 2 , n ) - 2 ; return edges ; }
function count ( n ) { return parseInt ( n * ( 3 * n - 1 ) / 2 ) ; }
function cntCells ( n ) { var cells = Math . pow ( n , 2 ) + Math . pow ( n - 1 , 2 ) ; return cells ; }
function findSum ( n ) { return Math . pow ( n , 3 ) ; }
function count ( n ) { return 15 * Math . pow ( 16 , n - 1 ) ; }
function findNumbers ( n ) { var ans = " " ; for ( var i = 0 ; i < n - 1 ; i ++ ) ans += ' ' ; var even = ans + ' ' ; var odd = ans + ' ' ; document . write ( " " + even + " " ) ; document . write ( " " + odd + " " ) ; }
function nth_term ( a , b , n ) { var z = 0 ; if ( n % 6 == 1 ) z = a ; else if ( n % 6 == 2 ) z = b ; else if ( n % 6 == 3 ) z = b - a ; else if ( n % 6 == 4 ) z = - a ; else if ( n % 6 == 5 ) z = - b ; if ( n % 6 == 0 ) z = - ( b - a ) ; return z ; }
function inProportion ( arr ) { var n = 4 ; arr . sort ( ) ; var extremes = arr [ 0 ] * arr [ 3 ] ; var means = arr [ 1 ] * arr [ 2 ] ; if ( extremes == means ) return true ; return false ; }
function findMissing ( arr , n , k , avg ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } var num = ( avg * ( n + k ) ) - sum ; var den = k ; if ( num % den != 0 ) return - 1 ; return ( Math . floor ( num / den ) ) ; }
function count ( n ) { return parseInt ( ( - 1 + Math . sqrt ( 1 + 8 * n ) ) / 2 ) ; }
function previousFibonacci ( n ) { var a = n / ( ( 1 + Math . sqrt ( 5 ) ) / 2 ) ; return Math . round ( a ) ; }
function findEquation ( a , b ) { var sum = ( a + b ) ; var product = ( a * b ) ; document . write ( " " + sum + " " + product + " " ) ; }
function cal ( n ) { var res = Math . pow ( Math . ceil ( ( Math . pow ( Math . pow ( 10 , ( n - 1 ) ) , 1 / 4 ) ) ) , 4 ) ; return parseInt ( res ) ; }
function count ( n ) { return 3 * n * ( n - 1 ) + 1 ; }
function sum ( m , n ) { return 8 * m * n - 6 * m - 6 * n + 4 ; }
function findNums ( n ) { if ( n <= 11 ) { if ( n == 8 ) document . write ( " " ) ; if ( n == 10 ) document . write ( " " ) ; else document . write ( " " ) ; return ; } if ( n % 2 == 0 ) document . write ( " " + ( n - 4 ) ) ; else document . write ( " " + ( n - 9 ) ) ; }
function count ( n ) { return Math . pow ( 2 , n - 1 ) ; }
function nextFibonacci ( n ) { let a = n * ( 1 + Math . sqrt ( 5 ) ) / 2.0 ; return Math . round ( a ) ; }
function sum ( h ) { return Math . pow ( 2 , h - 1 ) ; }
function product ( a , n ) { var ans = 1 ; var val = Math . pow ( 2 , n - 1 ) ; for ( var i = 0 ; i < n ; i ++ ) { ans *= Math . pow ( a [ i ] , val ) ; } return ans ; }
function oddFib ( n ) { n = ( 3 * n + 1 ) / 2 ; var a = - 1 , b = 1 , c , i ; for ( i = 1 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return c ; }
function sum ( arr , n ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } sum = sum * parseInt ( Math . pow ( 2 , n - 1 ) ) ; return sum ; }
function ways ( n ) { return parseInt ( n / 2 ) ; }
function no_of_ways ( a , n ) { let count_0 = 0 , count_1 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) count_0 ++ ; else count_1 ++ ; } if ( count_1 % 2 == 0 ) return count_0 ; else return count_1 ; }
function maxInt ( str ) { var str2 = " " ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] < ' ' ) { var l = ( ' ' . charCodeAt ( 0 ) - str [ i ] . charCodeAt ( 0 ) ) + ' ' . charCodeAt ( 0 ) ; str2 = str2 . concat ( String . fromCharCode ( l ) ) ; } } if ( str2 [ 0 ] == ' ' ) str2 [ 0 ] = ' ' ; return str2 ; }
function isPossible ( x , y , k ) { var minMoves = Math . abs ( x ) + Math . abs ( y ) ; if ( k >= minMoves && ( k - minMoves ) % 2 == 0 ) return true ; return false ; }
function countPairs ( arr , n ) { var map = { } ; for ( var i = 0 ; i < n ; i ++ ) map [ arr [ i ] - i ] = 0 ; for ( var i = 0 ; i < n ; i ++ ) map [ arr [ i ] - i ] ++ ; var res = 0 ; for ( const [ key , value ] of Object . entries ( map ) ) { var cnt = value ; res += ( cnt * ( cnt - 1 ) ) / 2 ; } return res ; }
function minInt ( str ) { for ( let i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] . charCodeAt ( ) >= ( ' ' ) . charCodeAt ( ) ) { str [ i ] = String . fromCharCode ( ( ( ' ' ) . charCodeAt ( ) - ( str [ i ] ) . charCodeAt ( ) ) + ( ' ' ) . charCodeAt ( ) ) ; } } if ( str [ 0 ] == ' ' ) str [ 0 ] = ' ' ; let s = str . join ( " " ) ; return s ; }
function findMinValue ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return ( parseInt ( sum / n ) + 1 ) ; }
function isFactorion ( n ) { let fact = new Array ( MAX ) ; fact [ 0 ] = 1 ; for ( let i = 1 ; i < MAX ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; let org = n ; let sum = 0 ; while ( n > 0 ) { let d = n % 10 ; sum += fact [ d ] ; n = parseInt ( n / 10 ) ; } if ( sum == org ) return true ; return false ; }
function modFact ( n , m ) { let result = 1 ; for ( let i = 1 ; i <= m ; i ++ ) result = ( result * i ) % MOD ; return result ; }
function minOperations ( n ) { var count = 0 ; var d = 0 ; if ( n == 1 ) return 0 ; while ( n > 9 ) { d = Math . max ( n % 10 , d ) ; n /= 10 ; count += 10 ; } d = Math . max ( d , n - 1 ) ; count += Math . abs ( d ) ; return count - 1 ; }
function findMaximumNum ( str , n , k ) { for ( var i = 0 ; i < n ; i ++ ) { if ( k < 1 ) break ; if ( str [ i ] !== " " ) { str [ i ] = " " ; k -- ; } } return str . join ( " " ) ; }
function Max_Sum ( n ) { return parseInt ( ( n * ( n - 1 ) ) / 2 ) ; }
function isDivisible ( arr , n ) { let lastDigit = arr [ n - 1 ] % 10 ; if ( lastDigit == 0 ) return true ; return false ; }
function calculate_angle ( n , i , j , k ) { var x , y ; if ( i < j ) x = j - i ; else x = j + n - i ; if ( j < k ) y = k - j ; else y = k + n - j ; var ang1 = ( 180 * x ) / n ; var ang2 = ( 180 * y ) / n ; var ans = 180 - ang1 - ang2 ; return ans ; }
function getArray ( n ) { let ans = [ ] ; let p2 = 1 ; while ( n > 0 ) { if ( n & 1 ) ans . push ( p2 ) ; n >>= 1 ; p2 *= 2 ; } return ans ; }
function getIndex ( n , shuffle ) { for ( i = 0 ; i < 3 ; i ++ ) { if ( shuffle [ i ] [ 0 ] == n ) n = shuffle [ i ] [ 1 ] ; else if ( shuffle [ i ] [ 1 ] == n ) n = shuffle [ i ] [ 0 ] ; } document . write ( n ) ; }
function calculate ( n , k , m , power ) { if ( n > m ) { if ( power == 0 ) return 0 ; else return power - 1 ; } else if ( n == m ) return power ; else return calculate ( n * k , k , m , power + 1 ) ; }
function printNumber ( holes ) { if ( holes == 0 ) document . write ( " " ) ; else if ( holes == 1 ) document . write ( " " ) ; else { let rem = 0 , quo = 0 ; rem = holes % 2 ; quo = parseInt ( holes / 2 , 10 ) ; if ( rem == 1 ) document . write ( " " ) ; for ( let i = 0 ; i < quo ; i ++ ) document . write ( " " ) ; } }
function minCost ( arr , n ) { var count_even = 0 ; var count_odd = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count_even ++ ; else count_odd ++ ; } return Math . min ( count_even , count_odd ) ; }
function sumPairs ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] * ( 2 * n ) ) ; } return sum ; }
function minSum ( arr , n ) { let sum = 0 ; arr . sort ( function ( a , b ) { return b - a } ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 4 < 2 ) sum = sum + arr [ i ] ; } return sum ; }
function countTriplets ( A , B , C ) { let ans = 0 ; for ( let i = 1 ; i <= A ; i ++ ) { for ( let j = 1 ; j <= B ; j ++ ) { for ( let k = 1 ; k <= C ; k ++ ) { if ( i * k > j * j ) ans ++ ; } } } return ans ; }
function getSum ( n ) { let sum = 0 ; let k = parseInt ( Math . sqrt ( n ) ) ; for ( let i = 1 ; i <= k ; i ++ ) { sum += Math . floor ( n / i ) ; } sum *= 2 ; sum -= Math . pow ( k , 2 ) ; return sum ; }
function distinctRemainders ( n ) { if ( n % 2 == 0 ) return parseInt ( n / 2 ) ; return ( 1 + parseInt ( n / 2 ) ) ; }
function countUnsetBits ( n ) { var cnt = 0 ; for ( var i = 1 ; i <= n ; i ++ ) { var temp = i ; while ( temp ) { if ( temp % 2 == 0 ) cnt ++ ; temp = parseInt ( temp / 2 ) ; } } return cnt ; }
function graphExists ( a , n ) { while ( 1 ) { a . sort ( ( a , b ) => b - a ) if ( a [ 0 ] == 0 ) return true ; var v = a [ 0 ] ; a . shift ( ) ; if ( v > a . length ) return false ; for ( var i = 0 ; i < v ; i ++ ) { a [ i ] -- ; if ( a [ i ] < 0 ) return false ; } } }
function negProdSubArr ( arr , n ) { let positive = 1 , negative = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; if ( i > 0 ) arr [ i ] *= arr [ i - 1 ] ; if ( arr [ i ] == 1 ) positive ++ ; else negative ++ ; } return ( positive * negative ) ; }
function difference ( n ) { let S , res ; S = Math . floor ( ( n * ( n + 1 ) ) / 2 ) ; res = S * ( S - 1 ) ; return res ; }
function maxItems ( x , y , z ) { let type1 = parseInt ( x / COST ) ; x %= COST ; let type2 = parseInt ( y / COST ) ; y %= COST ; let type3 = parseInt ( z / COST ) ; z %= COST ; let type4 = Math . min ( x , Math . min ( y , z ) ) ; let maxItems = type1 + type2 + type3 + type4 ; return maxItems ; }
function getCount ( l , r , p ) { let cnt = 0 ; let val = p ; while ( 1 ) { let a = parseInt ( r / val ) ; let b = parseInt ( ( l - 1 ) / val ) ; val *= p ; if ( a - b ) { cnt += ( a - b ) ; } else break ; } return cnt ; }
function topsyTurvy ( str ) { for ( var i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] == ' ' str [ i ] == ' ' str [ i ] == ' ' str [ i ] == ' ' str [ i ] == ' ' str [ i ] == ' ' ) { return false ; } } return true ; }
function countSubSeq ( arr , n , k ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { count ++ ; } } return ( Math . pow ( 2 , count ) - 1 ) ; }
function printMatrix ( n , k ) { for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( i == j ) document . write ( k + " " ) ; else document . write ( " " ) ; } document . write ( " " ) ; } }
function possible ( n ) { if ( n > 3 ) { let sum = parseInt ( ( n * ( n + 1 ) ) / 2 ) ; if ( sum % 3 == 0 ) { return true ; } } return false ; }
function findNthNumber ( A , B , N ) { var sum = 0 ; for ( i = 2 ; i < N ; i ++ ) { sum = A + B ; A = B ; B = sum ; } return sum ; }
function checkType ( arr , n ) { if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] <= arr [ n - 1 ] ) document . write ( " " ) ; else if ( arr [ 0 ] >= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) document . write ( " " ) ; else if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) document . write ( " " ) ; else document . write ( " " ) ; }
function cal_IST ( h , r ) { let IST = ( h * r * 1.0 ) / 360 ; let int_IST = parseInt ( IST ) ; let float_IST = Math . ceil ( parseInt ( ( IST - int_IST ) * 60 ) ) ; document . write ( int_IST + " " + float_IST ) ; }
function isPossible ( arr , p , n , m ) { var sum = 0 ; for ( var i = 0 ; i < p ; i ++ ) sum += arr [ i ] ; if ( sum == ( n * m ) ) return true ; return false ; }
function compareVal ( x , y ) { let a = y * Math . log ( x ) ; let b = x * Math . log ( y ) ; if ( a > b ) document . write ( x + " " + y + " " + y + " " + x ) ; else if ( a < b ) document . write ( x + " " + y + " " + y + " " + x ) ; else if ( a == b ) document . write ( x + " " + y + " " + y + " " + x ) ; }
function solve ( n ) { let n_2 = parseInt ( n / 2 , 10 ) ; let den ; den = " " ; while ( n_2 -- > 0 ) den += ' ' ; document . write ( 1 + " " + den + " " ) ; }
function countWays ( n ) { var ans = 1 ; for ( i = 0 ; i < n ; i ++ ) { ans *= 2 ; ans %= MOD ; } return ( ( ans - 1 + MOD ) % MOD ) ; }
function findMin ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; arr . sort ( ) ; let min = arr [ 0 ] ; let max = 0 ; for ( let i = n - 1 ; i >= 1 ; i -- ) { let num = arr [ i ] ; let total = num + min ; let j ; for ( j = 2 ; j <= num ; j ++ ) { if ( num % j == 0 ) { let d = j ; let now = parseInt ( num / d ) + ( min * d ) ; let reduce = total - now ; if ( reduce > max ) max = reduce ; } } } document . write ( sum - max ) ; }
function Survives ( n ) { let i ; for ( let i = 2 ; ; i ++ ) { if ( i > n ) return true ; if ( n % i == 0 ) return false ; n -= parseInt ( n / i ) ; } }
function nthXorFib ( n , a , b ) { if ( n == 0 ) return a ; if ( n == 1 ) return b ; if ( n == 2 ) return ( a ^ b ) ; return nthXorFib ( n % 3 , a , b ) ; }
function find_Solution ( x , n ) { let sum = x , e = 2 , o = 1 , p = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { p += 2 ; sum += ( o / e ) * ( Math . pow ( x , p ) / p ) ; o = o * ( o + 2 ) ; e = e * ( e + 2 ) ; } document . write ( sum . toFixed ( 10 ) ) ; } let x = - 0.5 ; if ( Math . abs ( x ) >= 1 ) { document . write ( " " ) ; }
function totalPay ( totalItems , priceOfOneItem , N , M ) { var freeItems = 0 , actual = 0 ; freeItems = totalItems / ( N + M ) ; actual = totalItems - freeItems ; var amount = actual * priceOfOneItem ; return amount ; }
function findRemainder ( n ) { let l = n % 10 ; while ( n >= 10 ) n /= 10 ; let f = n ; let remainder = f % l ; document . write ( Math . floor ( remainder ) ) ; }
function findBalance ( x , bal ) { if ( x % 10 == 0 && ( x + 1.50 ) <= bal ) { document . write ( ( bal - x - 1.50 ) . toFixed ( 2 ) ) ; } else { document . write ( ( bal ) . toFixed ( 2 ) ) ; } }
function increaseInVol ( l , b , h ) { let percentInc = ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) ; percentInc -= 1 ; percentInc *= 100 ; return percentInc ; }
function countOccurrances ( n , d ) { let count = 0 ; while ( n > 0 ) { count = ( n % 10 == d ) ? count + 1 : count ; n = parseInt ( n / 10 ) ; } return count ; }
function findFactors ( a , b ) { let c ; c = a + b - 1 ; document . write ( c ) ; }
function TwentyoneMatchstick ( arr , N ) { for ( var i = 0 ; i < N ; i += 1 ) { document . write ( 5 - arr [ i ] + " " ) ; } document . write ( " " ) ; }
function proizvolov ( a , b , n ) { return n * n ; }
function compareValues ( a , b , c , d ) { let log1 = Math . log ( a ) / Math . log ( 10 ) ; let num1 = log1 * b ; let log2 = Math . log ( c ) / Math . log ( 10 ) ; let num2 = log2 * d ; if ( num1 > num2 ) document . write ( a + " " + b ) ; else document . write ( c + " " + d ) ; }
function sum ( a , b , c , d , x ) { var ans = ( x * ( a + b ) * ( c - d ) ) / ( ( a * d ) - ( b * c ) ) ; return ans ; }
function min_visible_bottles ( arr , n ) { let m = new Map ( ) ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( m . has ( arr [ i ] ) ) { m . set ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) } else { m . set ( arr [ i ] , 1 ) } ans = Math . max ( ans , m . get ( arr [ i ] ) ) ; } document . write ( " " + " " + ans + " " ) ; }
function printRoots ( a , b , c ) { document . write ( 1 + " " + c / ( a * 1.0 ) ) ; }
function Cells ( n , x ) { let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) if ( x % i == 0 && parseInt ( x / i ) <= n ) ans ++ ; return ans ; }
function Cells ( n , x ) { if ( n <= 0 x <= 0 x > n * n ) return 0 ; var i = 0 , count = 0 ; while ( ++ i * i < x ) if ( x % i == 0 && x <= n * i ) count += 2 ; return i * i == x ? count + 1 : count ; }
function sum ( A , B , R ) { let sum = 0 ; for ( let i = 1 ; i <= R ; i ++ ) { sum = sum + ( i * A ) ; A = A + B ; } return sum ; }
function nambiarNumber ( str , i ) { if ( i >= str . length ) return " " ; let firstDigit = ( str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ; let digitParity = firstDigit % 2 ; let sumDigits = 0 ; while ( i < str . length ) { sumDigits += ( str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ; let sumParity = sumDigits % 2 ; if ( digitParity != sumParity ) { break ; } i ++ ; } return ( " " + sumDigits + nambiarNumber ( str , i + 1 ) ) ; }
function evenNumSubstring ( str ) { let len = str . length ; let count = 0 ; for ( let i = 0 ; i < len ; i ++ ) { let temp = str [ i ] - ' ' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
function Depreciation ( v , r , t ) { var D = v * Math . pow ( ( 1 - r / 100 ) , t ) return D ; }
function nextPowerOfFour ( n ) { let x = Math . floor ( Math . sqrt ( Math . sqrt ( n ) ) ) ; if ( Math . pow ( x , 4 ) == n ) return n ; else { x = x + 1 ; return Math . pow ( x , 4 ) ; } }
function speedOfTrain ( X , Y ) { var Speed ; Speed = 1188 * ( ( X - Y ) / Y ) ; return Speed ; }
function Division ( a , n ) { let maxi = Number . MIN_VALUE , mini = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { maxi = Math . max ( a [ i ] , maxi ) ; mini = Math . min ( a [ i ] , mini ) ; } return parseInt ( maxi / mini ) ; }
function validQuadruple ( arr , n ) { if ( n >= MAX ) return true ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) for ( let l = k + 1 ; l < n ; l ++ ) { if ( ( arr [ i ] ^ arr [ j ] ^ arr [ k ] ^ arr [ l ] ) == 0 ) { return true ; } } return false ; }
function solve ( arr , n ) { var b = Array ( n ) . fill ( 0 ) ; var p = 0 ; for ( i = n - 1 ; i >= 0 ; i -- ) { b [ p ] = arr [ i -- ] ; if ( i >= 0 ) b [ n - 1 - p ] = arr [ i ] ; p ++ ; } return b ; }
function countElements ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; let mean = sum / n ; let cnt = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let newMean = ( sum - arr [ i ] ) / ( n - 1 ) ; if ( newMean == mean ) cnt ++ ; } return cnt ; }
function sum_of_elements ( arr , n ) { var sumfirst = 0 , sumsecond = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( i < parseInt ( n / 2 ) ) { sumfirst += arr [ i ] ; } else { sumsecond += arr [ i ] ; } } document . write ( " " + sumfirst + " " ) ; document . write ( " " + sumsecond + " " ) ; }
function numberOfMinutes ( S , S1 ) { let Min = 0 ; Min = ( ( S - S1 ) / Math . floor ( S ) ) * 60 ; return Min ; }
function FindElement ( a , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum = sum + a [ i ] ; if ( sum % n == 0 ) { let m = parseInt ( sum / n ) ; for ( let i = 0 ; i < n ; i ++ ) if ( a [ i ] == m ) return m ; } return - 1 ; }
function Digits ( n ) { let largest = 0 ; let smallest = 9 ; while ( n ) { let r = n % 10 ; largest = Math . max ( r , largest ) ; smallest = Math . min ( r , smallest ) ; n = parseInt ( n / 10 ) ; } document . write ( largest + " " + smallest ) ; }
function count ( arr , n , k ) { arr . sort ( ) ; var cnt = 0 ; var i = 0 ; var j = 1 ; while ( i < n && j < n ) { if ( j <= i ) j = i + 1 else j = j while ( j < n && ( arr [ j ] - arr [ i ] ) < k ) j += 1 ; cnt += ( n - j ) ; i += 1 ; } return cnt ; }
function countSetBits ( n ) { n ++ ; var powerOf2 = 2 ; var cnt = n / 2 ; while ( powerOf2 <= n ) { var totalPairs = n / powerOf2 ; cnt += ( totalPairs / 2 ) * powerOf2 ; cnt += ( totalPairs % 2 == 1 ) ? ( n % powerOf2 ) : 0 ; powerOf2 <<= 1 ; } return cnt ; }
function decimalToBinary ( n ) { if ( n == 0 ) { document . write ( " " ) ; return ; } decimalToBinary ( parseInt ( n / 2 ) ) ; document . write ( n % 2 ) ; }
function MinimumValue ( x , y ) { if ( x > y ) { var temp = x ; x = y ; y = temp ; } var a = 1 ; var b = x - 1 ; var c = y - b ; document . write ( a + " " + b + " " + c ) ; }
function getHeight ( X ) { return ( 2 * X ) ; }
function volumeRec ( a , b , e , h ) { return ( ( ( b * h ) / 6 ) * ( 2 * a + e ) ) ; }
function firstSetBit ( n ) { let x = n & ( n - 1 ) ; return ( n ^ x ) ; }
function findHours ( a , b , k ) { if ( a >= b ) return - 1 ; let time = k / ( b - a ) ; time = time + 1 ; return time ; }
function minimum_sum ( n , k ) { if ( k % n == 0 ) return 0 ; return 1 ; }
function Vertices ( x , y ) { let val = Math . abs ( x ) + Math . abs ( y ) ; document . write ( val * ( x < 0 ? - 1 : 1 ) + " " ) ; document . write ( " " + val * ( y < 0 ? - 1 : 1 ) ) ; }
function SumofInverseDivisors ( N , Sum ) { let ans = ( Sum ) * 1.0 / ( N ) ; return ans ; }
function getX ( a , b , c , d ) { var X = ( b * c - a * d ) / ( d - c ) ; return X ; }
function countNum ( n ) { if ( n == 1 ) return 1 ; let count = Math . pow ( 2 , n - 2 ) ; return count ; }
function findNumber ( n ) { let num = n - 1 ; num = 2 * Math . pow ( 4 , num ) ; num = Math . floor ( num / 3.0 ) ; return num ; }
function MinRemove ( a , n , k ) { let cnt = new Array ( k ) . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) cnt [ 0 ] ++ ; else if ( cnt [ a [ i ] - 1 ] > 0 ) { cnt [ a [ i ] - 1 ] -- ; cnt [ a [ i ] ] ++ ; } } return n - ( k * cnt [ k - 1 ] ) ; }
function sum_of_4_squares ( n ) { var i , odd = 0 , even = 0 ; for ( i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i % 2 == 0 ) even += i ; else odd += i ; if ( ( n / i ) != i ) { if ( ( n / i ) % 2 == 0 ) even += ( n / i ) ; else odd += ( n / i ) ; } } } if ( n % 2 == 1 ) return 8 * ( odd + even ) ; else return 24 * ( odd ) ; }
function mosaic ( n ) { let i , ans = 1 ; for ( i = 2 ; i <= n ; i ++ ) { if ( n % i == 0 && n > 0 ) { let count = 0 ; while ( n % i == 0 ) { n = parseInt ( n / i , 10 ) ; count ++ ; } ans *= count * i ; } } return ans ; }
function lowerWythoff ( n ) { var phi = ( 1 + Math . sqrt ( 5 ) ) / 2.0 ; for ( var i = 1 ; i <= n ; i ++ ) { var ans = Math . floor ( i * phi ) ; document . write ( ans ) ; if ( i != n ) document . write ( " " ) ; } }
function Total_Ways ( n ) { var fac = 1 ; for ( i = 2 ; i <= n - 1 ; i ++ ) { fac = fac * i ; } return ( fac * 2 ) ; }
function LowerHessenbergMatrix ( n ) { for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 1 ; j <= n ; j ++ ) { if ( j > i + 1 ) document . write ( ' ' + " " ) ; else document . write ( Math . floor ( Math . random ( ) * 10 ) + " " ) ; } document . write ( " " ) ; } }
function UpperHessenbergMatrix ( n ) { for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 1 ; j <= n ; j ++ ) { if ( i > j + 1 ) document . write ( ' ' + " " ) ; else document . write ( Math . floor ( Math . random ( ) * 10 ) + " " ) ; } document . write ( " " ) ; } }
function count ( N ) { var a = 0 ; a = ( N * ( N + 1 ) ) / 2 ; return a ; }
function specialSieve ( n ) { let cnt = 0 ; let prime = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) prime [ i ] = 0 ; for ( let i = 2 ; i <= n ; i ++ ) { if ( ! prime [ i ] ) { cnt ++ ; for ( let j = i ; j <= n ; j += i ) prime [ j ] = cnt ; } } for ( let i = 2 ; i <= n ; i ++ ) document . write ( prime [ i ] + " " ) ; }
function sameLength ( A , B ) { while ( A > 0 && B > 0 ) { A = parseInt ( A / 10 ) ; B = parseInt ( B / 10 ) ; } if ( A == 0 && B == 0 ) return true ; return false ; }
function isValidSeq ( a , n ) { var nodes = n + 2 ; for ( var i = 0 ; i < n ; i ++ ) { if ( a [ i ] < 1 a [ i ] > nodes ) return false ; } return true ; }
function e ( x , n ) { var r ; if ( n == 0 ) return 1 ; r = e ( x , n - 1 ) ; p = p * x ; f = f * n ; return ( r + p / f ) ; }
function numberOfDays ( a , b , n ) { var Days = b * ( n + a ) / ( a + b ) ; return Days ; }
function numberOfMen ( D , m , d ) { var Men = ( m * ( D - d ) ) / d ; return Men ; }
function countX ( a , b ) { if ( b > a ) return 0 ; else if ( a == b ) return - 1 ; else { let x = a - b , ans = 0 ; for ( let i = 1 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) { let d1 = i , d2 = b - 1 ; if ( i * i != x ) d2 = parseInt ( x / i ) ; if ( d1 > b ) ans ++ ; if ( d2 > b ) ans ++ ; } } return ans ; } }
function maxPeople ( p ) { var tmp = 0 , count = 0 ; for ( var i = 1 ; i * i <= p ; i ++ ) { tmp = tmp + ( i * i ) ; if ( tmp <= p ) count ++ ; else break ; } return count ; }
function getAverage ( x , y ) { var avg = ( x & y ) + ( ( x ^ y ) >> 1 ) ; return avg ; }
function solve ( n , k ) { if ( n >= ( k * ( k + 1 ) ) / 2 ) { return true ; } return false ; }
function closetAND ( arr , n , k ) { let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { let X = arr [ i ] ; for ( let j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = Math . min ( ans , Math . abs ( k - X ) ) ; } } return ans ; }
function closetAND ( arr , n , k ) { let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { let X = arr [ i ] ; for ( let j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = Math . min ( ans , Math . abs ( k - X ) ) ; if ( X <= k ) break ; } } return ans ; }
function count_square ( n ) { let count = 0 ; for ( let i = 1 ; i <= n ; i = i + 2 ) { let k = n - i + 1 ; count += ( k * k ) ; } return count ; }
function Rate ( N1 , N2 ) { var rate = ( N2 - N1 ) * 100 / N1 ; return parseInt ( rate ) ; }
function solve ( a , n ) { let ones = 0 , twos = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) ones ++ ; else twos ++ ; } let ind = 0 ; if ( twos > 0 ) a [ ind ++ ] = 2 ; let evenOnes = ( ones % 2 == 0 ) ? true : false ; if ( evenOnes ) ones -= 1 ; for ( let i = 0 ; i < ones ; i ++ ) a [ ind ++ ] = 1 ; for ( let i = 0 ; i < twos - 1 ; i ++ ) a [ ind ++ ] = 2 ; if ( evenOnes ) a [ ind ++ ] = 1 ; for ( let i = 0 ; i < n ; i ++ ) document . write ( a [ i ] + " " ) ; }
function changeTheArray ( arr , n ) { let minEle = Math . min ( ... arr ) ; let maxEle = Math . max ( ... arr ) ; let minOperations = Number . MAX_VALUE ; for ( let num = minEle ; num <= maxEle ; num ++ ) { let operations = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != num ) { operations += ( Math . abs ( num - arr [ i ] ) - 1 ) ; } } minOperations = Math . min ( minOperations , operations ) ; } return minOperations ; }
function maxEdges ( N ) { var edges = 0 ; edges = Math . floor ( ( N * N ) / 4 ) ; return edges ; }
function findX ( A , B ) { let j = 0 , x = 0 ; while ( A != 0 B != 0 ) { if ( ( A % 2 == 1 ) && ( B % 2 == 1 ) ) { x += ( 1 << j ) ; } A >>= 1 ; B >>= 1 ; j += 1 ; } return x ; }
function isSumEqual ( ar , n ) { let sum = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) sum += ar [ i ] ; if ( sum == ar [ n - 1 ] ) return true ; return false ; }
function findIndex ( a , n ) { let res = 0 ; let min_diff = Number . MAX_VALUE ; let prod = new Array ( n ) ; prod [ 0 ] = a [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) prod [ i ] = prod [ i - 1 ] * a [ i ] ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let curr_diff = Math . abs ( parseInt ( prod [ n - 1 ] / prod [ i ] , 10 ) - prod [ i ] ) ; if ( curr_diff < min_diff ) { min_diff = curr_diff ; res = i ; } } return res ; }
function Permutation ( n , k ) { let p = new Array ( n + 1 ) ; for ( let i = 1 ; i <= n ; i ++ ) p [ i ] = i ; for ( let i = 1 ; i < n - k ; i ++ ) p [ i + 1 ] = i ; p [ 1 ] = n - k ; for ( let i = 1 ; i <= n ; i ++ ) document . write ( p [ i ] + " " ) ; }
function count_unique ( s , n ) { if ( s . has ( n ) ) return ; s . add ( n ) ; n += 1 ; while ( n % 10 == 0 ) { n = Math . floor ( n / 10 ) ; } count_unique ( s , n ) ; }
function vertices ( N , A , B ) { var position = 0 ; var minisum = Number . MAX_VALUE ; var sum = 0 ; for ( var i = 1 ; i <= N ; i ++ ) { if ( i == A i == B ) continue ; else { var x = Math . abs ( i - A ) ; var y = Math . abs ( i - B ) ; sum = x + y ; if ( sum < minisum ) { minisum = sum ; position = i ; } } } return position ; }
function getValueOfF ( n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; let cnt = 0 ; while ( n % 2 == 0 ) { cnt += 1 ; n = parseInt ( n / 2 , 10 ) ; } return 2 * cnt ; }
function maxProd ( N ) { if ( N == 0 ) return 1 ; if ( N < 10 ) return N ; return Math . max ( maxProd ( parseInt ( N / 10 ) ) * ( N % 10 ) , maxProd ( parseInt ( N / 10 ) - 1 ) * 9 ) ; }
function oddTriangularNumber ( N ) { return ( N * ( ( 2 * N ) - 1 ) ) ; }
function idstrt ( a1 , b1 , c1 , a2 , b2 , c2 ) { if ( ( a1 / a2 == b1 / b2 ) && ( a1 / a2 == c1 / c2 ) && ( b1 / b2 == c1 / c2 ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; }
function area ( a , b , c ) { var d = Math . abs ( ( c * c ) / ( 2 * a * b ) ) ; return d ; }
function line ( x0 , y0 ) { var c = parseInt ( 2 * y0 * x0 ) ; document . write ( y0 + " " + " " + x0 + " " + c ) ; }
function printOriginalMatrix ( a , b , mat ) { for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) document . write ( Math . min ( a [ i ] , b [ j ] ) + " " ) ; else document . write ( " " + " " ) ; } document . write ( " " ) ; } }
function maxAbsDiff ( arr , n ) { let minEle = arr [ 0 ] ; let maxEle = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { minEle = Math . min ( minEle , arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } return ( maxEle - minEle ) ; }
function isOsiris ( n ) { let a = n % 10 ; let b = parseInt ( ( n / 10 ) % 10 ) ; let c = parseInt ( n / 100 ) ; let digit_sum = a + b + c ; if ( n == ( 2 * ( digit_sum ) * 11 ) ) { return true ; } return false ; }
function isDudeney ( n ) { let cube_rt = parseInt ( Math . round ( ( Math . pow ( n , 1.0 / 3.0 ) ) ) ) ; if ( cube_rt * cube_rt * cube_rt != n ) return false ; let dig_sum = 0 ; let temp = n ; while ( temp > 0 ) { let rem = temp % 10 ; dig_sum += rem ; temp = parseInt ( temp / 10 ) ; } if ( cube_rt != dig_sum ) return false ; return true ; }
function countTriangles ( a , n ) { var cnt = 0 ; var pairs = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { pairs += a [ i ] / 2 ; if ( a [ i ] % 2 == 1 && pairs > 0 ) { cnt += 1 ; pairs -= 1 ; } } cnt += parseInt ( ( 2 * pairs ) / 3 ) ; return cnt ; }
function smallestMultiple ( n ) { if ( n == 1 ) return 5 ; return Math . pow ( 10 , n - 1 ) ; }
function countAnomalies ( arr , n , k ) { var cnt = 0 ; var i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( Math . abs ( arr [ i ] - ( sum - arr [ i ] ) ) > k ) cnt ++ ; return cnt ; }
function getHCF ( x , y ) { var minimum = Math . min ( x , y ) ; if ( x % minimum == 0 && y % minimum == 0 ) return minimum ; for ( var i = minimum / 2 ; i >= 2 ; i -- ) { if ( x % i == 0 && y % i == 0 ) return i ; } return 1 ; }
function findDivisors ( n ) { let div = new Array ( n + 1 ) . fill ( 0 ) ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j * i <= n ; j ++ ) div [ i * j ] ++ ; } for ( let i = 1 ; i <= n ; i ++ ) document . write ( div [ i ] + " " ) ; }
function findMaxCock ( ar ) { if ( R < 3 C < 3 ) return - 1 ; var max_sum = - 1000000000 ; for ( var i = 0 ; i < R - 2 ; i ++ ) { for ( var j = 0 ; j < C - 2 ; j ++ ) { var sum = ( ar [ i ] [ j ] + ar [ i ] [ j + 2 ] ) + ( ar [ i + 1 ] [ j + 1 ] ) + ( ar [ i + 2 ] [ j ] + ar [ i + 2 ] [ j + 1 ] + ar [ i + 2 ] [ j + 2 ] ) ; max_sum = Math . max ( max_sum , sum ) ; } } return max_sum ; }
function segments ( n , p , m ) { var c = new Map ( ) ; c . set ( 0 , 1 ) ; var hs = false ; var sum = 0 ; var ans = 0 ; var r ; for ( r = 0 ; r < n ; r ++ ) { if ( p [ r ] < m ) sum -- ; else if ( p [ r ] > m ) sum ++ ; if ( p [ r ] == m ) hs = true ; if ( hs ) { if ( c . has ( sum ) && c . has ( sum - 1 ) ) ans += c . get ( sum ) + c . get ( sum - 1 ) ; else if ( c . has ( sum ) ) ans += c . get ( sum ) ; else if ( c . has ( sum - 1 ) ) ans += c . get ( sum - 1 ) ; } else { if ( c . has ( sum ) ) c . set ( sum , c . get ( sum ) + 1 ) ; else c . set ( sum , 1 ) ; } } return ans ; }
function ellipsearea ( r ) { if ( r < 0 ) return - 1 ; var a = ( ( 3.14 * r * r ) / 4 ) ; return a ; }
function decideWinner ( a , n ) { var count0 = 0 ; var count1 = 0 ; var count2 = 0 ; var count3 = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 4 == 0 ) count0 ++ ; else if ( a [ i ] % 4 == 1 ) count1 ++ ; else if ( a [ i ] % 4 == 2 ) count2 ++ ; else if ( a [ i ] % 4 == 3 ) count3 ++ ; } if ( count0 % 2 == 0 && count1 % 2 == 0 && count2 % 2 == 0 && count3 == 0 ) return 1 ; else return 2 ; }
function minOperations ( arr , n ) { let mp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) } else { mp . set ( arr [ i ] , 1 ) } } let maxFreq = Number . MIN_SAFE_INTEGER ; for ( let x of mp ) maxFreq = Math . max ( maxFreq , x [ 1 ] ) ; return ( n - maxFreq ) ; }
function CntDivbyX ( arr , n , x ) { let number = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { number = number * 2 + arr [ i ] ; if ( ( number % x == 0 ) ) count += 1 ; } return count ; }
function CntDivbyX ( arr , n , x ) { let number = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { number = ( number * 2 + arr [ i ] ) % x ; if ( number == 0 ) count += 1 ; } return count ; }
function smallestIndex ( a , n ) { let right1 = 0 , right0 = 0 ; let i ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) right1 = i ; else right0 = i ; } return Math . min ( right1 , right0 ) ; }
function countCon ( ar , n ) { let cnt = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) cnt ++ ; } return cnt ; }
function printElements ( arr , n ) { for ( var i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) document . write ( arr [ i ] + " " ) ; } }
function noOfYears ( t1 , n1 , t2 ) { var years = ( ( t2 - 1 ) * n1 / ( t1 - 1 ) ) ; return years ; }
function numLen ( K ) { if ( K % 2 == 0 K % 5 == 0 ) return - 1 ; var number = 0 ; var len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = ( number * 10 + 1 ) % K ; if ( number == 0 ) return len ; } return - 1 ; }
function precomputation ( arr , n ) { for ( var i = 1 ; i < max_Element ; i ++ ) for ( var j = i ; j < max_Element ; j += i ) sum1 [ j ] += i ; for ( var i = 1 ; i < max_Element ; i ++ ) for ( var j = i ; j < max_Element ; j += i ) sum2 [ j ] += ( sum1 [ j ] - i ) * i ; for ( var i = 1 ; i < max_Element ; i ++ ) sum2 [ i ] /= 2 ; for ( var i = 1 ; i < max_Element ; i ++ ) for ( var j = i ; j < max_Element ; j += i ) sum3 [ j ] += i * ( sum2 [ j ] - i * ( sum1 [ j ] - i ) ) ; for ( var i = 1 ; i < max_Element ; i ++ ) sum3 [ i ] /= 3 ; for ( var i = 0 ; i < n ; i ++ ) document . write ( sum3 [ arr [ i ] ] + " " ) ; }
function sum ( k , n ) { let sum = 0 ; for ( let i = 0 ; i <= n ; i ++ ) { let p = 1 ; for ( let j = 0 ; j < n - i ; j ++ ) { p = p * k ; } for ( let j = 0 ; j < i ; j ++ ) { p = p * ( k - 1 ) ; } sum = sum + p ; } return sum ; }
function isPossible ( n ) { var fac = new Array ( 10 ) ; fac [ 0 ] = fac [ 1 ] = 1 ; for ( var i = 2 ; i < 10 ; i ++ ) fac [ i ] = fac [ i - 1 ] * i ; var sum = 0 ; var x = n ; while ( x != 0 ) { sum += fac [ x % 10 ] ; x = parseInt ( x / 10 ) ; } if ( sum % n == 0 ) return true ; return false ; }
function computeXOR ( n ) { switch ( n & 3 ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; case 3 : return 0 ; } }
function countNumbers ( x , n ) { if ( x > n ) return 0 ; return 1 + countNumbers ( x * 10 , n ) + countNumbers ( x * 10 + 1 , n ) ; }
function countSquares ( r , c , m ) { let squares = 0 ; for ( let i = 1 ; i <= 8 ; i ++ ) { for ( let j = 1 ; j <= 8 ; j ++ ) { if ( Math . max ( Math . abs ( i - r ) , Math . abs ( j - c ) ) <= m ) squares ++ ; } } return squares ; }
function countNonIncreasing ( arr , n ) { var cnt = 0 ; var len = 1 ; for ( var i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] <= arr [ i ] ) len ++ ; else { cnt += parseInt ( ( ( len + 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += parseInt ( ( ( len + 1 ) * len ) / 2 ) ; return cnt ; }
function minimumSteps ( n , m , a , b ) { if ( n > m ) return MAXN ; if ( n == m ) return 0 ; return Math . min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) ; }
function wastedWater ( V , M , N ) { let wasted_amt , amt_per_min , time_to_fill ; amt_per_min = M - N ; time_to_fill = V / amt_per_min ; wasted_amt = N * time_to_fill ; return wasted_amt ; }
function sphereSide ( h , r ) { if ( h < 0 && r < 0 ) return - 1 ; var R = ( ( h * r * Math . sqrt ( 2 ) ) / ( h + Math . sqrt ( 2 ) * r ) ) / 2 ; return R ; }
function Loss ( SP , P ) { var loss = 0 ; loss = ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ; document . write ( " " + loss . toFixed ( 3 ) ) ; }
function possibleways ( n ) { if ( n % 2 == 1 ) return 0 ; else if ( n % 4 == 0 ) return n / 4 - 1 ; else return n / 4 ; }
function countSubarrays ( arr , n , K ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { let product = 1 ; for ( let x = i ; x <= j ; x ++ ) product *= arr [ x ] ; if ( product % K == 0 ) count ++ ; } } return count ; }
function Permutations ( n , k ) { var ans = 1 ; if ( k >= 2 ) ans += ( n ) * ( n - 1 ) / 2 ; if ( k >= 3 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * 2 / 6 ; if ( k >= 4 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) * 9 / 24 ; return ans ; }
function findPairCount ( N , K ) { var count = 0 ; var rem = Array . from ( { length : K } , ( _ , i ) => 0 ) ; rem [ 0 ] = parseInt ( N / K ) ; for ( i = 1 ; i < K ; i ++ ) rem [ i ] = parseInt ( ( N - i ) / K + 1 ) ; if ( K % 2 == 0 ) { count += parseInt ( ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ) ; for ( i = 1 ; i < K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; count += ( rem [ K / 2 ] * ( rem [ K / 2 ] - 1 ) ) / 2 ; } else { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( i = 1 ; i <= K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; } return count ; }
function nDigitPerfectSquares ( n ) { document . write ( Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n - 1 ) ) ) , 2 ) + " " ) ; document . write ( Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n ) ) ) - 1 , 2 ) ) ; }
function MaxTraceSub ( mat ) { var max_trace = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { var r = i , s = j , trace = 0 ; while ( r < N && s < N ) { trace += mat [ r ] [ s ] ; r ++ ; s ++ ; max_trace = Math . max ( trace , max_trace ) ; } } } return max_trace ; }
function lastDigit ( a , b ) { var lastDig = ( a [ a . length - 1 ] - ' ' ) * ( b [ b . length - 1 ] - ' ' ) ; document . write ( lastDig % 10 ) ; }
function printPalindrome ( n ) { if ( n == 1 ) { document . write ( " " ) ; document . write ( " " ) ; } else { document . write ( " " + ( parseInt ( Math . pow ( 10 , n - 1 ) ) + 1 ) ) ; document . write ( " " + parseInt ( Math . pow ( 10 , n ) - 1 ) ) ; } }
function countDigits ( a , b ) { var count = 0 ; var p = Math . abs ( parseInt ( a / b ) ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = parseInt ( p / 10 ) ; } return count ; }
function countDigits ( a , b ) { return Math . floor ( ( Math . log ( Math . abs ( a ) ) / Math . log ( 10 ) ) - ( Math . log ( Math . abs ( b ) ) / Math . log ( 10 ) ) ) + 1 ; }
function smallestOdd ( n ) { if ( n == 1 ) return 1 ; return Math . pow ( 10 , n - 1 ) + 1 ; }
function nDigitPerfectCubes ( n ) { document . write ( Math . pow ( Math . ceil ( Math . cbrt ( Math . pow ( 10 , ( n - 1 ) ) ) ) , 3 ) + " " ) ; document . write ( Math . pow ( Math . ceil ( Math . cbrt ( Math . pow ( 10 , ( n ) ) ) ) - 1 , 3 ) ) ; }
function findNumbers ( n ) { var odd = Math . pow ( 10 , n ) - 1 ; var even = odd - 1 ; document . write ( " " + even + " " ) ; document . write ( " " + odd ) ; }
function longestSubArray ( arr , n ) { var isZeroPresent = false ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { isZeroPresent = true ; break ; } } if ( isZeroPresent ) return n ; return 0 ; }
function smallestEven ( n ) { if ( n == 1 ) return 0 ; return Math . pow ( 10 , n - 1 ) ; }
function printBalancedExpression ( a , b , c , d ) { if ( ( ( a == d ) && ( a != 0 ) ) || ( ( a == 0 ) && ( c == 0 ) && ( d == 0 ) ) ) { for ( i = 1 ; i <= a ; i ++ ) document . write ( " " ) ; for ( i = 1 ; i <= c ; i ++ ) document . write ( " " ) ; for ( i = 1 ; i <= d ; i ++ ) document . write ( " " ) ; for ( i = 1 ; i <= b ; i ++ ) document . write ( " " ) ; } else document . write ( - 1 ) ; }
function sumOfSeries ( n ) { let ans = Math . pow ( n % MOD , 2 ) ; return ( ans % MOD ) ; }
function kthOdd ( arr , n , k ) { for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) k -- ; if ( k == 0 ) return arr [ i ] ; } return - 1 ; }
function lastFiveDigits ( n ) { n = ( Math . floor ( n / 10000 ) ) * 10000 + ( Math . floor ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( Math . floor ( n / 10 ) % 10 ) * 10 + Math . floor ( n / 1000 ) % 10 ; let ans = 1 ; for ( let i = 0 ; i < 5 ; i ++ ) { ans *= n ; ans %= 100000 ; } document . write ( ans ) ; }
function maxValue ( n ) { if ( n == 1 ) return 0 ; return ( parseInt ( n * n / 2 ) - 1 ) ; }
function countNumbers ( n ) { if ( n % 2 == 1 ) return 0 ; return ( 9 * Math . pow ( 10 , parseInt ( n / 2 ) - 1 ) ) ; }
function count ( n ) { var cnt = 0 ; var p = 1 ; while ( p <= n ) { cnt ++ ; p *= 2 ; } return cnt ; }
function KthMinValAfterMconcatenate ( A , N , M , K ) { A . sort ( ( a , b ) => a - b ) return ( A [ ( ( K - 1 ) / M ) ] ) ; }
function sumN ( n ) { n = parseInt ( ( n + 1 ) / 2 ) ; return ( n * n ) ; }
function countNumbers ( n ) { return n - parseInt ( n / 2 , 10 ) - parseInt ( n / 3 , 10 ) - parseInt ( n / 5 , 10 ) - parseInt ( n / 7 , 10 ) + parseInt ( n / 6 , 10 ) + parseInt ( n / 10 , 10 ) + parseInt ( n / 14 , 10 ) + parseInt ( n / 15 , 10 ) + parseInt ( n / 21 , 10 ) + parseInt ( n / 35 , 10 ) - parseInt ( n / 30 , 10 ) - parseInt ( n / 42 , 10 ) - parseInt ( n / 70 , 10 ) - parseInt ( n / 105 , 10 ) + parseInt ( n / 210 , 10 ) ; }
function sum ( n ) { if ( n == 1 ) return 1 ; else return ( Math . pow ( n , n ) + sum ( n - 1 ) ) ; }
function findThirdDigit ( n ) { if ( n < 3 ) return 0 ; return n & 1 ? 1 : 6 ; }
function maxPrimes ( n ) { return parseInt ( n / 2 ) ; }
function sum ( n ) { return n * ( n + 1 ) * ( n + 2 ) / 3 ; }
function numbers ( n ) { return ( Math . pow ( 2 , n + 1 ) ) - 2 ; }
function NumberofWays ( n ) { var x = ( 1 * n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) / ( 4 * 3 * 2 * 1 ) ; var y = 1 * n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; return 1 * x * y ; }
function countNumbers ( n ) { return ( n / 2520 ) ; }
function nthTerm ( N ) { let nth = 0 , i ; for ( i = N ; i > 0 ; i -- ) { nth += Math . pow ( i , i ) ; } return nth ; }
function nthTerm ( N ) { let nth = 0 ; nth = parseInt ( ( N * N * ( N + 1 ) ) / 2 ) ; return nth ; }
function kthSmallest ( n , k ) { return ( 2 * k ) ; }
function isSumOfPowersOfTwo ( n ) { if ( n % 2 == 1 ) return false ; else return true ; }
function findNumbers ( n ) { var i = 1 ; while ( i <= n ) { document . write ( ( ( 2 * i ) - 1 ) + " " ) ; i ++ ; } }
function getTime ( u , v , x ) { let speed = u + v ; let time = x / speed ; return time ; }
function getProbability ( a , b , c , d ) { var p = a / b ; var q = c / d ; var ans = p * ( 1 / ( 1 - ( 1 - q ) * ( 1 - p ) ) ) ; return ans ; }
function findMinimum ( x , y ) { let low = 0 , high = y ; while ( low <= high ) { let mid = ( low + high ) >> 1 ; if ( ( mid * 2 + ( y - mid ) ) >= x ) high = mid - 1 ; else low = mid + 1 ; } return low ; }
function getResult ( n ) { let proOdd = 1 ; let proEven = 1 ; let num = n . toString ( ) ; for ( let i = 0 ; i < num . length ; i ++ ) if ( i % 2 == 0 ) proOdd = proOdd * ( num [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; else proEven = proEven * ( num [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; if ( proOdd == proEven ) document . write ( " " ) ; else document . write ( " " ) ; }
function LucasSum ( N ) { var sum = 0 ; var a = 2 , b = 1 , c ; sum += a ; while ( b <= N ) { sum += b ; var c = a + b ; a = b ; b = c ; } return sum ; }
function countNumbers ( l , r ) { return ( parseInt ( r / 6 ) - parseInt ( ( l - 1 ) / 6 ) ) ; }
function countWays ( N ) { let E = parseInt ( ( N * ( N - 1 ) ) / 2 , 10 ) ; if ( N == 1 ) return 0 ; return Math . pow ( 2 , E - 1 ) ; }
function BalanceArray ( A , Q ) { var ANS = [ ] ; var i , sum = 0 ; for ( i = 0 ; i < A . length ; i ++ ) if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; for ( i = 0 ; i < Q . length ; i ++ ) { var index = Q [ i ] [ 0 ] ; var value = Q [ i ] [ 1 ] ; if ( A [ index ] % 2 == 0 ) sum = sum - A [ index ] ; A [ index ] = A [ index ] + value ; if ( A [ index ] % 2 == 0 ) sum = sum + A [ index ] ; ANS . push ( sum ) ; } for ( i = 0 ; i < ANS . length ; i ++ ) document . write ( ANS [ i ] + " " ) ; }
function findMinSum ( arr , n ) { var occ = n - 1 , sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * Math . pow ( 2 , occ ) ; occ -- ; } return sum ; }
function findMinSum ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += arr [ i ] * ( n - i ) ; return sum ; }
function getPosition ( n , m ) { if ( m > ( n / 2 ) ) return ( m - parseInt ( n / 2 ) ) ; return ( m + parseInt ( n / 2 ) ) ; }
function minSum ( arr , n , x ) { var sum = 0 ; var largestDivisible = - 1 , minimum = arr [ 0 ] ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] % x == 0 && largestDivisible < arr [ i ] ) largestDivisible = arr [ i ] ; if ( arr [ i ] < minimum ) minimum = arr [ i ] ; } if ( largestDivisible == - 1 ) return sum ; var sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) ; return Math . min ( sum , sumAfterOperation ) ; }
function submatrixXor ( arr ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { let top_left = ( i + 1 ) * ( j + 1 ) ; let bottom_right = ( n - i ) * ( n - j ) ; if ( ( top_left % 2 == 1 ) && ( bottom_right % 2 == 1 ) ) ans = ( ans ^ arr [ i ] [ j ] ) ; } } return ans ; }
function findAnswer ( X , N ) { return ( N - 1 ) * 9 + X ; }
function count ( N , K , R ) { var sum = 0 ; for ( i = 1 ; i <= N ; i ++ ) { if ( i % K == R ) sum += i ; } return sum ; }
function getCount ( a , b , c ) { let count = 0 ; for ( let i = 1 ; i <= 81 ; i ++ ) { let cr = b * Math . pow ( i , a ) + c ; let tmp = cr ; let sm = 0 ; while ( tmp != 0 ) { sm += tmp % 10 ; tmp = Math . floor ( tmp / 10 ) ; } if ( sm == i && cr < 1e9 ) count ++ ; } return count ; }
function isSpiltPossible ( n , a ) { let sum = 0 , c1 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; if ( a [ i ] == 1 ) { c1 ++ ; } } if ( sum % 2 != 0 ) return false ; if ( ( sum / 2 ) % 2 == 0 ) return true ; if ( c1 > 0 ) return true ; else return false ; }
function matrixSum ( arr ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) { let top_left = ( i + 1 ) * ( j + 1 ) ; let bottom_right = ( n - i ) * ( n - j ) ; sum += ( top_left * bottom_right * arr [ i ] [ j ] ) ; } return sum ; }
function maxAND ( L , R ) { var maximum = L & R ; for ( var i = L ; i < R ; i ++ ) for ( var j = i + 1 ; j <= R ; j ++ ) maximum = Math . max ( maximum , ( i & j ) ) ; return maximum ; }
function maxAND ( L , R ) { if ( L == R ) return L ; else if ( ( R - L ) == 1 ) return ( R & L ) ; else { if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) return ( ( R - 1 ) & R ) ; else return ( ( R - 2 ) & ( R - 1 ) ) ; } }
function checkArray ( arr , n ) { return ( ( arr [ 0 ] % 2 ) > 0 && ( arr [ n - 1 ] % 2 ) > 0 && ( n % 2 ) > 0 ) ? 1 : 0 ; }
function findCount ( arr , n ) { var countOdd = 0 ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 1 ) countOdd ++ ; if ( countOdd % 2 == 0 ) return 1 ; else return 0 ; }
function Cycles ( N ) { var fact = 1 , result = 0 ; result = N - 1 ; var i = result ; while ( i > 0 ) { fact = fact * i ; i -- ; } return fact / 2 ; }
function getMaxNum ( a , b , c ) { if ( b % c == 0 ) return b ; var x = ( parseInt ( b / c ) * c ) ; if ( x >= a && x <= b ) return x ; else return - 1 ; }
function printPermutation ( n , k ) { for ( var i = 1 ; i <= n ; i ++ ) { var x = 2 * i - 1 ; var y = 2 * i ; if ( i <= k ) document . write ( y + " " + x + " " ) ; else document . write ( x + " " + y + " " ) ; } }
function isPossible ( Sx , Sy , Dx , Dy , x , y ) { if ( Math . abs ( Sx - Dx ) % x == 0 && Math . abs ( Sy - Dy ) % y == 0 && ( Math . abs ( Sx - Dx ) / x ) % 2 == ( Math . abs ( Sy - Dy ) / y ) % 2 ) return true ; return false ; }
function getPairs ( a ) { let count = 0 ; for ( let i = 0 ; i < a . length ; i ++ ) { for ( let j = 0 ; j < a . length ; j ++ ) { if ( a [ i ] < a [ j ] ) count ++ ; } } return count ; }
function getPairs ( a ) { let n = a . length ; let count = parseInt ( ( n * ( n - 1 ) ) / 2 , 10 ) ; return count ; }
function calcNodes ( N , I ) { var result = 0 ; result = I * ( N - 1 ) + 1 ; return result ; }
function countRhombi ( h , w ) { let ct = 0 ; for ( let i = 2 ; i <= h ; i += 2 ) for ( let j = 2 ; j <= w ; j += 2 ) ct += ( h - i + 1 ) * ( w - j + 1 ) ; return ct ; }
function maxSum ( N ) { var ans = 0 ; for ( var u = 1 ; u <= N ; u ++ ) { for ( var v = 1 ; v <= N ; v ++ ) { if ( u == v ) continue ; var degreeU = 2 ; if ( u == 1 u == N ) degreeU = 1 ; var degreeV = 2 ; if ( v == 1 v == N ) degreeV = 1 ; ans += ( degreeU * degreeV ) ; } } return ans ; }
function countSquares ( row , column ) { var topLeft = Math . min ( row , column ) - 1 ; var bottomRight = 8 - Math . max ( row , column ) ; var topRight = Math . min ( row , 9 - column ) - 1 ; var bottomLeft = 8 - Math . max ( row , 9 - column ) ; return ( topLeft + topRight + bottomRight + bottomLeft ) ; }
function canTakeDown ( bishopX , bishopY , pawnX , pawnY ) { if ( pawnX - bishopX == pawnY - bishopY ) return true ; else if ( - pawnX + bishopX == pawnY - bishopY ) return true ; else return false ; }
function calculateArea ( x , y ) { var pi = 3.1415926536 ; var arx = pi * x * x ; var ary = pi * y * y ; return arx - ary ; }
function findValues ( a , b ) { if ( ( a - b ) % 2 == 1 ) { document . write ( " " ) ; return ; } document . write ( ( a - b ) / 2 + " " + ( a + b ) / 2 ) ; }
function findPrimeFactors ( ) { for ( let i = 2 ; i < N ; i ++ ) if ( primeFactors [ i ] == 0 ) for ( let j = i ; j < N ; j += i ) primeFactors [ j ] = primeFactors [ parseInt ( j / i , 10 ) ] + 1 ; for ( let i = 1 ; i < N ; i ++ ) primeFactors [ i ] += primeFactors [ i - 1 ] ; }
function minValue ( n , x , y ) { let val = ( y * n ) / 100 ; if ( x >= val ) return 0 ; else return ( Math . ceil ( val ) - x ) ; }
function mixtureConcentration ( n , p ) { var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) res += p [ i ] ; res /= n ; return res ; }
function isPossible ( n , k , arr ) { let sum = arr [ 0 ] ; let maxVal = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { sum += arr [ i ] ; maxVal = Math . max ( maxVal , arr [ i ] ) ; } if ( maxVal > ( sum + k ) / n ) return false ; return true ; }
function countOddSquares ( n , m ) { return Math . pow ( m , 0.5 ) - Math . pow ( n - 1 , 0.5 ) ; }
function Square ( row , column , moves ) { var a = 0 , b = 0 , c = 0 , d = 0 , total = 0 ; a = row - moves ; b = row + moves ; c = column - moves ; d = column + moves ; if ( a < 1 ) a = 1 ; if ( c < 1 ) c = 1 ; if ( b > 8 ) b = 8 ; if ( d > 8 ) d = 8 ; total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; return total ; }
function findNumber ( n , m ) { var num = ( m - 1 ) * 9 + n ; return num ; }
function maxResult ( n , a , b , c ) { let maxVal = 0 ; for ( let i = 0 ; i <= n ; i += a ) for ( let j = 0 ; j <= n - i ; j += b ) { let z = ( n - ( i + j ) ) / c ; if ( Math . floor ( z ) == Math . ceil ( z ) ) { let x = i / a ; let y = j / b ; maxVal = Math . max ( maxVal , x + y + z ) ; } } return maxVal ; }
function make_sequence ( N ) { var arr = Array ( N + 1 ) , sum = 0 ; for ( var i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 1 ) arr [ i ] = 1 ; else arr [ i ] = 2 ; sum += arr [ i ] ; } if ( sum % 2 == 1 ) arr [ 2 ] = 3 ; for ( var i = 1 ; i <= N ; i ++ ) document . write ( arr [ i ] + " " ) ; }
function countOdd ( L , R ) { let N = Math . floor ( ( R - L ) / 2 ) ; if ( R % 2 != 0 L % 2 != 0 ) N += 1 ; return N ; }
function getMinCost ( n , m ) { let cost = ( n - 1 ) * m + ( m - 1 ) * n ; return cost ; }
function binomialCoeff ( n , k ) { if ( k > n ) return 0 ; var res = 1 ; if ( k > n - k ) k = n - k ; for ( var i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
function minAbsDiff ( n ) { let mod = n % 4 ; if ( mod == 0 mod == 3 ) { return 0 ; } return 1 ; }
function generateSequence ( n , g ) { for ( var i = 1 ; i <= n ; i ++ ) { document . write ( i * g + " " ) ; } }
function getMinNum ( a , b , c ) { if ( c < a c > b ) return c ; let x = ( parseInt ( b / c ) * c ) + c ; return x ; }
function isEvenOrOdd ( L , R ) { let oddCount = Math . floor ( ( R - L ) / 2 ) ; if ( R % 2 == 1 L % 2 == 1 ) oddCount ++ ; if ( oddCount % 2 == 0 ) return " " ; else return " " ; }
function countPairs ( n ) { let num = ( parseInt ( n / 2 , 10 ) + 1 ) ; let max = n % num ; let count = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { let val = ( ( n % i ) % j ) % n ; if ( val == max ) count ++ ; } } return count ; }
function countPairs ( n ) { if ( n == 2 ) return 4 ; let num = ( parseInt ( n / 2 , 10 ) + 1 ) ; let max = n % num ; let count = n - max ; return count ; }
function isDivisible ( n ) { temp = n ; sum = 0 ; while ( n ) { k = n % 10 ; sum += k ; n = parseInt ( n / 10 ) ; } if ( temp % sum == 0 ) return " " ; return " " ; }
function getResult ( n ) { let st = ( n ) . toString ( ) ; let sum = 0 ; for ( let i of st . split ( " " ) ) { sum = sum + parseInt ( i ) ; } if ( n % sum == 0 ) return " " ; else return " " ; }
function alter ( x , y ) { while ( true ) { if ( x == 0 y == 0 ) break ; if ( x >= 2 * y ) x = x % ( 2 * y ) ; else if ( y >= 2 * x ) y = y % ( 2 * x ) ; else break ; } document . write ( " " + x + " " + " " + y ) ; }
function secondary_polygon ( Angle ) { var edges_primary = 360 / Angle ; if ( edges_primary >= 6 ) { var edges_max_secondary = edges_primary / 2 ; document . write ( edges_max_secondary + 3 ) ; } else document . write ( " " ) ; }
function isDivisible ( n ) { temp = n ; while ( n ) { k = n % 10 ; if ( temp % k == 0 ) return " " ; n = Math . floor ( n / 10 ) ; } return " " ; }
function getResult ( n ) { let st = n . toString ( ) ; for ( let i = 0 ; i < st . length ; i ++ ) { let d = st [ i ] . charCodeAt ( 0 ) - 48 ; if ( n % d == 0 ) { return " " ; } } return " " ; }
function largestCoprime ( N ) { if ( N == 6 ) return 1 ; else if ( N % 4 == 0 ) return ( N / 2 ) - 1 ; else if ( N % 2 == 0 ) return ( N / 2 ) - 2 ; else return ( ( N - 1 ) / 2 ) ; }
function sum ( n ) { let i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; }
function sum ( n ) { if ( n < 2 ) { return 1 } else { return 1 / n + ( sum ( n - 1 ) ) } }
function nthTermOfTheSeries ( n ) { let nthTerm ; if ( n % 2 == 0 ) nthTerm = Math . pow ( n - 1 , 2 ) + n ; else nthTerm = Math . pow ( n + 1 , 2 ) + n ; return nthTerm ; }
function divide ( a , b ) { for ( let i = 2 ; i <= Math . min ( a , b ) ; i ++ ) { while ( a % i == 0 && b % i == 0 ) { a = a / i ; b = b / i ; } } document . write ( " " + a + " " + b + " " ) ; }
function minAbsDiff ( n ) { let left = 1 << ( Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) ) ; let right = left * 2 ; return Math . min ( ( n - left ) , ( right - n ) ) ; }
function find_probability ( p , q , r , s ) { var t = ( 1 - p / q ) * ( 1 - r / s ) ; var ans = ( p / q ) / ( 1 - t ) ; return ans ; }
function Nthterm ( n ) { let numerator = Math . pow ( n , 2 ) - 1 ; let denomenator = 2 * n - 3 ; document . write ( numerator + " " + denomenator ) ; }
function sumArray ( arr , n ) { let leftSum = new Array ( n ) ; let rightSum = new Array ( n ) ; let Sum = new Array ( n ) ; let i = 0 , j = 0 ; leftSum [ 0 ] = 0 ; rightSum [ n - 1 ] = 0 ; for ( i = 1 ; i < n ; i ++ ) leftSum [ i ] = arr [ i - 1 ] + leftSum [ i - 1 ] ; for ( j = n - 2 ; j >= 0 ; j -- ) rightSum [ j ] = arr [ j + 1 ] + rightSum [ j + 1 ] ; for ( i = 0 ; i < n ; i ++ ) Sum [ i ] = leftSum [ i ] + rightSum [ i ] ; for ( i = 0 ; i < n ; i ++ ) document . write ( Sum [ i ] + " " ) ; }
function calSum ( n ) { return ( n * ( 2 * n * n * n + 12 * n * n + 25 * n + 21 ) ) / 2 ; }
function getElements ( a , arr , n ) { let elements = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { elements [ i ] = 0 ; } elements [ 0 ] = a ; for ( let i = 0 ; i < n ; i ++ ) { elements [ i + 1 ] = arr [ i ] ^ elements [ i ] ; } for ( let i = 0 ; i < n + 1 ; i ++ ) document . write ( elements [ i ] + " " ) ; }
function nthterm ( n ) { let An = ( Math . pow ( 1 , n ) + Math . pow ( 2 , n ) ) * Math . pow ( 3 , n ) ; return An ; }
function minimumX ( n , k ) { let mini = Number . MAX_VALUE ; for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { let fir = i ; let sec = parseInt ( n / i , 10 ) ; let num1 = fir * k + sec ; let res = parseInt ( ( num1 / k ) , 10 ) * ( num1 % k ) ; if ( res == n ) mini = Math . min ( num1 , mini ) ; let num2 = sec * k + fir ; res = parseInt ( ( num2 / k ) , 10 ) * ( num2 % k ) ; if ( res == n ) mini = Math . min ( num2 , mini ) ; } } return mini ; }
function minimumX ( n , k ) { let ans = Number . MAX_VALUE ; for ( let rem = k - 1 ; rem > 0 ; rem -- ) { if ( n % rem == 0 ) ans = Math . min ( ans , rem + ( n / rem ) * k ) ; } return ans ; }
function getSum ( arr , p ) { return arr . length ; }
function getHermiteNumber ( n ) { if ( n == 0 ) return 1 ; else if ( n == 1 ) return 1 ; else return - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ; }
function find ( n ) { let b = n ; let a = b * ( n - 1 ) ; if ( a * b > n && a / b < n ) { document . write ( " " + a + " " + b ) ; } else document . write ( - 1 ) ; }
function SquareCube ( N ) { let cnt = 0 , i = 1 ; while ( Math . floor ( Math . pow ( i , 6 ) ) <= N ) { ++ cnt ; ++ i ; } return cnt ; }
function getSum ( n , d ) { let sum = 0 ; while ( d <= n ) { sum += d ; d += 10 ; } return sum ; }
function term ( n ) { let d = 2 ; let a1 = 0 ; An = a1 + ( n - 1 ) * d ; return Math . pow ( An , 3 ) ; }
function printThreeParts ( N ) { if ( N % 3 == 0 ) document . write ( " " + ( N - 2 ) ) ; else document . write ( " " + ( N - 3 ) ) ; }
function countDigitsToBeRemoved ( N , K ) { var s = N . toString ( ) ; var res = 0 ; var f_zero = 0 ; for ( var i = s . length - 1 ; i >= 0 ; i -- ) { if ( K === 0 ) return res ; if ( s [ i ] === " " ) { f_zero = 1 ; K -- ; } else res ++ ; } if ( K === 0 ) return res ; else if ( f_zero === 1 ) return s . length - 1 ; return - 1 ; }
function findSum ( n ) { let sum = 0 ; for ( x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; }
function check ( arr , x , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let y = Math . sqrt ( arr [ i ] ) ; if ( Math . floor ( y ) == Math . ceil ( y ) ) { sum += arr [ i ] ; } } if ( sum % x == 0 ) return true ; else return false ; } let arr = [ 2 , 3 , 4 , 9 , 10 ] ; let n = arr . length ; let x = 13 ; if ( check ( arr , x , n ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function findSum ( n , a , b ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( i % a == 0 i % b == 0 ) sum += i ; return sum ; }
function findLargestDivisor ( n ) { for ( let i = 2 ; i < Math . sqrt ( n ) + 1 ; i ++ ) { while ( n % ( i * i ) == 0 ) { n = n / i ; } } return n ; }
function findMedian ( a , n ) { a . sort ( ) ; if ( n % 2 != 0 ) return a [ parseInt ( n / 2 ) ] ; return ( a [ parseInt ( ( n - 1 ) / 2 ) ] + a [ parseInt ( n / 2 ) ] ) / 2.0 ; }
function printAMeans ( A , B , N ) { let d = ( B - A ) / ( N + 1 ) ; for ( let i = 1 ; i <= N ; i ++ ) document . write ( ( A + i * d ) + " " ) ; }
function getFinalElement ( n ) { let finalNum ; for ( finalNum = 2 ; finalNum * 2 <= n ; finalNum *= 2 ) ; return finalNum ; }
function isTriPerfect ( n ) { let sum = 1 + n ; let i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) { if ( parseInt ( n / i , 10 ) == i ) sum = sum + i ; else sum = sum + i + parseInt ( n / i , 10 ) ; } i += 1 ; } if ( sum == 3 * n & n != 1 ) return true ; else return false ; }
function MinimumMaximumPairs ( n , m ) { var max_pairs = parseInt ( ( ( n - m + 1 ) * ( n - m ) ) / 2 ) ; var min_pairs = m * parseInt ( ( ( ( n - m ) / m + 1 ) * ( ( n - m ) / m ) ) / 2 ) + parseInt ( Math . ceil ( ( ( n - m ) / ( m ) ) ) ) * ( ( n - m ) % m ) ; document . write ( " " + min_pairs + " " ) ; document . write ( " " + max_pairs ) ; }
function sum ( N , X , Y ) { var S1 , S2 , S3 ; S1 = ( parseInt ( N / X ) ) * ( 2 * X + parseInt ( N / X - 1 ) * X ) / 2 ; S2 = ( parseInt ( N / Y ) ) * ( 2 * Y + parseInt ( N / Y - 1 ) * Y ) / 2 ; S3 = ( parseInt ( N / ( X * Y ) ) ) * ( 2 * ( X * Y ) + parseInt ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2 ; return S1 + S2 - S3 ; }
function findTwoThreePrime ( l , r ) { if ( l == 1 ) l ++ ; let count = 0 ; for ( let i = l ; i <= r ; i ++ ) { let num = i ; while ( num % 2 == 0 ) num = parseInt ( num / 2 , 10 ) ; while ( num % 3 == 0 ) num = parseInt ( num / 3 , 10 ) ; if ( num == 1 ) count ++ ; } return count ; }
function countIntervals ( arr , V , N ) { let min = Number . MAX_VALUE , max = Number . MIN_VALUE ; let li , ri ; let freq = new Array ( MAX_VAL ) ; freq . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { li = arr [ i ] [ 0 ] ; freq [ li ] = freq [ li ] + 1 ; ri = arr [ i ] [ 1 ] ; freq [ ri + 1 ] = freq [ ri + 1 ] - 1 ; if ( li < min ) min = li ; if ( ri > max ) max = ri ; } for ( let i = min ; i <= max ; i ++ ) freq [ i ] = freq [ i ] + freq [ i - 1 ] ; return freq [ V ] ; }
function findNth ( N ) { let b = 14 ; for ( let i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) b = b * 2 ; else b = b - 8 ; } return b ; }
function addNDigits ( a , b , n ) { let num = a ; for ( let i = 0 ; i <= 9 ; i ++ ) { let tmp = a * 10 + i ; if ( tmp % b == 0 ) { a = tmp ; break ; } } if ( num == a ) return - 1 ; for ( let j = 0 ; j < n - 1 ; j ++ ) a *= 10 ; return a ; }
function countMoves ( n ) { let ct = 0 ; for ( let i = 1 ; i <= n ; i ++ ) ct += i * ( n - i ) ; ct += n ; return ct ; }
function Triplets ( n ) { var ans = 0 ; for ( let i = 1 ; i <= n ; ++ i ) { for ( let j = i ; j <= n ; ++ j ) { var x = i * i + j * j ; var y = parseInt ( Math . sqrt ( x ) ) ; if ( y * y == x && y <= n ) ++ ans ; } } return ans ; }
function Valid ( a , b , c ) { if ( a + b + c == 180 && a != 0 && b != 0 && c != 0 ) return 1 ; else return 0 ; } var a = 60 , b = 40 , c = 80 ; if ( ( Valid ( a , b , c ) ) == 1 ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function countNumbers ( N ) { return ( Math . pow ( 10 , N ) - 1 ) - ( Math . pow ( 10 , N ) - Math . pow ( 8 , N ) ) / 2 ; }
function calcDeterminant ( arr ) { let determinant = 0 ; for ( let i = 0 ; i < N ; i ++ ) { determinant += Math . pow ( arr [ i ] , 3 ) ; } determinant -= 3 * arr [ 0 ] * arr [ 1 ] * arr [ 2 ] ; return determinant ; }
function minimumMoves ( k , l , r ) { let count = r - l + 1 ; if ( count % k == 0 ) return 0 ; return ( k - ( count % k ) ) ; }
function Alphabet_N_Pattern ( N ) { var index , side_index , size ; var Right = 1 , Left = 1 , Diagonal = 2 ; for ( index = 0 ; index < N ; index ++ ) { document . write ( Left ++ ) ; for ( side_index = 0 ; side_index < 2 * index ; side_index ++ ) document . write ( " " ) ; if ( index != 0 && index != N - 1 ) document . write ( Diagonal ++ ) ; else document . write ( " " ) ; for ( side_index = 0 ; side_index < 2 * ( N - index - 1 ) ; side_index ++ ) document . write ( " " ) ; document . write ( Right ++ ) ; document . write ( " " ) ; } }
function prletGroups ( n ) { let x = 1 ; let y = n * n ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= n / 2 ; j ++ ) { document . write ( " " + x + " " + y + " " ) ; x ++ ; y -- ; } document . write ( " " ) ; } }
function findEle ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] == sum - arr [ i ] ) return arr [ i ] ; return - 1 ; }
function CheckArray ( arr , n ) { let prod = 1 ; for ( let i = 0 ; i < n ; ++ i ) prod *= arr [ i ] ; for ( let i = 0 ; i < n ; ++ i ) if ( arr [ i ] == prod / arr [ i ] ) return true ; return false ; }
function breakEvenPoint ( exp , S , M ) { var earn = S - M ; var res = Math . ceil ( exp / earn ) ; return res ; }
function otherNumber ( A , Lcm , Hcf ) { return ( Lcm * Hcf ) / A ; }
function sum ( a , b ) { var sum = 0 ; for ( var i = 1 ; i <= Math . min ( a , b ) ; i ++ ) if ( a % i == 0 && b % i == 0 ) sum += i ; return sum ; }
function minimumNumbers ( n , s ) { if ( s % n ) return parseInt ( s / n ) + 1 ; else return parseInt ( s / n ) ; }
function contiguousPerfectSquare ( arr , n ) { var a ; var b ; var current_length = 0 ; var max_length = 0 ; for ( var i = 0 ; i < n ; i ++ ) { b = ( Math . sqrt ( arr [ i ] ) ) ; a = parseInt ( b ) ; if ( a == b ) current_length ++ ; else current_length = 0 ; max_length = Math . max ( max_length , current_length ) ; } return max_length ; }
function checkNumber ( N ) { let temp = N ; while ( temp > 0 ) { if ( temp % 1000 == 144 ) temp = parseInt ( temp / 1000 , 10 ) ; else if ( temp % 100 == 14 ) temp = parseInt ( temp / 100 , 10 ) ; else if ( temp % 10 == 1 ) temp = parseInt ( temp / 10 , 10 ) ; else { return " " ; } } return " " ; }
function countPairs ( n ) { let count = 0 ; for ( let x = 1 ; x < n ; x ++ ) { for ( let y = x + 1 ; y <= n ; y ++ ) { if ( ( y * x ) % ( y + x ) == 0 ) count ++ ; } } return count ; }
function getSum ( a , n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; ++ i ) { sum += ( i / Math . pow ( a , i ) ) ; } return sum ; }
function calcFunction ( n , r ) { var finalDenominator = 1 ; var mx = Math . max ( r , n - r ) ; for ( var i = mx + 1 ; i <= n ; i ++ ) { var denominator = Math . pow ( i , i ) ; var numerator = Math . pow ( i - mx , i - mx ) ; finalDenominator = ( finalDenominator * denominator ) / numerator ; } return finalDenominator ; }
function getResult ( n ) { if ( ( n & 1 ) > 0 ) return 1 ; return - 1 ; }
function findAandB ( N ) { let val = N * N - 4.0 * N ; if ( val < 0 ) { document . write ( " " ) ; return ; } let a = ( N + Math . sqrt ( val ) ) / 2.0 ; let b = ( N - Math . sqrt ( val ) ) / 2.0 ; document . write ( " " + a . toFixed ( 4 ) + " " ) ; document . write ( " " + b . toFixed ( 5 ) ) ; }
function minOperations ( A , n ) { if ( ( n & 1 ) > 0 ) return - 1 ; let zeros = 0 , consZeros = 0 , ones = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( A [ i ] == 0 ) zeros ++ ; else ones ++ ; if ( i + 1 < n ) { if ( A [ i ] == 0 && A [ i + 1 ] == 0 ) consZeros ++ ; } } if ( A [ 0 ] == A [ n - 1 ] && A [ 0 ] == 0 ) consZeros ++ ; if ( zeros == ones ) return consZeros ; else return - 1 ; }
function findNum ( div , rem , N ) { var num = rem [ N - 1 ] ; for ( var i = N - 2 ; i >= 0 ; i -- ) { num = num * div [ i ] + rem [ i ] ; } return num ; }
function profitLoss ( N , M ) { if ( N == M ) document . write ( " " ) ; else { var result = 0.0 ; result = ( Math . abs ( N - M ) ) / M ; if ( N - M < 0 ) document . write ( " " + result . toFixed ( 6 ) * 100 + " " ) ; else document . write ( " " + result . toFixed ( 6 ) * 100 + " " ) ; } }
function countPieces ( N ) { return 2 * N ; }
function SellingPrice ( CP , PP ) { var P_decimal = 1 + ( PP / 100 ) ; var res = P_decimal * CP ; return res . toFixed ( 1 ) ; }
function lastCoordinate ( n , a , b ) { return ( parseInt ( n + 1 ) / 2 ) * a - parseInt ( n / 2 ) * b ; }
function findNum ( N , K ) { var rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; }
function minimum ( n ) { let product = 1 ; for ( let i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { while ( n % i == 0 ) n = n / i ; product = product * i ; } } if ( n >= 2 ) product = product * n ; return product ; }
function countDigit ( n ) { let temp = n ; let sum = 0 ; let product = 1 ; while ( temp != 0 ) { let d = temp % 10 ; temp = parseInt ( temp / 10 ) ; if ( d > 0 && n % d == 0 ) { sum += d ; product *= d ; } } document . write ( " " + sum ) ; document . write ( " " + product ) ; }
function findNum ( N , K ) { var rem = N % K ; if ( rem == 0 ) return N ; else return N - rem ; }
function countNumbers ( N ) { return parseInt ( Math . sqrt ( N ) , 10 ) - 1 ; }
function countOrderedPairs ( N ) { var count_pairs = 0 ; for ( var i = 1 ; i <= Math . sqrt ( N - 1 ) ; ++ i ) { for ( var j = i ; j * i < N ; ++ j ) ++ count_pairs ; } count_pairs *= 2 ; count_pairs -= parseInt ( Math . sqrt ( N - 1 ) ) ; return count_pairs ; }
function pairwiseDifference ( arr , n ) { var diff ; for ( i = 0 ; i < n - 1 ; i ++ ) { diff = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; document . write ( diff + " " ) ; } }
function GIF ( n ) { return Math . floor ( n ) ; }
function smallestDivisor ( n ) { if ( n % 2 == 0 ) return 2 ; for ( var i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) return i ; } return n ; }
function countRabbits ( Heads , Legs ) { var count = 0 ; count = ( Legs ) - 2 * ( Heads ) ; count = count / 2 ; return count ; }
function SumDivisible ( n , k ) { let sum = 0 , position = 1 ; while ( n > 0 ) { if ( position % 2 == 1 ) sum += n % 10 ; n = Math . floor ( n / 10 ) ; position ++ ; } if ( sum % k == 0 ) return true ; return false ; }
function isTriangleExists ( a , b , c ) { if ( a != 0 && b != 0 && c != 0 && ( a + b + c ) == 180 ) if ( ( a + b ) >= c || ( b + c ) >= a || ( a + c ) >= b ) return " " ; else return " " ; else return " " ; }
function maxSum ( a , n ) { var maxAnd = Math . max ( ... a ) ; var maxOR = 0 ; for ( var i = 0 ; i < n ; i ++ ) { maxOR |= a [ i ] ; } document . write ( ( maxAnd + maxOR ) ) ; }
function calculateSum ( n ) { return 2 * ( Math . pow ( n , 6 ) + 15 * Math . pow ( n , 4 ) + 15 * Math . pow ( n , 2 ) + 1 ) ; }
function countBits ( n ) { var count = 0 ; while ( n ) { count ++ ; n >>= 1 ; } return count ; }
function Check_is_possible ( l , r , k ) { var count = 0 ; for ( i = l ; i <= r ; i ++ ) { if ( i % k == 0 ) { count ++ ; } } return ( count > 1 ) ; } var l = 4 , r = 12 ; var k = 5 ; if ( Check_is_possible ( l , r , k ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function Check_is_possible ( l , r , k ) { var div_count = ( r / k ) - ( l / k ) ; if ( l % k == 0 ) { div_count ++ ; } return ( div_count > 1 ) ; } var l = 30 , r = 70 , k = 10 ; if ( Check_is_possible ( l , r , k ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function sum ( N ) { var S1 , S2 , S3 ; S1 = ( ( ( N / 2 ) ) * parseInt ( 2 * 2 + parseInt ( N / 2 - 1 ) * 2 ) / 2 ) ; S2 = ( parseInt ( parseInt ( N / 7 ) ) * ( 2 * 7 + parseInt ( N / 7 - 1 ) * 7 ) / 2 ) ; S3 = ( parseInt ( parseInt ( N / 14 ) ) * ( 2 * 14 + parseInt ( N / 14 - 1 ) * 14 ) / 2 ) ; return S1 + S2 - S3 ; }
function nth_group ( n ) { return n * ( 2 * Math . pow ( n , 2 ) + 1 ) ; }
function printPossible ( a , b , c ) { if ( ( a + b + c ) % 2 != 0 a + b < c ) document . write ( " " ) ; else document . write ( " " ) ; }
function Nth_Term ( n ) { return ( 2 * Math . pow ( n , 3 ) - 3 * Math . pow ( n , 2 ) + n + 6 ) / 6 ; }
function Sum_upto_nth_Term ( n ) { let r = n * ( n + 1 ) * ( 2 * n + 7 ) / 3 ; document . write ( r ) ; }
function Nth_Term ( n ) { return ( 3 * Math . pow ( n , 2 ) - n + 2 ) / ( 2 ) ; }
function countPermutations ( N , B ) { var x = Math . pow ( B , N ) ; var y = Math . pow ( B , N - 1 ) ; document . write ( x - y ) ; }
function EqualNumbers ( a , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += a [ i ] ; if ( sum % n ) return n - 1 ; return n ; }
function printNumberWithDR ( k , d ) { if ( d == 0 && k != 1 ) document . write ( " " ) ; else { document . write ( d ) ; k -- ; while ( k -- > 0 ) document . write ( " " ) ; } }
function findSteps ( n , m , a ) { var cur = 1 ; var steps = 0 ; for ( var i = 0 ; i < m ; i ++ ) { if ( a [ i ] >= cur ) steps += ( a [ i ] - cur ) ; else steps += ( n - cur + a [ i ] ) ; cur = a [ i ] ; } return steps ; }
function PossibleValues ( b , x , n ) { let leastdivisible = ( Math . floor ( b / x ) + 1 ) * x ; let flag = 1 ; while ( leastdivisible <= n ) { if ( leastdivisible - b >= 1 ) { document . write ( leastdivisible - b + " " ) ; leastdivisible += x ; flag = 0 ; } else break ; } if ( flag > 0 ) document . write ( - 1 + " " ) ; }
function sum_of_series ( n ) { var result = 0 ; for ( i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) result = result - parseInt ( Math . pow ( i , 2 ) ) ; else result = result + parseInt ( Math . pow ( i , 2 ) ) ; } return result ; }
function sum_of_series ( n ) { let result = 0 ; if ( n % 2 == 0 ) { result = - ( n * ( n + 1 ) ) / 2 ; } else { result = ( n * ( n + 1 ) ) / 2 ; } return result ; }
function numberOfDistinct ( n ) { var ans = 0 ; for ( i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { ans ++ ; if ( ( n / i ) != i ) ans ++ ; } } return ans ; }
function calculateAlternateSum ( n ) { if ( n <= 0 ) return 0 ; var fibo = Array ( n + 1 ) . fill ( 0 ) ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; var sum = Math . pow ( fibo [ 0 ] , 2 ) + Math . pow ( fibo [ 1 ] , 2 ) ; for ( i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum -= fibo [ i ] ; else sum += fibo [ i ] ; } return sum ; }
function getValue ( n ) { let i = 0 , k = 1 ; while ( i < n ) { i = i + k ; k = k * 2 ; } return parseInt ( k / 2 ) ; }
function nthKyneaNumber ( n ) { n = ( 1 << n ) + 1 ; n = n * n ; n = n - 2 ; return n ; }
function nthKyneaNumber ( n ) { return ( ( 1 << ( 2 * n ) ) + ( 1 << ( n + 1 ) ) - 1 ) ; }
function get_last_two_digit ( N ) { if ( N <= 10 ) { let ans = 0 , fac = 1 ; for ( let i = 1 ; i <= N ; i ++ ) { fac = fac * i ; ans += fac ; } return ans % 100 ; } return 13 ; }
function isProductEven ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) == 0 ) return true ; return false ; }
function get_unit_digit ( N ) { if ( N == 0 N == 1 ) return 1 ; else if ( N == 2 ) return 3 ; else if ( N == 3 ) return 9 ; return 3 ; }
function calculateSquareSum ( n ) { if ( n <= 0 ) return 0 ; var fibo = Array ( n + 1 ) . fill ( 0 ) ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; var sum = ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) ; for ( i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += ( fibo [ i ] * fibo [ i ] ) ; } return sum ; }
function sieve ( ) { let arr = new Array ( N + 1 ) ; for ( let i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = 0 ; } arr [ 0 ] = 1 ; arr [ 1 ] = 1 ; for ( let i = 2 ; i <= Math . ceil ( Math . sqrt ( N ) + 1 ) ; i ++ ) if ( arr [ i ] == 0 ) for ( let j = i * i ; j <= N ; j += i ) arr [ j ] = 1 ; let runningPrimeSum = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] == 0 ) runningPrimeSum += i ; dp [ i ] = runningPrimeSum ; } }
function fnMod ( n ) { var rem = n % 4 ; if ( rem == 0 rem == 3 ) return 0 ; else if ( rem == 1 rem == 2 ) return 1 ; return 0 ; }
function MinimumMoves ( a , n , x ) { var ans = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= a [ i - 1 ] ) { var p = parseInt ( ( a [ i - 1 ] - a [ i ] ) / x + 1 ) ; ans += p ; a [ i ] += p * x ; } } return ans ; }
function printLines ( n , k ) { for ( i = 0 ; i < n ; i ++ ) { document . write ( k * ( 6 * i + 1 ) + " " + k * ( 6 * i + 2 ) + " " + k * ( 6 * i + 3 ) + " " + k * ( 6 * i + 5 ) + " " ) ; } }
function NumberOfRectangles ( n , m ) { if ( n % 2 == 0 ) return ( n / 2 ) * m ; else if ( m % 2 == 0 ) return ( m / 2 ) * n ; return ( n * m - 1 ) / 2 ; }
function NumberOfSolutions ( x , y , z , n ) { var ans = 0 ; for ( var i = 0 ; i <= x ; i ++ ) { for ( var j = 0 ; j <= y ; j ++ ) { var temp = n - i - j ; if ( temp >= 0 ) { temp = Math . min ( temp , z ) ; ans += temp + 1 ; } } } return ans ; }
function findkth ( n , k ) { let v1 = [ ] ; let v2 = [ ] ; for ( let i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { v1 . push ( i ) ; if ( i != Math . sqrt ( n ) ) v2 . push ( n / i ) ; } } v2 . reverse ( ) ; if ( k > ( v1 . length + v2 . length ) ) document . write ( " " ) ; else { if ( k <= v1 . length ) document . write ( v1 [ k - 1 ] ) ; else document . write ( v2 [ k - v1 . length - 1 ] ) ; } }
function NumberOfSolutions ( a , b , c , d ) { let ans = 0 ; for ( let i = a ; i <= b ; i ++ ) if ( d >= Math . max ( c , i + 1 ) ) ans += d - Math . max ( c , i + 1 ) + 1 ; return ans ; }
function isSumDivides ( N ) { var temp = N ; var sum = 0 ; while ( temp > 0 ) { sum += temp % 10 ; temp = parseInt ( temp / 10 ) ; } if ( N % sum == 0 ) return 1 ; else return 0 ; }
function CountDigits ( n ) { if ( n == 1 ) return 1 ; var sum = 0 ; for ( i = 2 ; i <= n ; ++ i ) { sum += ( Math . log ( i ) / Math . log ( 10 ) ) ; } sum *= n ; return Math . ceil ( sum ) ; }
function findF_N ( n ) { var ans = 0 ; for ( var i = 0 ; i < n ; ++ i ) ans += ( i + 1 ) * ( n - i - 1 ) ; return ans ; }
function findNumber ( n , d ) { let ans = " " ; if ( d != 10 ) { ans += ( d ) . toString ( ) ; for ( let i = 1 ; i < n ; i ++ ) ans += ' ' ; } else { if ( n == 1 ) ans += " " ; else { ans += ' ' ; for ( let i = 1 ; i < n ; i ++ ) ans += ' ' ; } } return ans ; }
function form_sieve ( ) { sieve_Prime [ 1 ] = 1 ; for ( i = 2 ; i <= MAX ; i ++ ) { if ( sieve_Prime [ i ] == 0 ) { for ( j = i * 2 ; j <= MAX ; j += i ) { if ( sieve_Prime [ j ] == 0 ) { sieve_Prime [ j ] = 1 ; sieve_count [ i ] ++ ; } } } } }
function nthTerm ( n ) { return Math . pow ( n , 2 ) + 4 * n ; }
function NthTerm ( n ) { let x = ( 3 * n * n ) % 1000000009 ; return ( x - n + 1000000009 ) % 1000000009 ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( var i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } var n = 17 ; if ( isPrime ( n ) && ( n % 16 == 1 ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function sum ( N ) { var S1 , S2 , S3 ; S1 = ( ( N / 3 ) ) * ( 2 * 3 + ( N / 3 - 1 ) * 3 ) / 2 ; S2 = ( ( N / 4 ) ) * ( 2 * 4 + ( N / 4 - 1 ) * 4 ) / 2 ; S3 = ( ( N / 12 ) ) * ( 2 * 12 + ( N / 12 - 1 ) * 12 ) / 2 ; return S1 + S2 - S3 ; }
function nextGreater ( N ) { var power_of_2 = 1 , shift_count = 0 ; while ( true ) { if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) break ; shift_count ++ ; power_of_2 = power_of_2 * 2 ; } return ( N + power_of_2 ) ; }
function area ( r ) { if ( r < 0 ) return - 1 ; var area = ( 3.14 * Math . pow ( r / ( 2 * Math . sqrt ( 2 ) ) , 2 ) ) ; return area ; }
function area ( a ) { if ( a < 0 ) return - 1 ; var area = Math . pow ( ( a * Math . sqrt ( 3 ) ) / ( Math . sqrt ( 2 ) ) , 2 ) ; return area ; }
function sumProductDifference ( a , b , c , d , e ) { var rootSum = ( - 1 * b ) / a ; var rootProduct = e / a ; return Math . abs ( rootSum - rootProduct ) ; }
function heightCalculate ( H , n , m ) { let N = n * 1.0 ; let M = m * 1.0 ; let h = H * Math . sqrt ( N / ( N + M ) ) ; return h ; }
function numberOfSolutions ( n ) { let c = 0 ; for ( let x = 0 ; x <= n ; ++ x ) if ( n == x + n ^ x ) ++ c ; return c ; }
function minimumLectures ( m , n ) { let ans = 0 ; if ( n < Math . ceil ( 0.75 * m ) ) ans = Math . ceil ( ( ( 0.75 * m ) - n ) / 0.25 ) ; else ans = 0 ; return ans ; }
function countNumbers ( N ) { return parseInt ( ( Math . pow ( 10 , N ) - Math . pow ( 8 , N ) ) / 2 , 10 ) ; }
function findsolution ( n , x , y ) { if ( ( y - n + 1 ) * ( y - n + 1 ) + n - 1 < x y < n ) { document . write ( " " ) ; return ; } document . write ( y - n + 1 ) ; while ( n -- > 1 ) document . write ( " " + 1 ) ; }
function findPosition ( n , f , b ) { return n - Math . max ( f + 1 , n - b ) + 1 ; }
function nthOdd ( n ) { return ( 2 * n - 1 ) ; }
function countSolutions ( a ) { let count = 0 ; for ( let i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; }
function nthHarmonic ( N ) { let harmonic = 1.00 ; for ( let i = 2 ; i <= N ; i ++ ) { harmonic += parseFloat ( 1 ) / i ; } return harmonic ; }
function nthTerm ( n ) { return 2 * Math . pow ( n , 2 ) + n - 3 ; }
function nthTerm ( n ) { return 5 * Math . pow ( n , 2 ) - 5 * n ; }
function nthTerm ( n ) { return 3 * Math . pow ( n , 2 ) + n - 2 ; }
function nthTerm ( n ) { return 2 * Math . pow ( n , 2 ) + 4 * n - 2 ; }
function nthTerm ( n ) { return 3 * Math . pow ( n , 2 ) + 2 * n - 5 ; }
function nthTerm ( n ) { return 2 * Math . pow ( n , 2 ) + 3 * n - 5 ; }
function nthTerm ( n ) { return 3 * Math . pow ( n , 2 ) - 4 * n + 2 ; }
function nthTerm ( n ) { return 4 * Math . pow ( n , 2 ) - 3 * n + 2 ; }
function countDivisors ( n , k ) { var count = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 && i % k == 0 ) { count ++ ; } } return count ; }
function nthTerm ( n ) { return 2 * Math . pow ( n , 3 ) + Math . pow ( n , 2 ) ; }
function calculateSum ( n ) { return n * ( n + 1 ) / 2 + Math . pow ( ( n * ( n + 1 ) / 2 ) , 2 ) ; }
function calculateSum ( n ) { return n * ( n + 1 ) / 2 + n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ; }
function calculateSum ( n ) { return 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) + n * ( n + 1 ) / 2 + 2 * ( n ) ; }
function nthTerm ( n ) { return 2 * Math . pow ( n , 2 ) - n - 1 ; }
function nthTerm ( n ) { return 6 * Math . pow ( n , 2 ) - 4 * n - 2 ; }
function nthTerm ( n ) { return 4 * Math . pow ( n , 2 ) - 7 * n + 3 ; }
function nthTerm ( n ) { return Math . pow ( n , 2 ) + 2 * n + 2 ; }
function checkSolution ( a , b , c ) { if ( ( ( b * b ) - ( 4 * a * c ) ) > 0 ) document . write ( " " ) ; else if ( ( ( b * b ) - ( 4 * a * c ) ) == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function sum ( n ) { let ans = parseInt ( ( n * ( n - 1 ) ) / 2 ) ; return ans ; }
function getNthTerm ( N ) { return ( Math . pow ( N , 2 ) + N + 1 ) ; }
function findSum ( N ) { return ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) / 2 ; }
function getNthTerm ( N ) { return 4 * Math . pow ( N , 2 ) - 3 * N + 2 ; }
function findSum ( N ) { return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6 ; }
function findSum ( n ) { var sum2 , sum5 , sum10 ; sum2 = parseInt ( ( parseInt ( n / 2 ) * ( 4 + ( parseInt ( n / 2 ) - 1 ) * 2 ) ) / 2 ) ; sum5 = parseInt ( ( parseInt ( n / 5 ) * ( 10 + ( parseInt ( n / 5 ) - 1 ) * 5 ) ) / 2 ) ; sum10 = parseInt ( ( parseInt ( n / 10 ) * ( 20 + ( parseInt ( n / 10 ) - 1 ) * 10 ) ) / 2 ) ; return sum2 + sum5 - sum10 ; }
function prletNthElement ( n ) { let arr = Array ( n + 1 ) . fill ( 0 ) ; arr [ 1 ] = 3 ; arr [ 2 ] = 5 ; for ( i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 3 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 5 ; } return arr [ n ] ; }
function nthTerm ( N ) { return ( ( 3 * N * N ) - ( 6 * N ) + 2 ) ; }
function nthTerm ( N ) { return ( 2 * N + 3 ) * ( 2 * N + 3 ) - 2 * N ; }
function nextPerfectCube ( N ) { let nextN = Math . floor ( Math . cbrt ( N ) ) + 1 ; return nextN * nextN * nextN ; }
function findSum ( n ) { return Math . sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) ; }
function sum ( x , y , n ) { sum1 = ( Math . pow ( x , 2 ) * ( Math . pow ( x , 2 * n ) - 1 ) ) / ( Math . pow ( x , 2 ) - 1 ) ; sum2 = ( x * y * ( Math . pow ( x , n ) * Math . pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ; return sum1 + sum2 ; }
function calculateSum ( n ) { return ( n * ( parseInt ( Math . pow ( n , 2 ) + 3 * n + 5 ) ) / 3 ) ; }
function calculateSum ( n ) { return ( parseInt ( Math . pow ( 10 , n + 1 ) ) * ( 9 * n - 1 ) + 10 ) / parseInt ( Math . pow ( 9 , 3 ) ) - n * ( n + 1 ) / 18 ; }
function calculateSum ( n ) { if ( n % 2 == 1 ) return ( n + 1 ) / 2 ; return - n / 2 ; }
function calculateSum ( n ) { return parseInt ( Math . pow ( n * ( n + 1 ) / 2 , 2 ) ) ; }
function printPair ( g , l ) { document . write ( g + " " + l ) ; }
function findMaximumPieces ( n ) { return 1 + n * ( n + 1 ) / 2 ; }
function totEdge ( n ) { var result = 0 ; result = ( n * ( n - 1 ) ) / 2 ; return result ; }
function rmsValue ( arr , n ) { var square = 0 ; var mean = 0 ; var root = 0 ; for ( i = 0 ; i < n ; i ++ ) { square += Math . pow ( arr [ i ] , 2 ) ; } mean = ( square / ( n ) ) ; root = Math . sqrt ( mean ) ; return root ; }
function Mixture ( X , Y , Z ) { var result = 0.0 , result1 = 0.0 ; result1 = ( ( X - Y ) / X ) ; result = Math . pow ( result1 , Z ) ; result = result * X ; return result ; }
function coin ( totalRupees , X , Y , Z ) { var one = 0 , fifty = 0 , twentyfive = 0 , result = 0 , total = 0 ; one = X * 1 ; fifty = ( ( Y * 1 ) / 2.0 ) ; twentyfive = ( ( Z * 1 ) / 4.0 ) ; total = one + fifty + twentyfive ; result = ( ( totalRupees ) / total ) ; return result ; }
function sumOfSeries ( x , k ) { var y = ( ( ( x ) / 81 ) * ( 9 * k - 1 + Math . pow ( 10 , ( - 1 ) * k ) ) ) ; return y ; }
function calculateSum ( n ) { let a1 = 1 , a2 = 2 ; let r = 2 ; let d = 1 ; return ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( Math . pow ( r , n ) - 1 ) / ( r - 1 ) ; }
function Race ( B , C ) { var result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; }
function isDivisible ( n ) { while ( Math . floor ( n / 100 ) > 0 ) { let d = n % 10 ; n = Math . floor ( n / 10 ) ; n -= d * 5 ; } return ( n % 17 == 0 ) ; }
function calculateSum ( n ) { return ( Math . pow ( 2 , n + 1 ) + n - 2 ) ; }
function calculateSum ( n ) { return ( n * ( 4 * n * n + 6 * n - 1 ) / 3 ) ; }
function bridge_length ( trainLength , Speed , Time ) { return ( ( Time * Speed ) - trainLength ) ; }
function findN ( k ) { var ans ; if ( k == 0 ) ans = 3 ; if ( k == 1 ) ans = 1 ; else if ( k % 4 == 0 ) ans = k ; else if ( k % 4 == 3 ) ans = k - 1 ; else ans = - 1 ; return ans ; }
function Circular ( n ) { var Result = 1 ; while ( n > 0 ) { Result = Result * n ; n -- ; } return Result ; }
function Time ( arr , n , Emptypipe ) { var fill = 0 ; for ( var i = 0 ; i < n ; i ++ ) fill += 1 / arr [ i ] ; fill = fill - ( 1 / Emptypipe ) ; return 1 / fill ; }
function calculateAreaSum ( l , b ) { var size = 1 ; var maxSize = Math . min ( l , b ) ; var totalArea = 0 ; for ( var i = 1 ; i <= maxSize ; i ++ ) { var totalSquares = ( l - size + 1 ) * ( b - size + 1 ) ; var area = totalSquares * size * size ; totalArea += area ; size ++ ; } return totalArea ; }
function printCombination ( n ) { for ( let i = 1 ; i < n ; i ++ ) { if ( i % 3 != 0 ) { for ( let j = 1 ; j < n ; j ++ ) { if ( j % 3 != 0 ) { for ( let k = 1 ; k < n ; k ++ ) { if ( k % 3 != 0 && ( i + j + k ) == n ) { document . write ( i + " " + j + " " + k ) ; return ; } } } } } } }
function printCombination ( n ) { document . write ( 1 + " " ) ; if ( ( n - 2 ) % 3 == 0 ) document . write ( 2 + " " + ( n - 3 ) ) ; else document . write ( 1 + " " + ( n - 2 ) ) ; }
function checkPairs ( l , r ) { if ( ( l - r ) % 2 == 0 ) return false ; return true ; }
function calTime ( arr , n ) { var work = 0 ; for ( i = 0 ; i < n ; i ++ ) work += 1 / arr [ i ] ; return 1 / work ; }
function isPalindrome ( n ) { if ( n % 11 == 0 ) { return true ; } return false ; }
function percent ( a , b ) { var result = 0 ; result = ( ( b - a ) * 100 ) / a ; return result ; }
function nextPerfectSquare ( N ) { let nextN = Math . floor ( Math . sqrt ( N ) ) + 1 ; return nextN * nextN ; }
function printSubstrings ( n ) { var s = parseInt ( Math . log10 ( n ) ) ; var d = parseInt ( ( Math . pow ( 10 , s ) + 0.5 ) ) ; var k = d ; while ( n > 0 ) { while ( d > 0 ) { document . write ( parseInt ( n / d ) + " " ) ; d = parseInt ( d / 10 ) ; } n = n % k ; k = parseInt ( k / 10 ) ; d = k ; } }
function check ( n ) { let sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = Math . floor ( n / 10 ) ; } if ( sum % 7 == 0 ) return 1 ; else return 0 ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function numberSequence ( n ) { let num = Math . pow ( 4 , n ) - Math . pow ( 2 , n ) - 1 ; return num ; }
function complement ( num ) { var i , len = 0 , temp , comp ; temp = num ; while ( true ) { len ++ ; num = parseInt ( num / 10 ) ; if ( Math . abs ( num ) == 0 ) break ; } num = temp ; comp = parseInt ( Math . pow ( 10 , len ) - num ) ; return comp ; }
function calculate ( ar , size ) { var count = 0 ; for ( i = 0 ; i < size ; i ++ ) if ( ar [ i ] % 2 == 0 && ar [ i ] != 0 && ar [ i ] != 2 ) count ++ ; return count ; }
function findGreater ( x , y ) { if ( x > y ) { return false ; } else { return true ; } }
function print_C ( p0 ) { let p1 = 0 ; let i = 0 ; let x ; let flag ; let k ; while ( 1 ) { flag = 1 ; x = Math . pow ( 2 , i ) ; p1 = x * p0 + ( x - 1 ) ; for ( let k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; document . write ( p1 + " " ) ; i ++ ; } }
function print ( p0 ) { var p1 , i = 0 , x , flag = 1 , k , m = 4 ; while ( flag ) { flag = 1 ; x = Math . pow ( 2 , i ) ; p1 = x * p0 - ( x - 1 ) ; for ( k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; document . write ( p1 + " " ) ; i ++ ; } }
function boost_hyperfactorial ( num ) { let val = 1 ; for ( let i = 1 ; i <= num ; i ++ ) { val = val * Math . pow ( i , i ) ; } return val ; }
function boost_hyperfactorial ( num ) { var val = 1 ; for ( var i = 1 ; i <= num ; i ++ ) { for ( var j = 1 ; j <= i ; j ++ ) { val *= i ; } } return val ; }
function findOddPair ( A , N ) { var i , j ; var oddPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; }
function findOddPair ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( ( A [ i ] % 2 == 1 ) ) count ++ ; return count * ( count - 1 ) / 2 ; }
function gcd ( a , b ) { if ( a == 0 && b == 0 ) return 0 ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function isSurd ( n ) { for ( let i = 2 ; i * i <= n ; i ++ ) { let j = i ; while ( j < n ) j = j * i ; if ( j == n ) return false ; } return true ; }
function LastTwoDigit ( num ) { let one = num % 10 ; num = Math . floor ( num / 10 ) ; let tens = num % 10 ; tens *= 10 ; num = tens + one ; return num ; }
function countOddSum ( ar , n ) { let result = 0 ; for ( let i = 0 ; i <= n - 1 ; i ++ ) { let val = 0 ; for ( let j = i ; j <= n - 1 ; j ++ ) { val = val + ar [ j ] ; if ( val % 2 != 0 ) result ++ ; } } return ( result ) ; }
function printPFsInPairs ( n ) { for ( let i = 1 ; i * i <= n ; i ++ ) if ( n % i == 0 ) document . write ( i + " " + parseInt ( n / i ) + " " ) ; }
function findAngle ( n ) { let interiorAngle , exteriorAngle ; interiorAngle = Math . floor ( ( n - 2 ) * 180 / n ) ; exteriorAngle = Math . floor ( 360 / n ) ; document . write ( " " + interiorAngle + " " ) ; document . write ( " " + exteriorAngle ) ; }
function rainDayProbability ( a , n ) { let count = 0 , m ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count ++ ; } m = count / n ; return m ; }
function distance ( x1 , y1 , z1 , x2 , y2 , z2 ) { var d = Math . pow ( ( Math . pow ( x2 - x1 , 2 ) + Math . pow ( y2 - y1 , 2 ) + Math . pow ( z2 - z1 , 2 ) * 1.0 ) , 0.5 ) ; document . write ( " " + d . toFixed ( 10 ) ) ; return ; }
function twoEggDrop ( k ) { return Math . ceil ( ( - 1.0 + Math . sqrt ( 1 + 8 * k ) ) / 2.0 ) ; }
function DivisibleBy41 ( first , second , c , n ) { let digit = new Array ( n ) . fill ( 0 ) ; digit [ 0 ] = first ; digit [ 1 ] = second ; for ( let i = 2 ; i < n ; i ++ ) digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 ; let ans = digit [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) ans = ( ans * 10 + digit [ i ] ) % 41 ; if ( ans % 41 == 0 ) return true ; else return false ; }
function printSeries ( n ) { for ( let i = 1 ; i <= n ; i ++ ) { num = ( i * ( i + 1 ) * ( i + 2 ) * ( i + 3 ) / 24 ) ; document . write ( num + " " ) ; } }
function printSeries ( n ) { let i ; for ( i = 1 ; i <= n ; i ++ ) { let num = i * ( i + 1 ) * ( ( i + 2 ) / 6 ) ; document . write ( num + " " ) ; } }
function calculateSum ( n ) { let sum = 0 ; for ( let row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; }
function calculateSum ( n ) { sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; }
function findNthNonSquare ( n ) { var x = n ; var ans = x + Math . floor ( 0.5 + Math . sqrt ( x ) ) ; return parseInt ( ans ) ; }
function getMaxOnes ( n , x ) { let zeroes = parseInt ( n / x , 10 ) ; zeroes = zeroes * zeroes ; let total = n * n ; let ans = total - zeroes ; return ans ; }
function ways ( n ) { var first = 2 ; var second = 3 ; var res = 0 ; for ( i = 3 ; i <= n ; i ++ ) { res = first + second ; first = second ; second = res ; } return res ; }
function check ( n , m ) { if ( n == 2 m == 2 n % m == 0 ) { document . write ( " " + " " ) ; } else { document . write ( " " + " " ) ; } }
function MinimumMail ( n , k , x ) { let m = ( n - 1 ) + Math . ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + Math . ceil ( n * 1.0 / x ) * ( k - n ) ; return m ; }
function findAllSequence ( N ) { if ( N % 2 == 0 ) { return ( Math . pow ( 2 , N / 2 + 1 ) + Math . pow ( 2 , N / 2 ) - 2 ) ; } else { return ( Math . pow ( 2 , ( N + 1 ) / 2 ) + Math . pow ( 2 , ( N + 1 ) / 2 ) - 2 ) ; } }
function findArea ( a , b ) { var Area ; Area = 3.142 * a * b ; document . write ( " " + Area . toFixed ( 2 ) ) ; }
function calculate ( x , k , m ) { let result = x ; k = k - 1 ; while ( k -- ) { result = Math . pow ( result , x ) ; if ( result > m ) result %= m ; } return result ; }
function rev ( n , temp ) { if ( n == 0 ) return temp ; temp = ( temp * 10 ) + ( n % 10 ) ; return rev ( Math . floor ( n / 10 ) , temp ) ; }
function countOnes ( n ) { let count = 1 ; let rem = 1 ; while ( rem != 0 ) { rem = ( rem * 10 + 1 ) % n ; count ++ ; } return count ; }
function findGreater ( a , b , n ) { if ( ! ( ( n & 1 ) > 0 ) ) { a = Math . abs ( a ) ; b = Math . abs ( b ) ; } if ( a == b ) document . write ( " " + " " ) ; else if ( a > b ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; }
function fibonacci ( n ) { var fib ; for ( i = 0 ; i < n ; i ++ ) { fib = ( Math . pow ( ( 1 + Math . sqrt ( 5 ) ) , i ) - Math . pow ( ( 1 - Math . sqrt ( 5 ) ) , i ) ) / ( Math . pow ( 2 , i ) * Math . sqrt ( 5 ) ) ; document . write ( parseInt ( fib ) + " " ) ; } }
function findLCM ( a , b ) { var lar = Math . max ( a , b ) ; var small = Math . min ( a , b ) ; for ( i = lar ; ; i += lar ) { if ( i % small == 0 ) return i ; } }
function largestNum ( a , b ) { return a * ( parseInt ( a / b ) > 0 ? 1 : 0 ) + b * ( parseInt ( b / a ) > 0 ? 1 : 0 ) ; }
function center_hexadecagonal_num ( n ) { return 8 * n * n - 8 * n + 1 ; }
function findNature ( a , b , n ) { var seq = Array ( MAX ) . fill ( 0 ) ; seq [ 0 ] = a ; seq [ 1 ] = b ; for ( var i = 2 ; i <= n ; i ++ ) seq [ i ] = seq [ i - 1 ] + seq [ i - 2 ] ; return ( seq [ n ] & 1 ) ; }
function findNature ( a , b , n ) { if ( n == 0 ) return ( a & 1 ) == 1 ? true : false ; if ( n == 1 ) return ( b & 1 ) == 1 ? true : false ; if ( ( a & 1 ) == 0 ) { if ( ( b & 1 ) == 0 ) return false ; else return ( n % 3 != 0 ) ; } else { if ( ( b & 1 ) == 0 ) return ( ( n - 1 ) % 3 != 0 ) ; else return ( ( n + 1 ) % 3 != 0 ) ; } }
function check ( m , n ) { var RHS = m * Math . log ( n ) ; var LHS = n * Math . log ( m ) ; if ( LHS > RHS ) { document . write ( " " ) ; } else if ( LHS < RHS ) { document . write ( " " ) ; } else { document . write ( " " ) ; } }
function subtractOne ( x ) { let m = 1 ; while ( ! ( x & m ) ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
function subtractOne ( x ) { return ( ( x << 1 ) + ( ~ x ) ) ; }
function meanVector ( mat ) { document . write ( " " ) ; for ( var i = 0 ; i < rows ; i ++ ) { var mean = 0.00 ; var sum = 0 ; for ( var j = 0 ; j < cols ; j ++ ) sum += mat [ j ] [ i ] ; mean = sum / rows ; document . write ( mean + " " ) ; } document . write ( " " ) ; }
function countDigits ( n ) { let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) ans += Math . log10 ( i ) ; ans = ans * n ; return 1 + Math . floor ( ans ) ; }
function checksum ( n ) { if ( n % 5 == 0 ) document . write ( ( n / 5 - 2 ) + " " + ( n / 5 - 1 ) + " " + ( n / 5 ) + " " + ( n / 5 + 1 ) + " " + ( n / 5 + 2 ) ) ; else document . write ( " " ) ; }
function sumOfSeries ( n ) { let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) ans += i * i * i * i ; return ans ; }
function sumOfSeries ( n ) { return n * ( n + 1 ) * ( 6 * n * n * n + 9 * n * n + n - 1 ) / 30 ; }
function octahedral_num ( n ) { return n * ( 2 * n * n + 1 ) / 3 ; }
function countUnmarked ( N ) { if ( N % 2 == 0 ) return N / 2 ; else return N / 2 + 1 ; }
function Pentatope_number ( n ) { return n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 24 ; }
function minimumLength ( x , y , z ) { return 1 + Math . abs ( x - y ) + Math . abs ( y - z ) ; }
function endPointOfDiameterofCircle ( x1 , y1 , c1 , c2 ) { document . write ( " " + ( 2 * c1 - x1 ) + " " ) ; document . write ( " " + ( 2 * c2 - y1 ) ) ; }
function dodecahedral_num ( n ) { return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) / 2 ; }
function centeredTetrahedralNumber ( n ) { return ( 2 * n + 1 ) * ( n * n + n + 3 ) / 3 ; }
function centered_heptagonal_num ( n ) { return parseInt ( ( 7 * n * n - 7 * n + 2 ) / 2 ) ; }
function centeredIcosahedralNum ( n ) { return parseInt ( ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 3 ) / 3 ) ; }
function findSum ( n ) { return ( n * ( n + 1 ) * ( n + 1 ) * ( n + 2 ) ) / 12 ; }
function checkHankelMatrix ( n , m ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i + j < n ) { if ( m [ i ] [ j ] != m [ i + j ] [ 0 ] ) return false ; } else { if ( m [ i ] [ j ] != m [ i + j - n + 1 ] [ n - 1 ] ) return false ; } } } return true ; }
function swap ( a , b , c , d ) { a = a + b ; b = a - b ; a = a - b ; b = b + c ; c = b - c ; b = b - c ; c = c + d ; d = c - d ; c = c - d ; document . write ( " " + " " ) ; document . write ( " " + a + " " ) ; document . write ( " " + b + " " ) ; document . write ( " " + c + " " ) ; document . write ( " " + d ) ; }
function seriesSum ( n ) { var sum = 0 ; for ( i = 1 ; i <= n ; i ++ ) sum += i * ( ( i + 1 ) / 2 ) ; return sum ; }
function seriesSum ( n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
function checkCentrosymmetricted ( n , m ) { let mid_row ; if ( n & 1 ) mid_row = Math . floor ( n / 2 ) + 1 ; else mid_row = n / 2 ; for ( let i = 0 ; i < mid_row ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( m [ i ] [ j ] != m [ n - i - 1 ] [ n - j - 1 ] ) return false ; } } return true ; }
function Centered_Triangular_num ( n ) { return ( 3 * n * n + 3 * n + 2 ) / 2 ; }
function Dodecagonal_number ( n ) { return 5 * n * n - 4 * n ; }
function isPower ( n ) { for ( x = 2 ; x <= parseInt ( Math . sqrt ( n ) ) ; x ++ ) { var f = Math . log ( n ) / Math . log ( x ) ; if ( ( f - parseInt ( f ) ) == 0.0 ) return true ; } return false ; }
function number_of_digits ( n ) { let i , res , sum = 0 ; for ( i = 4 , res = 1 ; ; i *= 4 , res ++ ) { sum += i ; if ( sum >= n ) break ; } return res ; }
function check ( k , d0 , d1 ) { let s = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ; let a = ( k - 3 ) % 4 ; let x ; switch ( a ) { case 0 : x = 0 ; break ; case 1 : x = ( 2 * ( d0 + d1 ) ) % 10 ; break ; case 2 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ; break ; case 3 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ; break ; } let sum = d0 + d1 + parseInt ( ( k - 3 ) / 4 ) * s + x ; if ( sum % 3 == 0 ) return " " ; return " " ; }
function Reverseorder ( n ) { let prime = new Array ( n + 1 ) ; for ( let i = 0 ; i < n ; i ++ ) prime [ i ] = true ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( let p = n ; p >= 2 ; p -- ) if ( prime [ p ] ) document . write ( p + " " ) ; }
function MaximumHeight ( a , n ) { let result = 1 ; for ( i = 1 ; i <= n ; ++ i ) { let y = ( i * ( i + 1 ) ) / 2 ; if ( y < n ) result = i ; else break ; } return result ; }
function printCollatz ( n ) { while ( n != 1 ) { document . write ( n + " " ) ; if ( ( n & 1 ) != 0 ) n = 3 * n + 1 ; else n = parseInt ( n / 2 , 10 ) ; } document . write ( n ) ; }
function findpos ( n ) { var pos = 0 ; for ( i = 0 ; i < n . length ; i ++ ) { switch ( n . charAt ( i ) ) { case ' ' : pos = pos * 4 + 1 ; break ; case ' ' : pos = pos * 4 + 2 ; break ; case ' ' : pos = pos * 4 + 3 ; break ; case ' ' : pos = pos * 4 + 4 ; break ; } } return pos ; }
function checkVantieghemsTheorem ( limit ) { let prod = 1 ; for ( let n = 2 ; n < limit ; n ++ ) { if ( n == 2 ) document . write ( 2 + " " + " " ) ; if ( ( ( prod - n ) % ( ( 1 << n ) - 1 ) ) == 0 ) document . write ( n + " " + " " ) ; prod *= ( ( 1 << n ) - 1 ) ; } }
function magicOfSequence ( N ) { let sum = 0 ; for ( let i = 1 ; i <= N ; i ++ ) sum += ( i * i * i + i * 2 ) ; return sum ; }
function magicOfSequence ( N ) { return ( N * ( N + 1 ) / 2 ) + 2 * N ; }
function repUnitValue ( n ) { if ( n % 2 == 0 n % 5 == 0 ) return 0 ; let rem = 1 ; let power = 1 ; let k = 1 ; while ( rem % n != 0 ) { k ++ ; power = power * 10 % n ; rem = ( rem + power ) % n ; } return k ; }
function isPossibleToZero ( a , n ) { let even = 0 , odd = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( i & 1 ) == 0 ) odd += a [ i ] ; else even += a [ i ] ; } return ( odd == even ) ; }
function isPossibleToZero ( a , n ) { let num = 0 ; for ( let i = 0 ; i < n ; i ++ ) num = num * 10 + a [ i ] ; return ( num % 11 == 0 ) ; }
function cosXSertiesSum ( x , n ) { x = x * ( PI / 180.0 ) ; let res = 1 ; let sign = 1 , fact = 1 , pow = 1 , i ; for ( i = 1 ; i < 5 ; i ++ ) { sign = sign * - 1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; }
function summingSeries ( n ) { return Math . pow ( n , 2 ) ; }
function check ( N , D ) { let temp = ( N * ( N + 1 ) ) / 2 + D ; return ( temp % 2 == 0 ) ; }
function findNumberOfDigits ( n , base ) { var dig = parseInt ( Math . floor ( Math . log ( n ) / Math . log ( base ) ) + 1 ) ; document . write ( " " + " " + n + " " + base + " " + dig ) ; }
function isValidNesbitt ( a , b , c ) { let A = a / ( b + c ) ; let B = b / ( a + c ) ; let C = c / ( a + b ) ; let inequality = A + B + C ; return ( inequality >= 1.5 ) ; } let a = 1.0 , b = 2.0 , c = 3.0 ; if ( isValidNesbitt ( a , b , c ) == true ) { document . write ( " " + " " ) ; document . write ( " " + a + " " + b + " " + c ) ; }
function printFourSquares ( a ) { for ( let i = 0 ; i * i <= a ; i ++ ) { for ( let j = i ; j * j <= a ; j ++ ) { for ( let k = j ; k * k <= a ; k ++ ) { for ( let l = k ; l * l <= a ; l ++ ) { if ( i * i + j * j + k * k + l * l == a ) { document . write ( a + " " + i + " " + i + " " + j + " " + j + " " ) ; document . write ( k + " " + k + " " + l + " " + l + " " ) ; } } } } } }
function no_of_digit ( a , b ) { return ( Math . round ( ( b * Math . log10 ( a ) ) + 1 ) ) ; }
function find_sum_of_two_squares ( a , b ) { let ab = a * b ; for ( let i = 0 ; i * i <= ab ; i ++ ) { for ( let j = i ; i * i + j * j <= ab ; j ++ ) { if ( i * i + j * j == ab ) document . write ( i + " " + j + " " + ab + " " ) ; } } }
function check_euler_four_square_identity ( a , b , ab ) { let s = 0 ; for ( let i = 0 ; i * i <= ab ; i ++ ) { s = i * i ; for ( let j = i ; j * j <= ab ; j ++ ) { s = j * j + i * i ; for ( let k = j ; k * k <= ab ; k ++ ) { s = k * k + j * j + i * i ; for ( let l = k ; l * l <= ab ; l ++ ) { s = l * l + k * k + j * j + i * i ; if ( s == ab ) { document . write ( " " + i + " " ) ; document . write ( " " + j + " " ) ; document . write ( " " + k + " " ) ; document . write ( " " + l + " " ) ; document . write ( " " + a + " " + b ) ; document . write ( " " + " " + " " + " " ) ; document . write ( ab + " " ) ; document . write ( i + " " + i + " " ) ; document . write ( j + " " + j + " " ) ; document . write ( k + " " + k + " " ) ; document . write ( l + " " + l + " " ) ; document . write ( " " ) ; } } } } } }
function inversegrayCode ( n ) { let inv = 0 ; for ( ; n ; n = n >> 1 ) inv ^= n ; return inv ; }
function firstDigit ( n ) { let fact = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { fact = fact * i ; while ( fact % 10 == 0 ) fact = fact / 10 ; } while ( fact >= 10 ) fact = fact / 10 ; return ( Math . round ( fact ) ) ; }
function possibleToReach ( a , b ) { let c = Math . cbrt ( a * b ) ; let re1 = a / c ; let re2 = b / c ; if ( ( re1 * re1 * re2 == a ) && ( re2 * re2 * re1 == b ) ) return true ; else return false ; }
function nthSquareCube ( n ) { return n * n * n * n * n * n ; }
function findS ( s ) { let sum = 0 ; for ( let n = 1 ; sum < s ; n ++ ) { sum += n * n * n ; if ( sum == s ) return n ; } return - 1 ; }
function findKthGoodNo ( n ) { let lastDig = n % 10 ; if ( lastDig >= 0 && lastDig <= 4 ) return n << 1 ; else return ( n << 1 ) + 1 ; }
function powerNumbers ( n ) { let v = new Set ( ) ; for ( let i = 2 ; i * i * i <= n ; i ++ ) { let j = i * i ; while ( j * i <= n ) { j *= i ; let s = parseInt ( Math . sqrt ( j ) , 10 ) ; if ( s * s != j ) v . add ( j ) ; } } return v . size + parseInt ( Math . sqrt ( n ) , 10 ) ; }
function NicomachuTheorum_sum ( n ) { let sum = 0 ; for ( let k = 1 ; k <= n ; k ++ ) sum += k * k * k ; let triNo = n * ( n + 1 ) / 2 ; if ( sum == triNo * triNo ) document . write ( " " ) ; else document . write ( " " ) ; }
function countDigits ( n ) { return ( n * Math . log10 ( 2 ) + 1 ) ; }
function findBucketNo ( p ) { return Math . ceil ( ( Math . sqrt ( 8 * p + 1 ) - 1 ) / 2 ) ; }
function calculateProbability ( N ) { let probability = N / ( N + 1 ) ; return probability ; }
function isUndulating ( n ) { if ( n . length <= 2 ) return false ; for ( let i = 2 ; i < n . length ; i ++ ) if ( n [ i - 2 ] != n [ i ] ) return false ; return true ; }
function findNth ( n ) { let count = 0 ; for ( let curr = 19 ; ; curr += 9 ) { let sum = 0 ; for ( let x = curr ; x > 0 ; x = parseInt ( x / 10 ) ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } return - 1 ; }
function pythagoreanTriplet ( n ) { for ( let i = 1 ; i <= n / 3 ; i ++ ) { for ( let j = i + 1 ; j <= n / 2 ; j ++ ) { let k = n - i - j ; if ( i * i + j * j == k * k ) { document . write ( i + " " + j + " " + k ) ; return ; } } } document . write ( " " ) ; }
function findSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = i ; j <= n ; j ++ ) sum = sum + i * j ; return sum ; }
function findSum ( n ) { let multiTerms = n * ( n + 1 ) / 2 ; let sum = multiTerms ; for ( let i = 2 ; i <= n ; i ++ ) { multiTerms = multiTerms - ( i - 1 ) ; sum = sum + multiTerms * i ; } return sum ; }
function procal ( n ) { return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ; }
function testSomeNumbers ( limit , n ) { if ( n < 3 ) return ; for ( let a = 1 ; a <= limit ; a ++ ) for ( let b = a ; b <= limit ; b ++ ) { let pow_sum = ( Math . pow ( a , n ) + Math . pow ( b , n ) ) ; let c = Math . pow ( pow_sum , 1.0 / n ) ; let c_pow = Math . pow ( Math . round ( c ) , n ) ; if ( c_pow == pow_sum ) { document . write ( " " ) ; return ; } } document . write ( " " + " " ) ; }
function series ( A , X , n ) { let term = Math . pow ( A , n ) ; document . write ( term + " " ) ; for ( let i = 1 ; i <= n ; i ++ ) { term = term * X * ( n - i + 1 ) / ( i * A ) ; document . write ( term + " " ) ; } }
function fnMod ( n ) { if ( n % 5 == 1 ) return 4 ; else return 0 ; }
function totalSumDivisibleByNum ( n , number ) { let firstnum = Math . pow ( 10 , n - 1 ) ; let lastnum = Math . pow ( 10 , n ) ; let sum = 0 ; for ( let i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) sum += i ; return sum ; }
function totalSumDivisibleByNum ( digit , number ) { let firstnum = Math . pow ( 10 , digit - 1 ) ; let lastnum = Math . pow ( 10 , digit ) ; firstnum = ( firstnum - firstnum % number ) + number ; lastnum = ( lastnum - lastnum % number ) ; let count = ( ( lastnum - firstnum ) / number + 1 ) ; return ( ( lastnum + firstnum ) * count ) / 2 ; }
function numberofterm ( n , number ) { let firstnum = Math . pow ( 10 , n - 1 ) ; let lastnum = Math . pow ( 10 , n ) ; let count = 0 ; for ( let i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) count ++ ; return count ; }
function sumofseries ( n ) { let res = 0 ; for ( let i = 1 ; i <= n ; i ++ ) res += ( i ) * ( i + 1 ) * ( i + 2 ) ; return res ; }
function sumofseries ( n ) { return ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 4 ) ; }
function seiresSum ( n , a ) { let res = 0 , i ; for ( i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; }
function seiresSum ( n , a ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; }
function printGMeans ( A , B , N ) { let R = Math . pow ( ( B / A ) , 1.0 / ( N + 1 ) ) ; for ( let i = 1 ; i <= N ; i ++ ) document . write ( A * Math . pow ( R , i ) + " " ) ; }
function isDivisible ( n ) { while ( parseInt ( n / 100 ) ) { let last_digit = n % 10 ; n = parseInt ( n / 10 ) ; n += last_digit * 3 ; } return ( n % 29 == 0 ) ; }
function pronic_check ( n ) { var x = parseInt ( Math . sqrt ( n ) ) ; if ( x * ( x + 1 ) == n ) return true ; else return false ; }
function power ( n , r ) { let count = 0 ; for ( let i = r ; ( n / i ) >= 1 ; i = i * r ) count += n / i ; return count ; }
function isPrime ( p ) { let checkNumber = Math . pow ( 2 , p ) - 1 ; let nextval = 4 % checkNumber ; for ( let i = 1 ; i < p - 1 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ; return ( nextval == 0 ) ; }
function isPerfectSquare ( x ) { if ( x >= 0 ) { let sr = Math . sqrt ( x ) ; return ( ( sr * sr ) == x ) ; } return false ; }
function checkperfectsquare ( n ) { if ( Math . ceil ( Math . sqrt ( n ) ) == Math . floor ( Math . sqrt ( n ) ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; } }
function printGP ( a , r , n ) { let curr_term ; for ( let i = 0 ; i < n ; i ++ ) { curr_term = a * Math . pow ( r , i ) ; document . write ( curr_term + " " ) ; } }
function Nth_of_AP ( a , d , N ) { return ( a + ( N - 1 ) * d ) ; }
function checkFibinnary ( n ) { var prev_last = 0 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 && prev_last != 0 ) return false ; prev_last = n & 1 ; n >>= 1 ; } return true ; }
function sumOfSeries ( n ) { return parseInt ( ( 0.6172 * ( Math . pow ( 10 , n ) - 1 ) - 0.55 * n ) ) ; }
function Nonagonal ( n ) { return parseInt ( n * ( 7 * n - 5 ) / 2 ) ; }
function Nonagonal ( n ) { for ( let i = 1 ; i <= n ; i ++ ) { document . write ( parseInt ( i * ( 7 * i - 5 ) / 2 ) + " " ) ; } }
function seriesFunc ( n ) { let sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; let sumNatural = ( n * ( n + 1 ) / 2 ) ; return ( sumSquare + sumNatural + 1 ) ; }
function sum_series ( n ) { let nSquare = n * n ; return nSquare * ( nSquare - 1 ) / 4 ; }
function day_of_the_week ( y , m , d ) { let t = [ 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ] ; if ( m < 3 ) y -= 1 ; return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ; }
function Div_by_8 ( n ) { return ( ( ( n >> 3 ) << 3 ) == n ) ; }
function divisibleBy20 ( num ) { let lastTwoDigits = parseInt ( num . slice ( - 2 , num . length ) ) console . log ( num . slice ( - 2 , 1 ) ) return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4 == 0 ) ) }
function isPrime ( n , i ) { if ( n <= 2 ) return ( n == 2 ) ? true : false ; if ( n % i == 0 ) return false ; if ( i * i > n ) return true ; return isPrime ( n , i + 1 ) ; }
function subsetCount ( arr , n ) { return 1 << n ; }
function isSquareFree ( n ) { if ( n % 2 == 0 ) n = n / 2 ; if ( n % 2 == 0 ) return false ; for ( let i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { n = n / i ; if ( n % i == 0 ) return false ; } } return true ; }
function findArea ( d ) { return ( d * d ) / 2 ; }
function sumOfSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; }
function sumOfSeries ( n ) { return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ; }
function isDvisibleBy12 ( num ) { if ( num . length >= 3 ) { let d1 = num [ num . length - 1 ] . charCodeAt ( ) ; if ( d1 % 2 != 0 ) return false ; let d2 = num [ num . length - 2 ] . charCodeAt ( ) ; let sum = 0 ; for ( let i = 0 ; i < num . length ; i ++ ) sum += num [ i ] . charCodeAt ( ) ; return ( ( sum % 3 == 0 ) && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { let number = parseInt ( num , 10 ) ; document . write ( number ) ; return ( number % 12 == 0 ) ; } }
function StepstoReachTarget ( target ) { target = Math . abs ( target ) ; let n = Math . ceil ( ( - 1.0 + Math . sqrt ( 1 + 8.0 * target ) ) / 2 ) ; let sum = n * ( n + 1 ) / 2 ; if ( sum == target ) return n ; let d = sum - target ; if ( ( d & 1 ) == 0 ) return n ; else return n + ( ( n & 1 ) != 0 ? 2 : 1 ) ; }
function Calculate_GST ( org_cost , N_price ) { return ( ( ( N_price - org_cost ) * 100 ) / org_cost ) ; }
function avg_of_even_num ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += 2 * i ; return sum / n ; }
function avg_of_even_num ( n ) { return n + 1 ; }
function avg_of_odd_num ( n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += ( 2 * i + 1 ) ; return sum / n ; }
function avg_of_odd_num ( n ) { return n ; }
function seriesSum ( n ) { let i = 1 ; let res = 0.0 ; let sign = true ; while ( n > 0 ) { n -- ; if ( sign ) { sign = ! sign ; res = res + ++ i / ++ i ; } else { sign = ! sign ; res = res - ++ i / ++ i ; } } return res ; }
function countSymmetric ( n ) { if ( n == 0 ) return 1 ; return 1 << ( ( n * ( n + 1 ) ) / 2 ) ; }
function SternSequenceFunc ( BrocotSequence , n ) { for ( var i = 1 ; BrocotSequence . length < n ; i ++ ) { var considered_element = BrocotSequence [ i ] ; var precedent = BrocotSequence [ i - 1 ] ; BrocotSequence . push ( considered_element + precedent ) ; BrocotSequence . push ( considered_element ) ; } for ( var i = 0 ; i < 15 ; ++ i ) document . write ( BrocotSequence [ i ] + " " ) ; }
function centeredNonagonal ( n ) { return parseInt ( ( 3 * n - 2 ) * ( 3 * n - 1 ) / 2 ) ; }
function printAP ( a , d , n ) { let curr_term ; curr_term = a ; for ( let i = 1 ; i <= n ; i ++ ) { document . write ( curr_term + " " ) ; curr_term = curr_term + d ; } }
function isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) { for ( let i = lowQuant ; i <= upQuant ; i ++ ) { let ans = i * r ; if ( lowCost <= ans && ans <= upCost ) return true ; } return false ; }
function findNumbers ( n , d ) { for ( let i = 0 ; i < n - 2 ; i ++ ) document . write ( " " + " " ) ; document . write ( " " + " " ) ; document . write ( n + d ) ; }
function centeredHexagonalNumber ( n ) { return 3 * n * ( n - 1 ) + 1 ; }
function oddNumSum ( n ) { return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15 ; }
function isTrimorphic ( N ) { let cube = N * N * N ; while ( N > 0 ) { if ( N % 10 != cube % 10 ) return false ; N = parseInt ( N / 10 , 10 ) ; cube = parseInt ( cube / 10 , 10 ) ; } return true ; }
function reachTarget ( target ) { target = Math . abs ( target ) ; let sum = 0 , step = 0 ; while ( sum < target || ( sum - target ) % 2 != 0 ) { step ++ ; sum += step ; } return step ; }
function averageEven ( n ) { if ( n % 2 != 0 ) { document . write ( " " ) ; return - 1 ; } return ( n + 2 ) / 2 ; }
function getLudic ( n ) { let ludics = [ ] ; for ( let i = 1 ; i <= n ; i ++ ) ludics . push ( i ) ; for ( let index = 1 ; index < ludics . length ; index ++ ) { let first_ludic = ludics [ index ] ; let remove_index = index + first_ludic ; while ( remove_index < ludics . length ) { ludics . splice ( remove_index , 1 ) ; remove_index = remove_index + first_ludic - 1 ; } } return ludics ; }
function fifthPowerSum ( n ) { return ( ( 2 * n * n * n * n * n * n ) + ( 6 * n * n * n * n * n ) + ( 5 * n * n * n * n ) - ( n * n ) ) / 12 ; }
function maxFraction ( first , sec ) { a = first [ 0 ] ; b = first [ 1 ] c = sec [ 0 ] ; d = sec [ 1 ] Y = a * d - b * c return ( Y > 0 ) ? first : sec ; }
function find_distance ( n ) { return n * ( 3 * n + 7 ) ; }
function nearestPerfectSquare ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) { let sr = Math . floor ( Math . sqrt ( arr [ i ] ) ) ; if ( ( sr & 1 ) == ( arr [ i ] & 1 ) ) document . write ( ( sr * sr ) + " " ) ; else { sr ++ ; document . write ( ( sr * sr ) + " " ) ; } } }
function squareSum ( n ) { return n * ( 4 * n * n - 1 ) / 3 ; }
function squareSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( 2 * i ) * ( 2 * i ) ; return sum ; }
function kthdigit ( a , b , k ) { let p = Math . pow ( a , b ) ; let count = 0 ; while ( p > 0 && count < k ) { let rem = p % 10 ; count ++ ; if ( count == k ) return rem ; p = p / 10 ; } return 0 ; }
function isPentagonal ( N ) { var i = 1 , M ; do { M = ( 3 * i * i - i ) / 2 ; i += 1 ; } while ( M < N ) ; return ( M == N ) ; }
function fourthPowerSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum = sum + ( i * i * i * i ) ; return sum ; }
function fourthPowerSum ( n ) { return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n ) - n ) / 30 ; }
function unitDigitXRaisedY ( x , y ) { let res = 1 ; for ( let i = 0 ; i < y ; i ++ ) res = ( res * x ) % 10 ; return res ; }
function unitnumber ( x , y ) { x = x % 10 ; if ( y != 0 ) y = y % 4 + 4 ; return ( ( parseInt ( Math . pow ( x , y ) ) ) % 10 ) ; }
function aliquotSum ( n ) { let sum = 0 ; for ( let i = 1 ; i < n ; i ++ ) if ( n % i == 0 ) sum += i ; return sum ; }
function findDivisor ( x , y ) { if ( x == y ) return y ; return 2 ; }
function AvgofSquareN ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; }
function AvgofSquareN ( n ) { return ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
function sumofFactors ( n ) { if ( n % 2 != 0 ) return 0 ; let res = 1 ; for ( let i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { let count = 0 , curr_sum = 1 ; let curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; if ( i == 2 && count == 1 ) curr_sum = 0 ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
function maxArea ( A , len ) { let area = 0 ; for ( let i = 0 ; i < len ; i ++ ) { for ( let j = i + 1 ; j < len ; j ++ ) { area = Math . max ( area , Math . min ( A [ j ] , A [ i ] ) * ( j - i ) ) ; } } return area ; }
function maxArea ( A , len ) { let l = 0 ; let r = len - 1 ; let area = 0 ; while ( l < r ) { area = Math . max ( area , Math . min ( A [ l ] , A [ r ] ) * ( r - l ) ) ; if ( A [ l ] < A [ r ] ) l += 1 ; else r -= 1 ; } return area ; }
function sumofoddFactors ( n ) { let res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( let i = 3 ; i <= Math . sqrt ( n ) ; i ++ ) { let count = 0 ; let curr_sum = 1 ; let curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
function countSolutions ( n , val ) { let total = 0 ; if ( n == 1 && val >= 0 ) return 1 ; for ( let i = 0 ; i <= val ; i ++ ) { total += countSolutions ( n - 1 , val - i ) ; } return total ; }
function sumOfSeries ( n ) { return 0.0246 * ( Math . pow ( 10 , n ) - 1 - ( 9 * n ) ) ; }
function sumofNterm ( a , d , b , r , n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( ( a + ( i - 1 ) * d ) * ( b * Math . pow ( r , i - 1 ) ) ) ; return sum ; }
function sumOfTheSeries ( n ) { let sum = 0.0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += 1.0 / ( i * ( i + 1 ) ) ; return sum ; }
function sum ( n ) { let root = parseInt ( Math . sqrt ( n ) ) ; let ans = 0 ; for ( let i = 1 ; i <= root ; i ++ ) ans += parseInt ( n / i ) ; ans = ( 2 * ans ) - ( root * root ) ; return ans ; }
function sumOfTheSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let k = 2 ; for ( let j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; }
function sumOfTheSeries ( n ) { let sum_n = ( n * ( n + 1 ) / 2 ) ; let sum_sq_n = ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; return ( sum_n + sum_sq_n ) ; }
function sumofsquare ( n ) { let C = new Array ( n + 1 ) ; for ( let i = 0 ; i < C . length ; i ++ ) { C [ i ] = new Array ( 2 ) ; } let i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } let sum = 0 ; for ( i = 0 ; i <= n ; i ++ ) sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) ; return sum ; }
function sumOfSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= i ; j ++ ) sum = sum + i ; return sum ; }
function sumOfSeries ( n ) { var sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum = sum + i * i ; return sum ; }
function sumOfSeries ( n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
function evenSum ( n ) { var C = Array . from ( Array ( n + 1 ) , ( ) => Array ( n + 1 ) . fill ( 0 ) ) ; var i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } var sum = 0 ; for ( var i = 0 ; i <= n ; i += 2 ) sum += C [ n ] [ i ] ; return sum ; }
function evenbinomialCoeffSum ( n ) { return ( 1 << ( n - 1 ) ) ; }
function Series ( n ) { let sums = 0.0 ; for ( let i = 1 ; i < n + 1 ; i ++ ) { ser = 1 / Math . pow ( i , i ) ; sums += ser ; } return sums ; }
function sumOfSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum = sum + i * ( i + 1 ) * ( i + 2 ) ; return sum ; }
function Series ( n ) { let i ; let sums = 0 ; for ( i = 1 ; i <= n ; i ++ ) sums += ( i * i ) ; return sums ; }
function Series ( x , n ) { var sum = 1 , term = 1 , fct = 1 ; var p = 1 , multi = 1 ; for ( let i = 1 ; i < n ; i ++ ) { fct = fct * multi * ( multi + 1 ) ; p = p * x * x ; term = ( - 1 ) * term ; multi += 2 ; sum = sum + ( term * p ) / fct ; } return sum ; }
function fib ( n ) { if ( n < 6 ) return f [ n ] ; let t = 5 , fn = 5 ; while ( t < n ) { fn = Math . round ( fn * PHI ) ; t ++ ; } return fn ; }
function first ( a , b , c ) { a %= b ; for ( let i = 1 ; i <= b ; i ++ ) { a = a * 10 ; if ( a / b == c ) return i ; a %= b ; } return - 1 ; }
function timeToMeet ( s , v ) { var V = 3 * v / 2 ; var time = s / V ; document . write ( time . toFixed ( 6 ) ) ; }
function sumOfTheSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let k = 1 ; for ( let j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; }
function sumOfTheSeries ( n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; }
function checksum ( n ) { if ( n % 3 == 0 ) document . write ( n / 3 - 1 + " " + n / 3 + " " + ( n / 3 + 1 ) ) ; else document . write ( " " ) ; }
function solution ( a , b , n ) { for ( let i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) { document . write ( " " + i + " " + ( n - ( i * a ) ) / b ) ; return ; } } document . write ( " " ) ; }
function divisorSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; ++ i ) { for ( let j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } } return sum ; }
function divisorSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; ++ i ) sum += Math . floor ( n / i ) * i ; return sum ; }
function sum_all_divisors ( num ) { var sum = 0 ; for ( var i = 1 ; i <= Math . sqrt ( num ) ; i ++ ) { sum += t1 + t2 ; } return sum ; }
function sumOfSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= i ; j ++ ) sum += j ; return sum ; }
function printbinomial ( max ) { for ( let m = 0 ; m <= max ; m ++ ) { document . write ( m ) ; let binom = 1 ; for ( let x = 0 ; x <= m ; x ++ ) { if ( m != 0 && x != 0 ) binom = binom * ( m - x + 1 ) / x ; document . write ( " " + binom + " " ) ; } document . write ( " " ) ; } }
function binomialCoeffSum ( n ) { return ( 1 << n ) ; }
function evenPowerSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let j = 2 * i ; sum = sum + ( j * j * j * j ) ; } return sum ; }
function evenPowerSum ( n ) { return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) / 15 ; }
function quadrant ( x , y ) { if ( x > 0 && y > 0 ) document . write ( " " ) ; else if ( x < 0 && y > 0 ) document . write ( " " ) ; else if ( x < 0 && y < 0 ) document . write ( " " ) ; else if ( x > 0 && y < 0 ) document . write ( " " ) ; else if ( x == 0 && y > 0 ) document . write ( " " ) ; else if ( x == 0 && y < 0 ) document . write ( " " ) ; else if ( y == 0 && x < 0 ) document . write ( " " ) ; else if ( y == 0 && x > 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function squaresum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
function squaresum ( n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; }
function counLastDigitK ( low , high , k ) { let count = 0 ; for ( let i = low ; i <= high ; i ++ ) if ( i % 10 == k ) count ++ ; return count ; }
function counLastDigitK ( low , high , k ) { let mlow = 10 * ( Math . ceil ( low / 10.0 ) ) ; let mhigh = 10 * ( Math . floor ( high / 10.0 ) ) ; let count = ( mhigh - mlow ) / 10 ; if ( high % 10 >= k ) count ++ ; if ( low % 10 <= k && ( low % 10 ) > 0 ) count ++ ; return count ; }
function polite ( n ) { n += 1 ; let base = 2 ; return n + ( Math . log ( ( n + ( Math . log ( n ) / Math . log ( base ) ) ) ) ) / Math . log ( base ) ; }
function numberOfTriangles ( n ) { var ans = 2 * ( Math . pow ( 3 , n ) ) - 1 ; return ans ; }
function motzkin ( n ) { if ( n == 0 n == 1 ) return 1 ; return ( ( 2 * n + 1 ) * motzkin ( n - 1 ) + ( 3 * n - 3 ) * motzkin ( n - 2 ) ) / ( n + 2 ) ; }
function sumOfSeries ( n ) { return ( 0.666 ) * ( 1 - 1 / Math . pow ( 10 , n ) ) ; }
function getResult ( st ) { let sum = 0 ; let length = st . length ; for ( let i = 0 ; i < length ; i ++ ) { sum = sum + Math . pow ( st [ i ] - ' ' , length ) ; } let number = parseInt ( st , 10 ) ; if ( number == sum ) return " " ; else return " " ; }
function solve ( low , high , T ) { while ( low <= high ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( ( mid * ( mid + 1 ) ) == T ) return mid ; if ( mid > 0 && ( mid * ( mid + 1 ) ) > T && ( mid * ( mid - 1 ) ) <= T ) return mid - 1 ; if ( ( mid * ( mid + 1 ) ) > T ) high = mid - 1 ; else low = mid + 1 ; } return - 1 ; }
function nthSHN ( n , dp ) { if ( n == 1 n == 2 ) return dp [ n ] = 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; return dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n ; }
function summation ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
function isOverflow ( a , b ) { if ( a == 0 b == 0 ) return false ; var result = a * b ; if ( result >= 9223372036854775807 result <= - 9223372036854775808 ) result = 0 if ( a == parseInt ( result / b ) ) return false ; else return true ; }
function evenSum ( n ) { let curr = 2 , sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; }
function evenSum ( n ) { return ( n * ( n + 1 ) ) ; }
function kthgroupsum ( k ) { let cur = ( k * ( k - 1 ) ) + 1 ; let sum = 0 ; while ( k -- ) { sum += cur ; cur += 2 ; } return sum ; }
function kthgroupsum ( k ) { return k * k * k ; }
function oddSum ( n ) { let sum = 0 ; curr = 1 ; for ( let i = 0 ; i < n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; }
function oddSum ( n ) { return ( n * n ) ; }
function Convert ( radian ) { let pi = 3.14159 ; return ( radian * ( 180 / pi ) ) ; }
function nthTerm ( n ) { return ( n * n ) + ( n * n * n ) ; }
function prletKPFNums ( A , B , K ) { let prime = [ ] ; for ( let i = 0 ; i < B + 1 ; i ++ ) prime [ i ] = true ; let p_factors = [ ] ; for ( let i = 0 ; i < B + 1 ; i ++ ) p_factors [ i ] = 0 ; for ( let p = 2 ; p <= B ; p ++ ) if ( p_factors [ p ] == 0 ) for ( let i = p ; i <= B ; i += p ) p_factors [ i ] ++ ; for ( let i = A ; i <= B ; i ++ ) if ( p_factors [ i ] == K ) document . write ( i + " " ) ; }
function distance ( x1 , y1 , x2 , y2 ) { return Math . sqrt ( Math . pow ( x2 - x1 , 2 ) + Math . pow ( y2 - y1 , 2 ) * 1.0 ) ; }
function printXYZ ( n ) { if ( n == 1 ) document . write ( - 1 ) ; else document . write ( " " + n + " " + ( n + 1 ) + " " + n * ( n + 1 ) ) ; }
function seriesSum ( n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
function term ( n ) { let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) ans += i ; return ans ; }
function term ( n ) { return parseInt ( n * ( n + 1 ) / 2 ) ; }
function avgOfFirstN ( n ) { return ( 1 + n ) / 2 ; }
function summation ( n ) { let sum ; sum = ( Math . pow ( 10 , n + 1 ) - 10 - ( 9 * n ) ) / 81 ; return sum ; }
function sum ( x , n ) { let total = 1.0 ; let multi = x ; for ( let i = 1 ; i <= n ; i ++ ) { total = total + multi / i ; multi = multi * x ; } return total ; }
function term ( n ) { let x = parseInt ( ( ( 1 ) + Math . sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ; return x ; }
function isMember ( a , d , x ) { if ( d == 0 ) return ( x == a ) ; return ( ( x - a ) % d == 0 && ( x - a ) / d >= 0 ) ; }
function compute ( a , b ) { var AM = ( a + b ) / 2 ; var GM = Math . sqrt ( a * b ) ; var HM = ( GM * GM ) / AM ; return HM ; }
function minOp ( num ) { var rem ; var count = 0 ; while ( num ) { rem = num % 10 ; if ( ! ( rem == 3 rem == 8 ) ) count ++ ; num = parseInt ( num / 10 ) ; } return count ; }
function sumSquare ( n ) { for ( i = 1 ; i * i <= n ; i ++ ) for ( j = 1 ; j * j <= n ; j ++ ) if ( i * i + j * j == n ) { document . write ( i + " " + j + " " + " " ) ; return true ; } return false ; }
function sumSquare ( n ) { let s = new Map ( ) ; for ( let i = 0 ; i * i <= n ; ++ i ) { s . set ( i * i , 1 ) ; if ( s . has ( n - i * i ) ) { document . write ( Math . sqrt ( n - i * i ) + " " + i + " " ) ; return true ; } } return false ; }
function judgeSquareSum ( n ) { for ( i = 2 ; i * i <= n ; i ++ ) { var count = 0 ; if ( n % i == 0 ) { while ( n % i == 0 ) { count ++ ; n = parseInt ( n / i ) ; } if ( i % 4 == 3 && count % 2 != 0 ) return false ; } } return n % 4 != 3 ; }
function findK ( n , k ) { let a = [ ] ; for ( let i = 1 ; i < n ; i ++ ) if ( i % 2 == 1 ) a . push ( i ) ; for ( let i = 1 ; i < n ; i ++ ) if ( i % 2 == 0 ) a . push ( i ) ; return ( a [ k - 1 ] ) ; }
function sum ( L , R ) { let p = Math . floor ( R / 6 ) ; let q = Math . floor ( ( L - 1 ) / 6 ) ; let sumR = Math . floor ( 3 * ( p * ( p + 1 ) ) ) ; let sumL = Math . floor ( ( q * ( q + 1 ) ) * 3 ) ; return sumR - sumL ; }
function max_area ( n , m , k ) { if ( k > ( n + m - 2 ) ) document . write ( " " ) ; else { let result ; if ( k < Math . max ( m , n ) - 1 ) { result = Math . max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; } else { result = Math . max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; } document . write ( result ) ; } }
function countDigitOne ( n ) { let countr = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let str = i . toString ( ) ; countr += str . split ( " " ) . length - 1 ; } return countr ; }
function countDigitOne ( n ) { var countr = 0 ; for ( var i = 1 ; i <= n ; i *= 10 ) { var divider = i * 10 ; countr += parseInt ( n / divider ) * i + Math . min ( Math . max ( n % divider - i + 1 , 0 ) , i ) ; } return countr ; }
function asPowerSum ( w , m ) { while ( m > 0 ) { if ( ( m - 1 ) % w == 0 ) m = ( m - 1 ) / w ; else if ( ( m + 1 ) % w == 0 ) m = ( m + 1 ) / w ; else if ( m % w == 0 ) m = m / w ; else } return ( m == 0 ) ; }
function divisible ( num ) { let n = num . length ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += ( num . charAt ( i ) ) ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return - 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( sum % 3 == ( num . charAt ( i ) - ' ' ) % 3 ) return 1 ; if ( n == 2 ) return - 1 ; return 2 ; }
function calculate ( n , power ) { sum = 0 ; bp = Math . pow ( n , power ) ; while ( bp != 0 ) { d = bp % 10 ; sum = sum + d ; bp = Math . floor ( bp / 10 ) ; } return sum ; }
function totalNumber ( n ) { return 8 * Math . pow ( 9 , n - 1 ) ; }
function coutSubSeq ( A , N , M ) { let sum = 0 ; let ans = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { for ( let k = j + 1 ; k < N ; k ++ ) { sum = A [ i ] + A [ j ] + A [ k ] ; if ( sum % M == 0 ) ans ++ ; } } } return ans ; }
function findTerm ( n ) { if ( n == 1 ) return n ; else { let term = 7 ; for ( let i = 2 ; i <= n ; i ++ ) term = term * 2 + ( i - 1 ) ; return term ; } }
function findNumber ( n ) { n -- ; let i = 1 ; while ( n >= 0 ) { n -= i ; ++ i ; } return ( n + i ) ; }
function findNumber ( n ) { let x = Math . floor ( ( - 1 + Math . sqrt ( 1 + 8 * n - 8 ) ) / 2 ) ; let base = ( x * ( x + 1 ) ) / 2 + 1 ; return n - base + 1 ; }
function correlationCoefficient ( X , Y , n ) { let sum_X = 0 , sum_Y = 0 , sum_XY = 0 ; let squareSum_X = 0 , squareSum_Y = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum_X = sum_X + X [ i ] ; sum_Y = sum_Y + Y [ i ] ; sum_XY = sum_XY + X [ i ] * Y [ i ] ; squareSum_X = squareSum_X + X [ i ] * X [ i ] ; squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ; } let corr = ( n * sum_XY - sum_X * sum_Y ) / ( Math . sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ) ; return corr ; }
function result ( n , k , t ) { if ( t <= k ) document . write ( t ) ; else if ( t <= n ) document . write ( k ) ; else { let temp = t - n ; temp = k - temp ; document . write ( temp ) ; } }
function weightedMean ( X , W , n ) { let sum = 0 , numWeight = 0 ; for ( let i = 0 ; i < n ; i ++ ) { numWeight = numWeight + X [ i ] * W [ i ] ; sum = sum + W [ i ] ; } return ( numWeight ) / sum ; }
function weightedMean ( n ) { return parseInt ( ( 2 * n + 1 ) / 3 , 10 ) ; }
function series ( n ) { return ( 8 * n * n ) + 1 ; }
function gcd ( a , b ) { if ( a < b ) return gcd ( b , a ) ; if ( Math . abs ( b ) < 0.001 ) return a ; else return ( gcd ( b , a - Math . floor ( a / b ) * b ) ) ; }
function harmonicMean ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum = sum + ( 1 / arr [ i ] ) ; return n / sum ; }
function harmonicMean ( arr , freq , n ) { let sum = 0 , frequency_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum = sum + ( freq [ i ] / arr [ i ] ) ; frequency_sum = frequency_sum + freq [ i ] ; } return frequency_sum / sum ; }
function calculate ( a , b , n , m ) { let mul = 1 ; for ( let i = 0 ; i < m ; i ++ ) if ( b [ i ] != 0 ) mul = mul * b [ i ] ; for ( let i = 0 ; i < n ; i ++ ) { let x = Math . floor ( a [ i ] / mul ) ; document . write ( x + " " ) ; } }
function calculate_sum ( a , N ) { m = N / a ; sum = m * ( m + 1 ) / 2 ; ans = a * sum ; return ans ; }
function print ( n ) { document . write ( n + parseInt ( n / 2 ) + " " ) ; for ( i = 2 ; i <= n ; i += 2 ) document . write ( i + " " ) ; for ( i = 1 ; i <= n ; i += 2 ) document . write ( i + " " ) ; for ( i = 2 ; i <= n ; i += 2 ) document . write ( i + " " ) ; }
function gcdMax ( a , b , n , N ) { let cnt = Array . from ( { length : N } , ( _ , i ) => 0 ) ; let first = Array . from ( { length : N } , ( _ , i ) => 0 ) ; let second = Array . from ( { length : N } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; ++ i ) cnt [ a [ i ] ] = 1 ; for ( let i = 1 ; i < N ; ++ i ) for ( let j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) first [ i ] = Math . max ( first [ i ] , j ) ; cnt = Array . from ( { length : N } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; ++ i ) cnt [ b [ i ] ] = 1 ; for ( let i = 1 ; i < N ; ++ i ) for ( let j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) second [ i ] = Math . max ( second [ i ] , j ) ; let x ; for ( x = N - 1 ; x >= 0 ; x -- ) if ( first [ x ] > 0 && second [ x ] > 0 ) break ; document . write ( first [ x ] + " " + second [ x ] ) ; }
function factorial ( n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
function ispowerof2 ( num ) { if ( ( num & ( num - 1 ) ) == 0 ) return 1 ; return 0 ; }
function isWoodall ( x ) { if ( x % 2 == 0 ) return false ; if ( x == 1 ) return true ; x ++ ; let p = 0 ; while ( x % 2 == 0 ) { x = x / 2 ; p ++ ; if ( p == x ) return true ; } return false ; }
function print_result ( a , n , k , m ) { var v = Array . from ( Array ( m ) , ( ) => Array ( ) ) ; for ( var i = 0 ; i < n ; i ++ ) { var rem = a [ i ] % m ; v [ rem ] . push ( a [ i ] ) ; if ( v [ rem ] . length == k ) { for ( var j = 0 ; j < k ; j ++ ) document . write ( v [ rem ] [ j ] + " " ) ; return ; } } document . write ( " " ) ; }
function complement ( number ) { number = number . split ( ' ' ) for ( let i = 0 ; i < number . length ; i ++ ) { if ( number [ i ] != ' ' ) { number [ i ] = String ( 9 - Number ( number [ i ] ) + 0 ) ; } } number = number . join ( " " ) document . write ( " " + number ) ; }
function countWays ( n ) { let count = 0 ; for ( let i = 1 ; i * i < n ; i ++ ) if ( n % i == 0 ) count ++ ; return count ; }
function isPowerOfK ( n , k ) { let oneSeen = false ; while ( n > 0 ) { let digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n = Math . floor ( n / k ) ; } return true ; }
function printFactorialNums ( n ) { let fact = 1 ; let x = 2 ; while ( fact <= n ) { document . write ( fact + " " ) ; fact = fact * x ; x ++ ; } }
function Cel_To_Fah ( n ) { return ( ( n * 9.0 / 5.0 ) + 32.0 ) ; }
function countCompositions ( n ) { return 1 << ( n - 1 ) ; }
function computeLastDigit ( A , B ) { let variable = 1 ; return 1 ; else if ( ( B - A ) >= 5 ) return 0 ; else { for ( let i = A + 1 ; i <= B ; i ++ ) variable = ( variable * ( i % 10 ) ) % 10 ; return variable % 10 ; } }
function findSumSubsets ( n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; }
function findMin ( a , n ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += Math . log ( a [ i ] ) ; var x = parseInt ( Math . exp ( sum / n ) ) ; return x + 1 ; }
function sumOfAP ( a , d , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum = sum + a ; a = a + d ; } return sum ; }
function sumOfAP ( a , d , n ) { let sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) ; return sum ; }
function sumOfSeries ( n ) { x = 0 if ( n % 2 == 0 ) x = ( n / 2 ) * ( n + 1 ) else x = ( ( n + 1 ) / 2 ) * n return ( x * x ) }
function findValue ( arr , n ) { var ans = 0 ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = 0 ; j < n ; j ++ ) ans = Math . max ( ans , Math . abs ( arr [ i ] - arr [ j ] ) + Math . abs ( i - j ) ) ; return ans ; }
function countsubarray ( array , n , k ) { var count = 0 ; var i , j , mul ; for ( i = 0 ; i < n ; i ++ ) { if ( array [ i ] < k ) count ++ ; mul = array [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { mul = mul * array [ j ] ; if ( mul < k ) count ++ ; else break ; } } return count ; }
function multiplyFactors ( n ) { let M = 1000000007 ; let i ; prod = 1 ; for ( i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) prod = ( prod * i ) % M ; else { prod = ( prod * i ) % M ; prod = ( prod * n / i ) % M ; } } } return prod ; }
function countDigit ( n ) { if ( n / 10 == 0 ) return 1 ; return 1 + countDigit ( parseInt ( n / 10 ) ) ; }
function printTrib ( n ) { let dp = Array . from ( { length : n } , ( _ , i ) => 0 ) ; dp [ 0 ] = dp [ 1 ] = 0 ; dp [ 2 ] = 1 ; for ( let i = 3 ; i < n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] ; for ( let i = 0 ; i < n ; i ++ ) document . write ( dp [ i ] + " " ) ; }
function printTrib ( n ) { if ( n < 1 ) return ; let first = 0 , second = 0 ; let third = 1 ; document . write ( first + " " ) ; if ( n > 1 ) document . write ( second + " " ) ; if ( n > 2 ) document . write ( second + " " ) ; for ( let i = 3 ; i < n ; i ++ ) { let curr = first + second + third ; first = second ; second = third ; third = curr ; document . write ( curr + " " ) ; } }
function digit_product_Sum ( N ) { var a = [ ... Array ( N ) ] ; var product = 1 ; a [ 0 ] = 1 ; for ( var i = 1 ; i <= N ; i ++ ) { product = parseInt ( a [ i - 1 ] / 10 ) ; if ( product == 0 ) product = 1 ; else product = a [ i - 1 ] % 10 ; var val = parseInt ( a [ i - 1 ] / 10 ) ; if ( val == 0 ) val = a [ i - 1 ] ; a [ i ] = a [ i - 1 ] + val * product ; } for ( var i = 0 ; i < N ; i ++ ) document . write ( a [ i ] + " " ) ; }
function geometricMean ( arr , n ) { let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) product = product * arr [ i ] ; let gm = Math . pow ( product , 1 / n ) ; return gm ; }
function geometricMean ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum = sum + Math . log ( arr [ i ] ) ; sum = sum / n ; return Math . exp ( sum ) ; }
function printTaxicab2 ( N ) { let i = 1 ; count = 0 ; while ( count < N ) { let int_count = 0 ; for ( let j = 1 ; j <= Math . pow ( i , 1.0 / 3 ) ; j ++ ) for ( let k = j + 1 ; k <= Math . pow ( i , 1.0 / 3 ) ; k ++ ) if ( j * j * j + k * k * k == i ) int_count ++ ; if ( int_count == 2 ) { count ++ ; document . write ( count + " " + i + " " ) ; } i ++ ; } }
function isMagic ( n ) { var sum = 0 ; while ( n > 0 sum > 9 ) { if ( n = 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return ( sum = 1 ) ; }
function productOfSingelDgt ( n ) { if ( n >= 0 && n <= 9 ) return true ; var prime = [ 2 , 3 , 5 , 7 ] ; for ( i = 0 ; i < SIZE && n > 1 ; i ++ ) while ( n % prime [ i ] == 0 ) n = n / prime [ i ] ; return ( n == 1 ) ; }
function isComposite ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; }
function findSum ( n ) { let sum = 0 ; for ( let x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; }
function findSum ( n ) { return n * ( n + 1 ) / 2 ; }
function findSum ( n ) { if ( n % 2 == 0 ) return ( n / 2 ) * ( n + 1 ) else return ( ( n + 1 ) / 2 ) * n }
function sackRace ( p1 , s1 , p2 , s2 ) { return ( ( s1 > s2 && ( p2 - p1 ) % ( s1 - s2 ) == 0 ) || ( s2 > s1 && ( p1 - p2 ) % ( s2 - s1 ) == 0 ) ) ; }
function count ( x , y ) { let m = new Map ( ) ; while ( x % y != 0 ) { x = x % y ; ans ++ ; if ( m . has ( x ) ) return - 1 ; m . set ( x , 1 ) ; x = x * 10 ; } return ans ; }
function xorCalc ( k ) { if ( k == 1 ) return 2 ; if ( ( ( k + 1 ) & k ) == 0 ) return parseInt ( k / 2 ) ; return 1 ; }
function divCount ( n ) { var hash = Array ( n + 1 ) . fill ( true ) ; for ( var p = 2 ; p * p < n ; p ++ ) if ( hash [ p ] == true ) for ( var i = p * 2 ; i < n ; i += p ) hash [ i ] = false ; var total = 1 ; for ( var p = 2 ; p <= n ; p ++ ) { if ( hash [ p ] ) { var count = 0 ; if ( n % p == 0 ) { while ( n % p == 0 ) { n = parseInt ( n / p ) ; count ++ ; } total = total * ( count + 1 ) ; } } } return total ; }
function maxPrimefactorNum ( N ) { if ( N < 2 ) return 0 ; arr = Array . from ( { length : N + 1 } , ( _ , i ) => false ) ; var prod = 1 , res = 0 ; for ( var p = 2 ; p * p <= N ; p ++ ) { if ( arr [ p ] == false ) { for ( var i = p * 2 ; i <= N ; i += p ) arr [ i ] = true ; prod *= p ; if ( prod > N ) return res ; res ++ ; } } return res ; }
function arraySum ( arr , n ) { let x = ( n + 1 ) / 2 ; return ( arr [ 0 ] - 1 ) * n + x * x ; }
function countDigits ( a , b ) { let count = 0 ; let p = Math . abs ( a * b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = parseInt ( p / 10 , 10 ) ; } return count ; }
function countDigits ( a , b ) { if ( a == 0 b == 0 ) return 1 ; return Math . floor ( Math . log10 ( Math . abs ( a ) ) + Math . log10 ( Math . abs ( b ) ) ) + 1 ; }
function multiple ( a , b , x ) { if ( b < 0 ) { if ( a == 1 && x == 1 ) document . write ( " " ) ; else document . write ( " " ) ; } var mul = parseInt ( Math . pow ( a , b ) ) ; var ans = mul / x ; var ans1 = x * ans ; var ans2 = x * ( ans + 1 ) ; document . write ( ( ( mul - ans1 ) <= ( ans2 - mul ) ) ? ans1 : ans2 ) ; }
function area_fun ( side ) { let area = side * side ; return area ; }
function isPalindrome ( n ) { var divisor = 1 ; while ( parseInt ( n / divisor ) >= 10 ) divisor *= 10 ; while ( n != 0 ) { var leading = parseInt ( n / divisor ) ; var trailing = n % 10 ; if ( leading != trailing ) return false ; n = parseInt ( ( n % divisor ) / 10 ) ; divisor = divisor / 100 ; } return true ; }
function lastPosition ( n , m , k ) { if ( m <= n - k + 1 ) return m + k - 1 ; m = m - ( n - k + 1 ) ; return ( m % n == 0 ) ? n : ( m % n ) ; }
function maxSum ( n ) { if ( n == 1 ) return 1 ; else return ( parseInt ( n * ( n - 1 ) / 2 , 10 ) - 1 + parseInt ( n / 2 , 10 ) ) ; }
function primesInRange ( n ) { let fact = 1 ; for ( let k = 2 ; k < n ; k ++ ) { fact = fact * ( k - 1 ) ; if ( ( fact + 1 ) % k == 0 ) document . write ( ( k + " " ) ) ; } }
function check ( n ) { return 1162261467 % n == 0 ; }
function productPuzzle ( a , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += Math . log10 ( a [ i ] ) ; for ( var i = 0 ; i < n ; i ++ ) document . write ( parseInt ( ( EPS + Math . pow ( 10.00 , sum - Math . log10 ( a [ i ] ) ) ) ) + " " ) ; }
function changeEvenBits ( n ) { let to_subtract = 0 ; let m = 0 ; for ( x = n ; x ; x >>= 2 ) { if ( x & 1 ) to_subtract += ( 1 << m ) ; m += 2 ; } return n - to_subtract ; }
function closestNumber ( n , m ) { let q = parseInt ( n / m ) ; let n1 = m * q ; let n2 = ( n * m ) > 0 ? ( m * ( q + 1 ) ) : ( m * ( q - 1 ) ) ; if ( Math . abs ( n - n1 ) < Math . abs ( n - n2 ) ) return n1 ; return n2 ; }
function checkPronic ( x ) { for ( var i = 0 ; i <= parseInt ( Math . sqrt ( x ) ) ; i ++ ) if ( x == i * ( i + 1 ) ) return true ; return false ; }
function countConsecutive ( N ) { let count = 0 ; for ( let L = 1 ; L * ( L + 1 ) < 2 * N ; L ++ ) { let a = ( ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) ) ; if ( a - parseInt ( a , 10 ) == 0.0 ) count ++ ; } return count ; }
function findMinSum ( num ) { let sum = 0 ; for ( let i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ; return sum ; }
function compute_average ( a , b ) { return Math . floor ( ( a + b ) / 2 ) ; }
function minNum ( arr , n ) { let odd = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd += 1 ; return ( ( odd % 2 ) != 0 ) ? 1 : 2 ; }
function minNum ( arr , n ) { let odd = false ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd = ! odd ; if ( odd ) return 1 ; return 2 ; }
function checkJumbled ( num ) { if ( parseInt ( num / 10 , 10 ) == 0 ) return true ; while ( num != 0 ) { if ( parseInt ( num / 10 , 10 ) == 0 ) return true ; let digit1 = num % 10 ; let digit2 = parseInt ( num / 10 , 10 ) % 10 ; if ( Math . abs ( digit2 - digit1 ) > 1 ) return false ; num = parseInt ( num / 10 , 10 ) ; } return true ; }
function pell ( n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; }
function pell ( n ) { if ( n <= 2 ) return n ; let a = 1 ; let b = 2 ; let c ; for ( let i = 3 ; i <= n ; i ++ ) { c = 2 * b + a ; a = b ; b = c ; } return b ; }
function printDemlo ( str ) { let len = str . length ; let res = " " ; for ( let i = 1 ; i <= len ; i ++ ) res += i . toString ( ) ; for ( let i = len - 1 ; i >= 1 ; i -- ) res += i . toString ( ) ; return res ; }
function NumberofTimes ( str ) { var temporary_sum = 0 , count = 0 ; while ( str . length > 1 ) { temporary_sum = 0 ; for ( i = 0 ; i < str . length ; i ++ ) temporary_sum += ( str . charAt ( i ) - ' ' ) ; str = temporary_sum + " " ; count ++ ; } return count ; }
function calculateLeaps ( n ) { if ( n == 0 n == 1 ) { return 1 ; } else { let leaps = 0 ; for ( let i = 0 ; i < n ; i ++ ) leaps += calculateLeaps ( i ) ; return leaps ; } }
function CountPairs ( n ) { let k = n ; let imin = 1 ; let ans = 0 ; while ( imin <= n ) { let imax = Math . floor ( n / k ) ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; k = Math . floor ( n / imin ) ; } return ans ; }
function PowerOFPINnfactorial ( n , p ) { let ans = 0 ; let temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; }
function totalDigits ( n ) { var number_of_digits = 0 ; for ( var i = 1 ; i <= n ; i *= 10 ) number_of_digits += ( n - i + 1 ) ; return number_of_digits ; }
function numbersWith3Divisors ( n ) { let prime = new Array ( n + 1 ) ; prime . fill ( true ) ; prime [ 0 ] = prime [ 1 ] = 0 ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } document . write ( " " + " " ) ; for ( let i = 0 ; i * i <= n ; i ++ ) if ( prime [ i ] ) document . write ( i * i + " " ) ; }
function decToHexa ( n ) { var hexaDeciNum = Array . from ( { length : 100 } , ( _ , i ) => 0 ) ; var i = 0 ; while ( n != 0 ) { var temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexaDeciNum [ i ] = String . fromCharCode ( temp + 48 ) ; i ++ ; } else { hexaDeciNum [ i ] = String . fromCharCode ( temp + 55 ) ; i ++ ; } n = parseInt ( n / 16 ) ; } for ( j = i - 1 ; j >= 0 ; j -- ) document . write ( hexaDeciNum [ j ] ) ; }
function decToBinary ( n ) { let binaryNum = new Array ( 32 ) ; let i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = Math . floor ( n / 2 ) ; i ++ ; } for ( let j = i - 1 ; j >= 0 ; j -- ) document . write ( binaryNum [ j ] ) ; }
function decimalToBinary ( N ) { var B_Number = 0 ; var cnt = 0 ; while ( N != 0 ) { var rem = N % 2 ; var c = Math . pow ( 10 , cnt ) ; B_Number += rem * c ; N = parseInt ( N / 2 ) ; cnt ++ ; } return B_Number ; }
function binaryToDecimal ( n ) { let num = n ; let dec_value = 0 ; let base = 1 ; let temp = num ; while ( temp ) { let last_digit = temp % 10 ; temp = Math . floor ( temp / 10 ) ; dec_value += last_digit * base ; base = base * 2 ; } return dec_value ; }
function stirlingFactorial ( n ) { if ( n == 1 ) return 1 ; let z ; let e = 2.71 ; z = Math . sqrt ( 2 * 3.14 * n ) * Math . pow ( ( n / e ) , n ) ; return Math . floor ( z ) ; }
function countXorPair ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) count ++ ; } return count ; }
function countXorPair ( arr , n ) { let odd = 0 , even = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return odd * even ; }
function count_of_ways ( n ) { var count = 0 ; count = ( n + 1 ) * ( n + 2 ) / 2 ; return count ; }
function numOfCombinations ( arr , N ) { let C = [ 0 , 0 , 0 ] ; for ( let i = 0 ; i < N ; ++ i ) ++ C [ arr [ i ] % 3 ] ; return C [ 1 ] * C [ 2 ] + C [ 0 ] * ( C [ 0 ] - 1 ) / 2 + C [ 0 ] * ( C [ 0 ] - 1 ) * ( C [ 0 ] - 2 ) / 6 + C [ 1 ] * ( C [ 1 ] - 1 ) * ( C [ 1 ] - 2 ) / 6 + C [ 2 ] * ( C [ 2 ] - 1 ) * ( C [ 2 ] - 2 ) / 6 + C [ 0 ] * C [ 1 ] * C [ 2 ] ; }
function findRectNum ( n ) { return n * ( n + 1 ) ; }
function nthprimedigitsnumber ( number ) { let rem ; let num = " " ; while ( number > 0 ) { rem = number % 4 ; switch ( rem ) { case 1 : num += ' ' ; break ; case 2 : num += ' ' ; break ; case 3 : num += ' ' ; break ; case 0 : num += ' ' ; break ; } if ( number % 4 == 0 ) number -- ; number = parseInt ( number / 4 , 10 ) ; } let st = num . split ( ' ' ) ; st . reverse ( ) ; return ( st . join ( " " ) ) ; }
function findNoIsDivisibleOrNot ( a , n , l ) { for ( let i = 0 ; i < l ; i ++ ) { if ( a [ i ] % n != 0 ) return false ; } return true ; }
function countPairs ( N ) { let count = 0 ; for ( let i = 1 ; i <= parseInt ( Math . pow ( N , ( 1.0 / 3.0 ) ) , 10 ) ; i ++ ) { let cb = i * i * i ; let diff = N - cb ; let cbrtDiff = parseInt ( Math . pow ( diff , ( 1.0 / 3.0 ) ) , 10 ) ; if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) count ++ ; } return count ; }
function sumOfTermsInNthRow ( n ) { let sum = n * ( 2 * Math . pow ( n , 2 ) + 1 ) ; return sum ; }
function firstDigit ( x ) { while ( x >= 10 ) x = x / 10 ; return Math . floor ( x ) ; }
function FirstDigit ( arr , n ) { let S = 0 ; for ( let i = 0 ; i < n ; i ++ ) S = S + Math . log10 ( arr [ i ] * 1.0 ) ; let fract_S = S - Math . floor ( S ) ; let ans = parseInt ( Math . pow ( 10 , fract_S ) , 10 ) ; return ans ; }
function countDigit ( n ) { var temp = n , count = 0 ; while ( temp != 0 ) { var d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) count ++ ; } return count ; }
function getOccurence ( n , d ) { let result = 0 ; let itr = d ; while ( itr <= n ) { if ( itr % 10 == d ) result ++ ; if ( itr != 0 && Math . floor ( itr / 10 ) == d ) { result ++ ; itr ++ ; } else if ( Math . floor ( itr / 10 ) == d - 1 ) itr = itr + ( 10 - d ) ; else itr = itr + 10 ; } return result ; }
function cal_cos ( n ) { let accuracy = 0.0001 , x1 , denominator , cosx , cosval ; n = n * ( 3.142 / 180.0 ) ; x1 = 1 ; cosx = x1 ; cosval = Math . cos ( n ) ; let i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= Math . abs ( cosval - cosx ) ) ; document . write ( cosx . toFixed ( 5 ) ) ; }
function findMinZero ( p ) { let first = 1 ; let second = 1 ; let number = 2 ; let next = 1 ; while ( next ) { next = ( first + second ) % p ; first = second ; second = next ; number ++ ; } return number ; }
function printOtherSides ( n ) { if ( n % 2 != 0 ) { if ( n == 1 ) document . write ( " " ) ; else { var b = ( n * n - 1 ) / 2 ; var c = ( n * n + 1 ) / 2 ; document . write ( " " + b + " " + c ) ; } } else { if ( n == 2 ) document . write ( " " ) ; else { var b = n * n / 4 - 1 ; var c = n * n / 4 + 1 ; document . write ( " " + b + " " + c ) ; } } }
function makeOdd ( n ) { if ( n % 2 != 0 ) return 1 ; var i ; for ( i = 2 ; i <= n ; i ++ ) if ( ( n % i == 0 ) && ( ( n / i ) % 2 == 1 ) ) break ; return i ; }
function makeOdd ( n ) { if ( n % 2 != 0 ) return 1 ; var ans = 1 ; while ( n % 2 == 0 ) { n = parseInt ( n / 2 ) ; ans *= 2 ; } return ans ; }
function getTotalXorOfSubarrayXors ( arr , N ) { if ( N % 2 == 0 ) return 0 ; let res = 0 ; for ( let i = 0 ; i < N ; i += 2 ) { res ^= arr [ i ] ; } return res ; }
function closestMultiple ( n , x ) { if ( x > n ) return x ; n = n + parseInt ( x / 2 , 10 ) ; n = n - ( n % x ) ; return n ; }
function isAutomorphic ( N ) { let sq = N * N ; while ( N > 0 ) { if ( N % 10 != sq % 10 ) return - 1 ; N /= 10 ; sq /= 10 ; } return 1 ; }
function printNthElement ( n ) { var arr = Array ( n + 1 ) . fill ( 0 ) ; arr [ 1 ] = 4 ; arr [ 2 ] = 7 ; for ( var i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 4 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 7 ; } return arr [ n ] ; }
function maxSumLCM ( n ) { for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { max_sum += i ; if ( n / i != i ) max_sum += ( n / i ) ; } } return max_sum ; }
function printCubes ( a , b ) { for ( let i = a ; i <= b ; i ++ ) { for ( let j = 1 ; j * j * j <= i ; j ++ ) { if ( j * j * j == i ) { document . write ( j * j * j + " " ) ; break ; } } } }
function func ( a , k ) { for ( let i = 0 ; i < a . length ; i ++ ) if ( a [ i ] % k == 0 ) return true ; return false ; }
function tidyNum ( str1 , len ) { var str = str1 . split ( ' ' ) ; for ( i = len - 2 ; i >= 0 ; i -- ) { if ( str [ i ] > str [ i + 1 ] ) { str [ i ] -- ; for ( j = i + 1 ; j < len ; j ++ ) str [ j ] = ' ' ; } } return str . join ( " " ) ; }
function findCount ( m , n ) { let num1 = 0 ; for ( let i = 0 ; i < m ; i ++ ) num1 = ( num1 * 10 ) + 9 ; let num2 = 0 ; for ( let i = 0 ; i < ( m - 1 ) ; i ++ ) num2 = ( num2 * 10 ) + 9 ; return ( ( num1 / n ) - ( num2 / n ) ) ; }
function findNthEvenDigitNumber ( n ) { let count = 0 ; for ( let i = 0 ; ; i ++ ) { let curr = i ; let isCurrEvenDigit = true ; while ( curr != 0 ) { if ( curr % 10 == 1 curr % 10 == 3 curr % 10 == 5 curr % 10 == 7 curr % 10 == 9 ) isCurrEvenDigit = false ; curr = Math . floor ( curr / 10 ) ; } if ( isCurrEvenDigit === true ) count ++ ; if ( count === n ) return i ; } }
function printBinary ( num ) { if ( num >= 1 num <= 0 ) return " " ; let binary = " " ; let frac = 0.5 ; binary += " " ; while ( num > 0 ) { if ( binary . length >= 32 ) return " " ; if ( num >= frac ) { binary += " " ; num -= frac ; } else binary += " " ; frac = frac / 2 ; } return binary ; }
function isMultipleOf10 ( n ) { return ( n % 15 == 0 ) ; }
function isDivisibleBy25 ( str ) { n = str . length ; if ( n == 1 ) return false ; return ( ( str [ n - 1 ] - ' ' == 0 && str [ n - 2 ] - ' ' == 0 ) || ( ( str [ n - 2 ] - ' ' ) * 10 + ( str [ n - 1 ] - ' ' ) ) % 25 == 0 ) ; }
function check ( str ) { let n = str . length ; if ( n == 0 && n == 1 ) return false ; if ( n == 2 ) return ( ( ( str [ n - 2 ] - ' ' ) * 10 + ( str [ n - 1 ] - ' ' ) ) % 16 == 0 ) ; if ( n == 3 ) return ( ( ( str [ n - 3 ] - ' ' ) * 100 + ( str [ n - 2 ] - ' ' ) * 10 + ( str [ n - 1 ] - ' ' ) ) % 16 == 0 ) ; let last = str [ n - 1 ] - ' ' ; let second_last = str [ n - 2 ] - ' ' ; let third_last = str [ n - 3 ] - ' ' ; let fourth_last = str [ n - 4 ] - ' ' ; return ( ( fourth_last * 1000 + third_last * 100 + second_last * 10 + last ) % 16 == 0 ) ; }
function findIndex ( n ) { if ( n <= 1 ) return n ; let a = 0 , b = 1 , c = 1 ; let res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; }
function firstkdigits ( n , k ) { let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) product *= n ; while ( Math . floor ( product / Math . pow ( 10 , k ) ) != 0 ) product = Math . floor ( product / 10 ) ; return product ; }
function checkPandigital ( b , n ) { if ( n . length < b ) return 0 ; let hash = [ ] ; for ( let i = 0 ; i < b ; i ++ ) hash [ i ] = 0 ; for ( let i = 0 ; i < n . length ; i ++ ) { if ( n [ i ] >= ' ' && n [ i ] <= ' ' ) hash [ n [ i ] - ' ' ] = 1 ; else if ( n . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) <= b - 11 ) hash [ n . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) + 10 ] = 1 ; } for ( let i = 0 ; i < b ; i ++ ) if ( hash [ i ] == 0 ) return 0 ; return 1 ; }
function convert ( m , n ) { if ( m == n ) return 0 ; if ( m > n ) return m - n ; if ( m <= 0 && n > 0 ) return - 1 ; if ( n % 2 == 1 ) return 1 + convert ( m , n + 1 ) ; else return 1 + convert ( m , n / 2 ) ; }
function moduloMultiplication ( a , b , mod ) { let res = 0 ; a = ( a % mod ) ; while ( b > 0 ) { if ( ( b & 1 ) > 0 ) { res = ( res + a ) % mod ; } a = ( 2 * a ) % mod ; } return res ; }
function numberOf2sinRange ( n ) { var s = " " ; for ( var i = 0 ; i < n + 1 ; i ++ ) s += i . toString ( ) ; var count = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( s . charAt ( i ) == ' ' ) { count ++ ; } } return count ; }
function factorial ( n ) { let M = 1000000007 ; let f = 1 ; for ( let i = 1 ; i <= n ; i ++ ) return f ; }
function mod ( a , m ) { return ( a % m + m ) % m ; }
function findStarNum ( n ) { return ( 6 * n * ( n - 1 ) + 1 ) ; }
function isDivisibleBy5 ( str ) { n = str . length ; return ( ( ( str [ n - 1 ] - ' ' ) == 0 ) || ( ( str [ n - 1 ] - ' ' ) == 5 ) ) ; }
function isTidy ( num ) { let prev = 10 ; while ( num != 0 ) { let rem = num % 10 ; num /= 10 ; if ( rem > prev ) return false ; prev = rem ; } return true ; }
function minToggle ( arr , n ) { let zero = new Array ( n + 1 ) ; zero [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; ++ i ) { if ( arr [ i - 1 ] == 0 ) zero [ i ] = zero [ i - 1 ] + 1 ; else zero [ i ] = zero [ i - 1 ] ; } let ans = n ; for ( let i = 1 ; i <= n ; ++ i ) ans = Math . min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) ; return ans ; }
function nondecdigits ( n ) { let x = 0 ; for ( x = n ; x >= 1 ; x -- ) { let no = x ; let prev_dig = 11 ; let flag = true ; while ( no != 0 ) { if ( prev_dig < no % 10 ) { flag = false ; break ; } prev_dig = no % 10 ; no = Math . floor ( no / 10 ) ; } if ( flag == true ) break ; } return x ; }
function countDivisors ( n ) { let cnt = 0 ; for ( let i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cnt ++ ; cnt = cnt + 2 ; } } return cnt ; }
function validate ( n ) { for ( let i = 0 ; i < 10 ; i ++ ) { let temp = n ; let count = 0 ; while ( temp > 0 ) { if ( temp % 10 == i ) count ++ ; if ( count > i ) return false ; temp /= 10 ; } } return true ; }
function divisibleBy36 ( num ) { let l = num . length ; if ( l == 0 ) return " " ; if ( l == 1 && num [ 0 ] != ' ' ) return " " ; let two_digit_num = ( num [ l - 2 ] - ' ' ) * 10 + ( num [ l - 1 ] - ' ' ) ; if ( two_digit_num % 4 != 0 ) return " " ; let sum = 0 ; for ( let i = 0 ; i < l ; i ++ ) sum += ( num [ i ] - ' ' ) ; if ( sum % 9 != 0 ) return " " ; return " " ; }
function check ( str ) { let n = str . length ; let digitSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - ' ' ) ; return ( digitSum % 9 == 0 ) ; }
function getTotalXorOfSubarrayXors ( arr , N ) { let res = 0 ; for ( let i = 0 ; i < N ; i ++ ) for ( let j = i ; j < N ; j ++ ) for ( let k = i ; k <= j ; k ++ ) res = res ^ arr [ k ] ; return res ; }
function getTotalXorOfSubarrayXors ( arr , N ) { let res = 0 ; for ( let i = 0 ; i < N ; i ++ ) { let freq = ( i + 1 ) * ( N - i ) ; if ( freq % 2 == 1 ) res = res ^ arr [ i ] ; } return res ; }
function check ( str ) { let n = str . length ; if ( ( str [ n - 1 ] - ' ' ) % 2 != 0 ) return false ; let digitSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - ' ' ) ; return ( digitSum % 3 == 0 ) ; }
function check ( str ) { let n = str . length ; if ( n == 0 ) return false ; if ( n == 1 ) return ( ( str [ 0 ] - ' ' ) % 8 == 0 ) ; if ( n == 2 ) return ( ( ( str [ n - 2 ] - ' ' ) * 10 + ( str [ n - 1 ] - ' ' ) ) % 8 == 0 ) ; let last = str [ n - 1 ] - ' ' ; let second_last = str [ n - 2 ] - ' ' ; let third_last = str [ n - 3 ] - ' ' ; return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) ; }
function politness ( n ) { let count = 0 ; for ( let i = 2 ; i <= Math . sqrt ( 2 * n ) ; i ++ ) { let a ; if ( ( 2 * n ) % i != 0 ) continue ; a = 2 * n ; a = Math . floor ( a / i ) ; a -= ( i - 1 ) ; if ( a % 2 != 0 ) continue ; a = Math . floor ( a / 2 ) ; if ( a > 0 ) { count ++ ; } } return count ; }
function isRefactorableNumber ( n ) { let divCount = 0 ; for ( let i = 1 ; i <= Math . sqrt ( n ) ; ++ i ) { if ( n % i == 0 ) { if ( n / i == i ) ++ divCount ; else divCount += 2 ; } } return n % divCount == 0 ; }
function check ( str ) { let n = str . length ; let digitSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - ' ' ) ; return ( digitSum % 3 == 0 ) ; }
function nthPalindrome ( n , k ) { let temp = ( k & 1 ) != 0 ? parseInt ( k / 2 , 10 ) : ( parseInt ( k / 2 , 10 ) - 1 ) ; let palindrome = parseInt ( Math . pow ( 10 , temp ) , 10 ) ; palindrome += n - 1 ; document . write ( palindrome ) ; if ( ( k & 1 ) > 0 ) palindrome = parseInt ( palindrome / 10 , 10 ) ; while ( palindrome > 0 ) { document . write ( palindrome % 10 ) ; palindrome = parseInt ( palindrome / 10 , 10 ) ; } document . write ( " " + " " ) ; }
function findMax ( n , a , b , k , m ) { let arr = new Array ( n ) ; arr . fill ( 0 ) ; for ( let i = 0 ; i < m ; i ++ ) { let lowerbound = a [ i ] ; let upperbound = b [ i ] ; for ( let j = lowerbound ; j <= upperbound ; j ++ ) arr [ j ] += k [ i ] ; } let res = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) res = Math . max ( res , arr [ i ] ) ; return res ; }
function largestGCDSubsequence ( arr , n ) { var ans = 0 ; var maxele = Math . max ( ... arr ) ; for ( var i = 2 ; i <= maxele ; ++ i ) { var count = 0 ; for ( j = 0 ; j < n ; ++ j ) { if ( arr [ j ] % i == 0 ) ++ count ; } ans = Math . max ( ans , count ) ; } return ans ; }
function countOfBinaryNumberLessThanN ( N ) { var q = [ ] ; q . push ( 1 ) ; var cnt = 0 ; var t ; while ( q . length > 0 ) { t = q . pop ( ) ; if ( t <= N ) { cnt ++ ; q . push ( t * 10 ) ; q . push ( t * 10 + 1 ) ; } } return cnt ; }
function SubArraySum ( arr , n ) { let result = 0 , temp = 0 ; for ( let i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( let j = i ; j < n ; j ++ ) { temp += arr [ j ] ; result += temp ; } } return result ; }
function SubArraySum ( arr , n ) { let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) ; return result ; }
function nthElement ( a , b , n ) { let seq = [ ] ; for ( let i = 1 ; i <= n ; i ++ ) seq . push ( a * i ) ; seq . sort ( function ( a , b ) { return a - b } ) ; for ( let i = 1 , k = n ; i <= n && k > 0 ; i ++ ) { if ( ! seq . includes ( b * i ) ) { seq . push ( b * i ) ; seq . sort ( function ( a , b ) { return a - b } ) ; k -- ; } } return seq [ n - 1 ] ; }
function sumofproduct ( n ) { var ans = 0 ; for ( x = 1 ; x <= n ; x ++ ) { var y = parseInt ( n / x ) ; ans += ( y * x ) ; } return ans ; }
function lastNon0Digit ( n ) { if ( n < 10 ) return dig [ n ] ; if ( ( parseInt ( n / 10 , 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( parseInt ( n / 5 , 10 ) ) * dig [ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( parseInt ( n / 5 , 10 ) ) * dig [ n % 10 ] ) % 10 ; }
function minPower ( n , x ) { if ( x == 1 ) return n ; let ans = 0 ; while ( n > 0 ) { ans += ( n % x ) ; n = Math . floor ( n / x ) ; } return ans ; }
function calSum ( n ) { let a = 3 , b = 0 , c = 2 ; return 3 ; return 3 ; return 5 ; let sum = 5 ; while ( n > 2 ) { let d = a + b ; sum += d ; a = b ; b = c ; c = d ; n -- ; } return sum ; }
function findKHCF ( x , y , k ) { let small = Math . min ( x , y ) ; let count = 1 ; for ( let i = 2 ; i <= small ; i ++ ) { if ( x % i == 0 && y % i == 0 ) count ++ ; if ( count == k ) return i ; } return - 1 ; }
function firstFactorialDivisibleNumber ( x ) { var fact = 1 ; for ( i = 1 ; i < x ; i ++ ) { fact = fact * i ; if ( fact % x == 0 ) break ; } return i ; }
function highestPowerof2 ( n ) { let res = 0 ; for ( let i = n ; i >= 1 ; i -- ) { if ( ( i & ( i - 1 ) ) == 0 ) { res = i ; break ; } } return res ; }
function highestPowerof2 ( n ) { let p = parseInt ( Math . log ( n ) / Math . log ( 2 ) , 10 ) ; return Math . pow ( 2 , p ) ; }
function countMaxChoco ( money , price , wrap ) { if ( money < price ) return 0 ; let choc = parseInt ( money / price , 10 ) ; choc = choc + parseInt ( ( choc - 1 ) / ( wrap - 1 ) , 10 ) ; return choc ; }
function findSum ( N , K ) { let ans = 0 ; for ( let i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; }
function findSum ( N , K ) { let ans = 0 ; let y = N / K ; let x = N % K ; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; }
function maxHandshake ( n ) { return ( n * ( n - 1 ) ) / 2 ; }
function countNums ( n , x , y ) { arr = Array ( n + 1 ) . fill ( false ) ; if ( x <= n ) arr [ x ] = true ; if ( y <= n ) arr [ y ] = true ; var result = 0 ; for ( i = Math . min ( x , y ) ; i <= n ; i ++ ) { if ( arr [ i ] ) { if ( i + x <= n ) arr [ i + x ] = true ; if ( i + y <= n ) arr [ i + y ] = true ; result ++ ; } } return result ; }
function canBeSumofConsec ( n ) { return ( ( ( n & ( n - 1 ) ) != 0 ) && n != 0 ) ; }
function evenFibSum ( limit ) { if ( limit < 2 ) return 0 ; let ef1 = 0 , ef2 = 2 ; let sum = ef1 + ef2 ; while ( ef2 <= limit ) { let ef3 = 4 * ef2 + ef1 ; if ( ef3 > limit ) break ; ef1 = ef2 ; ef2 = ef3 ; sum += ef2 ; } return sum ; }
function evenFib ( n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ; return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; }
function countSteps ( x , y ) { if ( x % y == 0 ) return Math . floor ( x / y ) ; return Math . floor ( x / y ) + countSteps ( y , x % y ) ; }
function findCountOfSolutions ( n , p ) { let ans = 0 ; for ( let x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { let last = x + p * ( n / p ) ; if ( last > n ) last -= p ; ans += ( ( last - x ) / p + 1 ) ; } } return ans ; }
function spellsCount ( num ) { let n = num . length ; let result = 1 ; for ( let i = 0 ; i < n ; i ++ ) { let count = 1 ; while ( i < n - 1 && num [ i + 1 ] == num [ i ] ) { count ++ ; i ++ ; } result = result * Math . pow ( 2 , count - 1 ) ; } return result ; }
function sqroot ( s ) { var pSq = 0 ; var N = 0 ; for ( i = parseInt ( s ) ; i > 0 ; i -- ) { for ( j = 1 ; j < i ; j ++ ) { if ( j * j == i ) { pSq = i ; N = j ; break ; } } if ( pSq > 0 ) break ; } var d = s - pSq ; var P = ( d / ( 2.0 * N ) ) ; var A = N + P ; var sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) ; return sqrt_of_s ; }
function maxProd ( n ) { if ( n == 2 n == 3 ) return ( n - 1 ) ; let res = 1 ; while ( n > 4 ) { n -= 3 ; res *= 3 ; } return ( n * res ) ; }
function getSum ( n ) { let sum = 0 ; while ( n > 0 sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum = sum + n % 10 ; n = Math . floor ( n / 10 ) ; } return sum ; }
function digSum ( n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
function countMultiples ( n ) { return Math . floor ( n / 3 + n / 7 - n / 21 ) ; }
function nonFibonacci ( n ) { let prevPrev = 1 , prev = 2 , curr = 3 ; while ( n > 0 ) { prevPrev = prev ; prev = curr ; curr = prevPrev + prev ; n = n - ( curr - prev - 1 ) ; } n = n + ( curr - prev - 1 ) ; return prev + n ; }
function countOddSquares ( n , m ) { return Math . pow ( m , 0.5 ) - Math . pow ( n - 1 , 0.5 ) ; }
function gcd ( a , b ) { if ( a == b ) return a ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; { return gcd ( a >> 1 , b ) ; return gcd ( a >> 1 , b >> 1 ) << 1 ; } if ( ( ~ b & 1 ) == 1 ) return gcd ( a , b >> 1 ) ; if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ; return gcd ( ( b - a ) >> 1 , a ) ; }
function findPieces ( n ) { return ( n * ( n + 1 ) ) / 2 + 1 ; }
function findDigits ( n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; let x = ( ( n * Math . log10 ( n / Math . E ) + Math . log10 ( 2 * Math . PI * n ) / 2.0 ) ) ; return Math . floor ( x ) + 1 ; }
function findDigits ( n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; let digits = 0 ; for ( let i = 2 ; i <= n ; i ++ ) digits += Math . log10 ( i ) ; return Math . floor ( digits ) + 1 ; }
function findPairs ( n ) { var cubeRoot = parseInt ( Math . pow ( n , 1.0 / 3.0 ) ) ; var cube = Array . from ( { length : cubeRoot + 1 } , ( _ , i ) => 0 ) ; for ( i = 1 ; i <= cubeRoot ; i ++ ) cube [ i ] = i * i * i ; var l = 1 ; var r = cubeRoot ; while ( l < r ) { if ( cube [ l ] + cube [ r ] < n ) l ++ ; else if ( cube [ l ] + cube [ r ] > n ) r -- ; else { document . write ( " " + l + " " + r + " " ) ; l ++ ; r -- ; } } }
function countEvenSum ( arr , n ) { let result = 0 ; for ( let i = 0 ; i <= n - 1 ; i ++ ) { let sum = 0 ; for ( let j = i ; j <= n - 1 ; j ++ ) { sum = sum + arr [ j ] ; if ( sum % 2 == 0 ) result ++ ; } } return ( result ) ; }
function countEvenSum ( a , n ) { let res = 0 ; let s = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( a [ i ] % 2 == 1 ) { s = n - i - 1 - s ; } else { s = s + 1 ; } res = res + s ; } return res ; }
function calculateSum ( n ) { let fibo = [ ] ; if ( n <= 0 ) return 0 ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; let sum = fibo [ 0 ] + fibo [ 1 ] ; for ( let i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += fibo [ i ] ; } return sum ; } let n = 4 ; document . write ( ` ${ calculateSum ( n ) }
function isPower ( x , y ) { var res1 = parseInt ( Math . log ( y ) ) / parseInt ( Math . log ( x ) ) ; var res2 = Math . log ( y ) / Math . log ( x ) ; return ( res1 == res2 ) ; }
function isPerfectSquare ( n ) { for ( let sum = 0 , i = 1 ; sum < n ; i += 2 ) { sum += i ; if ( sum == n ) return true ; } return false ; }
function findCount ( d ) { return 9 * ( ( Math . pow ( 10 , d - 1 ) ) - ( Math . pow ( 9 , d - 1 ) ) ) ; }
function countDyckPaths ( n ) { let res = 1 ; for ( let i = 0 ; i < n ; ++ i ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; }
function countDivisors ( n ) { let count = 0 ; for ( let i = 1 ; i <= Math . sqrt ( n ) + 1 ; i ++ ) { if ( n % i == 0 ) count += ( Math . floor ( n / i ) == i ) ? 1 : 2 ; } if ( count % 2 == 0 ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; }
function printDivisors ( n ) { let v = [ ] ; let t = 0 ; for ( let i = 1 ; i <= parseInt ( Math . sqrt ( n ) ) ; i ++ ) { if ( n % i == 0 ) { if ( parseInt ( n / i ) == i ) document . write ( i + " " ) ; else { document . write ( i + " " ) ; v [ t ++ ] = parseInt ( n / i ) ; } } } for ( let i = v . length - 1 ; i >= 0 ; i -- ) { document . write ( v [ i ] + " " ) ; } }
function printDivisors ( n ) { for ( i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) document . write ( i + " " ) ; }
function printDivisors ( n ) { for ( let i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( parseInt ( n / i , 10 ) == i ) document . write ( i ) ; else document . write ( i + " " + parseInt ( n / i , 10 ) + " " ) ; } } }
function isTriangular ( num ) { if ( num < 0 ) return false ; let sum = 0 ; for ( let n = 1 ; sum <= num ; n ++ ) { sum = sum + n ; if ( sum == num ) return true ; } return false ; }
function isTriangular ( num ) { if ( num < 0 ) return false ; var c = ( - 2 * num ) ; var b = 1 , a = 1 ; var d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return false ; var root1 = ( - b + Math . sqrt ( d ) ) / ( 2 * a ) ; var root2 = ( - b - Math . sqrt ( d ) ) / ( 2 * a ) ; if ( root1 > 0 && Math . floor ( root1 ) == root1 ) return true ; if ( root2 > 0 && Math . floor ( root2 ) == root2 ) return true ; return false ; }
function fractionToDecimal ( numr , denr ) { let res = " " ; let mp = new Map ( ) ; mp . clear ( ) ; let rem = numr % denr ; while ( ( rem != 0 ) && ( ! mp . has ( rem ) ) ) { mp . set ( rem , res . length ) ; rem = rem * 10 ; let res_part = Math . floor ( rem / denr ) ; res += res_part . toString ( ) ; rem = rem % denr ; } if ( rem == 0 ) return " " ; else if ( mp . has ( rem ) ) return res . substr ( mp . get ( rem ) ) ; return " " ; }
function greyConverter ( n ) { return n ^ ( n >> 1 ) ; }
function seriesSum ( calculated , current , N ) { let i , cur = 1 ; if ( current == N + 1 ) return 0 ; for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ; return cur + seriesSum ( i , current + 1 , N ) ; }
function SieveOfSundaram ( n ) { let nNew = ( n - 1 ) / 2 ; let marked = [ ] ; for ( let i = 0 ; i < nNew + 1 ; i ++ ) marked [ i ] = false ; for ( let i = 1 ; i <= nNew ; i ++ ) for ( let j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) document . write ( 2 + " " ) ; for ( let i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) document . write ( 2 * i + 1 + " " ) ; return - 1 ; }
function squareRootExists ( n , p ) { n = n % p ; for ( let x = 2 ; x < p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; }
function modFact ( n , p ) { if ( n >= p ) return 0 ; let result = 1 ; for ( let i = 1 ; i <= n ; i ++ ) result = ( result * i ) % p ; return result ; }
function findMinX ( num , rem , k ) { while ( true ) { var j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ; if ( j == k ) return x ; x ++ ; } }
function countSquares ( m , n ) { if ( n < m ) [ m , n ] = [ n , m ] ; return m * ( m + 1 ) * ( 2 * m + 1 ) / 6 + ( n - m ) * m * ( m + 1 ) / 2 ; }
function countSquares ( m , n ) { if ( n < m ) { var temp = m ; m = n ; n = temp ; } return n * ( n + 1 ) * ( 3 * m - n + 1 ) / 6 ; }
function countWays ( n ) { for ( let i = 1 ; i < n ; i ++ ) for ( let j = i ; j < n ; j ++ ) for ( let k = j ; k < n ; k ++ ) for ( let l = k ; l < n ; l ++ ) if ( i + j + k + l == n ) counter ++ ; return counter ; }
function pairAndSum ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] & arr [ j ] ; return ans ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; for ( let i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
function computeTotient ( n ) { let phi = new Array ( n + 1 ) ; for ( let i = 1 ; i <= n ; i ++ ) phi [ i ] = i ; for ( let p = 2 ; p <= n ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( let i = 2 * p ; i <= n ; i += p ) { phi [ i ] = parseInt ( phi [ i ] / p , 10 ) * ( p - 1 ) ; } } } for ( let i = 1 ; i <= n ; i ++ ) document . write ( " " + i + " " + phi [ i ] + " " ) ; }
function isInside ( circle_x , circle_y , rad , x , y ) { if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) return true ; else return false ; } var x = 1 ; var y = 1 ; var circle_x = 0 ; var circle_y = 1 ; var rad = 2 ; if ( isInside ( circle_x , circle_y , rad , x , y ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function isFancy ( num ) { var fp = new Map ( ) ; fp . set ( ' ' , ' ' ) ; fp . set ( ' ' , ' ' ) ; fp . set ( ' ' , ' ' ) ; fp . set ( ' ' , ' ' ) ; fp . set ( ' ' , ' ' ) ; var n = num . length ; var l = 0 , r = n - 1 ; while ( l <= r ) { if ( ! fp . has ( num . charAt ( l ) ) || fp . get ( num . charAt ( l ) ) != num . charAt ( r ) ) return false ; l ++ ; r -- ; } return true ; }
function sumBitDifferences ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < 32 ; i ++ ) { let count = 0 ; for ( let j = 0 ; j < n ; j ++ ) if ( ( arr [ j ] & ( 1 << i ) ) ) count ++ ; ans += ( count * ( n - count ) * 2 ) ; } return ans ; }
function isPerfect ( n ) { sum = 1 ; for ( let i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return true ; return false ; }
function isLucky ( n ) { var arr = Array ( 10 ) . fill ( 0 ) ; for ( var i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { var digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = parseInt ( n / 10 ) ; } return true ; }
function mod ( num , a ) { let res = 0 ; for ( let i = 0 ; i < num . length ; i ++ ) res = ( res * 10 + num [ i ] - ' ' ) % a ; return res ; }
function nthMagicNo ( n ) { let pow = 1 , answer = 0 ; while ( n != 0 ) { pow = pow * 5 ; if ( ( n & 1 ) == 1 ) answer += pow ; n >>= 1 ; } return answer ; }
function modInverse ( a , m ) { for ( let x = 1 ; x < m ; x ++ ) if ( ( ( a % m ) * ( x % m ) ) % m == 1 ) return x ; }
function modInverse ( a , m ) { let m0 = m ; let y = 0 ; let x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { let q = parseInt ( a / m ) ; let t = m ; m = a % m ; a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) x += m0 ; return x ; } let a = 3 ; let m = 11 ; document . write ( ` ${ modInverse ( a , m ) }
function phi ( n ) { let result = n ; for ( let p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) n /= p ; result *= ( 1.0 - ( 1.0 / p ) ) ; } } if ( n > 1 ) result *= ( 1.0 - ( 1.0 / n ) ) ; return parseInt ( result ) ; } for ( let n = 1 ; n <= 10 ; n ++ ) document . write ( ` ${ n } ${ phi ( n ) }
function largestPower ( n , p ) { let x = 0 ; while ( n ) { n = parseInt ( n / p ) ; x += n ; } return Math . floor ( x ) ; }
function countOfMultiples ( n ) { return ( parseInt ( n / 3 , 10 ) + parseInt ( n / 5 , 10 ) - parseInt ( n / 15 , 10 ) ) ; }
function getPeriod ( n ) { let rem = 1 ; for ( let i = 1 ; i <= n + 1 ; i ++ ) rem = ( 10 * rem ) % n ; let d = rem ; let count = 0 ; do { rem = ( 10 * rem ) % n ; count ++ ; } while ( rem != d ) ; return count ; }
function getRemainder ( num , divisor ) { let t = ( num - divisor * parseInt ( num / divisor ) ) ; return t ; }
function getRemainder ( num , divisor ) { while ( num >= divisor ) num -= divisor ; return num ; }
function sum ( n ) { let sum = 0 ; let fact = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { fact *= i ; sum += 1.0 / fact ; } return sum . toFixed ( 5 ) ; }
function print ( n , k ) { let rem = 1 ; let ans = ' ' ; for ( let i = 0 ; i < k ; i ++ ) { ans += Math . floor ( ( ( 10 * rem ) / n ) ) ; rem = ( 10 * rem ) % n ; } document . write ( ans ) }
function printSquares ( n ) { let square = 0 , odd = 1 ; for ( let x = 0 ; x < n ; x ++ ) { document . write ( square + " " ) ; square = square + odd ; odd = odd + 2 ; } }
function printFibonacciNumbers ( n ) { let f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; document . write ( f1 + " " ) ; for ( i = 1 ; i < n ; i ++ ) { document . write ( f2 + " " ) ; let next = f1 + f2 ; f1 = f2 ; f2 = next ; } }
function factorial ( n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
function factorial ( n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
function gcd ( a , b ) { if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; } let a = 98 ; let b = 56 ; document . write ( ` ${ a } ${ b } ${ gcd ( a , b ) }
function isMultipleof5 ( n ) { while ( n > 0 ) n = n - 5 ; if ( n == 0 ) return true ; return false ; }
function isMultipleof5 ( n ) { str = Array ( n ) . fill ( ' ' ) ; var len = str . length ; if ( str [ len - 1 ] == ' ' str [ len - 1 ] == ' ' ) return true ; return false ; }
function powerOf2 ( n ) { if ( n == 1 ) return true ; else if ( n % 2 != 0 n == 0 ) return false ; return powerOf2 ( n / 2 ) ; }
function isPowerOfTwo ( x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }
function isPowerofTwo ( n ) { if ( n == 0 ) return false ; if ( ( n & ( ~ ( n - 1 ) ) ) == n ) return true ; return false ; }
function reversDigits ( num ) { if ( num > 0 ) { reversDigits ( Math . floor ( num / 10 ) ) ; rev_num += ( num % 10 ) * base_pos ; base_pos *= 10 ; } return rev_num ; }
function countSubsequences ( arr ) { let odd = 0 ; let even = 0 ; for ( let x of arr ) { if ( x & 1 ) odd ++ ; else even ++ ; } return ( ( 1 << odd ) - 1 ) * ( 1 << even ) ; }
function XorSum ( A , B , N , M ) { let ans = - 1 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) { if ( ans == - 1 ) ans = ( A [ i ] & B [ j ] ) ; else ans ^= ( A [ i ] & B [ j ] ) ; } } return ans ; }
function XorSum ( A , B , N , M ) { let ans1 = 0 , ans2 = 0 ; for ( let i = 0 ; i < N ; i ++ ) ans1 = ans1 ^ A [ i ] ; for ( let i = 0 ; i < M ; i ++ ) ans2 = ans2 ^ B [ i ] ; return ( ans1 & ans2 ) ; }
function getBit ( num , i ) { return ( ( num & ( 1 << i ) ) != 0 ) ; }
function clearBit ( num , i ) { let mask = ~ ( 1 << i ) ; return num & mask ; }
function countPairs ( arr , N , K ) { let mp = new Map ( ) ; let cnt = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( mp . has ( K - arr [ i ] ) ) { cnt += mp . get ( K - arr [ i ] ) ; } if ( mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . set ( arr [ i ] , 1 ) ; } } document . write ( cnt ) ; }
function prletORSumforEachElement ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) { let req_sum = 0 ; for ( let j = 0 ; j < N ; j ++ ) { req_sum += ( arr [ i ] arr [ j ] ) ; } document . write ( req_sum + " " ) ; } }
function constructArray ( A , N , K ) { let B = new Array ( N ) ; let totalXOR = A [ 0 ] ^ K ; for ( let i = 0 ; i < N ; i ++ ) B [ i ] = totalXOR ^ A [ i ] ; for ( let i = 0 ; i < N ; i ++ ) { document . write ( B [ i ] + " " ) ; } }
function countPairs ( arr , k , size ) { let count = 0 , x ; for ( let i = 0 ; i < size - 1 ; i ++ ) { for ( let j = i + 1 ; j < size ; j ++ ) { x = arr [ i ] | arr [ j ] ; if ( x == k ) count ++ ; } } document . write ( count ) ; }
function ConstructList ( Q ) { var xr = 0 ; var ans = [ ] ; for ( var i = N - 1 ; i >= 0 ; i -- ) { if ( Q [ i ] [ 0 ] == 0 ) ans . push ( Q [ i ] [ 1 ] ^ xr ) ; else xr ^= Q [ i ] [ 1 ] ; } ans . push ( xr ) ; ans . sort ( ( a , b ) => a - b ) ; return ans ; } var Q = [ [ 0 , 6 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 4 ] , [ 1 , 5 ] ] ; var ans = ConstructList ( Q ) ; ans . forEach ( element => { document . write ( " " + element ) ; }
function findMinXORSubarray ( arr , n , k ) { if ( n < k ) return ; let res_index = 0 ; let curr_xor = 0 ; for ( let i = 0 ; i < k ; i ++ ) curr_xor ^= arr [ i ] ; let min_xor = curr_xor ; for ( let i = k ; i < n ; i ++ ) { curr_xor ^= ( arr [ i ] ^ arr [ i - k ] ) ; if ( curr_xor < min_xor ) { min_xor = curr_xor ; res_index = ( i - k + 1 ) ; } } document . write ( min_xor ) ; }
function maxAndXor ( arr , n ) { let ans = Number . MAX_VALUE ; arr . sort ( ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) { ans = Math . min ( ans , arr [ i ] ^ arr [ i + 1 ] ) ; } return ans ; }
function NoCarrySum ( N , M ) { return N ^ M ; }
function FlipBits ( n ) { for ( let bit = 0 ; bit < 32 ; bit ++ ) { if ( ( ( n >> bit ) & 1 ) > 0 ) { n = n ^ ( 1 << bit ) ; break ; } } document . write ( " " ) ; document . write ( " " + n ) ; }
function FlipBits ( n ) { return n -= ( n & ( - n ) ) ; }
function constructXORArray ( A , n , K ) { let B = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) B [ i ] = A [ i ] ^ K ; for ( let i = 0 ; i < n ; i ++ ) document . write ( B [ i ] + " " ) ; document . write ( " " ) }
function find_and ( arr ) { let ans = arr [ 0 ] ; for ( let i = 0 ; i < arr . length ; i ++ ) { ans = ( ans & arr [ i ] ) ; } return ans ; }
function findNthNum ( N ) { let bit_L = 1 , last_num = 0 ; while ( bit_L * ( bit_L + 1 ) / 2 < N ) { last_num = last_num + bit_L ; bit_L ++ ; } let bit_R = N - last_num - 1 ; document . write ( ( 1 << bit_L ) + ( 1 << bit_R ) + " " ) ; }
function xorOfArray ( arr , n ) { let xor_arr = 0 ; for ( let i = 0 ; i < n ; i ++ ) { xor_arr = xor_arr ^ arr [ i ] ; } return xor_arr ; }
function isEven ( n ) { if ( n ^ 1 == n + 1 ) return true ; else return false ; }
function bitwiseOrTillN ( n ) { var result = 2 ; for ( var i = 4 ; i <= n ; i = i + 2 ) { result = result | i ; } return result ; }
function bitwiseOrTillN ( n ) { if ( n < 2 ) return 0 ; var bitCount = parseInt ( Math . log2 ( n ) + 1 ) ; return Math . pow ( 2 , bitCount ) - 2 ; }
function bitwiseAndOdd ( n ) { var result = 1 ; for ( var i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; }
function bitwiseAndOdd ( n ) { return 1 ; }
function genSequence ( n , val ) { for ( let i = 0 ; i < ( 1 << n ) ; i ++ ) { let x = i ^ ( i >> 1 ) ^ val ; document . write ( x + " " ) ; } }
function minTrees ( n ) { let count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
function extraElement ( A , B , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; for ( let i = 0 ; i < n + 1 ; i ++ ) ans ^= B [ i ] ; return ans ; }
function findLen ( arr , n , m ) { var filter = [ ] ; for ( var i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & m ) == m ) filter . push ( arr [ i ] ) ; if ( filter . length == 0 ) return 0 ; var c_and = filter [ 0 ] ; for ( var i = 1 ; i < filter . length ; i ++ ) c_and &= filter [ i ] ; if ( c_and == m ) return filter . length ; return 0 ; }
function findLen ( arr , n , m ) { var filter = [ ] ; for ( var i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] m ) == m ) filter . push ( arr [ i ] ) ; if ( filter . length == 0 ) return 0 ; var c_or = filter [ 0 ] ; for ( var i = 1 ; i < filter . length ; i ++ ) c_or |= filter [ i ] ; if ( c_or == m ) return filter . length ; return 0 ; }
function toggleBit ( n , k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; }
function clearBit ( n , k ) { return ( n & ( ~ ( 1 << ( k - 1 ) ) ) ) ; }
function maximizeExpression ( a , b ) { let result = a ; for ( let bit = MAX - 1 ; bit >= 0 ; bit -- ) { let bitOfD = 1 << bit ; let x = b & bitOfD ; if ( x == bitOfD ) { let y = result & bitOfD ; if ( y == 0 ) { result = result ^ bitOfD ; } } } return result ; }
function cntElements ( arr , n ) { let cnt = 0 ; for ( let i = 0 ; i < n - 2 ; i ++ ) { if ( arr [ i ] == ( arr [ i + 1 ] ^ arr [ i + 2 ] ) ) { cnt ++ ; } } return cnt ; }
function max_xor ( arr , n ) { let maxXor = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { maxXor = Math . max ( maxXor , arr [ i ] ^ arr [ j ] ) ; } } return maxXor ; }
function CountTriplets ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let first = arr [ i ] ; for ( let j = i + 1 ; j < n ; j ++ ) { first ^= arr [ j ] ; if ( first == 0 ) ans += ( j - i ) ; } } return ans ; }
function findMajority ( arr , n ) { let len = 32 ; let number = 0 ; for ( let i = 0 ; i < len ; i ++ ) { let countt = 0 ; for ( let j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) countt ++ ; } if ( countt > parseInt ( n / 2 , 10 ) ) number += ( 1 << i ) ; } let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] == number ) count ++ ; if ( count > parseInt ( n / 2 , 10 ) ) document . write ( number ) ; else document . write ( " " ) ; }
function countBits ( a , b ) { var count = 0 ; while ( a b ) { var last_bit_a = a & 1 ; var last_bit_b = b & 1 ; if ( last_bit_a != last_bit_b ) count ++ ; a = a >> 1 ; b = b >> 1 ; } return count ; }
function CountSetBits ( n ) { if ( n == 0 ) return 0 ; if ( ( n & 1 ) == 1 ) return 1 + CountSetBits ( n >> 1 ) ; else return CountSetBits ( n >> 1 ) ; }
function pairORSum ( arr , n ) { for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] | arr [ j ] ; return ans ; }
function multiplyByFifteen ( n ) { let prod = ( n << 4 ) ; prod = prod - n ; return prod ; }
function multiplyByFifteen ( n ) { var prod = ( n << 3 ) ; prod += ( n << 2 ) ; prod += ( n << 1 ) ; prod += n ; return prod ; }
function CalculatePairs ( a , n ) { let cnt_zero = 0 ; let cnt_one = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 0 ) cnt_zero += 1 ; else cnt_one += 1 ; } let total_XOR_pairs = cnt_zero * cnt_one ; let total_AND_pairs = ( cnt_one ) * ( cnt_one - 1 ) / 2 ; let total_OR_pairs = cnt_zero * cnt_one + ( cnt_one ) * ( cnt_one - 1 ) / 2 ; document . write ( " " + total_XOR_pairs + " " ) ; document . write ( " " + total_AND_pairs + " " ) ; document . write ( " " + total_OR_pairs + " " ) ; }
function isDefeat ( s1 , s2 , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) || ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) ) continue ; else if ( ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) || ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) ) continue ; else { return true ; } } return false ; }
function FindIndexKthBit ( n , k ) { let cnt = 0 ; let ind = 0 ; while ( n > 0 ) { if ( n & 1 > 0 ) cnt ++ ; if ( cnt == k ) return ind ; ind ++ ; n = n >> 1 ; } return - 1 ; }
function minAND ( arr , n ) { let s = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { s = s & arr [ i ] ; } document . write ( ( s ) + " " ) ; }
function check ( a , n ) { for ( var i = 0 ; i < n ; i ++ ) if ( a [ i ] ) return true ; return false ; }
function countX ( n ) { let binary = ( n >>> 0 ) . toString ( 2 ) ; let count = 0 ; for ( let i = 0 ; i < binary . length ; i ++ ) { if ( binary [ i ] == ' ' ) count ++ ; } let answer = Math . floor ( Math . pow ( 2 , count ) ) ; return answer ; }
function hasEqualBlockFrequency ( N ) { let S = N . toString ( 2 ) ; let p = new Set ( ) ; let c = 1 ; for ( let i = 0 ; i < S . length - 1 ; i ++ ) { if ( S [ i ] == S [ i + 1 ] ) c += 1 ; else { p . add ( c ) ; c = 1 ; } p . add ( c ) ; } if ( p . size == 1 ) document . write ( " " ) ; else document . write ( " " ) ; }
function binToDecimal3 ( n ) { var last_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; n = n >> 3 ; while ( n > 7 ) n = n >> 1 ; var first_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; document . write ( first_3 + " " + last_3 ) ; }
function minDistance ( n1 , n2 ) { var bitCount1 = Math . floor ( Math . log2 ( n1 ) ) + 1 ; var bitCount2 = Math . floor ( Math . log2 ( n2 ) ) + 1 ; var bitDiff = Math . abs ( bitCount1 - bitCount2 ) ; var maxBitCount = Math . max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * Math . pow ( 2 , bitDiff ) ; } else { n1 = n1 * Math . pow ( 2 , bitDiff ) ; } var xorValue = n1 ^ n2 ; var bitCountXorValue ; if ( xorValue == 0 ) bitCountXorValue = 1 ; else { bitCountXorValue = Math . floor ( Math . log2 ( xorValue ) ) + 1 ; } var disSimilarBitPosition = maxBitCount - bitCountXorValue ; var result = bitCount1 + bitCount2 - 2 * disSimilarBitPosition ; return result ; }
function printMaxAfterRemoval ( s ) { let flag = false ; let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' && flag == false ) { flag = true ; continue ; } else document . write ( s [ i ] ) ; } return 0 ; }
function bitPos ( n1 , n2 ) { if ( n1 == n2 ) return 0 ; let bitCount1 = Math . floor ( Math . log2 ( n1 ) ) + 1 ; let bitCount2 = Math . floor ( Math . log2 ( n2 ) ) + 1 ; let bitDiff = Math . abs ( bitCount1 - bitCount2 ) ; let maxBitCount = Math . max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * Math . pow ( 2 , bitDiff ) ; } else { n1 = n1 * Math . pow ( 2 , bitDiff ) ; } let xorValue = n1 ^ n2 ; let bitCountXorValue = Math . floor ( Math . log2 ( xorValue ) ) + 1 ; let disSimilarBitPosition = maxBitCount - bitCountXorValue + 1 ; return disSimilarBitPosition ; }
function countOddPair ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( ! ( A [ i ] & 1 ) ) count ++ ; let evenPairCount = parseInt ( count * ( count - 1 ) / 2 ) ; let totPairs = parseInt ( N * ( N - 1 ) / 2 ) ; return totPairs - evenPairCount ; }
function findevenPair ( A , N ) { let i , j ; let evenPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 == 0 ) evenPair ++ ; } } return evenPair ; }
function findevenPair ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( A [ i ] % 2 != 0 ) count ++ ; let oddCount = parseInt ( ( count * ( count - 1 ) ) / 2 ) ; return parseInt ( ( N * ( N - 1 ) ) / 2 ) - oddCount ; }
function calculate ( X ) { let number_of_bits = 8 ; return ( ( 1 << number_of_bits ) - 1 ) ^ X ; }
function ReplaceElements ( arr , n ) { if ( n <= 1 ) return ; let prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] ; for ( let i = 1 ; i < n - 1 ; i ++ ) { let curr = arr [ i ] ; arr [ i ] = prev ^ arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev ^ arr [ n - 1 ] ; }
function alternate ( a , b , x ) { return x = a ^ b ^ x ; }
function countZeros ( x ) { let total_bits = sizeofInt * 8 ; let res = 0 ; while ( ( x & ( 1 << ( total_bits - 1 ) ) ) == 0 ) { x = ( x << 1 ) ; res ++ ; } return res ; }
function LeadingZeros ( x , y ) { if ( ( x ^ y ) <= ( x & y ) ) document . write ( " " ) ; else if ( ( x & ( ~ y ) ) > y ) document . write ( y ) ; else document . write ( x ) ; }
function highestPowerOf2 ( n ) { return ( n & ( ~ ( n - 1 ) ) ) ; }
function solve ( A , B ) { var count = 0 ; for ( i = 0 ; i < 32 ; i ++ ) { if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) { count ++ ; } } document . write ( " " + count ) ; }
function isSubsetAndZero ( array , len , N ) { var arrAnd = array [ 0 ] ; for ( var i = 1 ; i < len ; i ++ ) { arrAnd = arrAnd & array [ i ] ; } if ( ( arrAnd & N ) == 0 ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; }
function setRightmostUnsetBit ( n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; return n | ( n + 1 ) ; }
function OR ( a , n ) { var ans = a [ 0 ] ; for ( var i = 1 ; i < n ; ++ i ) ans |= a [ i ] ; return ans ; }
function AND ( a , n ) { let ans = a [ 0 ] ; for ( let i = 0 ; i < n ; ++ i ) ans &= a [ i ] ; return ans ; }
function hammingDistance ( n1 , n2 ) { let x = n1 ^ n2 ; let setBits = 0 ; while ( x > 0 ) { setBits += x & 1 ; x >>= 1 ; } return setBits ; }
function findParity ( x ) { let y = x ^ ( x >> 1 ) ; y = y ^ ( y >> 2 ) ; y = y ^ ( y >> 4 ) ; y = y ^ ( y >> 8 ) ; y = y ^ ( y >> 16 ) ; if ( y & 1 ) return 1 ; return 0 ; }
function increment ( i ) { i = - ( ~ i ) ; return i ; }
function increment ( i ) { let i1 = - ( ~ ( i ) . charCodeAt ( ) ) ; return String . fromCharCode ( i1 ) ; }
function findOddPair ( A , N ) { let i , count = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) count ++ ; } return count * ( N - count ) ; }
function xorPairSum ( ar , n ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum = sum ^ ar [ i ] ; return 2 * sum ; }
function findEvenPair ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( ( ! ( ( A [ i ] & 1 ) > 0 ) ) ) count ++ ; return count * ( count - 1 ) / 2 ; }
function allBitsSetInTheGivenRange ( n , l , r ) { let num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; let new_num = n & num ; if ( new_num == 0 ) return true ; return false ; }
function calculateSum ( n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum = sum + ( 1 << i ) ; } return sum ; }
function checkSame ( n ) { let set = 0 , unset = 0 ; while ( n ) { if ( n & 1 ) set ++ ; else unset ++ ; n = n >> 1 ; } if ( set == unset ) return true ; else return false ; }
function onlyFirstAndLastAreSet ( n ) { if ( n == 1 ) return true ; if ( n == 2 ) return false ; return ( ( ( n - 1 ) & ( n - 2 ) ) == 0 ) ; }
function getInteger ( L , R ) { var number = 0 ; for ( var i = L ; i <= R ; i ++ ) number += Math . pow ( 2 , i ) ; return number ; }
function setbitsfromLtoR ( L , R ) { return ( 1 << ( R + 1 ) ) - ( 1 << L ) ; }
function maxOR ( arr , n , k , x ) { let preSum = new Array ( n + 1 ) ; let suffSum = new Array ( n + 1 ) ; let res = 0 , pow = 1 ; for ( let i = 0 ; i < k ; i ++ ) pow *= x ; preSum [ 0 ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) preSum [ i + 1 ] = preSum [ i ] | arr [ i ] ; suffSum [ n ] = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) suffSum [ i ] = suffSum [ i + 1 ] | arr [ i ] ; res = 0 ; for ( let i = 0 ; i < n ; i ++ ) res = Math . max ( res , preSum [ i ] | ( arr [ i ] * pow ) suffSum [ i + 1 ] ) ; return res ; }
function findXor ( arr , n ) { let xoR = 0 ; for ( let i = 0 ; i < n ; i ++ ) { xoR = xoR ^ arr [ i ] ; } return xoR * 2 ; }
function turnOnK ( n , k ) { if ( k <= 0 ) return n ; return ( n | ( 1 << ( k - 1 ) ) ) ; }
function printOdds ( arr , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) res = res ^ arr [ i ] ; let set_bit = res & ( ~ ( res - 1 ) ) ; let x = 0 , y = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & set_bit ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } document . write ( x + " " + y ) ; }
function findEletobeInserted ( A , n , k ) { var ans = k ; for ( var i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; return ans ; }
function printKthBit ( n , k ) { document . write ( ( n & ( 1 << ( k - 1 ) ) ) >> ( k - 1 ) ) ; }
function andSum ( arr , n ) { var ans = 0 ; for ( i = 0 ; i < BITS ; i ++ ) { var countSetBits = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) countSetBits ++ ; } var subset = ( 1 << countSetBits ) - 1 ; subset = ( subset * ( 1 << i ) ) ; ans += subset ; } return ans ; }
function countSetBits ( n ) { var count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; }
function multiplyWith4 ( n ) { return ( n << 2 ) ; }
function isEven ( n ) { let isEven = true ; for ( let i = 1 ; i <= n ; i ++ ) isEven = ! isEven ; return isEven ; }
function isEven ( n ) { return ( parseInt ( n / 2 , 10 ) * 2 == n ) ; }
function lastElement ( a , n ) { var steps = 1 ; var v = Array . from ( Array ( N ) , ( ) => Array ( 0 ) ) ; if ( n == 1 ) return a [ 0 ] ; for ( var i = 0 ; i < n ; i += 2 ) v [ steps ] . push ( a [ i ] a [ i + 1 ] ) ; while ( v [ steps ] . length > 1 ) { steps += 1 ; for ( var i = 0 ; i < v [ steps - 1 ] . length ; i += 2 ) { if ( steps & 1 ) v [ steps ] . push ( v [ steps - 1 ] [ i ] v [ steps - 1 ] [ i + 1 ] ) ; v [ steps ] . push ( v [ steps - 1 ] [ i ] ^ v [ steps - 1 ] [ i + 1 ] ) ; } } return v [ steps ] [ 0 ] ; }
function findWinner ( A , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) res ^= A [ i ] ; if ( res == 0 n % 2 == 0 ) return " " ; else return " " ; }
function printSubsets ( n ) { for ( let i = n ; i > 0 ; i = ( i - 1 ) & n ) document . write ( i + " " ) ; document . write ( " " ) ; }
function printSubsets ( n ) { for ( let i = n ; i > 0 ; i = ( i - 1 ) & n ) document . write ( i + " " ) ; document . write ( " " + " " ) ; }
function isFibbinaryNum ( n ) { if ( ( n & ( n >> 1 ) ) == 0 ) return true ; return false ; }
function maxXOR ( n , k ) { let c = ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; return ( ( 1 << c ) - 1 ) ; }
function divide ( dividend , divisor ) { var sign = ( ( dividend < 0 ) ? 1 : 0 ^ ( divisor < 0 ) ? 1 : 0 ) ? - 1 : 1 ; dividend = Math . abs ( dividend ) ; divisor = Math . abs ( divisor ) ; var quotient = 0 , temp = 0 ; while ( dividend >= divisor ) { dividend -= divisor ; ++ quotient ; } if ( sign == - 1 ) quotient = - quotient ; return quotient ; }
function swapBitsInPair ( x ) { return ( ( x & 0b10101010 ) >> 1 ) | ( ( x & 0b01010101 ) << 1 ) ; }
function evenbitsetnumber ( n ) { let count = 0 , res = 0 ; for ( let temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; }
function oddbitsetnumber ( n ) { let count = 0 ; let res = 0 ; for ( let temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; }
function toggleBits ( n1 , n2 ) { return ( n1 ^ n2 ) ; }
function evenbittogglenumber ( n ) { let res = 0 , count = 0 ; for ( let temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; }
function setleftmostunsetbit ( n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; let pos = 0 ; for ( let temp = n , count = 0 ; temp > 0 ; temp >>= 1 , count ++ ) if ( ( temp & 1 ) == 0 ) pos = count ; return ( n | ( 1 << ( pos ) ) ) ; }
function maxXorSum ( n , k ) { if ( k == 1 ) return n ; let res = 1 ; while ( res <= n ) res <<= 1 ; return res - 1 ; }
function printNumHavingAltBitPatrn ( n ) { var curr_num = 1 ; document . write ( curr_num + " " ) ; while ( true ) { curr_num <<= 1 ; if ( n < curr_num ) break ; document . write ( curr_num + " " ) ; curr_num = ( ( curr_num ) << 1 ) ^ 1 ; if ( n < curr_num ) break ; document . write ( curr_num + " " ) ; } }
function MaximumSum ( a , b , n ) { let sum1 = 0 , sum2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum1 |= a [ i ] ; sum2 |= b [ i ] ; } document . write ( sum1 + sum2 ) ; }
function multiply ( x , n ) { return x << n ; }
function isDivBy2PowerM ( n , m ) { if ( ( n & ( ( 1 << m ) - 1 ) ) == 0 ) return true ; return false ; }
function findWinner ( N ) { return N & 1 ; }
function countgroup ( a , n ) { var xs = 0 ; for ( var i = 0 ; i < n ; i ++ ) xs = xs ^ a [ i ] ; if ( xs == 0 ) return ( 1 << ( n - 1 ) ) - 1 ; }
function evenbittogglenumber ( n ) { let res = 0 , count = 0 ; for ( let temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; }
function divide ( n , m ) { document . write ( " " + ( ( n ) & ( m - 1 ) ) + " " ) ; document . write ( " " + ( n >> ( Math . log ( m ) / Math . log ( 2 ) ) ) ) ; }
function perfectPowerOf2 ( n ) { let per_pow = 1 ; while ( n > 0 ) { per_pow = per_pow << 1 ; n = n >> 1 ; } return per_pow ; }
function solve ( p , n ) { let G = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( p [ i ] % 2 != 0 ) G ^= ( p [ i ] + 1 ) ; else G ^= ( p [ i ] - 1 ) ; } return G ; }
function isDivisibleby17 ( n ) { if ( n == 0 n == 17 ) return true ; if ( n < 17 ) return false ; return isDivisibleby17 ( Math . floor ( n >> 4 ) - Math . floor ( n & 15 ) ) ; }
function answer ( n ) { let m = 2 ; let ans = 1 ; let r = 1 ; while ( r < n ) { r = ( Math . pow ( 2 , m ) - 1 ) * ( Math . pow ( 2 , m - 1 ) ) ; if ( r < n ) ans = r ; m ++ ; } return ans ; }
function maxAND ( arr , n ) { var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j < n ; j ++ ) res = Math . max ( res , arr [ i ] & arr [ j ] ) ; return res ; }
function checking ( s ) { let c = 0 ; let n = s . length ; for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == ' ' ) c ++ ; if ( c >= 6 && s [ i ] == ' ' ) return true ; } return false ; }
function findUnique ( a , n , k ) { let sizeof_let = 4 ; let LET_SIZE = 8 * sizeof_let ; let count = Array . from ( { length : LET_SIZE } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < LET_SIZE ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) if ( ( a [ j ] & ( 1 << i ) ) != 0 ) count [ i ] += 1 ; let res = 0 ; for ( let i = 0 ; i < LET_SIZE ; i ++ ) res += ( count [ i ] % k ) * ( 1 << i ) ; return res ; }
function findUniquePair ( arr , n ) { let XOR = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) XOR = XOR ^ arr [ i ] ; let set_bit_no = XOR & ~ ( XOR - 1 ) ; let x = 0 , y = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } document . write ( " " + x + " " + y + " " + " " ) ; }
function setallbitgivenrange ( n , l , r ) { let range = ( ( ( 1 << ( l - 1 ) ) - 1 ) ^ ( ( 1 << ( r ) ) - 1 ) ) ; return ( n range ) ; }
function countBits ( number ) { return Math . floor ( Math . log2 ( number ) + 1 ) ; }
function setBitNumber ( n ) { if ( n == 0 ) return 0 ; let msb = 0 ; n = n / 2 ; while ( n != 0 ) { n = $n / 2 ; msb ++ ; } return ( 1 << msb ) ; }
function setBitNumber ( n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n = n + 1 ; return ( n >> 1 ) ; }
function setBitNumber ( n ) { let k = parseInt ( Math . log ( n ) / Math . log ( 2 ) , 10 ) ; return 1 << k ; }
function allBitsSetInTheGivenRange ( n , l , r ) { var num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; var new_num = n & num ; if ( new_num == 0 ) return " " ; return " " ; }
function toggle ( n ) { let temp = 1 ; while ( temp <= n ) { n = n ^ temp ; temp = temp << 1 ; } return n ; }
function checkPowerof8 ( n ) { let i = Math . log ( n ) / Math . log ( 8 ) ; return ( i - Math . floor ( i ) < 0.000001 ) ; }
function adjacentSet ( n ) { let x = ( n & ( n >> 1 ) ) ; if ( x > 0 ) return true ; else return false ; }
function posOfRightMostSameBit ( m , n ) { let loopCounter = 1 ; while ( m > 0 n > 0 ) { let a = m % 2 == 1 ; let b = n % 2 == 1 ; if ( ! ( a ^ b ) ) { return loopCounter ; } m = m >> 1 ; n = n >> 1 ; loopCounter ++ ; } return - 1 ; }
function allBitsSetInTheGivenRange ( n , l , r ) { var num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; var new_num = n & num ; if ( num == new_num ) return " " ; return " " ; }
function printNonConsecutive ( n ) { let p = ( 1 << n ) ; for ( let i = 1 ; i < p ; i ++ ) if ( ( i & ( i << 1 ) ) == 0 ) document . write ( i + " " ) ; }
function shuffle ( N , key ) { let NO_OF_BITS = N ; let reverse_num = 0 , temp ; for ( let i = 0 ; i < NO_OF_BITS ; i ++ ) { temp = ( key & ( 1 << i ) ) ; if ( temp > 0 ) reverse_num |= ( 1 << ( ( NO_OF_BITS - 1 ) - i ) ) ; } document . write ( reverse_num ) ; }
function bitExtracted ( number , k , p ) { return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; }
function areSame ( a , b ) { if ( ( a - b ) == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function findSum ( n ) { let sum = 0 ; for ( let i = 1 ; 1 << i < n ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { let num = ( 1 << i ) + ( 1 << j ) ; if ( num <= n ) sum += num ; } } return sum ; }
function findMax ( num ) { let num_copy = num ; let j = 4 * 8 - 1 ; let i = 0 ; while ( i < j ) { let m = ( num_copy >> i ) & 1 ; let n = ( num_copy >> j ) & 1 ; if ( m > n ) { let x = ( 1 << i 1 << j ) ; num = num ^ x ; } i ++ ; j -- ; } return num ; }
function toggleLastMBits ( n , m ) { var num = ( 1 << m ) - 1 ; return ( n ^ num ) ; }
function isAMultipleOf4 ( n ) { if ( ( n & 3 ) == 0 ) return true ; return false ; }
function posOfRightMostDiffBit ( m , n ) { return parseInt ( Math . floor ( Math . log10 ( Math . pow ( m ^ n , 2 ) ) ) , 10 ) + 2 ; }
function areAllBitsSet ( n ) { if ( n == 0 ) return " " ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) return " " ; n = n >> 1 ; } return " " ; }
function areAllBitsSet ( n ) { if ( n == 0 ) return " " ; if ( ( ( n + 1 ) & n ) == 0 ) return " " ; return " " ; }
function setKthBit ( n , k ) { return ( ( 1 << k ) n ) ; }
function missingNumber ( arr1 , arr2 , n ) { let mnum = 0 ; for ( let i = 0 ; i < n ; i ++ ) mnum = mnum ^ arr1 [ i ] ; for ( let i = 0 ; i < n - 1 ; i ++ ) mnum = mnum ^ arr2 [ i ] ; return mnum ; }
function toggleKthBit ( n , k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; }
function countValues ( x ) { var count = 0 , n = 1 ; while ( x != 0 ) { if ( x % 2 == 0 ) count += n ; n *= 2 ; x = parseInt ( x / 2 ) ; } return count ; }
function constructXOR ( A , n ) { let XOR = 0 ; for ( let i = 0 ; i < n ; i ++ ) XOR ^= A [ i ] ; for ( let i = 0 ; i < n ; i ++ ) A [ i ] = XOR ^ A [ i ] ; }
function countTrailingZero ( x ) { let count = 0 ; while ( ( x & 1 ) == 0 ) { x = x >> 1 ; count ++ ; } return count ; }
function countTrailingZero ( x ) { let lookup = [ 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 ] ; return lookup [ ( - x & x ) % 37 ] ; }
function totalFlips ( A , B , C , N ) { let count = 0 ; for ( let i = 0 ; i < N ; ++ i ) { if ( A [ i ] == B [ i ] && C [ i ] == ' ' ) ++ count ; else if ( A [ i ] != B [ i ] && C [ i ] == ' ' ) ++ count ; } return count ; }
function countNumbers ( n ) { let k = 0 ; let count = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) count += ( Math . pow ( 2 , k ) ) ; k += 1 ; n >>= 1 ; } return count ; }
function multiply ( n , m ) { let ans = 0 , count = 0 ; while ( m ) { if ( m % 2 == 1 ) ans += n << count ; count ++ ; m = Math . floor ( m / 2 ) ; } return ans ; }
function EqualNumber ( A , B ) { return ( A ^ B ) ; }
function areSetBitsIncreasing ( n ) { var prev_count = Number . MAX_VALUE ; while ( n > 0 ) { while ( n > 0 && n % 2 == 0 ) n = parseInt ( n / 2 ) ; var curr_count = 1 ; while ( n > 0 && n % 2 == 1 ) { n = n / 2 ; curr_count ++ ; } if ( curr_count >= prev_count ) return false ; prev_count = curr_count ; } return true ; }
function findPattern ( n ) { let prev = n % 2 ; n = Math . floor ( n / 2 ) ; while ( n > 0 ) { let curr = n % 2 ; if ( curr == prev ) return false ; prev = curr ; n = Math . floor ( n / 2 ) ; } return true ; }
function countXOR ( n ) { let count0 = 0 , count1 = 0 ; while ( n != 0 ) { if ( n % 2 == 0 ) count0 ++ ; else count1 ++ ; n = Math . floor ( n / 2 ) ; } return ( count0 ^ count1 ) ; }
function xorPairCount ( arr , n , x ) { let s = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( s . has ( x ^ arr [ i ] ) ) { result ++ ; } s . add ( arr [ i ] ) ; } return result ; }
function xorPairCount ( arr , n , x ) { let m = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { let curr_xor = x ^ arr [ i ] ; if ( m . has ( curr_xor ) ) result += m . get ( curr_xor ) ; if ( m . has ( arr [ i ] ) ) { m . set ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . set ( arr [ i ] , 1 ) ; } } return result ; }
function isMultipleOf4 ( n ) { if ( n == 1 ) return false ; let XOR = 0 ; for ( let i = 1 ; i <= n ; i ++ ) XOR = XOR ^ i ; return ( XOR == n ) ; }
function multiplyTen ( n ) { return ( n << 1 ) + ( n << 3 ) ; }
function countValues ( n ) { let countV = 0 ; for ( let i = 0 ; i <= n ; i ++ ) if ( ( n + i ) == ( n ^ i ) ) countV ++ ; return countV ; }
function countValues ( n ) { let unset_bits = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) unset_bits ++ ; n = n >> 1 ; } return 1 << unset_bits ; }
function maxConsecutiveOnes ( x ) { let count = 0 ; while ( x != 0 ) { x = ( x & ( x << 1 ) ) ; count ++ ; } return count ; }
function swapThree ( ) { a = a ^ b ^ c ; b = a ^ b ^ c ; c = a ^ b ^ c ; a = a ^ b ^ c ; }
function findProffesion ( level , pos ) { if ( level == 1 ) return ' ' ; if ( findProffesion ( level - 1 , ( pos + 1 ) / 2 ) == ' ' ) return ( pos % 2 > 0 ) ? ' ' : ' ' ; return ( pos % 2 > 0 ) ? ' ' : ' ' ; }
function printTwoSetBitNums ( n ) { let x = 1 ; while ( n > 0 ) { let y = 0 ; while ( y < x ) { document . write ( ( 1 << x ) + ( 1 << y ) + " " ) ; n -- ; if ( n == 0 ) return ; y ++ ; } x ++ ; } }
function countStrings ( n ) { let a = [ ] , b = [ ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ; }
function findXOR ( Set , n ) { if ( n == 1 ) return Set [ 0 ] ; else return 0 ; }
function myXOR ( x , y ) { for ( let i = 31 ; i >= 0 ; i -- ) { let b1 = ( ( x & ( 1 << i ) ) == 0 ) ? 0 : 1 ; let b2 = ( ( y & ( 1 << i ) ) == 0 ) ? 0 : 1 ; let xoredBit = ( b1 & b2 ) ? 0 : ( b1 b2 ) ; res <<= 1 ; res |= xoredBit ; } return res ; }
function myXOR ( x , y ) { return ( x y ) & ( ~ x ~ y ) ; }
function myXOR ( x , y ) { return ( x & ( ~ y ) ) | ( ( ~ x ) & y ) ; }
function swapBits ( n , p1 , p2 ) { var bit1 = ( n >> p1 ) & 1 ; var bit2 = ( n >> p2 ) & 1 ; var x = ( bit1 ^ bit2 ) ; x = ( x << p1 ) | ( x << p2 ) ; var result = n ^ x ; return result ; }
function swapBits ( n , p1 , p2 ) { n ^= 1 << p1 ; n ^= 1 << p2 ; return n ; }
function multiplyBySevenByEight ( n ) { return ( n - ( n >> 3 ) ) ; }
function subtract ( x , y ) { while ( y != 0 ) { let borrow = ( ~ x ) & y ; x = x ^ y ; y = borrow << 1 ; } return x ; }
function subtract ( x , y ) { if ( y == 0 ) return x ; return subtract ( x ^ y , ( ~ x & y ) << 1 ) ; }
function square ( n ) { if ( n < 0 ) n = - n ; let res = n ; for ( let i = 1 ; i < n ; i ++ ) res += n ; return res ; }
function temp_convert ( F1 , B1 , F2 , B2 , T ) { var t2 ; t2 = F2 + ( B2 - F2 ) / ( B1 - F1 ) * ( T - F1 ) ; return t2 ; }
function Divisible ( arr , n ) { let count_even = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) count_even ++ ; return count_even + parseInt ( ( n - count_even ) / 2 ) ; }
function nextPowerOf2 ( n ) { var count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
function maxLength ( arr , n ) { let maxLen = 0 ; let i = 0 ; let j = i + 1 ; while ( j < n ) { if ( arr [ i ] != arr [ j ] ) { maxLen = Math . max ( maxLen , 2 ) ; let l = i - 1 ; let r = j + 1 ; while ( l >= 0 && r < n && arr [ l ] == arr [ i ] && arr [ r ] == arr [ j ] ) { l -- ; r ++ ; } maxLen = Math . max ( maxLen , 2 * ( r - j ) ) ; } i ++ ; j = i + 1 ; } return maxLen ; }
function maxLength ( a , n ) { let maxLen = 0 ; let prev_cnt = 0 , curr_cnt = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) curr_cnt ++ ; else { prev_cnt = curr_cnt ; curr_cnt = 1 ; } maxLen = Math . max ( maxLen , Math . min ( prev_cnt , curr_cnt ) ) ; } return ( 2 * maxLen ) ; }
