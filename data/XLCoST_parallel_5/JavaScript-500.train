function changeEvenBits ( n ) { let to_subtract = 0 ; let m = 0 ; for ( x = n ; x ; x >>= 2 ) { if ( x & 1 ) to_subtract += ( 1 << m ) ; m += 2 ; } return n - to_subtract ; }
function checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) { return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) ; }
function FindPairs ( n , k ) { document . write ( 1 + " " + n + " " ) ; k -- ; for ( let i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { document . write ( 1 + " " + i + " " ) ; k -- ; if ( k == 0 ) break ; if ( i != n / i ) { document . write ( 1 + " " + n / i + " " ) ; k -- ; } if ( k == 0 ) break ; } } }
function decrypt ( Str , Start , End ) { if ( Start > End ) { return ; } let mid = ( Start + End ) >> 1 ; document . write ( Str [ mid ] ) ; decrypt ( Str , mid + 1 , End ) ; decrypt ( Str , Start , mid - 1 ) ; }
function prefixDivisble ( n ) { let i = 1 ; while ( n > 0 ) { if ( n % i != 0 ) return false ; n = parseInt ( n / 10 ) ; i ++ ; } return true ; }
function minimum_required_operations ( arr , n , k ) { let answer = 0 ; let mod = 1000000007 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] + arr [ i + 1 ] > k ) { if ( arr [ i ] > k ) { answer += ( arr [ i ] - k ) ; arr [ i ] = k ; } answer += ( arr [ i ] + arr [ i + 1 ] ) - k ; arr [ i + 1 ] = ( k - arr [ i ] ) ; answer %= mod ; } } return answer ; }
function transpose ( A ) { for ( i = 0 ; i < N ; i ++ ) for ( j = i + 1 ; j < N ; j ++ ) { var temp = A [ i ] [ j ] ; A [ i ] [ j ] = A [ j ] [ i ] ; A [ j ] [ i ] = temp ; } } var A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; transpose ( A ) ; document . write ( " " ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) document . write ( A [ i ] [ j ] + " " ) ; document . write ( " \< " ) ; }
function checkFactors ( N ) { let ev_count = 0 , od_count = 0 ; for ( let i = 1 ; i <= Math . sqrt ( N ) + 1 ; i ++ ) { if ( N % i == 0 ) { if ( i == Math . floor ( N / i ) ) { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } else { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; if ( Math . floor ( N / i ) % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } } } if ( ev_count % 2 == 0 && od_count % 2 == 1 ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; }
function findevenPair ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( A [ i ] % 2 != 0 ) count ++ ; let oddCount = parseInt ( ( count * ( count - 1 ) ) / 2 ) ; return parseInt ( ( N * ( N - 1 ) ) / 2 ) - oddCount ; }
function countIntegralSolutions ( n ) { let result = 0 ; for ( let i = 0 ; i <= n ; i ++ ) for ( let j = 0 ; j <= n - i ; j ++ ) for ( let k = 0 ; k <= ( n - i - j ) ; k ++ ) if ( i + j + k == n ) result ++ ; return result ; }
function EnneacontahexagonNum ( n ) { return ( 94 * n * n - 92 * n ) / 2 ; }
function CountPairs ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] % 2 == 0 arr [ j ] % 2 == 0 ) count ++ ; } } return count ; }
function Findpermutation ( n ) { let a = new Array ( n + 1 ) ; a [ 1 ] = n ; for ( let i = 2 ; i <= n ; i ++ ) a [ i ] = i - 1 ; return a ; }
function countSetBits ( n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; }
function minTime ( arr , n ) { if ( n <= 0 ) return 0 ; let incl = arr [ 0 ] ; let excl = 0 ; for ( let i = 1 ; i < n ; i ++ ) { let incl_new = arr [ i ] + Math . min ( excl , incl ) ; let excl_new = incl ; incl = incl_new ; excl = excl_new ; } return Math . min ( incl , excl ) ; }
function countValues ( x ) { var count = 0 , n = 1 ; while ( x != 0 ) { if ( x % 2 == 0 ) count += n ; n *= 2 ; x = parseInt ( x / 2 ) ; } return count ; }
function countPairs ( arr , n ) { let ans = 0 ; let count = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( count . has ( arr [ i ] ) ) { ans += count . get ( arr [ i ] ) ; count . set ( arr [ i ] , count . get ( arr [ i ] ) + 1 ) ; } else { count . set ( arr [ i ] , 1 ) ; } } return ans ; }
function findRadius ( r1 , r2 ) { let a1 , a2 , a3 , r3 ; a1 = 3.14 * r1 * r1 ; a2 = 3.14 * r2 * r2 ; a3 = a1 + a2 ; r3 = Math . sqrt ( a3 / 3.14 ) ; return r3 ; }
function BeattySequence ( n ) { for ( let i = 1 ; i <= n ; i ++ ) { let ans = parseInt ( Math . floor ( i * Math . sqrt ( 2 ) ) ) ; document . write ( ans + " " ) ; } }
function testSomeNumbers ( limit , n ) { if ( n < 3 ) return ; for ( let a = 1 ; a <= limit ; a ++ ) for ( let b = a ; b <= limit ; b ++ ) { let pow_sum = ( Math . pow ( a , n ) + Math . pow ( b , n ) ) ; let c = Math . pow ( pow_sum , 1.0 / n ) ; let c_pow = Math . pow ( Math . round ( c ) , n ) ; if ( c_pow == pow_sum ) { document . write ( " " ) ; return ; } } document . write ( " " + " " ) ; }
function freq ( ar , m , n ) { let even = 0 , odd = 0 ; for ( let i = 0 ; i < m ; ++ i ) { for ( let j = 0 ; j < n ; ++ j ) { if ( ( ar [ i ] [ j ] % 2 ) == 0 ) ++ even ; else ++ odd ; } } document . write ( " " + odd + " " ) ; document . write ( " " + even + " " ) ; }
function findSum ( arr , n , k ) { var ans = arr [ n - k - 1 ] - arr [ 0 ] ; for ( var i = 1 ; i <= k ; i ++ ) { ans = Math . min ( arr [ n - 1 - ( k - i ) ] - arr [ i ] , ans ) ; } return ans ; }
function countSubStr ( str , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) m ++ ; } return m * Math . floor ( ( m - 1 ) / 2 ) ; }
function search ( arr , n , x ) { let i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) return i ; return - 1 ; }
function findPairs ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) arr [ i ] = Math . abs ( arr [ i ] ) ; arr . sort ( ( a , b ) => a - b ) ; let left = 0 ; let ans = 0 ; for ( let right = 0 ; right < N ; right ++ ) { while ( 2 * arr [ left ] < arr [ right ] ) left ++ ; ans += ( right - left ) ; } document . write ( ans ) ; }
function possibleStrings ( n , r , b , g ) { let fact = new Array ( n + 1 ) ; fact [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; let left = n - ( r + g + b ) ; let sum = 0 ; for ( let i = 0 ; i <= left ; i ++ ) { for ( let j = 0 ; j <= left - i ; j ++ ) { let k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; }
function pairStar ( input , i ) { output = output + input [ i ] ; if ( i == input . length - 1 ) return ; if ( input [ i ] == input [ i + 1 ] ) output = output + ' ' ; pairStar ( input , i + 1 ) ; }
function findLCMPrime ( a , b ) { if ( a == b ) { return a ; } return a * b ; }
function getFinalElement ( n ) { let finalNum ; for ( finalNum = 2 ; finalNum * 2 <= n ; finalNum *= 2 ) ; return finalNum ; }
function get ( x , y , z ) { if ( x > z ) return - 1 ; let val = z - x ; let div = Math . floor ( ( z - x ) / y ) ; let ans = div * y + x ; return ans ; }
function checkForSorting ( arr , n ) { let temp = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) { temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } else return false ; } } return true ; }
function printModulus ( X , Y ) { var n = Math . max ( X , Y ) ; for ( var i = 1 ; i <= n ; i ++ ) { if ( X % i == Y % i ) document . write ( i + " " ) ; } }
function findMinLength ( arr ) { let index = parseInt ( arr . length ) - 1 ; while ( index > 0 && arr [ index ] >= arr [ index - 1 ] ) { index -- ; } return index ; }
function countCon ( ar , n ) { let cnt = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) cnt ++ ; } return cnt ; }
function largestNum ( a , b ) { return a * ( parseInt ( a / b ) > 0 ? 1 : 0 ) + b * ( parseInt ( b / a ) > 0 ? 1 : 0 ) ; }
function factorial ( n ) { let M = 1000000007 ; let f = 1 ; for ( let i = 1 ; i <= n ; i ++ ) return f ; }
function possibleToReach ( x , y , z ) { if ( z < Math . abs ( x ) + Math . abs ( y ) || ( z - Math . abs ( x ) - Math . abs ( y ) ) % 2 == 1 ) { document . write ( " " + " " ) ; } else document . write ( " " + " " ) ; }
function sum ( x , y , n ) { sum1 = ( Math . pow ( x , 2 ) * ( Math . pow ( x , 2 * n ) - 1 ) ) / ( Math . pow ( x , 2 ) - 1 ) ; sum2 = ( x * y * ( Math . pow ( x , n ) * Math . pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ; return sum1 + sum2 ; }
function flipBitsOfAandB ( A , B ) { A = A ^ ( A & B ) ; B = B ^ ( A & B ) ; document . write ( A + " " + B ) ; }
function countStrings ( s ) { let cnt = 0 ; for ( let i = 1 ; s [ i ] ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { cnt ++ ; } } return cnt ; }
function findLargestString ( s , i , r ) { if ( i == s . length ) { if ( r == 0 ) return 0 ; else return - 1000000000 ; } if ( v [ i ] [ r ] ) return dp [ i ] [ r ] ; v [ i ] [ r ] = 1 ; dp [ i ] [ r ] = Math . max ( 1 + findLargestString ( s , i + 1 , ( r * 2 + ( s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ) % 3 ) , findLargestString ( s , i + 1 , r ) ) ; return dp [ i ] [ r ] ; }
function productPairs ( arr , n ) { let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; product = product % mod ; } } return product % mod ; }
function maxProduct ( arr , n ) { if ( n < 3 ) return - 1 ; let max_product = Number . MIN_VALUE ; for ( let i = 0 ; i < n - 2 ; i ++ ) for ( let j = i + 1 ; j < n - 1 ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) max_product = Math . max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; return max_product ; }
function getCount ( arr , n , num1 , num2 ) { let i = 0 ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == num1 ) break ; if ( i >= n - 1 ) return 0 ; let j ; for ( j = n - 1 ; j >= i + 1 ; j -- ) if ( arr [ j ] == num2 ) break ; if ( j == i ) return 0 ; return ( j - i - 1 ) ; }
function minimumX ( n , k ) { let mini = Number . MAX_VALUE ; for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { let fir = i ; let sec = parseInt ( n / i , 10 ) ; let num1 = fir * k + sec ; let res = parseInt ( ( num1 / k ) , 10 ) * ( num1 % k ) ; if ( res == n ) mini = Math . min ( num1 , mini ) ; let num2 = sec * k + fir ; res = parseInt ( ( num2 / k ) , 10 ) * ( num2 % k ) ; if ( res == n ) mini = Math . min ( num2 , mini ) ; } } return mini ; }
function NumberofTimes ( str ) { var temporary_sum = 0 , count = 0 ; while ( str . length > 1 ) { temporary_sum = 0 ; for ( i = 0 ; i < str . length ; i ++ ) temporary_sum += ( str . charAt ( i ) - ' ' ) ; str = temporary_sum + " " ; count ++ ; } return count ; }
function ReuleauxArea ( r ) { if ( r < 0 ) return - 1 ; var A = 0.70477 * 2 * Math . pow ( r , 2 ) ; return A ; }
function findMinRooms ( slots , n , m ) { let counts = Array ( m ) . fill ( 0 ) ; for ( let i = 0 ; i < m ; i ++ ) counts [ i ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < m ; j ++ ) if ( slots [ i ] [ j ] == ' ' ) counts [ j ] ++ ; let max = - 1 ; for ( let i = 0 ; i < m ; i ++ ) if ( max < counts [ i ] ) max = counts [ i ] ; return max ; }
function thirdLargest ( arr , arr_size ) { if ( arr_size < 3 ) { document . write ( " " ) ; return ; } let first = arr [ 0 ] ; for ( let i = 1 ; i < arr_size ; i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ; let second = Number . MIN_VALUE ; for ( let i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ; let third = Number . MIN_VALUE ; for ( let i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; document . write ( " " + " " , third ) ; }
function isMember ( a , d , x ) { if ( d == 0 ) return ( x == a ) ; return ( ( x - a ) % d == 0 && ( x - a ) / d >= 0 ) ; }
function printSeriesSum ( N ) { let sum = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { sum += Math . pow ( i , i - 1 ) ; } document . write ( sum ) ; }
function validQuadruple ( arr , n ) { if ( n >= MAX ) return true ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) for ( let l = k + 1 ; l < n ; l ++ ) { if ( ( arr [ i ] ^ arr [ j ] ^ arr [ k ] ^ arr [ l ] ) == 0 ) { return true ; } } return false ; }
function hexadecagonalNum ( n ) { return ( ( 14 * n * n ) - 12 * n ) / 2 ; }
function isDivisibleBy5 ( str ) { n = str . length ; return ( ( ( str [ n - 1 ] - ' ' ) == 0 ) || ( ( str [ n - 1 ] - ' ' ) == 5 ) ) ; }
function minTimeForWritingChars ( N , insert , remove , copy ) { if ( N == 0 ) return 0 ; if ( N == 1 ) return insert ; let dp = new Array ( N + 1 ) ; for ( let i = 0 ; i < N + 1 ; i ++ ) dp [ i ] = 0 ; dp [ 1 ] = insert ; for ( let i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) dp [ i ] = Math . min ( dp [ i - 1 ] + insert , dp [ parseInt ( i / 2 , 10 ) ] + copy ) ; else dp [ i ] = Math . min ( dp [ i - 1 ] + insert , dp [ parseInt ( ( i + 1 ) / 2 , 10 ) ] + copy + remove ) ; } return dp [ N ] ; }
function getTotalNumberOfSequences ( m , n ) { if ( m < n ) return 0 ; if ( n == 0 ) return 1 ; return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ; }
function numberSequence ( n ) { let num = Math . pow ( 4 , n ) - Math . pow ( 2 , n ) - 1 ; return num ; }
function findSubarrays ( arr , N , K ) { return N - K + 1 ; }
function FindTrip ( arr , N ) { for ( let i = 1 ; i < N - 1 ; i ++ ) { let p = arr [ i - 1 ] ; let q = arr [ i ] ; let r = arr [ i + 1 ] ; if ( p < q && q > r ) { document . write ( ( i - 1 ) + " " + ( i ) + " " + ( i + 1 ) ) ; return ; } } document . write ( - 1 ) ; }
function polyapothem ( n , a ) { if ( a < 0 && n < 0 ) return - 1 ; return ( a / ( 2 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ) ; }
function reverse ( str , len , l , r ) { if ( l < 0 r >= len l > r ) return " " ; while ( l < r ) { let c = str [ l ] ; str [ l ] = str [ r ] ; str [ r ] = c ; l ++ ; r -- ; } return str . join ( " " ) ; }
function divide ( dividend , divisor ) { var sign = ( ( dividend < 0 ) ? 1 : 0 ^ ( divisor < 0 ) ? 1 : 0 ) ? - 1 : 1 ; dividend = Math . abs ( dividend ) ; divisor = Math . abs ( divisor ) ; var quotient = 0 , temp = 0 ; while ( dividend >= divisor ) { dividend -= divisor ; ++ quotient ; } if ( sign == - 1 ) quotient = - quotient ; return quotient ; }
function MinimumMoves ( a , n , x ) { var ans = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= a [ i - 1 ] ) { var p = parseInt ( ( a [ i - 1 ] - a [ i ] ) / x + 1 ) ; ans += p ; a [ i ] += p * x ; } } return ans ; }
function power ( n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; }
function subsequence ( S , T , n , m ) { let dp = new Array ( ) for ( let i = 0 ; i < n + 1 ; i ++ ) { let temp = [ ] ; for ( let j = 0 ; j < m + 1 ; j ++ ) { temp . push ( [ ] ) } dp . push ( temp ) } for ( let i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( let j = 0 ; j <= m ; j ++ ) dp [ 0 ] [ j ] = 1 ; for ( let i = 1 ; i <= n ; ++ i ) { for ( let j = 1 ; j <= m ; ++ j ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] - dp [ i - 1 ] [ j - 1 ] ; if ( S [ i - 1 ] == T [ j - 1 ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ j - 1 ] ; dp [ i ] [ j ] += mod ; dp [ i ] [ j ] %= mod ; } } return dp [ n ] [ m ] ; }
function findMaxSum ( arr , n ) { let preSum = new Array ( n ) ; preSum . fill ( 0 ) ; let suffSum = new Array ( n ) ; suffSum . fill ( 0 ) ; let ans = Number . MIN_VALUE ; preSum [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) preSum [ i ] = preSum [ i - 1 ] + arr [ i ] ; suffSum [ n - 1 ] = arr [ n - 1 ] ; if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) ans = Math . max ( ans , preSum [ n - 1 ] ) ; for ( let i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] ; if ( suffSum [ i ] == preSum [ i ] ) ans = Math . max ( ans , preSum [ i ] ) ; } return ans ; }
function minMoves ( arr ) { let N = arr . length ; if ( N <= 2 ) return 0 ; let ans = Number . MAX_VALUE ; for ( let i = - 1 ; i <= 1 ; i ++ ) { for ( let j = - 1 ; j <= 1 ; j ++ ) { let num1 = arr [ 0 ] + i ; let num2 = arr [ 1 ] + j ; let flag = 1 ; let moves = Math . abs ( i ) + Math . abs ( j ) ; for ( let idx = 2 ; idx < N ; idx ++ ) { let num = num1 + num2 ; if ( Math . abs ( arr [ idx ] - num ) > 1 ) flag = 0 ; else moves += Math . abs ( arr [ idx ] - num ) ; num1 = num2 ; num2 = num ; } if ( flag > 0 ) ans = Math . min ( ans , moves ) ; } } if ( ans == Number . MAX_VALUE ) return - 1 ; return ans ; }
function length_of_chord ( r , x ) { document . write ( " " + " " + 2 * r * Math . sin ( x * ( 3.14 / 180 ) ) + " " ) ; }
function max_min ( a , n ) { a . sort ( ) ; return Math . min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) ; }
function Permutation ( n , k ) { let p = new Array ( n + 1 ) ; for ( let i = 1 ; i <= n ; i ++ ) p [ i ] = i ; for ( let i = 1 ; i < n - k ; i ++ ) p [ i + 1 ] = i ; p [ 1 ] = n - k ; for ( let i = 1 ; i <= n ; i ++ ) document . write ( p [ i ] + " " ) ; }
function countElement ( A , N , B , M , K ) { let cnt = 0 ; for ( let i = 0 ; i < M ; i ++ ) { let currentElement = B [ i ] ; for ( let j = 0 ; j < N ; j ++ ) { let diff = Math . abs ( currentElement - A [ j ] ) ; if ( diff <= K ) { cnt ++ ; break ; } } } document . write ( cnt ) ; }
function findFreq ( str , N ) { let freq = new Array ( 256 ) . fill ( 0 ) ; let max = 0 ; let charMax = ' ' ; for ( let i = 0 ; i < N ; i ++ ) { let ch = str [ i ] . charCodeAt ( 0 ) ; freq [ ch ] ++ ; if ( freq [ ch ] >= max ) { max = freq [ ch ] ; charMax = ch ; } document . write ( String . fromCharCode ( charMax ) + " " + max + " " ) ; } }
function maxvolume ( s ) { let maxvalue = 0 ; for ( let i = 1 ; i <= s - 2 ; i ++ ) { for ( let j = 1 ; j <= s - 1 ; j ++ ) { let k = s - i - j ; maxvalue = Math . max ( maxvalue , i * j * k ) ; } } return maxvalue ; }
function minLettersNeeded ( n ) { if ( n % 26 == 0 ) return parseInt ( n / 26 ) ; else return ( parseInt ( n / 26 ) + 1 ) ; }
function evenXorSubarray ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let XOR = 0 ; for ( let j = i ; j < n ; j ++ ) { XOR = XOR ^ arr [ j ] ; if ( ( XOR & 1 ) == 0 ) ans ++ ; } } document . write ( ans ) ; }
function equilibrium ( arr , n ) { sum = 0 ; leftsum = 0 ; for ( let i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( let i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; } return - 1 ; }
function countSubStr ( str , n , x ) { let res = 0 , count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == x ) { res += ( ( count + 1 ) * ( n - i ) ) ; count = 0 ; } else count ++ ; } return res ; }
function PrletBothArrays ( a , n ) { let v1 = [ ] , v2 = [ ] ; let mpp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { mpp . set ( a [ i ] , ( mpp . get ( a [ i ] ) == null ? 0 : mpp . get ( a [ i ] ) ) + 1 ) ; if ( mpp . get ( a [ i ] ) == 1 ) v1 . push ( a [ i ] ) ; else if ( mpp . get ( a [ i ] ) == 2 ) v2 . push ( a [ i ] ) ; else { document . write ( " " ) ; return ; } } v1 . sort ( ) ; document . write ( " " + " " ) ; for ( let i = 0 ; i < v1 . length ; i ++ ) document . write ( v1 [ i ] + " " ) ; v2 . sort ( ) ; v2 . reverse ( ) ; document . write ( " " + " " + " " ) ; for ( let i = 0 ; i < v2 . length ; i ++ ) document . write ( v2 [ i ] + " " ) ; }
function findTrailingZeros ( n ) { if ( n & 1 ) return 0 ; else { let ans = 0 ; n = parseInt ( n / 2 ) ; while ( n ) { ans += parseInt ( n / 5 ) ; n = parseInt ( n / 5 ) ; } return ans ; } }
function checkWord ( board , word , index , row , col ) { if ( row < 0 col < 0 row >= board . length col >= board [ 0 ] . length ) return false ; if ( board [ row ] [ col ] !== word [ index ] ) return false ; else if ( index === word . length - 1 ) return true ; var temp = board [ row ] [ col ] ; board [ row ] [ col ] = " " ; if ( checkWord ( board , word , index + 1 , row + 1 , col ) || checkWord ( board , word , index + 1 , row - 1 , col ) || checkWord ( board , word , index + 1 , row , col + 1 ) || checkWord ( board , word , index + 1 , row , col - 1 ) ) { board [ row ] [ col ] = temp ; return true ; } board [ row ] [ col ] = temp ; return false ; } var board = [ [ " " , " " , " " , " " ] , [ " " , " " , " " , " " ] , [ " " , " " , " " , " " ] , ] ; var word = " " ; var f = 0 ; for ( var i = 0 ; i < board . length ; i ++ ) { for ( var j = 0 ; j < board [ 0 ] . length ; j ++ ) { if ( board [ i ] [ j ] === word [ 0 ] && checkWord ( board , word , 0 , i , j ) ) { document . write ( " " ) ; f = 1 ; } } if ( f === 1 ) { i = board . length + 1 ; } } if ( f === 0 ) { document . write ( " " ) ; }
function printRoots ( a , b , c ) { document . write ( 1 + " " + c / ( a * 1.0 ) ) ; }
function findStarNum ( n ) { return ( 6 * n * ( n - 1 ) + 1 ) ; }
function hexDiagonal ( a ) { if ( a < 0 ) return - 1 ; var d = 1.73 * a ; return d ; }
function countDigit ( n ) { if ( n / 10 == 0 ) return 1 ; return 1 + countDigit ( parseInt ( n / 10 ) ) ; }
function printLastElement ( arr , N ) { var leftTurn = true ; var remainElements = N ; var step = 1 ; var head = 1 ; while ( remainElements > 1 ) { if ( leftTurn ) { head = head + step ; } else { if ( remainElements % 2 == 1 ) head = head + step ; } remainElements = remainElements / 2 ; step = step * 2 ; leftTurn = ! leftTurn ; } document . write ( arr [ head - 1 ] ) ; }
function countDer ( n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ; }
function countFreq ( arr , n ) { let visited = new Array ( n ) ; visited . fill ( false ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( visited [ i ] == true ) continue ; let count = 1 ; for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { visited [ j ] = true ; count ++ ; } } document . write ( arr [ i ] + " " + count + " " ) ; } }
function calc_distance ( A , B , n ) { var distance_traveled_A = 0 ; var distance_traveled_B = 0 ; var answer = 0 ; for ( i = 0 ; i < 5 ; i ++ ) { distance_traveled_A += A [ i ] ; distance_traveled_B += B [ i ] ; if ( ( distance_traveled_A == distance_traveled_B ) && ( A [ i ] == B [ i ] ) ) { answer += A [ i ] ; } } return answer ; }
function pairs ( n ) { let c = new Array ( 10 ) ; for ( var i = 0 ; i < c . length ; i ++ ) { c [ i ] = new Array ( 2 ) ; } for ( var i = 0 ; i < c . length ; i ++ ) { for ( var j = 0 ; j < c . length ; j ++ ) { c [ i ] [ j ] = 0 ; } } let tmp = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( i >= tmp * 10 ) tmp *= 10 ; c [ Math . floor ( i / tmp ) ] [ i % 10 ] ++ ; } let ans = 0 ; for ( let i = 1 ; i < 10 ; i ++ ) for ( let j = 1 ; j < 10 ; j ++ ) ans += c [ i ] [ j ] * c [ j ] [ i ] ; return ans ; }
function linearSearch ( arr , n ) { let i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return - 1 ; }
function minOperations ( str , n ) { var count = 0 ; for ( var i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] != str [ i + 1 ] ) count ++ ; } return ( count + 1 ) / 2 ; }
function minOperation ( arr ) { let minOp = Number . MIN_VALUE ; let minNeg = 0 , maxPos = 0 ; for ( let i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] < 0 ) { if ( arr [ i ] < minNeg ) minNeg = arr [ i ] ; } else { if ( arr [ i ] > maxPos ) maxPos = arr [ i ] ; } } return Math . abs ( minNeg ) + maxPos ; }
function maxHamming ( arr , n ) { let brr = new Array ( 2 * n + 1 ) ; for ( let i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) brr [ n + i ] = arr [ i ] ; let maxHam = 0 ; for ( let i = 1 ; i < n ; i ++ ) { let currHam = 0 ; for ( let j = i , k = 0 ; j < ( i + n ) ; j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ; if ( currHam == n ) return n ; maxHam = max ( maxHam , currHam ) ; } return maxHam ; }
function mod ( a , m ) { return ( a % m + m ) % m ; }
function check ( arr , N ) { let even = 0 ; let odd = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & 1 ) { odd ++ ; } else { even ++ ; } } if ( even == N odd == N ) document . write ( " " ) ; else document . write ( " " ) ; }
function count ( n , k ) { let count = Math . pow ( 10 , k ) - Math . pow ( 10 , k - 1 ) ; document . write ( count ) ; }
function sumOfInternalAngles ( n ) { if ( n < 3 ) return 0 ; return ( n - 2 ) * 180 ; }
function countNumbers ( N ) { return parseInt ( ( Math . pow ( 10 , N ) - Math . pow ( 8 , N ) ) / 2 , 10 ) ; }
function countToMake0lternate ( s ) { let result = 0 ; for ( let i = 0 ; i < ( s . length - 1 ) ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return result ; }
function check ( arr , n ) { for ( var i = 0 ; i < n ; i ++ ) { var hm = new Map ( ) ; var count = 0 ; for ( var j = i ; j < n ; j ++ ) { if ( hm . has ( arr [ j ] ) ) hm . set ( arr [ j ] , hm . get ( arr [ j ] ) + 1 ) else hm . set ( arr [ j ] , 1 ) if ( hm . get ( arr [ j ] ) == 1 ) count ++ ; if ( hm . get ( arr [ j ] ) == 2 ) count -- ; if ( count == 0 ) return " " ; } } return " " ; }
function findSubstringCount ( str ) { var result = 0 ; var n = str . length ; for ( var i = 0 ; i < n - 1 ; i ++ ) { if ( String . fromCharCode ( str [ i ] . charCodeAt ( 0 ) + 1 ) == str [ i + 1 ] ) { result ++ ; while ( String . fromCharCode ( str [ i ] . charCodeAt ( 0 ) + 1 ) === str [ i + 1 ] ) { i ++ ; } } } return result ; }
function countDigits ( n ) { return ( n * Math . log10 ( 2 ) + 1 ) ; }
function findPeak ( arr , n ) { if ( n == 1 ) return 0 ; if ( arr [ 0 ] >= arr [ 1 ] ) return 0 ; if ( arr [ n - 1 ] >= arr [ n - 2 ] ) return n - 1 ; for ( var i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] >= arr [ i - 1 ] && arr [ i ] >= arr [ i + 1 ] ) return i ; } }
function countNumberOfStrings ( s ) { let n = s . length - 1 ; let count = ( Math . pow ( 2 , n ) ) ; return count ; }
function posOfRightMostSameBit ( m , n ) { let loopCounter = 1 ; while ( m > 0 n > 0 ) { let a = m % 2 == 1 ; let b = n % 2 == 1 ; if ( ! ( a ^ b ) ) { return loopCounter ; } m = m >> 1 ; n = n >> 1 ; loopCounter ++ ; } return - 1 ; }
function closestMultiple ( n , x ) { if ( x > n ) return x ; n = n + parseInt ( x / 2 , 10 ) ; n = n - ( n % x ) ; return n ; }
function pairExists ( arr1 , m , arr2 , n ) { let s = new Set ( ) ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( s . has ( arr2 [ j ] - arr1 [ i ] ) ) return true ; } s . add ( arr1 [ i ] ) ; } return false ; }
function largest ( arr , n ) { arr . sort ( ) ; return arr [ n - 1 ] ; }
function countX ( a , b ) { if ( b > a ) return 0 ; else if ( a == b ) return - 1 ; else { let x = a - b , ans = 0 ; for ( let i = 1 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) { let d1 = i , d2 = b - 1 ; if ( i * i != x ) d2 = parseInt ( x / i ) ; if ( d1 > b ) ans ++ ; if ( d2 > b ) ans ++ ; } } return ans ; } }
function findEquation ( A , B , C ) { document . write ( " " + C + " " + " " + B + " " + A + " " ) }
function minSum ( arr , n ) { let sum = arr [ 0 ] , prev = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; }
function getM ( n ) { if ( n == 1 ) return - 1 ; else return n - 2 ; }
function subtract ( A , B , C ) { var i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; } var A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; var B = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; var C = Array . from ( Array ( N ) , ( ) => Array ( N ) ) ; var i , j ; subtract ( A , B , C ) ; document . write ( " " + " " ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) document . write ( C [ i ] [ j ] + " " ) ; document . write ( " " ) ; }
function nthTerm ( n ) { return 2 * Math . pow ( n , 2 ) + n - 3 ; }
function volumeRec ( a , b , e , h ) { return ( ( ( b * h ) / 6 ) * ( 2 * a + e ) ) ; }
function findNthNumber ( N ) { let result = 0 ; let p = 1 ; while ( N > 0 ) { result += ( p * ( N % 9 ) ) ; N = parseInt ( N / 9 , 10 ) ; p = p * 10 ; } return result ; }
function countSquares ( n ) { return ( Math . pow ( n , 2 ) - ( 2 * n ) + 2 ) ; }
function lis ( arr , n ) { let lis = Array ( n ) . fill ( 0 ) ; let i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return max ; }
function isPossible ( a , n ) { var cur = a [ 0 ] ; cur -- ; for ( var i = 1 ; i < n ; i ++ ) { var nxt = a [ i ] ; if ( nxt > cur ) nxt -- ; else if ( nxt < cur ) return false ; cur = nxt ; } return true ; }
function circle_inscribed ( a ) { return PI * ( a * a ) / 12 ; }
function spiralDiaSum ( n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; }
function getMin ( arr , n ) { var minVal = Math . min . apply ( Math , arr ) ; return minVal ; }
function colMaxDiff ( mat ) { let max_diff = Number . MIN_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { let max_val = mat [ 0 ] [ i ] , min_val = mat [ 0 ] [ i ] ; for ( let j = 1 ; j < N ; j ++ ) { max_val = Math . max ( max_val , mat [ j ] [ i ] ) ; min_val = Math . min ( min_val , mat [ j ] [ i ] ) ; } max_diff = Math . max ( max_diff , max_val - min_val ) ; } return max_diff ; }
function findSmallestNumK ( n ) { let cummAnd = n ; let i = n - 1 ; while ( cummAnd != 0 ) { cummAnd = cummAnd & i ; if ( cummAnd == 0 ) { return i ; } i -- ; } return - 1 ; }
function area ( d1 , a ) { var d2 = Math . sqrt ( 4 * ( a * a ) - d1 * d1 ) ; var area = 0.5 * d1 * d2 ; return area ; }
function evenNumSubstring ( str ) { let len = str . length ; let count = 0 ; for ( let i = 0 ; i < len ; i ++ ) { let temp = str [ i ] - ' ' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
function printChar ( str , n ) { let freq = [ ] ; for ( let i = 0 ; i < SIZE ; i ++ ) { freq . push ( 0 ) ; } for ( let i = 0 ; i < n ; i ++ ) freq [ str . charCodeAt ( i ) - 97 ] ++ ; for ( let i = 0 ; i < n ; i ++ ) { if ( freq [ str . charCodeAt ( i ) - 97 ] % 2 == 1 ) { document . write ( str [ i ] ) ; } } }
function isPossible ( A , B , n , m , x , y ) { if ( x > n y > m ) return false ; A . sort ( ) ; B . sort ( ) ; if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; }
function getMinOps ( arr ) { let ans = 0 ; for ( let i = 0 ; i < arr . length - 1 ; i ++ ) { ans += Math . max ( arr [ i ] - arr [ i + 1 ] , 0 ) ; } return ans ; }
function MinimumMail ( n , k , x ) { let m = ( n - 1 ) + Math . ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + Math . ceil ( n * 1.0 / x ) * ( k - n ) ; return m ; }
function can_empty ( a , b , c ) { if ( ( a + b + c ) % 4 != 0 ) return false ; else { let m = Math . min ( a , Math . min ( b , c ) ) ; if ( m < Math . floor ( ( a + b + c ) / 4 ) ) return false ; } return true ; }
function removeDuplicatesFromString ( string ) { let counter = 0 ; let str = string . split ( " " ) ; let i = 0 ; let size = str . length ; let x ; let length = 0 ; while ( i < size ) { x = str [ i ] . charCodeAt ( 0 ) - 97 ; if ( ( counter & ( 1 << x ) ) == 0 ) { str [ length ] = String . fromCharCode ( ' ' . charCodeAt ( 0 ) + x ) ; counter = counter | ( 1 << x ) ; length ++ ; } i ++ ; } return str . join ( " " ) . slice ( 0 , length ) ; }
function centeredDodecagonal ( n ) { return 6 * n * ( n - 1 ) + 1 ; }
function summation ( N ) { var co = parseInt ( ( N + 1 ) / 2 ) ; var ce = parseInt ( ( N ) / 2 ) ; var se = 2 * ( ( ce * ( ce + 1 ) ) * ( ce * ( ce + 1 ) ) ) ; var so = ( co * co ) * ( 2 * ( ( co * co ) ) - 1 ) ; return so - se ; }
function smallestMultiple ( n ) { if ( n == 1 ) return 5 ; return Math . pow ( 10 , n - 1 ) ; }
function rectCount ( n , m ) { return parseInt ( ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 , 10 ) ; }
function countUnique ( mat , n , m ) { let rowsum = new Array ( n ) ; rowsum . fill ( 0 ) ; let colsum = new Array ( m ) ; colsum . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] != 0 ) { rowsum [ i ] ++ ; colsum [ j ] ++ ; } let uniquecount = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] != 0 && rowsum [ i ] == 1 && colsum [ j ] == 1 ) uniquecount ++ ; return uniquecount ; }
function maxItems ( x , y , z ) { let type1 = parseInt ( x / COST ) ; x %= COST ; let type2 = parseInt ( y / COST ) ; y %= COST ; let type3 = parseInt ( z / COST ) ; z %= COST ; let type4 = Math . min ( x , Math . min ( y , z ) ) ; let maxItems = type1 + type2 + type3 + type4 ; return maxItems ; }
function center_octadecagon_num ( n ) { return 9 * n * n - 9 * n + 1 ; }
function polynomialRollingHash ( str ) { let p = 31 ; let m = ( 1e9 + 9 ) ; let power_of_p = 1 ; let hash_val = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { hash_val = ( hash_val + ( str [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) + 1 ) * power_of_p ) % m ; power_of_p = ( power_of_p * p ) % m ; } return hash_val ; }
function isFibbinaryNum ( n ) { if ( ( n & ( n >> 1 ) ) == 0 ) return true ; return false ; }
function calculate ( n , power ) { sum = 0 ; bp = Math . pow ( n , power ) ; while ( bp != 0 ) { d = bp % 10 ; sum = sum + d ; bp = Math . floor ( bp / 10 ) ; } return sum ; }
function maxPossibleSum ( arr , N ) { arr . sort ( ) ; let sum = 0 ; let j = N - 3 ; while ( j >= 0 ) { sum += arr [ j ] ; j -= 3 ; } document . write ( sum ) ; }
function maxWater ( arr , n ) { let left = 0 ; let right = n - 1 ; let l_max = 0 ; let r_max = 0 ; let result = 0 ; while ( left <= right ) { if ( r_max <= l_max ) { result += Math . max ( 0 , r_max - arr [ right ] ) ; r_max = Math . max ( r_max , arr [ right ] ) ; right -= 1 ; } else { result += Math . max ( 0 , l_max - arr [ left ] ) ; l_max = Math . max ( l_max , arr [ left ] ) ; left += 1 ; } } return result ; }
function maxArea ( polet_x , polet_y , n , length , width ) { polet_x . sort ( ( a , b ) => a - b ) ; ; polet_y . sort ( ( a , b ) => a - b ) ; ; let dx = polet_x [ 0 ] ; let dy = polet_y [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { dx = Math . max ( dx , polet_x [ i ] - polet_x [ i - 1 ] ) ; dy = Math . max ( dy , polet_y [ i ] - polet_y [ i - 1 ] ) ; } dx = Math . max ( dx , ( length + 1 ) - polet_x [ n - 1 ] ) ; dy = Math . max ( dy , ( width + 1 ) - polet_y [ n - 1 ] ) ; document . write ( ( dx - 1 ) * ( dy - 1 ) ) ; }
function sumNodes ( l ) { let leafNodeCount = Math . pow ( 2 , l - 1 ) ; let sumLastLevel = 0 ; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; let sum = sumLastLevel * l ; return sum ; }
function eccHyperbola ( A , B ) { let r = B * B / A * A ; r += 1 ; return Math . sqrt ( r ) ; }
function Kroneckerproduct ( A , B ) { let C = new Array ( rowa * rowb ) for ( let i = 0 ; i < ( rowa * rowb ) ; i ++ ) { C [ i ] = new Array ( cola * colb ) ; for ( let j = 0 ; j < ( cola * colb ) ; j ++ ) { C [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < rowa ; i ++ ) { for ( let k = 0 ; k < rowb ; k ++ ) { for ( let j = 0 ; j < cola ; j ++ ) { for ( let l = 0 ; l < colb ; l ++ ) { C [ i + l + 1 ] [ j + k + 1 ] = A [ i ] [ j ] * B [ k ] [ l ] ; document . write ( C [ i + l + 1 ] [ j + k + 1 ] + " " ) ; } } document . write ( " " ) ; } } }
function Survives ( n ) { let i ; for ( let i = 2 ; ; i ++ ) { if ( i > n ) return true ; if ( n % i == 0 ) return false ; n -= parseInt ( n / i ) ; } }
function countSwaps ( A , n ) { var mp = new Map ( ) ; var max_frequency = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( mp . has ( A [ i ] ) ) mp . set ( A [ i ] , mp . get ( A [ i ] ) + 1 ) else mp . set ( A [ i ] , 1 ) ; max_frequency = Math . max ( max_frequency , mp . get ( A [ i ] ) ) ; } return n - max_frequency ; }
function maxLength ( arr , n ) { let maxLen = 0 ; let i = 0 ; let j = i + 1 ; while ( j < n ) { if ( arr [ i ] != arr [ j ] ) { maxLen = Math . max ( maxLen , 2 ) ; let l = i - 1 ; let r = j + 1 ; while ( l >= 0 && r < n && arr [ l ] == arr [ i ] && arr [ r ] == arr [ j ] ) { l -- ; r ++ ; } maxLen = Math . max ( maxLen , 2 * ( r - j ) ) ; } i ++ ; j = i + 1 ; } return maxLen ; }
function isSubsetSum ( set , n , sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
function No_of_cubes ( N , K ) { let No = 0 ; No = ( N - K + 1 ) ; No = Math . pow ( No , 3 ) ; return No ; }
function maxModProdSubarr ( arr , n , M ) { var ans = 0 ; var length = n ; for ( i = 0 ; i < n ; i ++ ) { var product = 1 ; for ( j = i ; j < n ; j ++ ) { product = ( product * arr [ i ] ) % M ; if ( product > ans ) { ans = product ; if ( length > j - i + 1 ) { length = j - i + 1 ; } } } } document . write ( " " + ans + " " ) ; document . write ( " " + " " + length ) ; }
function printNSE ( arr , n ) { var next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { next = arr [ j ] ; break ; } } document . write ( arr [ i ] + " " + next + " " ) ; } }
function isPowerOfK ( n , k ) { let oneSeen = false ; while ( n > 0 ) { let digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n = Math . floor ( n / k ) ; } return true ; }
function computeMaxValue ( arr , n ) { var ans = 0 ; for ( var i = 0 ; i < n - 1 ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { var val = Math . max ( arr [ i ] / arr [ j ] , arr [ j ] / arr [ i ] ) ; ans = Math . max ( ans , val ) ; } } return ans ; }
function distance ( x1 , y1 , z1 , x2 , y2 , z2 ) { var d = Math . pow ( ( Math . pow ( x2 - x1 , 2 ) + Math . pow ( y2 - y1 , 2 ) + Math . pow ( z2 - z1 , 2 ) * 1.0 ) , 0.5 ) ; document . write ( " " + d . toFixed ( 10 ) ) ; return ; }
function isLoeschian ( n ) { for ( let x = 1 ; x <= Math . sqrt ( n ) ; x ++ ) { for ( let y = 1 ; y <= Math . sqrt ( n ) ; y ++ ) { if ( x * x + x * y + y * y == n ) return true ; } } return false ; }
function countNegative ( M , n , m ) { let count = 0 ; let i = 0 ; let j = m - 1 ; while ( j >= 0 && i < n ) { if ( M [ i ] [ j ] < 0 ) { count += j + 1 ; i += 1 ; } else j -= 1 ; } return count ; }
function heightCalculate ( H , n , m ) { let N = n * 1.0 ; let M = m * 1.0 ; let h = H * Math . sqrt ( N / ( N + M ) ) ; return h ; }
function Nonagonal ( n ) { for ( let i = 1 ; i <= n ; i ++ ) { document . write ( parseInt ( i * ( 7 * i - 5 ) / 2 ) + " " ) ; } }
function eulerian ( n , m ) { var dp = Array . from ( Array ( n + 1 ) , ( ) => Array ( m + 1 ) . fill ( 0 ) ) ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ; } } } return dp [ n ] [ m ] ; }
function findDecimal ( arr , N ) { let bit , power = 0 , result = 0 ; for ( let i = N - 1 ; i >= 0 ; i -- ) { bit = Math . abs ( Math . floor ( arr [ i ] ) - Math . round ( arr [ i ] ) ) ; if ( bit != 0 ) result += Math . pow ( 2 , power ) ; power ++ ; } document . write ( result ) ; }
function MatrixChainOrder ( p , n ) { var dp = Array . from ( Array ( n ) , ( ) => Array ( n ) ) ; for ( var i = 1 ; i < n ; i ++ ) dp [ i ] [ i ] = 0 ; for ( var L = 1 ; L < n - 1 ; L ++ ) for ( var i = 1 ; i < n - L ; i ++ ) dp [ i ] [ i + L ] = Math . min ( dp [ i + 1 ] [ i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i ] [ i + L - 1 ] + p [ i - 1 ] * p [ i + L - 1 ] * p [ i + L ] ) ; return dp [ 1 ] [ n - 1 ] ; }
function maxPointOfIntersection ( x , y ) { let k = y * ( y - 1 ) / 2 ; k = k + x * ( 2 * y + x - 1 ) ; return k ; }
function findMinSum ( num ) { let sum = 0 ; for ( let i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ; return sum ; }
function findOccurrences ( str1 , substr1 ) { let counter = 0 ; for ( let i = 0 ; i < str1 . length ; i ++ ) { if ( str1 [ i ] == substr1 [ 0 ] ) { for ( let j = i + 1 ; j < str1 . length ; j ++ ) { if ( str1 [ j ] == substr1 [ 1 ] ) { for ( let k = j + 1 ; k < str1 . length ; k ++ ) { if ( str1 [ k ] == substr1 [ 2 ] ) counter ++ ; } } } } } return counter ; }
function lenOfLongSubarr ( arr , n ) { var um = new Map ( ) ; var sum = 0 , maxLen = 0 ; for ( var i = 0 ; i < n ; i ++ ) { sum += arr [ i ] == 0 ? - 1 : 1 ; if ( sum == 1 ) maxLen = i + 1 ; else if ( ! um . has ( sum ) ) um . set ( sum , i ) ; if ( um . has ( sum - 1 ) ) { if ( maxLen < ( i - um . get ( sum - 1 ) ) ) maxLen = i - um . get ( sum - 1 ) ; } } return maxLen ; }
function binomialCoeff ( n , k ) { if ( k > n ) return 0 ; var res = 1 ; if ( k > n - k ) k = n - k ; for ( var i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
function maxResult ( n , a , b , c ) { let maxVal = 0 ; for ( let i = 0 ; i <= n ; i += a ) for ( let j = 0 ; j <= n - i ; j += b ) { let z = ( n - ( i + j ) ) / c ; if ( Math . floor ( z ) == Math . ceil ( z ) ) { let x = i / a ; let y = j / b ; maxVal = Math . max ( maxVal , x + y + z ) ; } } return maxVal ; }
function expectedSteps ( x ) { if ( x == 0 ) return 0 ; if ( x <= 5 ) return 6 ; if ( v [ x ] ) return dp [ x ] ; v [ x ] = 1 ; dp [ x ] = 1 + ( expectedSteps ( x - 1 ) + expectedSteps ( x - 2 ) + expectedSteps ( x - 3 ) + expectedSteps ( x - 4 ) + expectedSteps ( x - 5 ) + expectedSteps ( x - 6 ) ) / 6 ; return dp [ x ] ; }
function isTwoAlter ( s ) { for ( let i = 0 ; i < s . length - 2 ; i ++ ) { if ( s [ i ] != s [ i + 2 ] ) { return false ; } } if ( s [ 0 ] == s [ 1 ] ) return false ; return true ; }
function count9s ( number ) { let count = 0 ; let n = ( number . length ) ; for ( let i = 0 ; i < n ; i ++ ) { let sum = number [ i ] - ' ' ; if ( number [ i ] == ' ' ) { count ++ ; } for ( let j = i + 1 ; j < n ; j ++ ) { sum = ( sum + number [ j ] - ' ' ) % 9 ; if ( sum == 0 ) { count ++ ; } } } return count ; }
function printDuplicates ( arr , n ) { let i ; let fl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ arr [ i ] % n ] >= n ) { if ( arr [ arr [ i ] % n ] < 2 * n ) { document . write ( arr [ i ] % n + " " ) ; fl = 1 ; } } arr [ arr [ i ] % n ] += n ; } if ( ! fl ) document . write ( " " ) ; }
function countSubsequences ( arr ) { let odd = 0 ; for ( let x = 0 ; x < arr . length ; x ++ ) { if ( arr [ x ] & 1 ) odd ++ ; } return ( 1 << odd ) - 1 ; }
function getPairsCount ( a , n ) { let count = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( ( a [ i ] * a [ j ] ) == Math . abs ( i - j ) ) count ++ ; } } return count ; }
function answer ( L , R ) { if ( 2 * L <= R ) document . write ( L + " " + 2 * L + " " ) ; else document . write ( - 1 ) ; }
function precompute ( s , K ) { var n = s . length ; for ( var i = 0 ; i < n - 1 ; i ++ ) { cnt [ i + 1 ] = cnt [ i ] + ( s . substring ( i , i + K . length ) == K ) ; } } var s = " " ; var K = " " ; precompute ( s , K ) ; var Q = [ [ 1 , 6 ] , [ 5 , 11 ] ] ; Q . forEach ( ( it ) => { document . write ( cnt [ it [ 1 ] - 1 ] - cnt [ it [ 0 ] - 1 ] + " " ) ; }
function check ( n , m ) { if ( m % n == 0 ) { document . write ( " " ) ; } else { document . write ( " " ) ; } return 0 ; }
function det ( d ) { let Sum = d [ 0 ] [ 0 ] * ( ( d [ 1 ] [ 1 ] * d [ 2 ] [ 2 ] ) - ( d [ 2 ] [ 1 ] * d [ 1 ] [ 2 ] ) ) ; Sum -= d [ 0 ] [ 1 ] * ( ( d [ 1 ] [ 0 ] * d [ 2 ] [ 2 ] ) - ( d [ 1 ] [ 2 ] * d [ 2 ] [ 0 ] ) ) ; Sum += d [ 0 ] [ 2 ] * ( ( d [ 0 ] [ 1 ] * d [ 1 ] [ 2 ] ) - ( d [ 0 ] [ 2 ] * d [ 1 ] [ 1 ] ) ) ; return Sum ; }
function countEvenPairs ( N , M ) { let count = 0 ; nEven = parseInt ( Math . floor ( N / 2 ) ) ; nOdd = parseInt ( Math . ceil ( N / 2 ) ) ; mEven = parseInt ( Math . floor ( M / 2 ) ) ; mOdd = parseInt ( Math . ceil ( M / 2 ) ) ; count = nEven * mEven + nOdd * mOdd ; return count ; }
function solve ( n , d , input ) { let a = new Array ( N ) ; let cnt = new Array ( V + 1 ) ; for ( let i = 0 ; i < n ; ++ i ) a [ i ] = input [ i ] ; let answer = 0 ; for ( let i = 0 ; i < d ; ++ i ) cnt [ a [ i ] ] ++ ; for ( let i = d ; i <= n - 1 ; ++ i ) { let acc = 0 ; let low_median = - 1 , high_median = - 1 ; for ( let v = 0 ; v <= V ; ++ v ) { acc += cnt [ v ] ; if ( low_median == - 1 && acc >= parseInt ( Math . floor ( ( d + 1 ) / 2.0 ) ) ) low_median = v ; if ( high_median == - 1 && acc >= parseInt ( Math . ceil ( ( d + 1 ) / 2.0 ) ) ) high_median = v ; } let double_median = low_median + high_median ; if ( a [ i ] >= double_median ) answer ++ ; cnt [ a [ i - d ] ] -- ; cnt [ a [ i ] ] ++ ; } document . write ( answer ) ; }
function maximumValue ( arr , n ) { var ans = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { ans = Math . max ( ans , arr [ i ] + arr [ j ] + i - j ) ; } } document . write ( ans ) ; }
function alternate ( a , b , x ) { return x = a ^ b ^ x ; }
function findLen ( arr , i , curr , n , m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; var l = findLen ( arr , i + 1 , curr , n , m ) ; var r = findLen ( arr , i + 1 , curr arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }
function findPairs ( arr1 , arr2 , n , m , x ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < m ; j ++ ) if ( arr1 [ i ] + arr2 [ j ] == x ) document . write ( arr1 [ i ] + " " + arr2 [ j ] + " " ) ; }
function smallest_pair ( a , n ) { let min = Number . MAX_VALUE , secondMin = Number . MAX_VALUE ; for ( let j = 0 ; j < n ; j ++ ) { if ( a [ j ] < min ) { secondMin = min ; min = a [ j ] ; } else if ( ( a [ j ] < secondMin ) && a [ j ] != min ) secondMin = a [ j ] ; } return ( secondMin + min ) ; }
function maxSum ( N ) { var ans = 0 ; for ( var u = 1 ; u <= N ; u ++ ) { for ( var v = 1 ; v <= N ; v ++ ) { if ( u == v ) continue ; var degreeU = 2 ; if ( u == 1 u == N ) degreeU = 1 ; var degreeV = 2 ; if ( v == 1 v == N ) degreeV = 1 ; ans += ( degreeU * degreeV ) ; } } return ans ; }
function findMaxAverage ( arr , n , k ) { if ( k > n ) return - 1 ; let sum = arr [ 0 ] ; for ( let i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; let max_sum = sum ; let max_end = k - 1 ; for ( let i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; }
function minMovesToSort ( arr , n ) { var moves = 0 ; var i , mn = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > mn ) moves += arr [ i ] - mn ; mn = arr [ i ] ; } return moves ; }
function CalPeri ( ) { var S = 5 , Perimeter ; Perimeter = 10 * S ; document . write ( " " + Perimeter ) ; }
function sum ( n ) { if ( n == 1 ) return 1 ; else return ( Math . pow ( n , n ) + sum ( n - 1 ) ) ; }
function path_to_root ( node ) { while ( node >= 1 ) { document . write ( node + " " ) ; node = parseInt ( node / 2 , 10 ) ; } }
function check ( current_row , current_col , destination_row , destination_col ) { if ( current_row == destination_row ) return " " ; else if ( current_col == destination_col ) return " " ; else return " " ; }
function findSumOfAllSubsets ( arr , n , k ) { let factorial_N = 1 , factorial_d = 1 , factorial_D = 1 ; for ( let i = 1 ; i <= n - 1 ; i ++ ) factorial_N *= i ; for ( let i = 1 ; i <= k - 1 ; i ++ ) factorial_d *= i ; for ( let i = 1 ; i <= n - k ; i ++ ) factorial_D *= i ; let freq = factorial_N / ( factorial_d * factorial_D ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum = sum * freq ; document . write ( " " + k + " " + sum + " " ) ; }
function maximumCandy ( candies , safety , N , M ) { let total = 0 ; let ans = Number . MAX_VALUE ; let all_safe = true ; for ( let i = 0 ; i < N ; i ++ ) { if ( candies [ i ] + M > safety [ i ] ) { all_safe = false ; ans = Math . min ( ans , safety [ i ] ) ; } else { ans = Math . min ( ans , candies [ i ] + M ) ; } total += candies [ i ] ; } if ( all_safe ) return total ; else return ans ; }
function getSetBitsFromOneToN ( N ) { var two = 2 var ans = 0 var n = N while ( n != 0 ) { ans += Math . floor ( N / two ) * ( two >> 1 ) if ( ( N & ( two - 1 ) ) > ( two >> 1 ) - 1 ) ans += ( N & ( two - 1 ) ) - ( two >> 1 ) + 1 two <<= 1 ; n >>= 1 ; } return ans }
function sphere ( a ) { if ( a < 0 ) return - 1 ; var r = a / 2 ; return r ; }
function productOfGP ( a , r , n ) { let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) { product = product * a ; a = a * r ; } return product ; }
function fib ( n ) { if ( n < 6 ) return f [ n ] ; let t = 5 , fn = 5 ; while ( t < n ) { fn = Math . round ( fn * PHI ) ; t ++ ; } return fn ; }
function bin ( n ) { let i ; document . write ( " " ) ; for ( i = 1 << 30 ; i > 0 ; i = Math . floor ( i / 2 ) ) { if ( ( n & i ) != 0 ) { document . write ( " " ) ; } else { document . write ( " " ) ; } } }
function ispalindrome ( s ) { let l = s . length ; let j ; for ( let i = 0 , j = l - 1 ; i <= j ; i ++ , j -- ) { if ( s [ i ] != s [ j ] ) return false ; } return true ; } let s = " " ; let cnt = 0 ; let flag = 0 ; while ( s . length > 0 ) { if ( ispalindrome ( s ) ) { flag = 1 ; break ; } else { cnt ++ ; s = s . substring ( 0 , s . length - 1 ) ; } }
function Length_Diagonals ( a , theta ) { let p = a * Math . sqrt ( 2 + ( 2 * Math . cos ( theta * ( Math . PI / 180 ) ) ) ) ; let q = a * Math . sqrt ( 2 - ( 2 * Math . cos ( theta * ( Math . PI / 180 ) ) ) ) ; return [ p , q ] ; }
function solve ( n ) { var ans = 0 ; for ( y = n + 1 ; y <= n * n + n ; y ++ ) { if ( ( n * n ) % ( y - n ) == 0 ) { ans += 1 ; } } document . write ( ans ) ; }
function maximizeFinalElement ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; if ( arr [ 0 ] != 1 ) arr [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] > 1 ) { arr [ i ] = arr [ i - 1 ] + 1 ; } } return arr [ n - 1 ] ; }
function nthTerm ( n ) { return 4 * Math . pow ( n , 2 ) - 3 * n + 2 ; }
function findOddPair ( A , N ) { let i , count = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) count ++ ; } return count * ( N - count ) ; }
function fractionToDecimal ( numr , denr ) { let res = " " ; let mp = new Map ( ) ; mp . clear ( ) ; let rem = numr % denr ; while ( ( rem != 0 ) && ( ! mp . has ( rem ) ) ) { mp . set ( rem , res . length ) ; rem = rem * 10 ; let res_part = Math . floor ( rem / denr ) ; res += res_part . toString ( ) ; rem = rem % denr ; } if ( rem == 0 ) return " " ; else if ( mp . has ( rem ) ) return res . substr ( mp . get ( rem ) ) ; return " " ; }
function find ( n , k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; }
function closetAND ( arr , n , k ) { let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { let X = arr [ i ] ; for ( let j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = Math . min ( ans , Math . abs ( k - X ) ) ; } } return ans ; }
function minSteps ( arr , n , k ) { let i , cnt = 0 ; let flag ; if ( k == 1 ) flag = 0 ; else flag = 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == flag ) { cnt ++ ; flag = ( flag + 1 ) % 2 ; } } return cnt ; }
function waysOfDecoding ( s ) { let dp = new Array ( s . length + 1 ) ; for ( let i = 0 ; i < s . length + 1 ; i ++ ) dp [ i ] = 0 ; dp [ 0 ] = 1 ; dp [ 1 ] = s [ 0 ] == ' ' ? 9 : s [ 0 ] == ' ' ? 0 : 1 ; for ( let i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] == ' ' ) { dp [ i + 1 ] = 9 * dp [ i ] ; if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 9 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 6 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 15 * dp [ i - 1 ] ) % M ; } else { dp [ i + 1 ] = s [ i ] != ' ' ? dp [ i ] : 0 ; if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' ' && s [ i ] <= ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + ( s [ i ] <= ' ' ? 2 : 1 ) * dp [ i - 1 ] ) % M ; } } return dp [ s . length ] ; }
function lengtang ( r1 , r2 , d ) { document . write ( " " + " " + ( Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 - r2 ) , 2 ) ) ) . toFixed ( 5 ) ) ; }
function majorityNumber ( arr , n ) { let ans = - 1 ; let freq = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; if ( freq . has ( arr [ i ] ) ) { freq . set ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) } else { freq . set ( arr [ i ] , 1 ) } if ( freq . get ( arr [ i ] ) > n / 2 ) ans = arr [ i ] ; } return ans ; }
function minCost ( cost , n ) { var totalCost = 0 ; var boardingBus = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( cost [ boardingBus ] > cost [ i ] ) { totalCost += ( ( i - boardingBus ) * cost [ boardingBus ] ) ; boardingBus = i ; } } totalCost += ( ( n - boardingBus ) * cost [ boardingBus ] ) ; return totalCost ; }
function countCubes ( a , b ) { return ( Math . floor ( b ** ( 1. / 3. ) ) - Math . ceil ( a ** ( 1. / 3. ) ) + 1 ) }
function largestSubStr ( s ) { while ( s . length && s [ s . length - 1 ] == ' ' ) s = s . substring ( 0 , s . length - 1 ) ; ; if ( s . length == 0 ) return " " ; else return s ; }
function maxSum ( mat , n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ] ; let dp = new Array ( n ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } let maxSum = Number . MIN_VALUE , max ; for ( let j = 0 ; j < n ; j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) { for ( let j = 0 ; j < n ; j ++ ) { max = Number . MIN_VALUE ; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 ] ) ) max = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1 ] ) ) max = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + max ; } } for ( let j = 0 ; j < n ; j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ] ; return maxSum ; }
function areElementsContiguous ( arr , n ) { let max = Number . MIN_VALUE ; let min = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { max = Math . max ( max , arr [ i ] ) ; min = Math . min ( min , arr [ i ] ) ; } let m = max - min + 1 ; if ( m > n ) return false ; let visited = new Array ( n ) ; visited . fill ( false ) ; for ( let i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( let i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; }
function getSum ( arr , p ) { return arr . length ; }
function fun ( marks , n ) { let dp = new Array ( n ) ; let temp ; for ( let i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( marks [ i ] > marks [ i + 1 ] ) { temp = i ; while ( true ) { if ( ( marks [ temp ] > marks [ temp + 1 ] ) && temp >= 0 ) { if ( dp [ temp ] > dp [ temp + 1 ] ) { temp -= 1 ; continue ; } else { dp [ temp ] = dp [ temp + 1 ] + 1 ; temp -= 1 ; } } else break ; } } else if ( marks [ i ] < marks [ i + 1 ] ) dp [ i + 1 ] = dp [ i ] + 1 ; } let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += dp [ i ] ; return sum ; }
function findMinValue ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return ( parseInt ( sum / n ) + 1 ) ; }
function count ( a , n ) { let countElements = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let flag = true ; for ( let j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; if ( a [ i ] % a [ j ] == 0 ) { flag = false ; break ; } } if ( flag == true ) ++ countElements ; } return countElements ; }
function countDigit ( n ) { return Math . floor ( Math . log10 ( n ) + 1 ) ; }
function line ( x0 , y0 ) { var c = parseInt ( 2 * y0 * x0 ) ; document . write ( y0 + " " + " " + x0 + " " + c ) ; }
function find_angle ( x , y , z ) { var volume = x * x * y ; var ans = 0 ; if ( z < volume / 2 ) { var d = ( ( x * y * y ) / ( 2.0 * z ) ) ; ans = Math . atan ( d ) ; } else { z = volume - z ; var d = ( 2 * z ) / ( x * x * x ) ; ans = Math . atan ( d ) ; } ans = ( ( ans * 180 ) / 3.14159265 ) ; return ans ; }
function findX ( A , B ) { let j = 0 , x = 0 ; while ( A != 0 B != 0 ) { if ( ( A % 2 == 1 ) && ( B % 2 == 1 ) ) { x += ( 1 << j ) ; } A >>= 1 ; B >>= 1 ; j += 1 ; } return x ; }
function asciiToSentence ( str , len ) { var num = 0 ; for ( var i = 0 ; i < len ; i ++ ) { num = num * 10 + ( str [ i ] - ' ' ) ; if ( num >= 32 && num <= 122 ) { var ch = String . fromCharCode ( num ) ; document . write ( ch ) ; num = 0 ; } } }
function countWords ( str ) { let count = 1 ; for ( let i = 1 ; i < str . length - 1 ; i ++ ) { if ( str [ i ] >= ' ' && str [ i ] <= ' ' ) count ++ ; } return count ; }
function modifiedBinaryPattern ( n ) { for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= i ; j ++ ) { if ( j == 1 j == i ) document . write ( 1 ) ; else document . write ( 0 ) ; } document . write ( " " ) ; } }
function isPossible ( x , y ) { if ( ( x - y ) == 1 ) return false ; return true ; }
function maxSumArray ( arr , n ) { var sum = 0 ; var mp = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( mp . has ( arr [ i ] ) ) mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) else mp . set ( arr [ i ] , 1 ) } var minimum = 1000000000 ; mp . forEach ( ( value , key ) => { minimum = Math . min ( minimum , value * key ) ; } ) ; return ( sum - minimum ) ; }
function minRemove ( arr , n ) { let LIS = new Array ( n ) . fill ( 0 ) ; let len = 0 ; for ( let i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) LIS [ i ] = Math . max ( LIS [ i ] , LIS [ j ] + 1 ) ; } len = Math . max ( len , LIS [ i ] ) ; } return n - len ; }
function print_product ( a , b , c , d ) { let prod1 = a * c ; let prod2 = b * d ; let prod3 = ( a + b ) * ( c + d ) ; let real = prod1 - prod2 ; let imag = prod3 - ( prod1 + prod2 ) ; document . write ( real + " " + imag + " " ) ; }
function numSeq ( n ) { return Math . floor ( ( Math . pow ( 3 , n ) + 3 * Math . pow ( - 1 , n ) ) / 4 ) ; }
function getCount ( a , b , c ) { let count = 0 ; for ( let i = 1 ; i <= 81 ; i ++ ) { let cr = b * Math . pow ( i , a ) + c ; let tmp = cr ; let sm = 0 ; while ( tmp != 0 ) { sm += tmp % 10 ; tmp = Math . floor ( tmp / 10 ) ; } if ( sm == i && cr < 1e9 ) count ++ ; } return count ; }
function pairs_count ( arr , n , sum ) { let ans = 0 ; arr . sort ( ) ; let i = 0 , j = n - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] < sum ) i ++ ; else if ( arr [ i ] + arr [ j ] > sum ) j -- ; else { let x = arr [ i ] , xx = i ; while ( i < j && arr [ i ] == x ) i ++ ; let y = arr [ j ] , yy = j ; while ( j >= i && arr [ j ] == y ) j -- ; if ( x == y ) { let temp = i - xx + yy - j - 1 ; ans += ( temp * ( temp + 1 ) ) / 2 ; } else ans += ( i - xx ) * ( yy - j ) ; } } return ans ; }
function DecakismyriagonNum ( N ) { return ( 99998 * N * N - 99996 * N ) / 2 ; }
function insertAfter ( prev_node , new_data ) { if ( prev_node == null ) { document . write ( " " ) ; return ; } var new_node = new Node ( new_data ) ; new_node . next = prev_node . next ; prev_node . next = new_node ; }
function judgeSquareSum ( n ) { for ( i = 2 ; i * i <= n ; i ++ ) { var count = 0 ; if ( n % i == 0 ) { while ( n % i == 0 ) { count ++ ; n = parseInt ( n / i ) ; } if ( i % 4 == 3 && count % 2 != 0 ) return false ; } } return n % 4 != 3 ; }
function LeftRightNode ( preorder , n ) { var min = 1000000000 , max = - 1000000000 ; for ( var i = 0 ; i < n ; i ++ ) { if ( min > preorder [ i ] ) min = preorder [ i ] ; if ( max < preorder [ i ] ) max = preorder [ i ] ; } document . write ( " " + min + " " ) ; document . write ( " " + max ) ; }
function sumOfAP ( a , d , n ) { let sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) ; return sum ; }
function seriesSum ( n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
function Substring ( s ) { var ans = 1 , temp = 1 ; for ( var i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { ++ temp ; } else { ans = Math . max ( ans , temp ) ; temp = 1 ; } } ans = Math . max ( ans , temp ) ; return ans ; }
function RightRotate ( a , n , k ) { k = k % n ; for ( let i = 0 ; i < n ; i ++ ) { if ( i < k ) { document . write ( a [ n + i - k ] + " " ) ; } else { document . write ( ( a [ i - k ] ) + " " ) ; } } document . write ( " " ) ; }
function squareSide ( a ) { if ( a < 0 ) return - 1 ; var x = ( 0.423 * a ) ; return x ; }
function solve ( s1 , s2 ) { let flag1 = 0 , flag2 = 0 ; if ( s1 . length != s2 . length ) return false ; let l = s1 . length ; for ( let i = 0 ; i < l ; i ++ ) { if ( s1 [ i ] == ' ' ) flag1 = 1 ; if ( s2 [ i ] == ' ' ) flag2 = 1 ; if ( flag1 && flag2 ) return true ; } if ( ! flag1 && ! flag2 ) return true ; return false ; }
function getPosition ( N , M ) { if ( M > parseInt ( N / 2 ) ) { return ( M - parseInt ( N / 2 ) ) ; } return ( M + parseInt ( N / 2 ) ) ; }
function distributeN ( A , B , C , n ) { let max1 = Math . max ( A , B ) ; let max2 = Math . max ( B , C ) ; let maximum = Math . max ( max1 , max2 ) ; let sum = A + B + C ; let p = ( 3 * maximum ) - sum ; let diff = n - p ; if ( diff < 0 diff % 3 ) document . write ( " " ) ; else document . write ( " " ) ; }
function findSum ( N ) { var sum = ( N ) * ( N + 1 ) / 2 ; var r = ( Math . log ( N ) / Math . log ( 2 ) ) + 1 ; var expSum = ( Math . pow ( 2 , r ) ) - 1 ; document . write ( sum - expSum ) ; }
function prletMissingElements ( arr , N ) { let diff = arr [ 0 ] - 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] - i != diff ) { while ( diff < arr [ i ] - i ) { document . write ( ( i + diff ) + " " ) ; diff ++ ; } } } }
function maxsubStringLength ( S , N ) { let arr = Array . from ( { length : N } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < N ; i ++ ) if ( S [ i ] == ' ' S [ i ] == ' ' S [ i ] == ' ' S [ i ] == ' ' S [ i ] == ' ' ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; let maxLen = 0 ; let curr_sum = 0 ; let hash = new Map ( ) ; for ( let i = 0 ; i < N ; i ++ ) { curr_sum += arr [ i ] ; if ( curr_sum == 0 ) maxLen = Math . max ( maxLen , i + 1 ) ; if ( hash . has ( curr_sum ) ) maxLen = Math . max ( maxLen , i - hash . get ( curr_sum ) ) ; else hash . set ( curr_sum , i ) ; } return maxLen ; }
function countSubString ( S , C ) { var count = 0 ; var conCount = 0 ; for ( var i = 0 ; i < S . length ; i ++ ) { var ch = S [ i ] ; if ( ch === C ) conCount ++ ; else { count += ( conCount * ( conCount + 1 ) ) / 2 ; conCount = 0 ; } } count += ( conCount * ( conCount + 1 ) ) / 2 ; document . write ( count ) ; }
function exponential ( n , x ) { var sum = 1 ; for ( i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; }
function findNature ( a , b , n ) { if ( n == 0 ) return ( a & 1 ) == 1 ? true : false ; if ( n == 1 ) return ( b & 1 ) == 1 ? true : false ; if ( ( a & 1 ) == 0 ) { if ( ( b & 1 ) == 0 ) return false ; else return ( n % 3 != 0 ) ; } else { if ( ( b & 1 ) == 0 ) return ( ( n - 1 ) % 3 != 0 ) ; else return ( ( n + 1 ) % 3 != 0 ) ; } }
function count_square ( n ) { let count = 0 ; for ( let i = 1 ; i <= n ; i = i + 2 ) { let k = n - i + 1 ; count += ( k * k ) ; } return count ; }
function check ( a , b , Na , Nb , k , m ) { if ( Na < k Nb < m ) return " " ; a . sort ( ) ; b . sort ( ) ; if ( a [ k - 1 ] < b [ Nb - m ] ) { return " " ; } return " " ; }
function completeSequence ( s ) { let n = s . length ; let open = 0 , close = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' ) open ++ ; else close ++ ; if ( close > open ) { document . write ( " " ) ; return ; } } document . write ( s ) ; for ( let i = 0 ; i < open - close ; i ++ ) document . write ( " " ) ; }
function maximumArea ( l , b , x , y ) { var left = x * b ; var right = ( l - x - 1 ) * b ; var above = l * y ; var below = ( b - y - 1 ) * l ; document . write ( Math . max ( Math . max ( left , right ) , Math . max ( above , below ) ) ) ; }
function printNum ( L , R ) { for ( let i = L ; i <= R ; i ++ ) { let temp = i ; let c = 10 ; let flag = 0 ; while ( temp > 0 ) { if ( temp % 10 >= c ) { flag = 1 ; break ; } c = temp % 10 ; temp /= 10 ; } if ( flag == 0 ) document . write ( i + " " ) ; } }
function averageRuns ( runs , matches , notout ) { let out1 ; out1 = matches - notout ; if ( out1 == 0 ) return - 1 ; let avg = parseInt ( ( runs ) / out1 , 10 ) ; return avg ; }
function multiplyBySevenByEight ( n ) { return ( n - ( n >> 3 ) ) ; }
function maxSelectionCount ( a , n ) { var res = 0 ; a . sort ( ) ; var select = 1 ; for ( var i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= select ) { res ++ ; select ++ ; } } return res ; }
function calculateSum ( n ) { return ( Math . pow ( 2 , n + 1 ) + n - 2 ) ; }
function minParentheses ( p ) { var bal = 0 ; var ans = 0 ; for ( var i = 0 ; i < p . length ; ++ i ) { bal += p [ i ] == ' ' ? 1 : - 1 ; if ( bal == - 1 ) { ans += 1 ; bal += 1 ; } } return bal + ans ; }
function minSwaps ( N , M , A , B ) { let count01 = 0 ; let count10 = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) { if ( A [ i ] [ j ] != B [ i ] [ j ] ) { if ( A [ i ] [ j ] == 1 ) count10 ++ ; else count01 ++ ; } } } if ( count01 == count10 ) return count01 ; else return - 1 ; }
function findTrailingZeros ( n ) { let count = 0 ; for ( let i = 5 ; Math . floor ( n / i ) >= 1 ; i *= 5 ) count += Math . floor ( n / i ) ; return count ; }
function countNum ( arr , n ) { let count = 0 ; arr . sort ( ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ; return count ; }
function printModulus ( X , Y ) { var d = Math . abs ( X - Y ) ; var i = 1 ; while ( i * i <= d ) { if ( d % i == 0 ) { document . write ( i + " " ) ; if ( d / i != i ) document . write ( parseInt ( d / i ) + " " ) ; } i ++ ; } }
function SubseqWidths ( A , n ) { A . sort ( ( a , b ) => a - b ) var pow2 = Array ( n ) . fill ( 0 ) ; pow2 [ 0 ] = 1 ; for ( var i = 1 ; i < n ; ++ i ) pow2 [ i ] = ( pow2 [ i - 1 ] * 2 ) % MOD ; var ans = 0 ; for ( var i = 0 ; i < n ; ++ i ) ans = ( ans + ( pow2 [ i ] - pow2 [ n - 1 - i ] ) * A [ i ] ) % MOD ; return ans ; }
function find_Numb_ways ( n ) { var odd_indices = n / 2 ; var even_indices = ( n / 2 ) + ( n % 2 ) ; var arr_odd = Math . pow ( 4 , odd_indices ) ; var arr_even = Math . pow ( 5 , even_indices ) ; return arr_odd * arr_even ; }
function balancedTernary ( n ) { var output = " " ; while ( n > 0 ) { var rem = n % 3 ; n = parseInt ( n / 3 ) ; if ( rem == 2 ) { rem = - 1 ; n ++ ; } output = ( rem == 0 ? ' ' : ( rem == 1 ) ? ' ' : ' ' ) + output ; } return output ; }
function MinOfCubedDP ( k ) { let DP = new Array ( k + 1 ) ; DP . fill ( 0 ) ; let j = 1 , t = 1 ; DP [ 0 ] = 0 ; for ( let i = 1 ; i <= k ; i ++ ) { DP [ i ] = Number . MAX_VALUE ; while ( j <= i ) { if ( j == i ) DP [ i ] = 1 ; else if ( DP [ i ] > DP [ i - j ] ) DP [ i ] = DP [ i - j ] + 1 ; t ++ ; j = t * t * t ; } t = j = 1 ; } return DP [ k ] ; }
function Mixture ( X , Y , Z ) { var result = 0.0 , result1 = 0.0 ; result1 = ( ( X - Y ) / X ) ; result = Math . pow ( result1 , Z ) ; result = result * X ; return result ; }
function cntWays ( str , n ) { var x = n + 1 ; var ways = x * x * ( x * x - 1 ) / 12 ; return ways ; }
function SumofInverseDivisors ( N , Sum ) { let ans = ( Sum ) * 1.0 / ( N ) ; return ans ; }
function vectorMagnitude ( x , y , z ) { var sum = x * x + y * y + z * z ; return Math . sqrt ( sum ) ; }
function countSubSeq ( str , len ) { var ans = 0 ; var mul = 1 ; for ( var i = 0 ; i < len ; i ++ ) { if ( str [ i ] == ' ' ) ans += mul ; mul *= 2 ; } return ans ; }
function isPentadecagon ( N ) { var n = ( 11 + Math . sqrt ( 104 * N + 121 ) ) / 26 ; return ( n - parseInt ( n ) ) == 0 ; } var N = 15 ; if ( isPentadecagon ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function isSubSeqDivisible ( str ) { let i , j , k , l = str . length ; let arr = [ ] ; for ( i = 0 ; i < l ; i ++ ) arr [ i ] = str [ i ] - ' ' ; for ( i = 0 ; i < l ; i ++ ) { for ( j = i ; j < l ; j ++ ) { for ( k = j ; k < l ; k ++ ) { if ( arr [ i ] % 8 == 0 ) return true ; else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ; else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ; } } } return false ; }
function EqualNumber ( A , B ) { return ( A ^ B ) ; }
function allBitsSetInTheGivenRange ( n , l , r ) { var num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; var new_num = n & num ; if ( new_num == 0 ) return " " ; return " " ; }
function findUnique ( a , n , k ) { let sizeof_let = 4 ; let LET_SIZE = 8 * sizeof_let ; let count = Array . from ( { length : LET_SIZE } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < LET_SIZE ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) if ( ( a [ j ] & ( 1 << i ) ) != 0 ) count [ i ] += 1 ; let res = 0 ; for ( let i = 0 ; i < LET_SIZE ; i ++ ) res += ( count [ i ] % k ) * ( 1 << i ) ; return res ; }
function Maxcost ( s , cost ) { let maxcost = 0 ; let i = 0 ; while ( i < s . length - 1 ) { if ( s [ i ] == s [ i + 1 ] ) { if ( cost [ i ] > cost [ i + 1 ] ) maxcost += cost [ i ] ; else { maxcost += cost [ i + 1 ] ; cost [ i + 1 ] = cost [ i ] ; } } i ++ ; } return maxcost ; }
function find ( N , sum ) { if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } let s = 0 ; for ( let i = 1 ; i <= 6 ; i ++ ) s = s + find ( N - 1 , sum - i ) / 6 ; return s ; }
function GenerateArray ( N , X ) { let prev_xor = X ; for ( let i = 1 ; i <= N ; i ++ ) { document . write ( ( i ^ prev_xor ) ) ; if ( i != N ) { document . write ( " " ) ; } prev_xor = i ; } }
function MinOperation ( a , b , n ) { a . sort ( function ( a , b ) { return a - b } ) ; b . sort ( function ( a , b ) { return a - b } ) ; let result = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( a [ i ] > b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; else if ( a [ i ] < b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; } return result ; }
function LCIS ( arr1 , n , arr2 , m ) { let table = [ ] ; for ( let j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let current = 0 ; for ( let j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ; if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } } let result = 0 ; for ( let i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; }
function distinctCount ( arr , n ) { let s = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) s . add ( Math . abs ( arr [ i ] ) ) ; return s . size ; }
function nthTerm ( N ) { let nth = 0 , first_term = 4 ; let pi = 1 , po = 1 ; let n = N ; while ( n > 1 ) { pi *= n - 1 ; n -- ; po *= 2 ; } nth = ( first_term * pi ) / po ; return nth ; }
function countWays ( n ) { if ( n <= 2 ) document . write ( " " ) ; else { var ans = ( n - 1 ) * ( n - 2 ) / 2 ; document . write ( ans ) ; } }
function findMinLength ( arr , N ) { let front = 0 , back = N - 1 ; while ( front < back ) { let x = arr [ front ] ; if ( arr [ front ] != arr [ back ] ) break ; while ( arr [ front ] == x && front <= back ) front ++ ; while ( arr [ back ] == x && front <= back ) back -- ; } document . write ( back - front + 1 ) ; document . write ( " " ) ; }
function TetracontaoctagonalNum ( n ) { return ( 46 * n * n - 44 * n ) / 2 ; }
function sumBitDifferences ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < 32 ; i ++ ) { let count = 0 ; for ( let j = 0 ; j < n ; j ++ ) if ( ( arr [ j ] & ( 1 << i ) ) ) count ++ ; ans += ( count * ( n - count ) * 2 ) ; } return ans ; }
function distance ( r , R ) { let d = Math . sqrt ( Math . pow ( R , 2 ) - ( 2 * r * R ) ) ; return d ; }
function findMinimumTime ( tasks , K ) { var map = new Map ( ) ; var curr_time = 0 ; tasks . split ( ' ' ) . forEach ( c => { if ( map . has ( c ) ) { if ( curr_time - map . get ( c ) <= K ) { curr_time += K - ( curr_time - map . get ( c ) ) + 1 ; } } map . set ( c , curr_time ) ; curr_time ++ ; } ) ; document . write ( curr_time ) ; }
function centered_heptagonal_num ( n ) { return parseInt ( ( 7 * n * n - 7 * n + 2 ) / 2 ) ; }
function smallestNumber ( N ) { document . write ( N * parseInt ( Math . ceil ( Math . pow ( 2 , ( N - 1 ) ) / N ) ) ) ; }
function findRepeatFirstN2 ( s ) { let p = - 1 , i , j ; for ( i = 0 ; i < s . length ; i ++ ) { for ( j = i + 1 ; j < s . length ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } } if ( p != - 1 ) break ; } return p ; }
function maxSubarrayXOR ( arr , n ) { let ans = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { let curr_xor = 0 ; for ( let j = i ; j < n ; j ++ ) { curr_xor = curr_xor ^ arr [ j ] ; ans = Math . max ( ans , curr_xor ) ; } } return ans ; }
function isStar ( N ) { let n = ( 6 + Math . sqrt ( 24 * N + 12 ) ) / 6 ; return ( n - parseInt ( n ) ) == 0 ; } let i = 13 ; if ( isStar ( i ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function solve ( a , n ) { let mx = 0 ; for ( let j = 1 ; j < n ; j ++ ) { if ( mx > a [ j ] ) return false ; mx = Math . max ( mx , a [ j - 1 ] ) ; } return true ; }
function longestSubstring ( s ) { var cnt = 1 , maxi = 1 ; var n = s . length ; for ( i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i - 1 ) ) cnt ++ ; else { maxi = Math . max ( cnt , maxi ) ; cnt = 1 ; } } maxi = Math . max ( cnt , maxi ) ; return maxi ; }
function Colour_Combination ( s ) { let temp = s [ 0 ] ; for ( let i = 1 ; i < s . length ; i ++ ) { if ( temp != s [ i ] ) { if ( ( temp == ' ' temp == ' ' ) && ( s [ i ] == ' ' s [ i ] == ' ' ) ) temp = ' ' ; else if ( ( temp == ' ' temp == ' ' ) && ( s [ i ] == ' ' s [ i ] == ' ' ) ) temp = ' ' ; else temp = ' ' ; } } return temp ; }
function totalTriangles ( h , v ) { if ( h == 0 && v == 0 ) return 1 ; if ( h == 0 ) return ( ( v + 1 ) * ( v + 2 ) / 2 ) ; if ( v == 0 ) return ( h + 1 ) ; var total = ( h + 1 ) * ( ( v + 1 ) * ( v + 2 ) / 2 ) ; return total ; }
function lucas ( n ) { let a = 2 , b = 1 , c , i ; if ( n == 0 ) return a ; for ( i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return b ; }
function checkJumbled ( num ) { if ( parseInt ( num / 10 , 10 ) == 0 ) return true ; while ( num != 0 ) { if ( parseInt ( num / 10 , 10 ) == 0 ) return true ; let digit1 = num % 10 ; let digit2 = parseInt ( num / 10 , 10 ) % 10 ; if ( Math . abs ( digit2 - digit1 ) > 1 ) return false ; num = parseInt ( num / 10 , 10 ) ; } return true ; }
function createArray ( n , s ) { if ( 2 * n <= s ) { for ( let i = 0 ; i < n - 1 ; i ++ ) { document . write ( 2 + " " ) ; s -= 2 ; } document . write ( s + " " ) ; document . write ( 1 ) ; } else document . write ( " " ) ; }
function solve ( arr , n ) { var countzeroes = 0 ; var countones = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) countzeroes ++ ; else countones ++ ; } if ( Math . abs ( countzeroes - countones ) == 1 ) document . write ( " " ) ; else document . write ( " " ) ; }
function sumoflength ( arr , n ) { let s = new Set ( ) ; let j = 0 , ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { while ( j < n && ! s . has ( arr [ j ] ) ) { s . add ( arr [ i ] ) ; j ++ ; } ans += Math . floor ( ( ( j - i ) * ( j - i + 1 ) ) / 2 ) ; s . delete ( arr [ i ] ) ; } return ans ; }
function prodSquare ( n ) { for ( i = 2 ; i * i <= n ; i ++ ) for ( j = 2 ; j <= n ; j ++ ) if ( i * i * j * j == n ) return true ; return false ; }
function findCountOfPairs ( a , b , n ) { let ans = 0 ; for ( let i = 1 ; i <= a ; i ++ ) { ans += parseInt ( b / n , 10 ) ; ans += ( i % n + b % n ) >= n ? 1 : 0 ; } return ans ; }
function isOsiris ( n ) { let a = n % 10 ; let b = parseInt ( ( n / 10 ) % 10 ) ; let c = parseInt ( n / 100 ) ; let digit_sum = a + b + c ; if ( n == ( 2 * ( digit_sum ) * 11 ) ) { return true ; } return false ; }
function checkEVENodd ( arr , n , l , r ) { if ( arr [ r ] == 1 ) document . write ( " " ) ; else document . write ( " " ) ; }
function sumSquare ( n ) { let s = new Map ( ) ; for ( let i = 0 ; i * i <= n ; ++ i ) { s . set ( i * i , 1 ) ; if ( s . has ( n - i * i ) ) { document . write ( Math . sqrt ( n - i * i ) + " " + i + " " ) ; return true ; } } return false ; }
function isCentereddecagonal ( N ) { let n = ( 5 + Math . sqrt ( 20 * N + 5 ) ) / 10 ; return ( n - parseInt ( n ) ) == 0 ; } let N = 11 ; if ( isCentereddecagonal ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function isConversionPossible ( s1 , s2 , x ) { let diff = 0 , n ; n = s1 . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( s1 [ i ] == s2 [ i ] ) continue ; diff = ( ( s2 [ i ] . charCodeAt ( 0 ) - s1 [ i ] . charCodeAt ( 0 ) ) + 26 ) % 26 ; if ( diff > x ) { document . write ( " " ) ; return ; } } document . write ( " " ) ; }
function isDefeat ( s1 , s2 , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) || ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) ) continue ; else if ( ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) || ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) ) continue ; else { return true ; } } return false ; }
function nearest ( n ) { var prevSquare = parseInt ( Math . sqrt ( n ) ) ; var nextSquare = prevSquare + 1 ; prevSquare = prevSquare * prevSquare ; nextSquare = nextSquare * nextSquare ; if ( ( n - prevSquare ) < ( nextSquare - n ) ) { ans = parseInt ( ( prevSquare - n ) ) ; } else ans = parseInt ( ( nextSquare - n ) ) ; return ans ; }
function printSorted ( a , b , c ) { let get_max = Math . max ( a , Math . max ( b , c ) ) ; let get_min = - Math . max ( - a , Math . max ( - b , - c ) ) ; let get_mid = ( a + b + c ) - ( get_max + get_min ) ; document . write ( get_min + " " + get_mid + " " + get_max ) ; }
function firstSetBit ( n ) { let x = n & ( n - 1 ) ; return ( n ^ x ) ; }
function dealnnoy ( n , m ) { var dp = Array . from ( Array ( m + 1 ) , ( ) => Array ( n + 1 ) ) ; for ( var i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( var i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( var i = 1 ; i <= m ; i ++ ) for ( var j = 1 ; j <= n ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; return dp [ m ] [ n ] ; }
function totalSubSets ( n , l , r ) { let zero = Math . floor ( r / 3 ) - Math . ceil ( l / 3 ) + 1 ; let one = Math . floor ( ( r - 1 ) / 3 ) - Math . ceil ( ( l - 1 ) / 3 ) + 1 ; let two = Math . floor ( ( r - 2 ) / 3 ) - Math . ceil ( ( l - 2 ) / 3 ) + 1 ; let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( 3 ) ; for ( let j = 0 ; j < 3 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = zero ; dp [ 0 ] [ 1 ] = one ; dp [ 0 ] [ 2 ] = two ; for ( let i = 1 ; i < n ; ++ i ) { dp [ i ] [ 0 ] = ( ( dp [ i - 1 ] [ 0 ] * zero ) + ( dp [ i - 1 ] [ 1 ] * two ) + ( dp [ i - 1 ] [ 2 ] * one ) ) % MOD ; dp [ i ] [ 1 ] = ( ( dp [ i - 1 ] [ 0 ] * one ) + ( dp [ i - 1 ] [ 1 ] * zero ) + ( dp [ i - 1 ] [ 2 ] * two ) ) % MOD ; dp [ i ] [ 2 ] = ( ( dp [ i - 1 ] [ 0 ] * two ) + ( dp [ i - 1 ] [ 1 ] * one ) + ( dp [ i - 1 ] [ 2 ] * zero ) ) % MOD ; } return dp [ n - 1 ] [ 0 ] ; }
function minimumflip ( mat , n ) { let flip = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; return flip ; }
function findLast ( mat ) { let m = mat . length ; let n = mat [ 0 ] . length ; let rows = new Set ( ) ; let cols = new Set ( ) ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] ) { rows . add ( i ) ; cols . add ( j ) ; } } } let avRows = m - rows . size ; let avCols = n - cols . size ; let choices = Math . min ( avRows , avCols ) ; if ( choices & 1 ) document . write ( " " ) else document . write ( " " ) }
function count ( N , X , subStr , index , n ) { if ( index == n ) return 0 ; let a = subStr + N [ index ] ; let b = 0 ; if ( parseInt ( a ) % X == 0 ) b = 1 ; let m1 = count ( N , X , a , index + 1 , n ) ; let m2 = b + count ( N , X , " " , index + 1 , n ) ; return Math . max ( m1 , m2 ) ; }
function evenFib ( n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ; return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; }
function permutationCoeff ( n , k ) { let fact = new Array ( n + 1 ) ; fact [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; return parseInt ( fact [ n ] / fact [ n - k ] , 10 ) ; }
function Centered_Triangular_num ( n ) { return ( 3 * n * n + 3 * n + 2 ) / 2 ; }
function findMedian ( a , n ) { a . sort ( ) ; if ( n % 2 != 0 ) return a [ parseInt ( n / 2 ) ] ; return ( a [ parseInt ( ( n - 1 ) / 2 ) ] + a [ parseInt ( n / 2 ) ] ) / 2.0 ; }
function count ( head , key ) { if ( head == null ) return 0 ; if ( head . data == key ) return 1 + count ( head . next , key ) ; return count ( head . next , key ) ; }
function findRadiusOfcircumcircle ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; var radius = Math . sqrt ( Math . pow ( l , 2 ) + Math . pow ( b , 2 ) ) / 2 ; return radius ; }
function longestSubArray ( arr , n ) { var isZeroPresent = false ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { isZeroPresent = true ; break ; } } if ( isZeroPresent ) return n ; return 0 ; }
function checkSolution ( a , b , c ) { if ( a == c ) document . write ( " " ) ; else document . write ( " " ) ; }
function mulsum ( arr , n , N ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % N == 0 ) { sum = sum + arr [ i ] ; } } document . write ( sum ) ; }
function divisibleBy36 ( num ) { let l = num . length ; if ( l == 0 ) return " " ; if ( l == 1 && num [ 0 ] != ' ' ) return " " ; let two_digit_num = ( num [ l - 2 ] - ' ' ) * 10 + ( num [ l - 1 ] - ' ' ) ; if ( two_digit_num % 4 != 0 ) return " " ; let sum = 0 ; for ( let i = 0 ; i < l ; i ++ ) sum += ( num [ i ] - ' ' ) ; if ( sum % 9 != 0 ) return " " ; return " " ; }
function isRepdigit ( num , b ) { let prev = - 1 ; while ( num != 0 ) { let digit = num % b ; num = parseInt ( num / b ) ; if ( prev != - 1 && digit != prev ) return false ; prev = digit ; } return true ; } let num = 2000 , base1 = 7 ; if ( isRepdigit ( num , base1 ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function CountTriplets ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let first = arr [ i ] ; for ( let j = i + 1 ; j < n ; j ++ ) { first ^= arr [ j ] ; if ( first == 0 ) ans += ( j - i ) ; } } return ans ; }
function findAns ( mat , x , y , n , m ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { ans += Math . abs ( x - i ) + Math . abs ( y - j ) ; } } } return ans ; }
function maxRepeating ( arr , n , k ) { for ( let i = 0 ; i < n ; i ++ ) arr [ arr [ i ] % k ] += k ; let max = arr [ 0 ] , result = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; result = i ; } } return result ; }
function FindMaxS ( X , Y , Z , n , A , B , C ) { if ( X < 0 Y < 0 Z < 0 ) return Number . MIN_VALUE ; if ( n < 0 ) return 0 ; if ( dp [ n ] [ X ] [ Y ] [ Z ] != - 1 ) { return dp [ n ] [ X ] [ Y ] [ Z ] ; } let ch = A [ n ] + FindMaxS ( X - 1 , Y , Z , n - 1 , A , B , C ) ; let ca = B [ n ] + FindMaxS ( X , Y - 1 , Z , n - 1 , A , B , C ) ; let co = C [ n ] + FindMaxS ( X , Y , Z - 1 , n - 1 , A , B , C ) ; let no = FindMaxS ( X , Y , Z , n - 1 , A , B , C ) ; let maximum = Math . max ( ch , Math . max ( ca , Math . max ( co , no ) ) ) ; dp [ n ] [ X ] [ Y ] [ Z ] = maximum ; return dp [ n ] [ X ] [ Y ] [ Z ] ; } let X = 1 ; let Y = 1 ; let Z = 1 ; let A = [ 10 , 0 , 5 ] ; let B = [ 5 , 10 , 0 ] ; let C = [ 0 , 5 , 10 ] ; let n = B . length ; for ( let i = 0 ; i < 50 ; i ++ ) { dp [ i ] = new Array ( 50 ) ; for ( let j = 0 ; j < 50 ; j ++ ) { dp [ i ] [ j ] = new Array ( 50 ) ; for ( let k = 0 ; k < 50 ; k ++ ) { dp [ i ] [ j ] [ k ] = new Array ( 50 ) ; for ( let l = 0 ; l < 50 ; l ++ ) { dp [ i ] [ j ] [ k ] [ l ] = - 1 ; } } } }
function count ( n ) { if ( n == 2 ) return 1 ; else if ( n == 4 ) return 2 ; else if ( n == 6 ) return 4 ; let table = Array . from ( { length : n + 1 } , ( _ , i ) => 0 ) ; let i ; for ( i = 0 ; i < n + 1 ; i ++ ) table [ i ] = 0 ; table [ 0 ] = 0 ; table [ 2 ] = 1 ; table [ 4 ] = 2 ; table [ 6 ] = 4 ; for ( i = 8 ; i <= n ; i = i + 2 ) { table [ i ] = table [ i - 2 ] + table [ i - 4 ] + table [ i - 6 ] ; } return table [ n ] ; }
function FindMinimumCost ( ind , a , n , k , dp ) { if ( ind == ( n - 1 ) ) return 0 ; else if ( dp [ ind ] != - 1 ) return dp [ ind ] ; else { var ans = Number . MAX_VALUE ; for ( var i = 1 ; i <= k ; i ++ ) { if ( ind + i < n ) ans = Math . min ( ans , Math . abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ; else break ; } return dp [ ind ] = ans ; } }
function MatrixChainOrder ( p , i , j ) { if ( i == j ) return 0 ; var min = Number . MAX_VALUE ; var k = 0 ; for ( k = i ; k < j ; k ++ ) { var count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; }
function closestNumber ( n , m ) { let q = parseInt ( n / m ) ; let n1 = m * q ; let n2 = ( n * m ) > 0 ? ( m * ( q + 1 ) ) : ( m * ( q - 1 ) ) ; if ( Math . abs ( n - n1 ) < Math . abs ( n - n2 ) ) return n1 ; return n2 ; }
function maxTripletSum ( arr , n ) { let sum = - 1000000 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; }
function adjacentSet ( n ) { let x = ( n & ( n >> 1 ) ) ; if ( x > 0 ) return true ; else return false ; }
function maxGcd ( a , b ) { document . write ( Math . abs ( a - b ) ) ; }
function towerOfHanoi ( n , from_rod , to_rod , aux_rod ) { if ( n == 1 ) { document . write ( " " + from_rod + " " + to_rod + " " ) ; return ; } towerOfHanoi ( n - 1 , from_rod , aux_rod , to_rod ) ; document . write ( " " + n + " " + from_rod + " " + to_rod + " " ) ; towerOfHanoi ( n - 1 , aux_rod , to_rod , from_rod ) ; }
function sortExceptUandL ( a , l , u , n ) { let b = [ ] ; for ( let i = 0 ; i < l ; i ++ ) b [ i ] = a [ i ] ; for ( let i = u + 1 ; i < n ; i ++ ) b [ l + ( i - ( u + 1 ) ) ] = a [ i ] ; b . sort ( ) ; for ( let i = 0 ; i < l ; i ++ ) a [ i ] = b [ i ] ; for ( let i = u + 1 ; i < n ; i ++ ) a [ i ] = b [ l + ( i - ( u + 1 ) ) ] ; }
function maxOR ( arr , n ) { let max_value = Math . max ( ... arr ) ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { ans = Math . max ( ans , ( max_value arr [ i ] ) ) ; } return ans ; }
function inProportion ( arr ) { var n = 4 ; arr . sort ( ) ; var extremes = arr [ 0 ] * arr [ 3 ] ; var means = arr [ 1 ] * arr [ 2 ] ; if ( extremes == means ) return true ; return false ; }
function findWaysToPair ( p ) { var dp = Array ( p + 1 ) ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; for ( var i = 3 ; i <= p ; i ++ ) { dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ p ] ; }
function decdiagonal ( a ) { if ( a < 0 ) return - 1 ; var d = 1.902 * a ; return d ; }
function doMatch ( A , B ) { for ( i = 0 ; i < A . length ; i ++ ) { if ( A . charAt ( i ) != ' ' && B . charAt ( i ) != ' ' ) { if ( A . charAt ( i ) != B . charAt ( i ) ) return 0 ; } } return 1 ; }
function countTriplets ( N ) { let cnt = 0 ; for ( let A = 1 ; A <= N ; ++ A ) { for ( let B = 1 ; B <= N / A ; ++ B ) { cnt += N / ( A * B ) ; } } return cnt ; }
function findMinSum ( mat , N ) { var sum = 0 ; for ( var i = 0 ; i < N ; i ++ ) { var res = 0 ; for ( var j = 0 ; j < N ; j ++ ) { if ( i != j ) { res |= mat [ i ] [ j ] ; } } sum += res ; } return sum ; }
function generatepermutation ( N ) { var answer = [ ] ; answer . push ( N ) ; console . log ( answer ) ; for ( var i = 1 ; i < N ; i ++ ) { console . log ( answer ) ; answer . push ( i ) ; } for ( var i in answer ) document . write ( answer [ i ] + " " ) ; }
function minimumCost ( cost , n ) { let dp1 = 0 , dp2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let dp0 = cost [ i ] + Math . min ( dp1 , dp2 ) ; dp2 = dp1 ; dp1 = dp0 ; } return Math . min ( dp1 , dp2 ) ; }
function countSubstrs ( str , i , j , n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; let res = countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ; if ( str [ i ] == str [ j ] ) res ++ ; return res ; }
function lastDigit2PowerN ( n ) { if ( n == 0 ) return 1 ; else if ( n % 4 == 1 ) return 2 ; else if ( n % 4 == 2 ) return 4 ; else if ( n % 4 == 3 ) return 8 ; else }
function IsPrime ( i ) { if ( i % 2 == 0 && i != 2 ) return false ; else { for ( j = 3 ; j <= Math . sqrt ( i ) ; j += 2 ) { if ( i % j == 0 ) return false ; } return true ; } } var c = 0 ; var N = 72 ; for ( i = 2 ; i <= Math . sqrt ( N ) ; i ++ ) { if ( IsPrime ( i ) ) { if ( N % i == 0 ) { c ++ ; if ( IsPrime ( N / i ) && i != ( N / i ) ) c ++ ; } } }
function MaximumPath ( Mat ) { let result = 0 ; let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( N + 2 ) ; for ( let j = 0 ; j < N + 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < N ; i ++ ) dp [ 0 ] [ i + 1 ] = Mat [ 0 ] [ i ] ; for ( let i = 1 ; i < N ; i ++ ) for ( let j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j - 1 ] , Math . max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] ; for ( let i = 0 ; i <= N ; i ++ ) result = Math . max ( result , dp [ N - 1 ] [ i ] ) ; return result ; }
function allBitsSetInTheGivenRange ( n , l , r ) { let num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; let new_num = n & num ; if ( new_num == 0 ) return true ; return false ; }
function findTemperature ( x , y , s ) { let Day1 , Day2 ; let diff = ( x - y ) * 6 ; Day2 = ( diff + s ) / 2 ; Day1 = s - Day2 ; document . write ( " " + Day1 + " " ) ; document . write ( " " + Day2 + " " ) ; }
function numberOfTriangles ( n ) { var ans = 2 * ( Math . pow ( 3 , n ) ) - 1 ; return ans ; }
function areaSquare ( side ) { let area = side * side ; return area ; }
function superSeq ( X , Y , m , n ) { if ( m == 0 ) return n ; if ( n == 0 ) return m ; if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ; return 1 + Math . min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ; }
function findNumber ( N ) { let ans = [ 1 , 2 , 4 , 8 , 7 , 5 ] ; return ans [ N % 6 ] ; }
function shuffle ( N , key ) { let NO_OF_BITS = N ; let reverse_num = 0 , temp ; for ( let i = 0 ; i < NO_OF_BITS ; i ++ ) { temp = ( key & ( 1 << i ) ) ; if ( temp > 0 ) reverse_num |= ( 1 << ( ( NO_OF_BITS - 1 ) - i ) ) ; } document . write ( reverse_num ) ; }
function FindSub ( str , res , i ) { if ( i === str . length ) { if ( res . length > 0 ) { document . write ( res + " " ) ; } return ; } var ch = str [ i ] ; FindSub ( str , res , i + 1 ) ; FindSub ( str , res + ch , i + 1 ) ; FindSub ( str , res + ch . charCodeAt ( 0 ) , i + 1 ) ; }
function findAngle ( M1 , M2 ) { var angle = Math . abs ( ( M2 - M1 ) / ( 1 + M1 * M2 ) ) ; var ret = Math . atan ( angle ) ; var val = ( ret * 180 ) / PI ; document . write ( val . toFixed ( 4 ) ) ; }
function binary_searched_find_x ( k ) { var l = 0 ; var r = k ; var ans = 0 ; while ( l <= r ) { var mid = parseInt ( l + ( r - l ) / 2 ) ; if ( Math . pow ( ( ( mid * ( mid + 1 ) ) / 2 ) , 2 ) >= k ) { ans = mid ; r = mid - 1 ; } else { l = mid + 1 ; } } return ans ; }
function minPolets ( n , m ) { let ans = 0 ; if ( ( n % 2 != 0 ) && ( m % 2 != 0 ) ) { ans = Math . floor ( ( n * m ) / 2 ) + 1 ; } else { ans = Math . floor ( ( n * m ) / 2 ) ; } return ans ; }
function sentencePalindrome ( str ) { let l = 0 ; let h = str . length - 1 ; str = str . toLowerCase ( ) ; while ( l <= h ) { let getAtl = str [ l ] ; let getAth = str [ h ] ; if ( ! ( getAtl >= ' ' && getAtl <= ' ' ) ) l ++ ; else if ( ! ( getAth >= ' ' && getAth <= ' ' ) ) h -- ; else if ( getAtl == getAth ) { l ++ ; h -- ; } else return false ; } return true ; }
function numberOfDays ( a , b , n ) { var Days = b * ( n + a ) / ( a + b ) ; return Days ; }
function findAnswer ( X , N ) { return ( N - 1 ) * 9 + X ; }
function findoptimal ( N ) { if ( N <= 6 ) return N ; let screen = [ ] ; let b ; let n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = Math . max ( 2 * screen [ n - 4 ] , Math . max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; } return screen [ N - 1 ] ; }
function maxbalancedprefix ( str , n ) { var sum = 0 ; var maxi = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) sum += 1 ; else sum -= 1 ; if ( sum < 0 ) break ; if ( sum == 0 ) maxi = i + 1 ; } return maxi ; }
function productOfSingelDgt ( n ) { if ( n >= 0 && n <= 9 ) return true ; var prime = [ 2 , 3 , 5 , 7 ] ; for ( i = 0 ; i < SIZE && n > 1 ; i ++ ) while ( n % prime [ i ] == 0 ) n = n / prime [ i ] ; return ( n == 1 ) ; }
function minimumStepReqArr ( arr , N ) { let cntStep = 0 ; N += 1 ; for ( let i = 31 ; i >= 0 ; i -- ) { if ( ( N & ( 1 << i ) ) != 0 ) { cntStep += 1 ; } } return cntStep ; }
function twoWaySort ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) arr [ i ] *= - 1 ; arr . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= - 1 ; }
function minimumIncreasingSubsequences ( arr , N ) { arr . sort ( function ( a , b ) { return a - b } ) ; let count = 0 ; let i = 0 ; while ( i < N ) { let x = arr [ i ] ; let freqX = 0 ; while ( i < N && arr [ i ] == x ) { freqX ++ ; i ++ ; } count = Math . max ( count , freqX ) ; } document . write ( count ) ; }
function countSquares ( r , c , m ) { let squares = 0 ; for ( let i = 1 ; i <= 8 ; i ++ ) { for ( let j = 1 ; j <= 8 ; j ++ ) { if ( Math . max ( Math . abs ( i - r ) , Math . abs ( j - c ) ) <= m ) squares ++ ; } } return squares ; }
function LCSubStr ( X , Y , m , n ) { var LCStuff = Array ( m + 1 ) . fill ( ) . map ( ( ) => Array ( n + 1 ) . fill ( 0 ) ) ; var result = 0 ; for ( i = 0 ; i <= m ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) LCStuff [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 ; result = Math . max ( result , LCStuff [ i ] [ j ] ) ; } else LCStuff [ i ] [ j ] = 0 ; } } return result ; }
function increment ( i ) { i = - ( ~ i ) ; return i ; }
function squareArea ( a ) { if ( a < 0 ) return - 1 ; var area = ( Math . pow ( 1.268 , 2 ) * Math . pow ( a , 2 ) ) ; return area ; }
function findMin ( arr , N , k ) { let pairs = 0 ; for ( let i = 0 ; i < N ; i ++ ) { pairs += arr [ i ] / 2 ; } if ( k > pairs ) return - 1 ; else return 2 * k + N - 1 ; }
function nearestPerfectSquare ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) { let sr = parseInt ( Math . sqrt ( arr [ i ] ) ) ; let a = sr * sr ; let b = ( sr + 1 ) * ( sr + 1 ) ; if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) document . write ( a + " " ) ; else document . write ( b + " " ) ; } }
function printNthElement ( n ) { var arr = Array ( n + 1 ) . fill ( 0 ) ; arr [ 1 ] = 4 ; arr [ 2 ] = 7 ; for ( var i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 4 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 7 ; } return arr [ n ] ; }
function weightedMean ( X , W , n ) { let sum = 0 , numWeight = 0 ; for ( let i = 0 ; i < n ; i ++ ) { numWeight = numWeight + X [ i ] * W [ i ] ; sum = sum + W [ i ] ; } return ( numWeight ) / sum ; }
function findSum ( n ) { let sum = 0 ; for ( let x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; }
function smallestNum ( n ) { res = 1 ; for ( var i = 2 ; ; i *= 2 ) { var length = parseInt ( Math . log ( i ) / Math . log ( 10 ) ) + 1 ; if ( length == n ) return parseInt ( Math . log ( i ) / Math . log ( 2 ) ) ; } }
function smallestDivisor ( n ) { if ( n % 2 == 0 ) return 2 ; for ( var i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) return i ; } return n ; }
function findOddPair ( A , N ) { var i , j ; var oddPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; }
function maximizeProduct ( N ) { let MSB = Math . log2 ( N ) ; let X = 1 << MSB ; let Y = N - ( 1 << MSB ) ; for ( let i = 0 ; i < MSB ; i ++ ) { if ( ! ( N & ( 1 << i ) ) ) { X += 1 << i ; Y += 1 << i ; } } document . write ( X + " " + Y ) ; }
function kthNonDivisible ( N , K ) { return K + parseInt ( Math . floor ( ( K - 1 ) / ( N - 1 ) ) , 10 ) ; }
function Max_Sum ( n ) { return parseInt ( ( n * ( n - 1 ) ) / 2 ) ; }
function precompute ( ) { var fact = 1 ; for ( var i = 1 ; i <= 18 ; i ++ ) { fact = fact * i ; m [ fact ] = i ; } }
function maxPointCount ( arr , k , size ) { let curr_points = 0 ; let max_points = 0 ; for ( let i = 0 ; i < K ; i ++ ) curr_points += arr [ i ] ; max_points = curr_points ; let j = size - 1 ; for ( let i = K - 1 ; i >= 0 ; i -- ) { curr_points = curr_points + arr [ j ] - arr [ i ] ; max_points = Math . max ( curr_points , max_points ) ; j -- ; } return max_points ; }
function CountSubarray ( arr , n , k ) { var temp = k , count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == temp ) { if ( temp == 1 ) { count ++ ; temp = k ; } else temp -- ; } else { temp = k ; if ( arr [ i ] == k ) i -- ; } } return count ; }
function findLCS ( arr , n ) { let mp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( mp . has ( arr [ i ] ) != 0 ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . set ( arr [ i ] , 1 ) ; } } return mp . size ; }
function findDiff ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let count = 0 , max_count = 0 , min_count = n ; for ( let i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_count = Math . max ( max_count , count ) ; min_count = Math . min ( min_count , count ) ; count = 0 ; } } return ( max_count - min_count ) ; }
function findMaximumNum ( str , n , k ) { for ( var i = 0 ; i < n ; i ++ ) { if ( k < 1 ) break ; if ( str [ i ] !== " " ) { str [ i ] = " " ; k -- ; } } return str . join ( " " ) ; }
function FindKthChar ( str , K , X ) { var ans = " " ; var sum = 0 ; for ( i = 0 ; i < str . length ; i ++ ) { var digit = parseInt ( str [ i ] ) ; var range = parseInt ( Math . pow ( digit , X ) ) ; sum += range ; if ( K <= sum ) { ans = str [ i ] ; break ; } } return ans ; }
function printNumberWithDR ( k , d ) { if ( d == 0 && k != 1 ) document . write ( " " ) ; else { document . write ( d ) ; k -- ; while ( k -- > 0 ) document . write ( " " ) ; } }
function gonNum257 ( n ) { return ( 255 * n * n - 253 * n ) / 2 ; }
function isTidy ( num ) { let prev = 10 ; while ( num != 0 ) { let rem = num % 10 ; num /= 10 ; if ( rem > prev ) return false ; prev = rem ; } return true ; }
function minimumDiff ( arr , N ) { let res = arr [ 0 ] , sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; let min_diff = sum ; for ( let i = 0 ; i < N ; i ++ ) { if ( Math . abs ( sum - ( arr [ i ] * N ) ) < min_diff ) { min_diff = Math . abs ( sum - ( arr [ i ] * N ) ) ; res = arr [ i ] ; } } document . write ( res ) ; }
function sum_series ( n ) { let nSquare = n * n ; return nSquare * ( nSquare - 1 ) / 4 ; }
function largestNum ( n ) { let num = 0 ; for ( let i = 0 ; i <= 32 ; i ++ ) { let x = ( 1 << i ) ; if ( ( x - 1 ) <= n ) num = ( 1 << i ) - 1 ; else break ; } return num ; }
function gcdMax ( a , b , n , N ) { let cnt = Array . from ( { length : N } , ( _ , i ) => 0 ) ; let first = Array . from ( { length : N } , ( _ , i ) => 0 ) ; let second = Array . from ( { length : N } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; ++ i ) cnt [ a [ i ] ] = 1 ; for ( let i = 1 ; i < N ; ++ i ) for ( let j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) first [ i ] = Math . max ( first [ i ] , j ) ; cnt = Array . from ( { length : N } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; ++ i ) cnt [ b [ i ] ] = 1 ; for ( let i = 1 ; i < N ; ++ i ) for ( let j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) second [ i ] = Math . max ( second [ i ] , j ) ; let x ; for ( x = N - 1 ; x >= 0 ; x -- ) if ( first [ x ] > 0 && second [ x ] > 0 ) break ; document . write ( first [ x ] + " " + second [ x ] ) ; }
function canMakeEqual ( S ) { var N = S . length ; var weightOfString = 0 ; for ( var i = 0 ; i < N ; i ++ ) { weightOfString += S . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) + 1 ; } if ( weightOfString % N == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function Max_Sum ( arr1 , arr2 , n ) { let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { dp [ i ] [ 0 ] = arr1 [ i ] ; dp [ i ] [ 1 ] = arr2 [ i ] ; continue ; } dp [ i ] [ 0 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] + arr1 [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] + arr2 [ i ] ) ; } return Math . max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) ; }
function countNumbers ( x , n ) { if ( x > n ) return 0 ; return 1 + countNumbers ( x * 10 , n ) + countNumbers ( x * 10 + 1 , n ) ; }
function findFourElements ( A , n , X ) { for ( let i = 0 ; i < n - 3 ; i ++ ) { for ( let j = i + 1 ; j < n - 2 ; j ++ ) { for ( let k = j + 1 ; k < n - 1 ; k ++ ) { for ( let l = k + 1 ; l < n ; l ++ ) if ( A [ i ] + A [ j ] + A [ k ] + A [ l ] == X ) document . write ( A [ i ] + " " + A [ j ] + " " + A [ k ] + " " + A [ l ] ) ; } } } }
function findK ( A , i , j , n , m , k ) { if ( n < 1 m < 1 ) return - 1 ; if ( k <= m ) return A [ i + 0 ] [ j + k - 1 ] ; if ( k <= ( m + n - 1 ) ) return A [ i + ( k - m ) ] [ j + m - 1 ] ; if ( k <= ( m + n - 1 + m - 1 ) ) return A [ i + n - 1 ] [ j + m - 1 - ( k - ( m + n - 1 ) ) ] ; if ( k <= ( m + n - 1 + m - 1 + n - 2 ) ) return A [ i + n - 1 - ( k - ( m + n - 1 + m - 1 ) ) ] [ j + 0 ] ; return findK ( A , i + 1 , j + 1 , n - 2 , m - 2 , k - ( 2 * n + 2 * m - 4 ) ) ; }
function maximumSumPermutation ( arr ) { var N = arr . length ; arr . sort ( ( a , b ) => a - b ) ; var temp = arr [ 0 ] ; arr [ 0 ] = arr [ N - 1 ] ; arr [ N - 1 ] = temp ; document . write ( arr ) ; }
function minAbsDiff ( n ) { let mod = n % 4 ; if ( mod == 0 mod == 3 ) { return 0 ; } return 1 ; }
function numberOfWays ( x ) { let dp = Array ( x + 1 ) . fill ( 0 ) ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
function countMultiples ( n ) { return Math . floor ( n / 3 + n / 7 - n / 21 ) ; }
function minOps ( arr , n , k ) { var max = arr [ 0 ] ; for ( var i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ; else res += ( max - arr [ i ] ) / k ; } return res ; }
function KnapSack ( val , wt , n , W ) { let dp = new Array ( W + 1 ) ; for ( let i = 0 ; i < W + 1 ; i ++ ) { dp [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) for ( let j = W ; j >= wt [ i ] ; j -- ) dp [ j ] = Math . max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; return dp [ W ] ; }
function LIS ( a , n ) { let dp = new Array ( ) ; let d = new Array ( ) ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { dp [ a [ i ] ] = 1 ; for ( j = 2 ; j * j <= a [ i ] ; j ++ ) { if ( a [ i ] % j == 0 ) { dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) ; dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ a [ i ] / j ] ] + 1 ) ; d [ j ] = a [ i ] ; d [ a [ i ] / j ] = a [ i ] ; } } ans = Math . max ( ans , dp [ a [ i ] ] ) ; d [ a [ i ] ] = a [ i ] ; } return ans ; }
function findSide ( a , B , C ) { var A = 180 - C - B ; var radA = Math . PI * ( A / 180 ) ; var radB = Math . PI * ( B / 180 ) ; var radC = Math . PI * ( C / 180 ) ; var b = a / Math . sin ( radA ) * Math . sin ( radB ) ; var c = a / Math . sin ( radA ) * Math . sin ( radC ) ; document . write ( b + " " ) ; document . write ( c ) ; }
function first_digit ( x , y ) { var length = parseInt ( Math . log ( x ) / Math . log ( y ) ) + 1 ; var first_digit = parseInt ( x / Math . pow ( y , length - 1 ) ) ; document . write ( first_digit ) ; }
function maxOperations ( X , Y ) { if ( X > Y ) return - 1 ; let diff = Y - X ; if ( diff == 1 ) return - 1 ; if ( diff % 2 == 0 ) return ( diff / 2 ) ; return ( 1 + ( ( diff - 3 ) / 2 ) ) ; }
function findPolet ( n , h ) { for ( let i = 1 ; i < n ; i ++ ) document . write ( Math . sqrt ( i / ( n * 1.0 ) ) * h + " " ) ; }
function minValue ( A , B , n ) { A . sort ( ) ; B . sort ( ) ; let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ; return result ; }
function find_number ( N , K ) { var r ; if ( N % 100 == 0 ) { N += 1 ; r = N . toString ( ) ; } else { r = N . toString ( ) ; } for ( var i = 1 ; i <= K ; i ++ ) r += " " ; return r ; }
function computeXOR ( n ) { switch ( n & 3 ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; case 3 : return 0 ; } }
function seriesFunc ( n ) { let sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; let sumNatural = ( n * ( n + 1 ) / 2 ) ; return ( sumSquare + sumNatural + 1 ) ; }
function countSubStr ( str , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( str [ j ] == ' ' ) res ++ ; } } } return res ; }
function possibleToReach ( a , b ) { let c = Math . cbrt ( a * b ) ; let re1 = a / c ; let re2 = b / c ; if ( ( re1 * re1 * re2 == a ) && ( re2 * re2 * re1 == b ) ) return true ; else return false ; }
function findSubsequenceCount ( S , T ) { let m = T . length ; let n = S . length ; if ( m > n ) return 0 ; let mat = new Array ( m + 1 ) ; for ( let i = 0 ; i <= m ; i ++ ) { mat [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j <= n ; j ++ ) { mat [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= m ; i ++ ) mat [ i ] [ 0 ] = 0 ; for ( let j = 0 ; j <= n ; j ++ ) mat [ 0 ] [ j ] = 1 ; for ( let i = 1 ; i <= m ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { if ( T [ i - 1 ] != S [ j - 1 ] ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ; else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ; } } return mat [ m ] [ n ] ; }
function minNum ( n ) { if ( n < 3 ) document . write ( - 1 ) ; else document . write ( ( 210 * ( parseInt ( Math . pow ( 10 , n - 1 ) / 210 ) + 1 ) ) ) ; }
function countSubsequences ( s ) { let aCount = 0 ; let bCount = 0 ; let cCount = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == ' ' ) aCount = ( 1 + 2 * aCount ) ; else if ( s [ i ] == ' ' ) bCount = ( aCount + 2 * bCount ) ; else if ( s [ i ] == ' ' ) cCount = ( bCount + 2 * cCount ) ; } return cCount ; }
function SubArrayProdct ( arr , n ) { let result = 1 ; for ( let i = 0 ; i < n ; i ++ ) result *= Math . pow ( arr [ i ] , ( i + 1 ) * ( n - i ) ) ; return result ; }
function maxSumPairWithDifferenceLessThanK ( arr , N , k ) { var maxSum = 0 ; arr . sort ( ( a , b ) => a - b ) ; for ( i = N - 1 ; i > 0 ; -- i ) { if ( arr [ i ] - arr [ i - 1 ] < k ) { maxSum += arr [ i ] ; maxSum += arr [ i - 1 ] ; -- i ; } } return maxSum ; }
function countTotalDistinct ( str ) { let cnt = 0 ; let items = new Set ( ) ; for ( let i = 0 ; i < str . length ; ++ i ) { let temp = " " ; let ans = new Set ( ) ; for ( let j = i ; j < str . length ; ++ j ) { temp = temp + str [ j ] ; ans . add ( str [ j ] ) ; if ( ! items . has ( temp ) ) { items . add ( temp ) ; cnt += ans . size ; } } } return cnt ; }
function canBreakN ( n ) { for ( let i = 2 ; ; i ++ ) { let m = parseInt ( i * ( i + 1 ) / 2 , 10 ) ; if ( m > n ) break ; let k = n - m ; if ( k % i != 0 ) continue ; document . write ( i ) ; return ; } document . write ( " " ) ; }
function countNegative ( M , n , m ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ; else break ; } } return count ; }
function countPairs ( X , Y , m , n ) { let suffix = Array . from ( { length : 1005 } , ( _ , i ) => 0 ) ; let total_pairs = 0 ; for ( let i = 0 ; i < n ; i ++ ) suffix [ Y [ i ] ] ++ ; for ( let i = 1e3 ; i >= 3 ; i -- ) suffix [ i ] += suffix [ i + 1 ] ; for ( let i = 0 ; i < m ; i ++ ) { if ( X [ i ] == 0 ) continue ; else if ( X [ i ] == 1 ) { total_pairs += suffix [ 0 ] ; continue ; } else if ( X [ i ] == 2 ) total_pairs += suffix [ 5 ] ; else if ( X [ i ] == 3 ) total_pairs += suffix [ 2 ] + suffix [ 4 ] ; else total_pairs += suffix [ X [ i ] + 1 ] ; total_pairs += suffix [ 0 ] + suffix [ 1 ] ; } return total_pairs ; }
function solve ( s ) { let area = ( 1.732 * Math . pow ( s , 2 ) ) / 8 ; return area ; }
function print ( a , n ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i != j ) document . write ( a [ i ] + " " + a [ j ] + " " ) ; } } }
function nth_group ( n ) { return n * ( 2 * Math . pow ( n , 2 ) + 1 ) ; }
function minCostToMakeElementEqual ( a , n ) { let y ; if ( n % 2 == 1 ) y = a [ Math . trunc ( n / 2 ) ] ; else y = Math . trunc ( ( a [ n / 2 ] + a [ ( n - 2 ) / 2 ] ) / 2 ) ; let s = 0 ; for ( let i = 0 ; i < n ; i ++ ) s += Math . abs ( a [ i ] - y ) ; return s ; }
function isProduct ( arr , n , x ) { for ( var i = 0 ; i < n - 1 ; i ++ ) for ( var j = i + 1 ; i < n ; i ++ ) if ( arr [ i ] * arr [ j ] == x ) return true ; return false ; }
function countOddSquares ( n , m ) { return Math . pow ( m , 0.5 ) - Math . pow ( n - 1 , 0.5 ) ; }
function properDivisorSum ( n ) { var sum = 0 ; for ( var i = 1 ; i <= n ; ++ i ) sum += parseInt ( n / i ) * i ; return sum - n * ( ( n + 1 ) / 2 ) ; }
function HexacontatetragonNum ( n ) { return ( 62 * n * n - 60 * n ) / 2 ; }
function Numberofways ( n ) { var count = 0 ; for ( var a = 1 ; a < n ; a ++ ) { for ( var b = 1 ; b < n ; b ++ ) { var c = n - ( a + b ) ; if ( a + b > c && a + c > b && b + c > a ) { count ++ ; } } } return count ; }
function no_of_moves ( Matrix , x , y ) { let moves = 0 ; for ( let i = 0 ; i < M ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { if ( Matrix [ i ] [ j ] != 0 ) { moves += Math . abs ( x - i ) ; moves += Math . abs ( y - j ) ; } } } document . write ( moves ) ; }
function findSteps ( n , m , a ) { var cur = 1 ; var steps = 0 ; for ( var i = 0 ; i < m ; i ++ ) { if ( a [ i ] >= cur ) steps += ( a [ i ] - cur ) ; else steps += ( n - cur + a [ i ] ) ; cur = a [ i ] ; } return steps ; }
function solve ( low , high , T ) { while ( low <= high ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( ( mid * ( mid + 1 ) ) == T ) return mid ; if ( mid > 0 && ( mid * ( mid + 1 ) ) > T && ( mid * ( mid - 1 ) ) <= T ) return mid - 1 ; if ( ( mid * ( mid + 1 ) ) > T ) high = mid - 1 ; else low = mid + 1 ; } return - 1 ; }
function count ( arr , low , high , x ) { if ( ( low > high ) || ( low == high && arr [ low ] != x ) ) return 0 ; if ( low == high && arr [ low ] == x ) return 1 ; return count ( arr , low , Math . floor ( ( low + high ) / 2 ) , x ) + count ( arr , 1 + Math . floor ( ( low + high ) / 2 ) , high , x ) ; }
function printOdds ( arr , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) res = res ^ arr [ i ] ; let set_bit = res & ( ~ ( res - 1 ) ) ; let x = 0 , y = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & set_bit ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } document . write ( x + " " + y ) ; }
function correlationCoefficient ( X , Y , n ) { let sum_X = 0 , sum_Y = 0 , sum_XY = 0 ; let squareSum_X = 0 , squareSum_Y = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum_X = sum_X + X [ i ] ; sum_Y = sum_Y + Y [ i ] ; sum_XY = sum_XY + X [ i ] * Y [ i ] ; squareSum_X = squareSum_X + X [ i ] * X [ i ] ; squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ; } let corr = ( n * sum_XY - sum_X * sum_Y ) / ( Math . sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ) ; return corr ; }
function countPairs ( n ) { let num = ( parseInt ( n / 2 , 10 ) + 1 ) ; let max = n % num ; let count = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { let val = ( ( n % i ) % j ) % n ; if ( val == max ) count ++ ; } } return count ; }
function solve ( values , salary ) { var ret = 1 ; var amt = 0 ; values . sort ( ( a , b ) => a - b ) ; salary . sort ( ( a , b ) => a - b ) ; while ( salary . length ) { while ( values . length && values [ values . length - 1 ] >= salary [ salary . length - 1 ] ) { amt ++ ; values . pop ( ) ; } if ( amt == 0 ) return 0 ; ret *= amt -- ; ret %= MOD ; salary . pop ( ) ; } return ret ; }
function string ( l , x , y ) { var p = 97 ; for ( var j = 0 ; j < l ; j ++ ) { var ans = String . fromCharCode ( p + ( j % y ) ) ; document . write ( ans ) ; } }
function numberOfWays ( n , k ) { if ( n == 0 ) return 1 ; if ( k == 0 ) return 1 ; if ( n >= Math . pow ( 2 , k ) ) { let curr_val = Math . pow ( 2 , k ) ; return numberOfWays ( n - curr_val , k ) + numberOfWays ( n , k - 1 ) ; } else return numberOfWays ( n , k - 1 ) ; }
function equation_ellipse ( x1 , y1 , a , b , c , e ) { var t = a * a + b * b ; var a1 = t - e * ( a * a ) ; var b1 = t - e * ( b * b ) ; var c1 = ( - 2 * t * x1 ) - ( 2 * e * c * a ) ; var d1 = ( - 2 * t * y1 ) - ( 2 * e * c * b ) ; var e1 = - 2 * e * a * b ; var f1 = ( - e * c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; document . write ( " " + " " ) ; document . write ( a1 + " " + b1 + " " + c1 + " " + d1 + " " + e1 + " " + f1 + " " ) ; }
function round ( n ) { let a = parseInt ( n / 10 , 10 ) * 10 ; let b = a + 10 ; return ( n - a > b - n ) ? b : a ; }
function find_max ( i , sum , v , k ) { if ( i == v . length ) return 0 ; if ( dp [ i ] [ sum ] != - 1 ) return dp [ i ] [ sum ] ; let ans = 0 ; if ( ( sum + find_max ( i + 1 , sum , v , k ) ) % k == 0 ) ans = find_max ( i + 1 , sum , v , k ) ; if ( ( sum + v [ i ] + find_max ( i + 1 , ( sum + v [ i ] ) % k , v , k ) ) % k == 0 ) ans = Math . max ( ans , v [ i ] + find_max ( i + 1 , ( sum + v [ i ] ) % k , v , k ) ) ; return dp [ i ] [ sum ] = ans ; } let arr = [ 43 , 1 , 17 , 26 , 15 ] ; let k = 16 ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } for ( var i = 0 ; i < dp . length ; i ++ ) { for ( var j = 0 ; j < dp . length ; j ++ ) { dp [ i ] [ j ] = - 1 ; } }
function getCount ( rows , columns , A ) { var res = 0 ; for ( var i = 0 ; i < rows ; i ++ ) { for ( var j = i + 1 ; j < rows ; j ++ ) { if ( A [ i ] [ 0 ] * A [ j ] [ 1 ] == A [ i ] [ 1 ] * A [ j ] [ 0 ] ) { res ++ ; } } } return res ; }
function SubMasks ( N ) { for ( let S = N ; S > 0 ; S = ( S - 1 ) & N ) { document . write ( S + " " ) ; } }
function countWays ( n ) { for ( let i = 1 ; i < n ; i ++ ) for ( let j = i ; j < n ; j ++ ) for ( let k = j ; k < n ; k ++ ) for ( let l = k ; l < n ; l ++ ) if ( i + j + k + l == n ) counter ++ ; return counter ; }
function sortArray ( A , N ) { let x = 0 , y = 0 , z = 0 ; if ( N % 4 == 0 N % 4 == 1 ) { for ( let i = 0 ; i < N / 2 ; i ++ ) { x = i ; if ( i % 2 == 0 ) { y = N - i - 2 ; z = N - i - 1 ; } A [ z ] = A [ y ] ; A [ y ] = A [ x ] ; A [ x ] = x + 1 ; } document . write ( " " ) ; for ( let i = 0 ; i < N ; i ++ ) document . write ( A [ i ] + " " ) ; } else { document . write ( " " ) ; } }
function getModulo ( n , d ) { return ( n & ( d - 1 ) ) ; }
function largestNumber ( N ) { if ( N > 45 ) return - 1 ; let num = 0 , digit = 9 ; while ( N > 0 && digit > 0 ) { if ( digit <= N ) { num *= 10 ; num += digit ; N -= digit ; } digit -= 1 ; } return num * 10 ; }
function printFourSquares ( a ) { for ( let i = 0 ; i * i <= a ; i ++ ) { for ( let j = i ; j * j <= a ; j ++ ) { for ( let k = j ; k * k <= a ; k ++ ) { for ( let l = k ; l * l <= a ; l ++ ) { if ( i * i + j * j + k * k + l * l == a ) { document . write ( a + " " + i + " " + i + " " + j + " " + j + " " ) ; document . write ( k + " " + k + " " + l + " " + l + " " ) ; } } } } } }
function countBuildings ( arr , n ) { let count = 1 ; let curr_max = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > curr_max arr [ i ] == curr_max ) { count ++ ; curr_max = arr [ i ] ; } } return count ; }
function minimumSteps ( a , b , c ) { if ( a < 1 b < 1 ) return - 1 ; if ( a == 1 && b == 1 ) return c ; if ( a < b ) { a = a + b ; b = a - b ; a = a - b ; } return minimumSteps ( a - b , b , c + 1 ) ; }
function lastRemovedCharacter ( str ) { var n = str . length ; if ( n == 1 ) return str [ 0 ] ; if ( str [ n - 2 ] == " " ) { return " " - str [ n - 1 ] + " " ; } else return str [ n - 1 ] ; }
function updateString ( S , A , B ) { let l = A . length ; for ( let i = 0 ; i + l <= S . length ; i ++ ) { let curr = S . substring ( i , i + l ) ; if ( curr == A ) { let new_string = S . substring ( 0 , i ) + B + S . substring ( i + l ) ; S = new_string ; i += l - 1 ; } else { let new_string = S . substring ( 0 , i ) + A + S . substring ( i + l ) ; S = new_string ; i += l - 1 ; } } return S ; }
function numLen ( K ) { if ( K % 2 == 0 K % 5 == 0 ) return - 1 ; var number = 0 ; var len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = ( number * 10 + 1 ) % K ; if ( number == 0 ) return len ; } return - 1 ; }
function multiple ( a , b , x ) { if ( b < 0 ) { if ( a == 1 && x == 1 ) document . write ( " " ) ; else document . write ( " " ) ; } var mul = parseInt ( Math . pow ( a , b ) ) ; var ans = mul / x ; var ans1 = x * ans ; var ans2 = x * ( ans + 1 ) ; document . write ( ( ( mul - ans1 ) <= ( ans2 - mul ) ) ? ans1 : ans2 ) ; }
function minimumMEX ( arr , N , K ) { let s = new Set ( ) ; for ( let i = 1 ; i <= N + 1 ; i ++ ) s . add ( i ) ; for ( let i = 0 ; i < K ; i ++ ) s . delete ( arr [ i ] ) ; let entry = s . entries ( ) ; let mex = 1 ; for ( let i = K ; i < N ; i ++ ) { s . delete ( arr [ i ] ) ; s . add ( arr [ i - K ] ) ; let firstElem = entry . next ( ) . value mex = Math . min ( mex , 1 ) ; } document . write ( mex + " " ) ; }
function findSolutions ( N ) { let count = 0 ; for ( let i = 1 ; i <= Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { if ( ( i + parseInt ( N / i ) ) % 2 == 0 ) { count ++ ; } } } document . write ( 4 * count + " " ) ; }
function leastValue ( P , A , N , a ) { let ans = - 1 ; let tmp = Number . MAX_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { let t = ( P - a [ i ] * 0.006 ) ; if ( Math . abs ( t - A ) < tmp ) { tmp = Math . abs ( t - A ) ; ans = i ; } } return a [ ans ] ; }
function turnOnK ( n , k ) { if ( k <= 0 ) return n ; return ( n | ( 1 << ( k - 1 ) ) ) ; }
function sumOfSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum = sum + i * ( i + 1 ) * ( i + 2 ) ; return sum ; }
function area_fun ( side ) { let area = side * side ; return area ; }
function checkPairs ( l , r ) { if ( ( l - r ) % 2 == 0 ) return false ; return true ; }
function group_formed ( S ) { let count = 1 ; for ( let i = 0 ; i < S . length - 1 ; i ++ ) { if ( S [ i ] != S [ i + 1 ] ) count += 1 ; } document . write ( count ) ; }
function solve ( N ) { let ans = 0 ; while ( N != 0 ) { ans += N ; N = parseInt ( N / 2 , 10 ) ; } document . write ( ans ) ; }
function segregateElements ( arr , n ) { let temp = new Array ( n ) ; let j = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n j == 0 ) return ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
function removeAll ( arr , n ) { if ( arr [ 0 ] < arr [ n - 1 ] ) document . write ( " " ) ; else document . write ( " " ) ; }
function printPairs ( arr , n ) { let pairs = new Set ( ) ; let pair_exists = false ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] > 0 ) pairs . add ( arr [ i ] ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) if ( pairs . has ( - arr [ i ] ) ) { document . write ( arr [ i ] + " " + - arr [ i ] + " " ) ; pair_exists = true ; } } if ( pair_exists == false ) document . write ( " " ) ; }
function lenghtOfLongestAP ( A , n ) { var dp = new Map ( ) ; var res = 2 ; for ( var i = 0 ; i < n ; ++ i ) { for ( var j = i + 1 ; j < n ; ++ j ) { var d = A [ j ] - A [ i ] ; if ( dp . has ( d ) ) { if ( dp . get ( d ) . has ( i ) ) { var tmp = dp . get ( d ) ; tmp . set ( j , dp . get ( d ) . get ( i ) + 1 ) ; } else { var tmp = new Map ( ) ; tmp . set ( j , 2 ) ; dp . set ( d , tmp ) ; } } else { var tmp = new Map ( ) ; tmp . set ( j , 2 ) ; dp . set ( d , tmp ) ; } res = Math . max ( res , dp . get ( d ) . get ( j ) ) ; } } return res ; }
function binarySearch ( arr , l , r , x ) { if ( r >= l ) { let mid = l + Math . floor ( ( r - l ) / 2 ) ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; }
function calculateWays ( arr1 , arr2 , N ) { let A = arr2 [ 0 ] , B = arr2 [ 1 ] ; let C = arr2 [ 2 ] , D = arr2 [ 3 ] ; let ans = 0 ; for ( let b = 0 ; b <= B && b * 5 <= ( N ) ; b ++ ) for ( let c = 0 ; c <= C && b * 5 + c * 10 <= ( N ) ; c ++ ) for ( let d = 0 ; d <= D && b * 5 + c * 10 + d * 20 <= ( N ) ; d ++ ) if ( ( b * 5 ) + ( c * 10 ) + ( d * 20 ) >= ( N - A ) ) ans ++ ; return ans ; }
function areaOfSquare ( S ) { let area = S * S ; return area ; }
function noOfYears ( t1 , n1 , t2 ) { var years = ( ( t2 - 1 ) * n1 / ( t1 - 1 ) ) ; return years ; }
function graphExists ( a , n ) { while ( 1 ) { a . sort ( ( a , b ) => b - a ) if ( a [ 0 ] == 0 ) return true ; var v = a [ 0 ] ; a . shift ( ) ; if ( v > a . length ) return false ; for ( var i = 0 ; i < v ; i ++ ) { a [ i ] -- ; if ( a [ i ] < 0 ) return false ; } } }
function solve ( s , k ) { var count = 0 , length = 0 , pos = 0 ; var m = new Map ( ) ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( ! m . has ( s [ i ] ) ) { m . set ( s [ i ] , 0 ) ; } m . set ( s [ i ] , m . get ( s [ i ] ) + 1 ) ; length ++ ; if ( length > k ) { if ( ! m . has ( s [ pos ] ) ) { m . set ( s [ pos ] , 0 ) ; } m . set ( s [ pos ] , m [ s [ pos ] ] - 1 ) ; pos += 1 ; length -- ; } if ( length == k && m . get ( s [ i ] ) == length ) count ++ ; } document . write ( count ) ; }
function findCnt ( arr , i , required_sum , n ) { if ( i == n ) { if ( required_sum == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ required_sum + base ] ) return dp [ i ] [ required_sum + base ] ; v [ i ] [ required_sum + base ] = 1 ; dp [ i ] [ required_sum + base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; return dp [ i ] [ required_sum + base ] ; }
function isPossible ( x , y , k ) { var minMoves = Math . abs ( x ) + Math . abs ( y ) ; if ( k >= minMoves && ( k - minMoves ) % 2 == 0 ) return true ; return false ; }
