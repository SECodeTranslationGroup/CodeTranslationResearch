function countWords ( str , len ) { let count = 1 ; if ( len == 1 ) return count ; if ( str [ 0 ] == str [ 1 ] ) count *= 1 ; else count *= 2 ; for ( let j = 1 ; j < len - 1 ; j ++ ) { if ( str [ j ] == str [ j - 1 ] && str [ j ] == str [ j + 1 ] ) count *= 1 ; else if ( str [ j ] == str [ j - 1 ] str [ j ] == str [ j + 1 ] str [ j - 1 ] == str [ j + 1 ] ) count *= 2 ; else count *= 3 ; } if ( str [ len - 1 ] == str [ len - 2 ] ) count *= 1 ; else count *= 2 ; return count ; }
function minNum ( arr , n ) { let odd = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd += 1 ; return ( ( odd % 2 ) != 0 ) ? 1 : 2 ; }
function MinOfCubed ( k ) { if ( k < 8 ) return k ; let res = k ; for ( let i = 1 ; i <= k ; i ++ ) { if ( ( i * i * i ) > k ) return res ; res = Math . min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; } return res ; }
function findSum ( arr , n , k ) { if ( k <= n - 2 ) return ( arr [ n - 1 ] - arr [ 0 ] ) ; return 0 ; }
function decodeStr ( str , len ) { var c = Array ( len ) . fill ( " " ) ; var med , pos = 1 , k ; if ( len % 2 == 1 ) med = parseInt ( len / 2 ) ; else med = parseInt ( len / 2 ) - 1 ; c [ med ] = str [ 0 ] ; if ( len % 2 == 0 ) c [ med + 1 ] = str [ 1 ] ; if ( len & 1 ) k = 1 ; else k = 2 ; for ( var i = k ; i < len ; i += 2 ) { c [ med - pos ] = str [ i ] ; if ( len % 2 == 1 ) c [ med + pos ] = str [ i + 1 ] ; else c [ med + pos + 1 ] = str [ i + 1 ] ; pos ++ ; } for ( var i = 0 ; i < len ; i ++ ) { document . write ( c [ i ] ) ; } }
function countSubArrayWithOddProduct ( A , N ) { var count = 0 ; var last = - 1 ; var K = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) { K = ( i - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; last = i ; } } K = ( N - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; return count ; }
function findSum ( N , K ) { let ans = 0 ; let y = N / K ; let x = N % K ; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; }
function solve ( arr , n , X , Y ) { var diff = Y - X ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 1 ) { diff = diff % ( arr [ i ] - 1 ) ; } } if ( diff == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function nthTerm ( N ) { if ( N == 1 ) { return 2 ; } return ( ( N - 1 ) * 13 ) + nthTerm ( N - 1 ) ; }
function centered_cube ( n ) { return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; }
function smallestNum ( N ) { x = Math . pow ( 10.0 , ( N - 1 ) / 2.0 ) ; return Math . ceil ( x ) ; }
function multiplyFactors ( n ) { let M = 1000000007 ; let i ; prod = 1 ; for ( i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) prod = ( prod * i ) % M ; else { prod = ( prod * i ) % M ; prod = ( prod * n / i ) % M ; } } } return prod ; }
function deleteElement ( arr , n , x ) { let i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) break ; if ( i < n ) { n = n - 1 ; for ( let j = i ; j < n ; j ++ ) arr [ j ] = arr [ j + 1 ] ; } return n ; }
function findNumberOfTriangles ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { for ( let k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] > arr [ k ] && arr [ i ] + arr [ k ] > arr [ j ] && arr [ k ] + arr [ j ] > arr [ i ] ) count ++ ; } } return count ; }
function cntPairs ( a , n ) { var odd = 0 , even = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd ++ ; else if ( ( a [ i ] / 2 ) % 2 == 1 ) even ++ ; } var ans = odd * even + ( odd * ( odd - 1 ) ) / 2 ; return ans ; }
function sumOfSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= i ; j ++ ) sum += j ; return sum ; }
function nthTerm ( N ) { let nth = 0 ; if ( N % 2 == 1 ) nth = ( N * N ) + 1 ; else nth = ( N * N ) - 1 ; return nth ; }
function setBitNumber ( n ) { if ( n == 0 ) return 0 ; let msb = 0 ; n = n / 2 ; while ( n != 0 ) { n = $n / 2 ; msb ++ ; } return ( 1 << msb ) ; }
function isPalindrome ( n ) { if ( n % 11 == 0 ) { return true ; } return false ; }
function fnMod ( n ) { var rem = n % 4 ; if ( rem == 0 rem == 3 ) return 0 ; else if ( rem == 1 rem == 2 ) return 1 ; return 0 ; }
function ellipsearea ( r ) { if ( r < 0 ) return - 1 ; var a = ( ( 3.14 * r * r ) / 4 ) ; return a ; }
function findSetBits ( n ) { let dp = new Array ( n + 1 ) ; dp . fill ( 0 ) ; document . write ( dp [ 0 ] + " " ) ; for ( let i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { dp [ i ] = dp [ parseInt ( i / 2 , 10 ) ] ; } else { dp [ i ] = dp [ parseInt ( i / 2 , 10 ) ] + 1 ; } document . write ( dp [ i ] + " " ) ; } }
function unitDigitXRaisedY ( x , y ) { let res = 1 ; for ( let i = 0 ; i < y ; i ++ ) res = ( res * x ) % 10 ; return res ; }
function check ( n , marks ) { let x = Math . max ( ... marks ) ; let bonus = 100 - x ; let c = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( marks [ i ] + bonus >= 50 ) c += 1 ; } return c ; }
function octaside ( a ) { if ( a < 0 ) return - 1 ; var s = a / ( Math . sqrt ( 2 ) + 1 ) ; return s ; }
function countTriplets ( A ) { var cnt = 0 ; var tuples = new Map ( ) ; A . forEach ( a => { A . forEach ( b => { if ( tuples . has ( a & b ) ) tuples . set ( a & b , tuples . get ( a & b ) + 1 ) else tuples . set ( a & b , 1 ) } ) ; } ) ; A . forEach ( a => { tuples . forEach ( ( value , key ) => { if ( ( key & a ) == 0 ) cnt += value ; } ) ; } ) ; return cnt ; }
function minDiff ( arr , n , k ) { var result = Number . MAX_VALUE ; arr . sort ( ( a , b ) => a - b ) ; for ( i = 0 ; i <= n - k ; i ++ ) result = Math . min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; }
function isSubseqPossible ( arr , N , K ) { let i ; let odd = 0 , even = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd == 0 || ( even == 0 && K % 2 == 0 ) ) return false ; return true ; }
function binaryToDecimal ( n ) { let num = n ; let dec_value = 0 ; let base = 1 ; let temp = num ; while ( temp ) { let last_digit = temp % 10 ; temp = Math . floor ( temp / 10 ) ; dec_value += last_digit * base ; base = base * 2 ; } return dec_value ; }
function sumDivisibles ( A , B , M ) { var sum = 0 ; for ( var i = A ; i <= B ; i ++ ) if ( i % M == 0 ) sum += i ; return sum ; }
function count_min_length ( s ) { var hash = new Array ( 26 ) . fill ( 0 ) ; var ans = 2147483648 ; for ( var i = 0 ; i < 26 ; i ++ ) hash [ i ] = - 1 ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( hash [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] == - 1 ) hash [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] = i ; else { if ( hash [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] == i - 1 || hash [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] == i - 2 ) return 0 ; ans = Math . min ( ans , i - hash [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] - 1 ) ; hash [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] = i ; } } if ( ans === 2147483648 ) return - 1 ; return ans ; }
function calculateSum ( n ) { return ( n * ( parseInt ( Math . pow ( n , 2 ) + 3 * n + 5 ) ) / 3 ) ; }
function calculateSum ( n ) { if ( n % 2 == 1 ) return ( n + 1 ) / 2 ; return - n / 2 ; }
function results ( n , k ) { return parseInt ( Math . round ( Math . pow ( n , ( 1.0 / Math . pow ( 2.0 , k ) ) ) ) ) ; }
function findCycles ( N ) { let res = 0 ; let finalResult = 0 ; let val = 2 * N - 1 ; let s = val ; res = ( N - 1 ) * ( N - 2 ) ; finalResult = res + s ; return finalResult ; }
function isPentagonal ( N ) { var i = 1 , M ; do { M = ( 3 * i * i - i ) / 2 ; i += 1 ; } while ( M < N ) ; return ( M == N ) ; }
function SellingPrice ( CP , PP ) { var P_decimal = 1 + ( PP / 100 ) ; var res = P_decimal * CP ; return res . toFixed ( 1 ) ; }
function ways ( n ) { var first = 2 ; var second = 3 ; var res = 0 ; for ( i = 3 ; i <= n ; i ++ ) { res = first + second ; first = second ; second = res ; } return res ; }
function countPairs ( arr , n ) { let ans = 0 ; arr . sort ( function ( a , b ) { return a - b } ) ; let left = 0 , right = 1 ; while ( right < n ) { if ( arr [ left ] == arr [ right ] ) ans += right - left ; else left = right ; right ++ ; } return ans ; }
function distance ( a1 , b1 , c1 , a2 , b2 , c2 ) { var d = a1 * a2 + b1 * b2 + c1 * c2 ; var e1 = Math . sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) ; var e2 = Math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ; d = parseFloat ( d / ( e1 * e2 ) ) ; var pi = 3.14159 ; var A = ( 180 / pi ) * Math . acos ( d ) ; document . write ( " " + A . toFixed ( 1 ) + " " ) ; }
function get_concentration ( mass , volume ) { if ( volume == 0 ) return - 1 ; else return ( mass / volume ) * 1000 ; }
function findSum ( N ) { return ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) / 2 ; }
function find ( n ) { document . write ( parseInt ( n / 2 , 10 ) + " " ) ; }
function CntcontSubs ( a , n ) { let c = 0 , d = 0 , i , sum = 1 , j ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 != 0 a [ i ] % 4 == 0 ) d ++ ; sum = a [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { sum = sum * a [ j ] ; if ( sum % 2 != 0 sum % 4 == 0 ) c ++ ; } sum = 1 ; } return c + d ; }
function zigzag ( s , rows ) { let interval = 2 * rows - 2 ; for ( let i = 0 ; i < rows ; i ++ ) { let step = interval - 2 * i ; for ( let j = i ; j < s . length ; j = j + interval ) { document . write ( s [ j ] ) ; if ( step > 0 && step < interval && step + j < s . length ) { for ( let k = 0 ; k < ( interval - rows - i ) ; k ++ ) document . write ( " " ) ; document . write ( s [ j + step ] ) ; for ( let k = 0 ; k < i - 1 ; k ++ ) document . write ( " " ) ; } else { for ( let k = 0 ; k < ( interval - rows ) ; k ++ ) document . write ( " " ) ; } } document . write ( " " ) ; } }
function distancesum ( x , y , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ) ; return sum ; }
function bitPos ( n1 , n2 ) { if ( n1 == n2 ) return 0 ; let bitCount1 = Math . floor ( Math . log2 ( n1 ) ) + 1 ; let bitCount2 = Math . floor ( Math . log2 ( n2 ) ) + 1 ; let bitDiff = Math . abs ( bitCount1 - bitCount2 ) ; let maxBitCount = Math . max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * Math . pow ( 2 , bitDiff ) ; } else { n1 = n1 * Math . pow ( 2 , bitDiff ) ; } let xorValue = n1 ^ n2 ; let bitCountXorValue = Math . floor ( Math . log2 ( xorValue ) ) + 1 ; let disSimilarBitPosition = maxBitCount - bitCountXorValue + 1 ; return disSimilarBitPosition ; }
function perfectPowerOf2 ( n ) { let per_pow = 1 ; while ( n > 0 ) { per_pow = per_pow << 1 ; n = n >> 1 ; } return per_pow ; }
function longestCommonSum ( n ) { let maxLen = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let sum1 = 0 , sum2 = 0 ; for ( let j = i ; j < n ; j ++ ) { sum1 += arr1 [ j ] ; sum2 += arr2 [ j ] ; if ( sum1 == sum2 ) { let len = j - i + 1 ; if ( len > maxLen ) maxLen = len ; } } } return maxLen ; }
function arraySum ( arr , n ) { let x = ( n + 1 ) / 2 ; return ( arr [ 0 ] - 1 ) * n + x * x ; }
function sumofseries ( n ) { let res = 0 ; for ( let i = 1 ; i <= n ; i ++ ) res += ( i ) * ( i + 1 ) * ( i + 2 ) ; return res ; }
function findAandB ( N ) { let val = N * N - 4.0 * N ; if ( val < 0 ) { document . write ( " " ) ; return ; } let a = ( N + Math . sqrt ( val ) ) / 2.0 ; let b = ( N - Math . sqrt ( val ) ) / 2.0 ; document . write ( " " + a . toFixed ( 4 ) + " " ) ; document . write ( " " + b . toFixed ( 5 ) ) ; }
function calculateSum ( n ) { let fibo = [ ] ; if ( n <= 0 ) return 0 ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; let sum = fibo [ 0 ] + fibo [ 1 ] ; for ( let i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += fibo [ i ] ; } return sum ; } let n = 4 ; document . write ( ` ${ calculateSum ( n ) }
function minSum ( arr , n ) { let sum = 0 ; arr . sort ( function ( a , b ) { return b - a } ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 4 < 2 ) sum = sum + arr [ i ] ; } return sum ; }
function multiplyWith3Point5 ( x ) { return ( x << 1 ) + x + ( x >> 1 ) ; }
function charactersCount ( str , n ) { let count = 0 ; while ( n > 0 ) { let cur = str [ 0 ] . charCodeAt ( ) ; let ind = 0 ; for ( let j = 1 ; j < n ; j ++ ) { if ( str [ j ] . charCodeAt ( ) < cur ) { cur = str [ j ] . charCodeAt ( ) ; ind = j ; } } str = str . substring ( 0 , ind ) + str . substring ( ind + 1 ) ; n -- ; count += ind + 1 ; } document . write ( count + " " ) ; }
function pairORSum ( arr , n ) { for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] | arr [ j ] ; return ans ; }
function NimGame ( N , A , B ) { let sum = A + B ; if ( N % sum <= A - 1 ) return " " ; else return " " ; }
function overflow ( H , r , h , N , R ) { let tank_cap = 3.14 * r * r * H ; let water_vol = 3.14 * r * r * h ; let balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R ; let vol = water_vol + balls_vol ; if ( vol > tank_cap ) { document . write ( " " ) ; } else { document . write ( " " ) ; } }
function maxDiffSubsets ( arr ) { var totalSum = 0 ; var pos = false , neg = false ; var min = Number . MAX_VALUE ; for ( i = 0 ; i < arr . length ; i ++ ) { totalSum += Math . abs ( arr [ i ] ) ; if ( arr [ i ] > 0 ) pos = true ; if ( arr [ i ] < 0 ) neg = true ; if ( arr [ i ] < min ) min = arr [ i ] ; } if ( pos && neg ) return totalSum ; else return totalSum - 2 * min ; }
function minCost ( arr , n , circumference ) { arr . sort ( ( a , b ) => a - b ) var arr2 = Array ( 2 * n ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { arr2 [ i ] = arr [ i ] ; arr2 [ i + n ] = arr [ i ] + circumference ; } var res = 1000000000 ; for ( var i = 0 ; i < n ; i ++ ) res = Math . min ( res , arr2 [ i + ( n - 1 ) ] - arr2 [ i ] ) ; return res ; }
function findCost ( A , N ) { var totalCost = 0 ; var i ; for ( i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 0 ) { A [ i ] = 1 ; totalCost += i ; } } return totalCost ; }
function fib ( n ) { var f0 = 0 ; var f1 = 1 ; if ( n == 0 ) return 0 ; if ( n == 1 ) return 1 ; else { var rem = parseInt ( ( n % 60 ) ) ; if ( rem == 0 ) return 0 ; for ( i = 2 ; i < rem + 3 ; i ++ ) { var f = ( f0 + f1 ) % 60 ; f0 = f1 ; f1 = f ; } var s = f1 - 1 ; return s ; } }
function countMaxChoco ( money , price , wrap ) { if ( money < price ) return 0 ; let choc = parseInt ( money / price , 10 ) ; choc = choc + parseInt ( ( choc - 1 ) / ( wrap - 1 ) , 10 ) ; return choc ; }
function substrDeletion ( str , len ) { let count0 = 0 , count1 = 0 ; for ( let i = 0 ; i < len ; i ++ ) { if ( str [ i ] == ' ' ) count0 ++ ; else count1 ++ ; } return Math . min ( count0 , count1 ) ; }
function minPower ( n , x ) { if ( x == 1 ) return n ; let ans = 0 ; while ( n > 0 ) { ans += ( n % x ) ; n = Math . floor ( n / x ) ; } return ans ; }
function countOccurrences ( arr , n , x ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( x == arr [ i ] ) res ++ ; } return res ; }
function CountPairs ( arr , n ) { var count = 0 ; for ( i = 0 ; i < n - 1 ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( ( i * j ) == ( arr [ i ] * arr [ j ] ) ) count ++ ; } } return count ; }
function findpair ( l , r ) { let ans1 = l ; let ans2 = 2 * l ; document . write ( ans1 + " " + ans2 ) ; }
function isPossible ( str ) { let freq = new Map ( ) ; let max_freq = 0 ; for ( let j = 0 ; j < ( str . length ) ; j ++ ) { if ( freq . has ( str [ j ] ) ) { freq . set ( str [ j ] , freq . get ( str [ j ] ) + 1 ) ; if ( freq . get ( str [ j ] ) > max_freq ) max_freq = freq . get ( str [ j ] ) ; } else { freq . set ( str [ j ] , 1 ) ; if ( freq . get ( str [ j ] ) > max_freq ) max_freq = freq . get ( str [ j ] ) ; } } if ( max_freq <= ( str . length - max_freq + 1 ) ) return true ; return false ; }
function printMiddleCharacter ( str ) { let len = str . length ; let middle = parseInt ( len / 2 , 10 ) ; document . write ( str [ middle ] ) ; }
function exponentMod ( A , B , C ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; var y ; if ( B % 2 == 0 ) { y = exponentMod ( A , B / 2 , C ) ; y = ( y * y ) % C ; } else { y = A % C ; y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C ; } return parseInt ( ( ( y + C ) % C ) ) ; }
function findLength ( s , k ) { var ans = 1000000000 ; var l = 0 ; var r = 0 ; var cnt_zero = 0 , cnt_one = 0 ; while ( l < s . length && r <= s . length ) { if ( cnt_zero >= k && cnt_one >= 1 ) { ans = Math . min ( ans , r - l ) ; l ++ ; if ( s [ l - 1 ] == ' ' ) cnt_zero -- ; else cnt_one -- ; } else { if ( r == s . length ) break ; if ( s [ r ] == ' ' ) cnt_zero ++ ; else cnt_one ++ ; r ++ ; } } if ( ans == 1000000000 ) return - 1 ; return ans ; }
function printMatrix ( n , k ) { for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( i == j ) document . write ( k + " " ) ; else document . write ( " " ) ; } document . write ( " " ) ; } }
function remainingArea ( N , M , K ) { while ( K -- && N && M ) { if ( N > M ) N = N - M ; else M = M - N ; } if ( N > 0 && M > 0 ) return N * M ; else return 0 ; }
function countDigits ( a , b ) { let count = 0 ; let p = Math . abs ( a * b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = parseInt ( p / 10 , 10 ) ; } return count ; }
function countPairs ( arr , N ) { let odd = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & 1 ) odd ++ ; } let ans = ( N - odd + Math . floor ( odd / 2 ) - 1 ) + Math . floor ( odd / 2 ) ; return ans ; }
function countSol ( coeff , n , rhs ) { let dp = new Array ( rhs + 1 ) ; dp . fill ( 0 ) ; dp [ 0 ] = 1 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = coeff [ i ] ; j <= rhs ; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ; return dp [ rhs ] ; }
function find_longest_subarray ( A , N , K ) { let MaxLen = 0 ; let Len = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( K % A [ i ] == 0 ) { Len ++ ; MaxLen = Math . max ( MaxLen , Len ) ; } else { Len = 0 ; } } return MaxLen ; }
function polite ( n ) { n += 1 ; let base = 2 ; return n + ( Math . log ( ( n + ( Math . log ( n ) / Math . log ( base ) ) ) ) ) / Math . log ( base ) ; }
function findLen ( arr , i , curr , n , m ) { if ( i == n ) { if ( ! curr ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; var l = findLen ( arr , i + 1 , curr , n , m ) ; var r = findLen ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }
function maxBalancedStr ( s ) { var open1 = 0 , close1 = 0 ; var open2 = 0 , close2 = 0 ; var open3 = 0 , close3 = 0 ; for ( i = 0 ; i < s . length ; i ++ ) { switch ( s . charAt ( i ) ) { case ' ' : open1 ++ ; break ; case ' ' : close1 ++ ; break ; case ' ' : open2 ++ ; break ; case ' ' : close2 ++ ; break ; case ' ' : open3 ++ ; break ; case ' ' : close3 ++ ; break ; } } var maxLen = 2 * Math . min ( open1 , close1 ) + 2 * Math . min ( open2 , close2 ) + 2 * Math . min ( open3 , close3 ) ; return maxLen ; }
function area_of_circle ( m , n ) { var square_of_radius = ( m * n ) / 4 ; var area = ( 3.141 * square_of_radius ) ; return area ; }
function findNums ( arr , n ) { var S = 0 , X = 0 ; for ( i = 0 ; i < n ; i ++ ) { S += arr [ i ] ; X ^= arr [ i ] ; } document . write ( X + " " + ( X + S ) ) ; }
function maxSubsequences ( arr , n ) { let map = new Map ( ) ; let maxCount = 0 ; let count ; for ( let i = 0 ; i < n ; i ++ ) { if ( map . has ( arr [ i ] ) ) { count = map [ arr [ i ] ] ; if ( count > 1 ) { map . add ( arr [ i ] , count - 1 ) ; } else map . delete ( arr [ i ] ) ; if ( arr [ i ] - 1 > 0 ) if ( map . has ( arr [ i ] - 1 ) ) map [ arr [ i ] - 1 ] ++ ; else map . set ( arr [ i ] - 1 , 1 ) ; } else { maxCount ++ ; if ( arr [ i ] - 1 > 0 ) if ( map . has ( arr [ i ] - 1 ) ) map [ arr [ i ] - 1 ] ++ ; else map . set ( arr [ i ] - 1 , 1 ) ; } } return maxCount ; }
function minumumOperation ( N , arr ) { let sum_arr = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sum_arr = sum_arr + arr [ i ] ; } if ( sum_arr >= N ) document . write ( sum_arr - N + " " ) ; else document . write ( 1 + " " ) ; }
function segregate0and1 ( arr , size ) { let left = 0 , right = size - 1 ; while ( left < right ) { while ( arr [ left ] == 0 && left < right ) left ++ ; while ( arr [ right ] == 1 && left < right ) right -- ; if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } }
function printOtherSides ( n ) { if ( n % 2 != 0 ) { if ( n == 1 ) document . write ( " " ) ; else { var b = ( n * n - 1 ) / 2 ; var c = ( n * n + 1 ) / 2 ; document . write ( " " + b + " " + c ) ; } } else { if ( n == 2 ) document . write ( " " ) ; else { var b = n * n / 4 - 1 ; var c = n * n / 4 + 1 ; document . write ( " " + b + " " + c ) ; } } }
function highestPowerof2 ( n ) { let res = 0 ; for ( let i = n ; i >= 1 ; i -- ) { if ( ( i & ( i - 1 ) ) == 0 ) { res = i ; break ; } } return res ; }
function xorK ( n , k ) { let res = n ; for ( let i = 1 ; i < k ; i ++ ) res = ( res ^ n ) ; return n ; }
function CountDigits ( n ) { if ( n == 1 ) return 1 ; var sum = 0 ; for ( i = 2 ; i <= n ; ++ i ) { sum += ( Math . log ( i ) / Math . log ( 10 ) ) ; } sum *= n ; return Math . ceil ( sum ) ; }
function minOperation ( N ) { if ( N % 2 == 0 ) { return ( N / 2 ) * ( N / 2 ) ; } let k = ( N - 1 ) / 2 ; return k * ( k + 1 ) ; }
function ksmallest ( arr , n , k ) { arr . sort ( function ( a , b ) { return a - b } ) ; if ( k < arr [ 0 ] ) return k ; if ( k == arr [ 0 ] ) return arr [ 0 ] + 1 ; if ( k > arr [ n - 1 ] ) return k + n ; if ( arr [ 0 ] == 1 ) k -- ; else k -= ( arr [ 0 ] - 1 ) ; for ( let i = 1 ; i < n ; i ++ ) { let c = arr [ i ] - arr [ i - 1 ] - 1 ; if ( k <= c ) return arr [ i - 1 ] + k ; else k -= c ; } return arr [ n - 1 ] + k ; }
function findM ( s , x ) { var cnt = 0 ; for ( i = 0 ; i < s . length ; i ++ ) { if ( s . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) != x ) cnt ++ ; } return cnt ; }
function specialSieve ( n ) { let cnt = 0 ; let prime = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) prime [ i ] = 0 ; for ( let i = 2 ; i <= n ; i ++ ) { if ( ! prime [ i ] ) { cnt ++ ; for ( let j = i ; j <= n ; j += i ) prime [ j ] = cnt ; } } for ( let i = 2 ; i <= n ; i ++ ) document . write ( prime [ i ] + " " ) ; }
function nambiarNumber ( str , i ) { if ( i >= str . length ) return " " ; let firstDigit = ( str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ; let digitParity = firstDigit % 2 ; let sumDigits = 0 ; while ( i < str . length ) { sumDigits += ( str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ; let sumParity = sumDigits % 2 ; if ( digitParity != sumParity ) { break ; } i ++ ; } return ( " " + sumDigits + nambiarNumber ( str , i + 1 ) ) ; }
function unique ( s ) { let str = " " ; let len = s . length ; for ( let i = 0 ; i < len ; i ++ ) { let c = s [ i ] ; if ( str . indexOf ( c ) < 0 ) { str += c ; } } return str ; }
function countWays ( n ) { let res = new Array ( n + 2 ) ; res [ 0 ] = 1 ; res [ 1 ] = 1 ; res [ 2 ] = 2 ; for ( let i = 3 ; i <= n ; i ++ ) res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] ; return res [ n ] ; }
function totEdge ( n ) { var result = 0 ; result = ( n * ( n - 1 ) ) / 2 ; return result ; }
function minInsertion ( str ) { let n = str . length ; let res = 0 ; let count = new Array ( 26 ) ; for ( let i = 0 ; i < count . length ; i ++ ) { count [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) count [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] % 2 == 1 ) res ++ ; } return ( res == 0 ) ? 0 : res - 1 ; }
