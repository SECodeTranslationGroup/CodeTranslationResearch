function findWays ( N ) { let dp = new Array ( N + 1 ) ; dp [ 0 ] = 1 ; for ( let i = 1 ; i <= N ; i ++ ) { dp [ i ] = 0 ; for ( let j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 ) { dp [ i ] = dp [ i ] + dp [ i - j ] ; } } } document . write ( dp [ N ] ) ; }
function numberOfPairs ( n ) { let count = 0 ; let i = 1 , j = n - 1 ; while ( i < j ) { if ( i + j == n ) { count ++ ; } i ++ ; j -- ; } return count ; }
function findkey ( A , B , C ) { let ans = 0 ; let cur = 1 ; while ( A > 0 ) { let a = A % 10 ; let b = B % 10 ; let c = C % 10 ; A = Math . floor ( A / 10 ) ; B = Math . floor ( B / 10 ) ; C = Math . floor ( C / 10 ) ; let m = Math . max ( a , Math . max ( c , b ) ) ; ans += cur * m ; cur = cur * 10 ; } return ans ; }
function count ( a , b , m , n ) { if ( ( m == 0 && n == 0 ) n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( a [ m - 1 ] == b [ n - 1 ] ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; }
function checkRightAngled ( X1 , Y1 , X2 , Y2 , X3 , Y3 ) { var A = Math . pow ( X2 - X1 , 2 ) + Math . pow ( Y2 - Y1 , 2 ) ; var B = Math . pow ( X3 - X2 , 2 ) + Math . pow ( Y3 - Y2 , 2 ) ; var C = Math . pow ( X3 - X1 , 2 ) + Math . pow ( Y3 - Y1 , 2 ) ; if ( A > 0 && B > 0 && C > 0 && ( A === B + C B === A + C C === A + B ) ) document . write ( " " ) ; else document . write ( " " ) ; }
function find_winner ( str , n ) { var str1 = " " , str2 = " " ; for ( var i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { str1 += str [ i ] ; } else { str2 += str [ i ] ; } } str1 = str1 . split ( ' ' ) . sort ( ) ; str2 = str2 . split ( ' ' ) . sort ( ) ; if ( str1 < str2 ) document . write ( " " ) ; else if ( str2 < str1 ) document . write ( " " ) ; else document . write ( " " ) ; }
function findBitwiseORGivenXORAND ( X , Y ) { return X + Y ; }
function findDirection ( n , m ) { if ( n > m ) { if ( m % 2 == 0 ) document . write ( " " ) ; else document . write ( " " ) ; } else { if ( n % 2 == 0 ) document . write ( " " ) ; else document . write ( " " ) ; } }
function doMatch ( A , B ) { for ( i = 0 ; i < A . length ; i ++ ) { if ( A . charAt ( i ) != ' ' && B . charAt ( i ) != ' ' ) { if ( A . charAt ( i ) != B . charAt ( i ) ) return 0 ; } } return 1 ; }
function first ( str ) { for ( var i = 0 ; i < str . length ; i ++ ) if ( str [ i ] === str [ i ] . toUpperCase ( ) ) return str [ i ] ; return 0 ; } var str = " " ; var res = first ( str ) ; if ( res == 0 ) document . write ( " " ) ; else { document . write ( res ) ; document . write ( " " ) ; }
function rectanglearea ( a , b ) { if ( a < 0 b < 0 ) return - 1 ; return 2 * a * b ; }
function calculateAngle ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) { var ABx = x1 - x2 ; var ABy = y1 - y2 ; var ABz = z1 - z2 ; var BCx = x3 - x2 ; var BCy = y3 - y2 ; var BCz = z3 - z2 ; var dotProduct = ABx * BCx + ABy * BCy + ABz * BCz ; var magnitudeAB = ABx * ABx + ABy * ABy + ABz * ABz ; var magnitudeBC = BCx * BCx + BCy * BCy + BCz * BCz ; var angle = dotProduct ; angle /= Math . sqrt ( magnitudeAB * magnitudeBC ) ; angle = ( angle * 180 ) / PI ; document . write ( Math . abs ( angle ) . toFixed ( 4 ) ) ; }
function countPairs ( arr , N ) { let answer = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] + arr [ j ] == i + j ) { answer ++ ; } } } document . write ( answer ) ; }
function permutationCoeff ( n , k ) { let fact = new Array ( n + 1 ) ; fact [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; return parseInt ( fact [ n ] / fact [ n - k ] , 10 ) ; }
function findSum ( s ) { let sum = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { for ( let j = i + 1 ; j < s . length ; j ++ ) { if ( s [ i ] == s [ j ] ) { sum += ( j - i ) ; } } } return sum ; }
function findMinInsertions ( str , l , h ) { if ( l > h ) return Number . MAX_VALUE ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( Math . min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) }
function numberofterm ( n , number ) { let firstnum = Math . pow ( 10 , n - 1 ) ; let lastnum = Math . pow ( 10 , n ) ; let count = 0 ; for ( let i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) count ++ ; return count ; }
function octadiagonal ( a ) { if ( a < 0 ) return - 1 ; return a * Math . sqrt ( 4 + ( 2 * Math . sqrt ( 2 ) ) ) ; }
function submatrixXor ( arr ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { let top_left = ( i + 1 ) * ( j + 1 ) ; let bottom_right = ( n - i ) * ( n - j ) ; if ( ( top_left % 2 == 1 ) && ( bottom_right % 2 == 1 ) ) ans = ( ans ^ arr [ i ] [ j ] ) ; } } return ans ; }
function cyl ( r , h ) { if ( r < 0 && h < 0 ) return - 1 ; var R = ( 2 * r ) / 3 ; var H = ( 2 * h ) / 3 ; var V = 3.14 * Math . pow ( R , 2 ) * H ; return V ; }
function StepstoReachTarget ( target ) { target = Math . abs ( target ) ; let n = Math . ceil ( ( - 1.0 + Math . sqrt ( 1 + 8.0 * target ) ) / 2 ) ; let sum = n * ( n + 1 ) / 2 ; if ( sum == target ) return n ; let d = sum - target ; if ( ( d & 1 ) == 0 ) return n ; else return n + ( ( n & 1 ) != 0 ? 2 : 1 ) ; }
function can_empty ( a , b , c ) { if ( ( a + b + c ) % 4 != 0 ) return false ; else { let m = Math . min ( a , Math . min ( b , c ) ) ; if ( m < Math . floor ( ( a + b + c ) / 4 ) ) return false ; } return true ; }
function cntRect ( points , N , rectangle ) { var cntHor = new Set ( ) ; var cntVer = new Set ( ) ; cntHor . add ( 0 ) ; cntVer . add ( 0 ) ; cntHor . add ( rectangle [ 3 ] [ 0 ] ) ; cntVer . add ( rectangle [ 3 ] [ 1 ] ) ; for ( var i = 0 ; i < N ; i ++ ) { cntHor . add ( points [ i ] [ 0 ] ) ; cntVer . add ( points [ i ] [ 1 ] ) ; } return ( cntHor . size - 1 ) * ( cntVer . size - 1 ) ; }
function FirstRepeated ( str ) { let checker = 0 ; for ( let i = 0 ; i < str . length ; ++ i ) { let val = ( str [ i ] - ' ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return i ; checker |= ( 1 << val ) ; } return - 1 ; }
function constructArray ( N , K , X ) { let ans = new Array ( K ) . fill ( 0 ) ; ans [ 0 ] = X ; for ( let i = 0 ; i < N ; ++ i ) { document . write ( ans [ i % K ] + " " ) ; } document . write ( " " ) ; }
function nthTerm ( n ) { return 4 * Math . pow ( n , 2 ) - 3 * n + 2 ; }
function minRadius ( k , x , y , n ) { let dis = Array . from ( { length : n } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; dis . sort ( ) ; return dis [ k - 1 ] ; }
function printRLE ( s ) { for ( var i = 0 ; i < s . length ; i ++ ) { var count = 1 ; while ( i + 1 < s . length && s . charAt ( i ) == s . charAt ( i + 1 ) ) { i ++ ; count ++ ; } document . write ( s . charAt ( i ) + " " + count + " " ) ; } document . write ( " " ) ; }
function nthMagicNo ( n ) { let pow = 1 , answer = 0 ; while ( n != 0 ) { pow = pow * 5 ; if ( ( n & 1 ) == 1 ) answer += pow ; n >>= 1 ; } return answer ; }
function maxDiff ( arr , n ) { let diff = arr [ 1 ] - arr [ 0 ] ; let curr_sum = diff ; let max_sum = curr_sum ; for ( let i = 1 ; i < n - 1 ; i ++ ) { diff = arr [ i + 1 ] - arr [ i ] ; if ( curr_sum > 0 ) curr_sum += diff ; else curr_sum = diff ; if ( curr_sum > max_sum ) max_sum = curr_sum ; } return max_sum ; }
function findSubArray ( arr , n ) { let sum = 0 ; let maxsize = - 1 , startindex = 0 ; let endindex = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ; for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] == 0 ) sum += - 1 ; else sum += 1 ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } endindex = startindex + maxsize - 1 ; if ( maxsize == - 1 ) document . write ( " " ) ; else document . write ( startindex + " " + endindex ) ; return maxsize ; }
function averageEven ( n ) { if ( n % 2 != 0 ) { document . write ( " " ) ; return - 1 ; } return ( n + 2 ) / 2 ; }
function printRoots ( a , b , c ) { document . write ( 1 + " " + c / ( a * 1.0 ) ) ; }
function maxGCD ( N ) { for ( var i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { return N / i ; } } return 1 ; }
function numbersWith3Divisors ( n ) { let prime = new Array ( n + 1 ) ; prime . fill ( true ) ; prime [ 0 ] = prime [ 1 ] = 0 ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } document . write ( " " + " " ) ; for ( let i = 0 ; i * i <= n ; i ++ ) if ( prime [ i ] ) document . write ( i * i + " " ) ; }
function findEquation ( x1 , y1 , z1 , x2 , y2 , z2 , d , e , f ) { var a = x2 - x1 ; var b = y2 - y1 ; var c = z2 - z1 ; var A = parseInt ( ( b * f - c * e ) ) ; var B = parseInt ( ( a * f - c * d ) ) ; var C = parseInt ( ( a * e - b * d ) ) ; var D = - parseInt ( ( A * d - B * e + C * f ) ) ; document . write ( A + " " + B + " " + C + " " + D + " " ) ; }
function min_modulo ( l , r ) { if ( r - l >= MOD ) return 0 ; else { let ans = MOD - 1 ; for ( let i = l ; i <= r ; i ++ ) { for ( let j = i + 1 ; j <= r ; j ++ ) { ans = Math . min ( ans , ( i * j ) % MOD ) ; } } return ans ; } }
function findTwoThreePrime ( l , r ) { if ( l == 1 ) l ++ ; let count = 0 ; for ( let i = l ; i <= r ; i ++ ) { let num = i ; while ( num % 2 == 0 ) num = parseInt ( num / 2 , 10 ) ; while ( num % 3 == 0 ) num = parseInt ( num / 3 , 10 ) ; if ( num == 1 ) count ++ ; } return count ; }
function count_min_length ( s ) { var hash = new Array ( 26 ) . fill ( 0 ) ; var ans = 2147483648 ; for ( var i = 0 ; i < 26 ; i ++ ) hash [ i ] = - 1 ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( hash [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] == - 1 ) hash [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] = i ; else { if ( hash [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] == i - 1 || hash [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] == i - 2 ) return 0 ; ans = Math . min ( ans , i - hash [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] - 1 ) ; hash [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] = i ; } } if ( ans === 2147483648 ) return - 1 ; return ans ; }
function countMinSteps ( arr , target , n ) { arr = arr . sort ( function ( a , b ) { return a - b ; } ) ; var minimumSteps = 0 ; var i = 0 , j = n - 1 ; while ( i <= j ) { if ( arr [ i ] + arr [ j ] <= target ) { i ++ ; j -- ; } else { j -- ; } minimumSteps ++ ; } return minimumSteps ; }
function Avgdifference ( arr , N , K ) { let sum = 0 ; for ( let i = 0 ; i < K ; i ++ ) sum += arr [ i ] ; let min = sum ; let max = sum ; for ( let i = K ; i <= N - K + 1 ; i ++ ) { sum += arr [ i ] - arr [ i - K ] ; if ( min > sum ) min = sum ; if ( max < sum ) max = sum ; } return ( max - min ) / K ; }
function find_greatest_divisor ( l , r ) { if ( l == r ) return l ; return 1 ; }
function areAllBitsSet ( n ) { if ( n == 0 ) return " " ; if ( ( ( n + 1 ) & n ) == 0 ) return " " ; return " " ; }
function noAdjacentDup ( s1 ) { let n = s1 . length ; let s = s1 . split ( ' ' ) ; for ( let i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { s [ i ] = ' ' ; while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] ++ ; i ++ ; } } return ( s ) ; }
function fib ( n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
function findDay ( Y , B ) { let lyear , rest , totaldays , day ; Y = ( Y - 1 ) - B ; lyear = Math . floor ( Y / 4 ) ; rest = Y - lyear ; totaldays = ( rest * 365 ) + ( lyear * 366 ) + 1 ; day = ( totaldays % 7 ) ; if ( day == 0 ) document . write ( " " ) ; else if ( day == 1 ) document . write ( " " ) ; else if ( day == 2 ) document . write ( " " ) ; else if ( day == 3 ) document . write ( " " ) ; else if ( day == 4 ) document . write ( " " ) ; else if ( day == 5 ) document . write ( " " ) ; else if ( day == 6 ) document . write ( " " ) ; else document . write ( " " ) ; }
function getInvCount ( arr , n ) { let invcount = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let small = 0 ; for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ; let great = 0 ; for ( let j = i - 1 ; j >= 0 ; j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ; invcount += great * small ; } return invcount ; }
function findMinDifference ( arr , n ) { arr . sort ( ) ; let diff1 = arr [ n - 1 ] - arr [ 1 ] ; let diff2 = arr [ n - 2 ] - arr [ 0 ] ; return Math . min ( diff1 , diff2 ) ; }
function maxPointOfIntersection ( x , y ) { let k = y * ( y - 1 ) / 2 ; k = k + x * ( 2 * y + x - 1 ) ; return k ; }
function isPossible ( A , B , n , m , x , y ) { if ( x > n y > m ) return false ; A . sort ( ) ; B . sort ( ) ; if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; }
function subsetSum ( arr , n , i , sum , count ) { if ( i == n ) { if ( sum == 0 ) { count ++ ; } return count ; } count = subsetSum ( arr , n , i + 1 , sum - arr [ i ] , count ) ; count = subsetSum ( arr , n , i + 1 , sum , count ) ; return count ; }
function nthTerm ( N ) { let nth = 0 ; if ( N % 2 == 1 ) nth = ( N * N ) + 1 ; else nth = ( N * N ) - 1 ; return nth ; }
function swapThree ( ) { a = a ^ b ^ c ; b = a ^ b ^ c ; c = a ^ b ^ c ; a = a ^ b ^ c ; }
function rearrange ( A , B , N , X ) { let flag = true ; A . sort ( ) ; B . sort ( ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( A [ i ] + B [ N - 1 - i ] > X ) { flag = false ; break ; } } if ( flag == true ) document . write ( " " ) ; else document . write ( " " ) ; }
function findMinDenomin ( n ) { return ( Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ) ; }
function fibonacci ( n ) { var fib ; for ( i = 0 ; i < n ; i ++ ) { fib = ( Math . pow ( ( 1 + Math . sqrt ( 5 ) ) , i ) - Math . pow ( ( 1 - Math . sqrt ( 5 ) ) , i ) ) / ( Math . pow ( 2 , i ) * Math . sqrt ( 5 ) ) ; document . write ( parseInt ( fib ) + " " ) ; } }
function findFirstMissing ( array , start , end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; let mid = parseInt ( ( start + end ) / 2 , 10 ) ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }
function minimumOperations ( S , N ) { let ans = 0 ; let cntOne = 0 ; for ( let i = N - 1 ; i >= 0 ; i -- ) { if ( S [ i ] == ' ' ) { ans += cntOne ; cntOne *= 2 ; } else cntOne ++ ; } document . write ( ans ) ; }
function countSubsequences ( arr ) { let odd = 0 ; let even = 0 ; for ( let x of arr ) { if ( x & 1 ) odd ++ ; else even ++ ; } return ( ( 1 << odd ) - 1 ) * ( 1 << even ) ; }
function sumOfSubarrayProd ( arr , n ) { let ans = 0 ; let res = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { let incr = arr [ i ] * ( 1 + res ) ; ans += incr ; res = incr ; } document . write ( ans ) ; }
function minElements ( arr , n ) { let halfSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = parseInt ( halfSum / 2 , 10 ) ; arr . sort ( function ( a , b ) { return a - b } ) ; arr . reverse ( ) ; let res = 0 , curr_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } return res ; }
function Count_numbers ( L , R ) { var count = ( R - L ) / 2 ; if ( R % 2 != 0 L % 2 != 0 ) count += 1 ; document . write ( count ) ; }
function XOROfElements ( arr , n ) { var FirstHalfXOR = 0 ; var SecondHalfXOR = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( i < parseInt ( n / 2 ) ) FirstHalfXOR ^= arr [ i ] ; else SecondHalfXOR ^= arr [ i ] ; } document . write ( FirstHalfXOR + " " + SecondHalfXOR + " " ) ; }
function separateChar ( str ) { var n = str . length , digitSum = 0 ; var alphabetSum = 0 , j = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( str [ i ] >= ' ' && str [ i ] <= ' ' ) digitSum += ( str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ; else { alphabetSum += ( str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) + 1 ) ; alphabetSum %= 26 ; } } var sumStr = digitSum . toString ( ) ; var alphabetStr = String . fromCharCode ( alphabetSum + ' ' . charCodeAt ( 0 ) - 1 ) ; sumStr += alphabetStr ; return sumStr ; }
function squarearea ( r ) { if ( r < 0 ) return - 1 ; var a = 4 * ( Math . pow ( r , 2 ) / 5 ) ; return a ; }
function getFirstElement ( a , N , K , M ) { K %= N ; let index ; if ( K >= M ) index = ( N - K ) + ( M - 1 ) ; else index = ( M - K - 1 ) ; let result = a [ index ] ; return result ; }
function maxCost ( mat , N ) { let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) for ( let j = 1 ; j < i + 1 && j < N ; j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + Math . max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; let result = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 1 ] [ i ] ; return result ; }
function convertToDecimal ( N ) { document . write ( " " + N + " " ) ; if ( N != 0 ) { let decimalNumber = 0 ; let i = 0 , remainder ; while ( N != 0 ) { remainder = N % 10 ; N = parseInt ( N / 10 , 10 ) ; decimalNumber += remainder * Math . pow ( 3 , i ) ; ++ i ; } document . write ( decimalNumber + " " ) ; } else document . write ( " " + " " ) ; }
function isCheck ( str ) { var len = str . length ; var lowerStr = " " , upperStr = " " ; for ( var i = 0 ; i < len ; i ++ ) { if ( str [ i ] >= ' ' && str [ i ] < ' ' ) upperStr = upperStr + str [ i ] ; else lowerStr = lowerStr + str [ i ] ; } lowerStr = lowerStr . toUpperCase ( ) ; console . log ( lowerStr ) ; return lowerStr === upperStr ; }
function maxValue ( arr , n , moves ) { for ( var i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > 0 ) { var distance = n - 1 - i ; if ( moves < distance ) break ; var can_take = parseInt ( moves / distance ) ; var take = Math . min ( arr [ i ] , can_take ) ; arr [ n - 1 ] += take ; moves -= take * distance ; } } return arr [ n - 1 ] ; }
function cyl ( a ) { if ( a < 0 ) return - 1 ; var r = ( 2 * a * ( Math . sqrt ( 2 ) ) / 3 ) ; var h = ( 2 * a ) / 3 ; var V = ( 3.14 * ( Math . pow ( r , 2 ) * h ) ) ; return V ; }
function printArray ( arr , n ) { arr . sort ( ) ; let l = 0 , r = n - 1 , flag = 0 , i ; let k = 2 ; while ( l <= r ) { if ( flag == 0 ) { for ( i = l ; i < l + k && i <= r ; i ++ ) document . write ( arr [ i ] + " " ) ; flag = 1 ; l = i ; } else { for ( i = r ; i > r - k && i >= l ; i -- ) document . write ( arr [ i ] + " " ) ; flag = 0 ; r = i ; } k ++ ; } }
function getArray ( n ) { let ans = [ ] ; let p2 = 1 ; while ( n > 0 ) { if ( n & 1 ) ans . push ( p2 ) ; n >>= 1 ; p2 *= 2 ; } return ans ; }
function numberOfSticks ( x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }
function maxAverageOfPath ( cost , N ) { let dp = new Array ( N + 1 ) ; for ( let i = 0 ; i < N + 1 ; i ++ ) { dp [ i ] = new Array ( N + 1 ) ; for ( let j = 0 ; j < N + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( let j = 1 ; j < N ; j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( let i = 1 ; i < N ; i ++ ) for ( let j = 1 ; j < N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; }
function FindRank ( arr , length ) { document . write ( " " + " " ) ; for ( i = 1 ; i < arr . length ; i ++ ) { var rank = 1 ; for ( j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) rank ++ ; } document . write ( rank + " " ) ; } }
function checkSolution ( a , b , c ) { if ( b == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function binomialCoeffSum ( n ) { return ( 1 << n ) ; }
function findMissing ( a , b , n , m ) { for ( let i = 0 ; i < n ; i ++ ) { let j ; for ( j = 0 ; j < m ; j ++ ) if ( a [ i ] == b [ j ] ) break ; if ( j == m ) document . write ( a [ i ] + " " ) ; } }
function areaOfKite ( d1 , d2 ) { var area = ( d1 * d2 ) / 2 ; return area ; }
function minOR ( arr , n ) { if ( n == 1 ) return 0 ; var pre = Array ( n ) , suf = Array ( n ) ; pre [ 0 ] = arr [ 0 ] , suf [ n - 1 ] = arr [ n - 1 ] ; for ( var i = 1 ; i < n ; i ++ ) pre [ i ] = ( pre [ i - 1 ] arr [ i ] ) ; for ( var i = n - 2 ; i >= 0 ; i -- ) suf [ i ] = ( suf [ i + 1 ] arr [ i ] ) ; var ans = Math . min ( pre [ n - 2 ] , suf [ 1 ] ) ; for ( var i = 1 ; i < n - 1 ; i ++ ) ans = Math . min ( ans , ( pre [ i - 1 ] suf [ i + 1 ] ) ) ; return ans ; }
function findCount ( arr , N , K ) { arr . sort ( ) ; let result = 1 ; let cur_max = arr [ 0 ] ; let cur_min = arr [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) { cur_max = arr [ i ] ; if ( cur_max - cur_min > K ) { result ++ ; cur_max = arr [ i ] ; cur_min = arr [ i ] ; } } return result ; }
function printSorted ( arr , start , end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; document . write ( arr [ start ] + " " ) ; printSorted ( arr , start * 2 + 2 , end ) ; }
function checkpoint ( h , k , x , y , a ) { var p = parseInt ( Math . pow ( ( y - k ) , 2 ) - 4 * a * ( x - h ) ) ; return p ; }
function isOverflow ( a , b ) { if ( a == 0 b == 0 ) return false ; var result = a * b ; if ( result >= 9223372036854775807 result <= - 9223372036854775808 ) result = 0 if ( a == parseInt ( result / b ) ) return false ; else return true ; }
function numberofways ( n , m ) { let dp = new Array ( n + 2 ) ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( n + 2 ) ; for ( let j = 0 ; j < dp [ i ] . length ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ n + 1 ] = 1 ; for ( let k = n ; k >= m ; k -- ) { for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; }
function count_numbers ( k , n , flag ) { if ( n == 1 ) { if ( flag ) { return ( k - 1 ) ; } else { return 1 ; } } if ( flag ) return ( k - 1 ) * ( count_numbers ( k , n - 1 , 0 ) + count_numbers ( k , n - 1 , 1 ) ) ; else return count_numbers ( k , n - 1 , 1 ) ; }
function countPairs ( arr1 , arr2 , m , n , x ) { let count = 0 ; for ( let i = 0 ; i < m ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ; return count ; }
function countOfBase ( N ) { let count = 0 ; for ( let i = 2 ; i <= N ; ++ i ) { let highestPower = parseInt ( Math . log ( N ) / Math . log ( i ) ) ; let firstDigit = parseInt ( N / Math . pow ( i , highestPower ) ) ; if ( firstDigit == 1 ) { ++ count ; } } return count ; }
function longestSubsequence ( arr , N ) { let count = 1 ; for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != arr [ i - 1 ] ) { count ++ ; } } document . write ( count ) ; }
function countOddSum ( ar , n ) { let result = 0 ; for ( let i = 0 ; i <= n - 1 ; i ++ ) { let val = 0 ; for ( let j = i ; j <= n - 1 ; j ++ ) { val = val + ar [ j ] ; if ( val % 2 != 0 ) result ++ ; } } return ( result ) ; }
function turnOnK ( n , k ) { if ( k <= 0 ) return n ; return ( n | ( 1 << ( k - 1 ) ) ) ; }
function sumOfFactors ( N ) { var ans = 0 ; for ( i = 1 ; i <= N ; i ++ ) { var first = i ; var last = parseInt ( N / i ) * i ; var factors = parseInt ( ( last - first ) / i ) + 1 ; var totalContribution = parseInt ( ( ( factors ) * ( factors + 1 ) ) / 2 ) * i ; ans += totalContribution ; } return ans ; }
function checkPandigital ( b , n ) { if ( n . length < b ) return 0 ; let hash = [ ] ; for ( let i = 0 ; i < b ; i ++ ) hash [ i ] = 0 ; for ( let i = 0 ; i < n . length ; i ++ ) { if ( n [ i ] >= ' ' && n [ i ] <= ' ' ) hash [ n [ i ] - ' ' ] = 1 ; else if ( n . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) <= b - 11 ) hash [ n . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) + 10 ] = 1 ; } for ( let i = 0 ; i < b ; i ++ ) if ( hash [ i ] == 0 ) return 0 ; return 1 ; }
function validQuadruple ( arr , n ) { if ( n >= MAX ) return true ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) for ( let l = k + 1 ; l < n ; l ++ ) { if ( ( arr [ i ] ^ arr [ j ] ^ arr [ k ] ^ arr [ l ] ) == 0 ) { return true ; } } return false ; }
function printCombination ( n ) { document . write ( 1 + " " ) ; if ( ( n - 2 ) % 3 == 0 ) document . write ( 2 + " " + ( n - 3 ) ) ; else document . write ( 1 + " " + ( n - 2 ) ) ; }
function getPositionCount ( a , n ) { var count = 1 ; var min = a [ 0 ] ; for ( var i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= min ) { min = a [ i ] ; count ++ ; } } return count ; }
function maxDifference ( arr , N , k ) { let M , S = 0 , S1 = 0 , max_difference = 0 ; for ( let i = 0 ; i < N ; i ++ ) S += arr [ i ] ; let temp ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } M = Math . max ( k , N - k ) ; for ( let i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; }
function addOne ( x ) { let m = 1 ; while ( x & m ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
function findPair ( a , n , z ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) if ( i != j && a [ i ] + a [ j ] == z ) return true ; return false ; }
