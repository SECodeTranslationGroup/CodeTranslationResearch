void findWays ( int N ) { int [ ] dp = new int [ N + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ] = 0 ; for ( int j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 ) { dp [ i ] = dp [ i ] + dp [ i - j ] ; } } } Console . Write ( dp [ N ] ) ; }
int numberOfPairs ( int n ) { int count = 0 ; int i = 1 , j = n - 1 ; while ( i < j ) { if ( i + j == n ) { count ++ ; } i ++ ; j -- ; } return count ; }
int findkey ( int A , int B , int C ) { int ans = 0 ; int cur = 1 ; while ( A > 0 ) { int a = A % 10 ; int b = B % 10 ; int c = C % 10 ; A = A / 10 ; B = B / 10 ; C = C / 10 ; int m = Math . Max ( a , Math . Max ( c , b ) ) ; ans += cur * m ; cur = cur * 10 ; } return ans ; }
int count ( string a , string b , int m , int n ) { if ( ( m == 0 && n == 0 ) n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( a [ m - 1 ] == b [ n - 1 ] ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; }
void checkRightAngled ( int X1 , int Y1 , int X2 , int Y2 , int X3 , int Y3 ) { int A = ( int ) Math . Pow ( ( X2 - X1 ) , 2 ) + ( int ) Math . Pow ( ( Y2 - Y1 ) , 2 ) ; int B = ( int ) Math . Pow ( ( X3 - X2 ) , 2 ) + ( int ) Math . Pow ( ( Y3 - Y2 ) , 2 ) ; int C = ( int ) Math . Pow ( ( X3 - X1 ) , 2 ) + ( int ) Math . Pow ( ( Y3 - Y1 ) , 2 ) ; if ( ( A > 0 && B > 0 && C > 0 ) && ( A == ( B + C ) || B == ( A + C ) || C == ( A + B ) ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; }
void find_winner ( String str , int n ) { String str1 = " " , str2 = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { str1 += str [ i ] ; } else { str2 += str [ i ] ; } } char [ ] a = str1 . ToCharArray ( ) ; Array . Sort ( a ) ; char [ ] b = str2 . ToCharArray ( ) ; Array . Sort ( b ) ; str1 = new String ( a ) ; str2 = new String ( b ) ; if ( str1 . CompareTo ( str2 ) < 0 ) Console . Write ( " A " ) ; else if ( str1 . CompareTo ( str2 ) > 0 ) Console . Write ( " B " ) ; else Console . Write ( " Tie " ) ; }
int findBitwiseORGivenXORAND ( int X , int Y ) { return X + Y ; }
void findDirection ( int n , int m ) { if ( n > m ) { if ( m % 2 == 0 ) Console . Write ( " Up STRNEWLINE " ) ; else Console . Write ( " Down STRNEWLINE " ) ; } else { if ( n % 2 == 0 ) Console . Write ( " Left STRNEWLINE " ) ; else Console . Write ( " Right STRNEWLINE " ) ; } }
int doMatch ( String A , String B ) { for ( int i = 0 ; i < A . Length ; i ++ ) { if ( A [ i ] != ' * ' && B [ i ] != ' * ' ) if ( A [ i ] != B [ i ] ) return 0 ; } return 1 ; }
char first ( string str ) { for ( int i = 0 ; i < str . Length ; i ++ ) if ( char . IsUpper ( str [ i ] ) ) return str [ i ] ; return '0' ; }
float rectanglearea ( float a , float b ) { if ( a < 0 b < 0 ) return - 1 ; return 2 * a * b ; }
void calculateAngle ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 ) { int ABx = x1 - x2 ; int ABy = y1 - y2 ; int ABz = z1 - z2 ; int BCx = x3 - x2 ; int BCy = y3 - y2 ; int BCz = z3 - z2 ; double dotProduct = ABx * BCx + ABy * BCy + ABz * BCz ; double magnitudeAB = ABx * ABx + ABy * ABy + ABz * ABz ; double magnitudeBC = BCx * BCx + BCy * BCy + BCz * BCz ; double angle = dotProduct ; angle /= Math . Sqrt ( magnitudeAB * magnitudeBC ) ; angle = ( angle * 180 ) / 3.14 ; Console . Write ( String . Format ( " { 0 : F4 } " , Math . Abs ( angle ) ) ) ; }
void countPairs ( int [ ] arr , int N ) { int answer = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] + arr [ j ] == i + j ) { answer ++ ; } } } Console . Write ( answer ) ; }
int permutationCoeff ( int n , int k ) { int [ ] fact = new int [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; return fact [ n ] / fact [ n - k ] ; }
int findSum ( String s ) { int sum = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { for ( int j = i + 1 ; j < s . Length ; j ++ ) { if ( s [ i ] == s [ j ] ) { sum += ( j - i ) ; } } } return sum ; }
int findMinInsertions ( char [ ] str , int l , int h ) { if ( l > h ) return int . MaxValue ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( Math . Min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; }
int numberofterm ( int n , int number ) { int firstnum = ( int ) Math . Pow ( 10 , n - 1 ) ; int lastnum = ( int ) Math . Pow ( 10 , n ) ; int count = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) count ++ ; return count ; }
double octadiagonal ( double a ) { if ( a < 0 ) return - 1 ; return a * Math . Sqrt ( 4 + ( 2 * Math . Sqrt ( 2 ) ) ) ; }
int submatrixXor ( int [ , ] arr ) { int n = 3 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int top_left = ( i + 1 ) * ( j + 1 ) ; int bottom_right = ( n - i ) * ( n - j ) ; if ( ( top_left % 2 == 1 ) && ( bottom_right % 2 == 1 ) ) ans = ( ans ^ arr [ i , j ] ) ; } } return ans ; }
double cyl ( double r , double h ) { if ( r < 0 && h < 0 ) return - 1 ; double R = ( 2 * r ) / 3 ; double H = ( 2 * h ) / 3 ; double V = 3.14 * Math . Pow ( R , 2 ) * H ; return V ; }
int StepstoReachTarget ( int target ) { target = Math . Abs ( target ) ; int n = ( int ) Math . Ceiling ( ( - 1.0 + ( int ) Math . Sqrt ( 1 + 8.0 * target ) ) / 2 ) ; int sum = n * ( n + 1 ) / 2 ; if ( sum == target ) return n ; int d = sum - target ; if ( ( d & 1 ) == 0 ) return n ; else return n + ( ( n & 1 ) != 0 ? 2 : 1 ) ; }
bool can_empty ( int a , int b , int c ) { if ( ( a + b + c ) % 4 != 0 ) return false ; else { int m = Math . Min ( a , Math . Min ( b , c ) ) ; if ( m < ( ( a + b + c ) / 4 ) ) return false ; } return true ; }
int cntRect ( int [ , ] points , int N , int [ , ] rectangle ) { HashSet < int > cntHor = new HashSet < int > ( ) ; HashSet < int > cntVer = new HashSet < int > ( ) ; cntHor . Add ( 0 ) ; cntVer . Add ( 0 ) ; cntHor . Add ( rectangle [ 3 , 0 ] ) ; cntVer . Add ( rectangle [ 3 , 1 ] ) ; for ( int i = 0 ; i < N ; i ++ ) { cntHor . Add ( points [ i , 0 ] ) ; cntVer . Add ( points [ i , 1 ] ) ; } return ( cntHor . Count - 1 ) * ( cntVer . Count - 1 ) ; }
int FirstRepeated ( string str ) { int checker = 0 ; for ( int i = 0 ; i < str . Length ; ++ i ) { int val = ( str [ i ] - ' a ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return i ; checker |= ( 1 << val ) ; } return - 1 ; }
void constructArray ( int N , int K , int X ) { int [ ] ans = new int [ K ] ; ans [ 0 ] = X ; for ( int i = 0 ; i < N ; ++ i ) { Console . Write ( ans [ i % K ] + " ▁ " ) ; } }
int nthTerm ( int n ) { return 4 * ( int ) Math . Pow ( n , 2 ) - 3 * n + 2 ; }
int minRadius ( int k , int [ ] x , int [ ] y , int n ) { int [ ] dis = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; Array . Sort ( dis ) ; return dis [ k - 1 ] ; }
void printRLE ( String s ) { for ( int i = 0 ; i < s . Length - 1 ; i ++ ) { int count = 1 ; while ( s [ i ] == s [ i + 1 ] ) { i ++ ; count ++ ; if ( i + 1 == s . Length ) break ; } Console . Write ( s [ i ] + " " + count + " ▁ " ) ; } Console . WriteLine ( ) ; }
int nthMagicNo ( int n ) { int pow = 1 , answer = 0 ; while ( n != 0 ) { pow = pow * 5 ; if ( ( int ) ( n & 1 ) == 1 ) answer += pow ; n >>= 1 ; } return answer ; }
int maxDiff ( int [ ] arr , int n ) { int diff = arr [ 1 ] - arr [ 0 ] ; int curr_sum = diff ; int max_sum = curr_sum ; for ( int i = 1 ; i < n - 1 ; i ++ ) { diff = arr [ i + 1 ] - arr [ i ] ; if ( curr_sum > 0 ) curr_sum += diff ; else curr_sum = diff ; if ( curr_sum > max_sum ) max_sum = curr_sum ; } return max_sum ; }
int findSubArray ( int [ ] arr , int n ) { int sum = 0 ; int maxsize = - 1 , startindex = 0 ; int endindex = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] == 0 ) sum += - 1 ; else sum += 1 ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } endindex = startindex + maxsize - 1 ; if ( maxsize == - 1 ) Console . WriteLine ( " No ▁ such ▁ subarray " ) ; else Console . WriteLine ( startindex + " ▁ to ▁ " + endindex ) ; return maxsize ; }
int averageEven ( int n ) { if ( n % 2 != 0 ) { Console . Write ( " Invalid ▁ Input " ) ; return - 1 ; } return ( n + 2 ) / 2 ; }
void printRoots ( long a , long b , long c ) { Console . WriteLine ( "1 , ▁ " + c / ( a * 1.0 ) ) ; }
int maxGCD ( int N ) { for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { return N / i ; } } return 1 ; }
void numbersWith3Divisors ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; prime [ 0 ] = prime [ 1 ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == false ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = true ; } } System . Console . WriteLine ( " Numbers ▁ with ▁ 3 ▁ divisors ▁ : ▁ " ) ; for ( int i = 0 ; i * i <= n ; i ++ ) if ( ! prime [ i ] ) System . Console . Write ( i * i + " ▁ " ) ; }
void findEquation ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int d , int e , int f ) { double a = x2 - x1 ; double b = y2 - y1 ; double c = z2 - z1 ; int A = ( int ) ( b * f - c * e ) ; int B = ( int ) ( a * f - c * d ) ; int C = ( int ) ( a * e - b * d ) ; int D = - ( int ) ( A * d - B * e + C * f ) ; Console . Write ( A + " x ▁ + ▁ " + B + " y ▁ + ▁ " + C + " z ▁ + ▁ " + D + " = ▁ 0 ▁ " ) ; }
int min_modulo ( int l , int r ) { if ( r - l >= MOD ) return 0 ; else { int ans = MOD - 1 ; for ( int i = l ; i <= r ; i ++ ) { for ( int j = i + 1 ; j <= r ; j ++ ) { ans = Math . Min ( ans , ( i * j ) % MOD ) ; } } return ans ; } }
int findTwoThreePrime ( int l , int r ) { if ( l == 1 ) l ++ ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ; while ( num % 2 == 0 ) num /= 2 ; while ( num % 3 == 0 ) num /= 3 ; if ( num == 1 ) count ++ ; } return count ; }
int count_min_length ( string s ) { int [ ] hash = new int [ 26 ] ; int ans = int . MaxValue ; for ( int i = 0 ; i < 26 ; i ++ ) hash [ i ] = - 1 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( hash [ s [ i ] - ' a ' ] == - 1 ) hash [ s [ i ] - ' a ' ] = i ; else { if ( hash [ s [ i ] - ' a ' ] == i - 1 hash [ s [ i ] - ' a ' ] == i - 2 ) return 0 ; ans = Math . Min ( ans , i - hash [ s [ i ] - ' a ' ] - 1 ) ; hash [ s [ i ] - ' a ' ] = i ; } } if ( ans == int . MaxValue ) return - 1 ; return ans ; }
int countMinSteps ( int [ ] arr , int target , int n ) { Array . Sort ( arr ) ; int minimumSteps = 0 ; int i = 0 ; int j = n - 1 ; while ( i <= j ) { if ( arr [ i ] + arr [ j ] <= target ) { i += 1 ; j -= 1 ; } else { j -= 1 ; } minimumSteps += 1 ; } return minimumSteps ; }
double Avgdifference ( double [ ] arr , int N , int K ) { double sum = 0 ; for ( int i = 0 ; i < K ; i ++ ) sum += arr [ i ] ; double min = sum ; double max = sum ; for ( int i = K ; i <= N - K + 1 ; i ++ ) { sum += arr [ i ] - arr [ i - K ] ; if ( min > sum ) min = sum ; if ( max < sum ) max = sum ; } return ( max - min ) / K ; }
int find_greatest_divisor ( int l , int r ) { if ( l == r ) { return l ; } return 1 ; }
String areAllBitsSet ( int n ) { if ( n == 0 ) return " No " ; if ( ( ( n + 1 ) & n ) == 0 ) return " Yes " ; return " No " ; }
String noAdjacentDup ( String s1 ) { int n = s1 . Length ; char [ ] s = s1 . ToCharArray ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { s [ i ] = ' a ' ; while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] ++ ; i ++ ; } } return ( new String ( s ) ) ; }
int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
void findDay ( int Y , int B ) { int lyear , rest , totaldays , day ; Y = ( Y - 1 ) - B ; lyear = Y / 4 ; rest = Y - lyear ; totaldays = ( rest * 365 ) + ( lyear * 366 ) + 1 ; day = ( totaldays % 7 ) ; if ( day == 0 ) Console . WriteLine ( " Monday " ) ; else if ( day == 1 ) Console . WriteLine ( " Tuesday " ) ; else if ( day == 2 ) Console . WriteLine ( " Wednesday " ) ; else if ( day == 3 ) Console . WriteLine ( " Thursday " ) ; else if ( day == 4 ) Console . WriteLine ( " Friday " ) ; else if ( day == 5 ) Console . WriteLine ( " Saturday " ) ; else if ( day == 6 ) Console . WriteLine ( " Sunday " ) ; else Console . WriteLine ( " INPUT ▁ YEAR ▁ IS ▁ WRONG ! " ) ; }
int getInvCount ( int [ ] arr , int n ) { int invcount = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int small = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ; int great = 0 ; for ( int j = i - 1 ; j >= 0 ; j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ; invcount += great * small ; } return invcount ; }
int findMinDifference ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int diff1 = arr [ n - 1 ] - arr [ 1 ] ; int diff2 = arr [ n - 2 ] - arr [ 0 ] ; return Math . Min ( diff1 , diff2 ) ; }
int maxPointOfIntersection ( int x , int y ) { int k = y * ( y - 1 ) / 2 ; k = k + x * ( 2 * y + x - 1 ) ; return k ; }
bool isPossible ( int [ ] A , int [ ] B , int n , int m , int x , int y ) { if ( x > n y > m ) return false ; Array . Sort ( A ) ; Array . Sort ( B ) ; if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; }
int subsetSum ( int [ ] arr , int n , int i , int sum , int count ) { if ( i == n ) { if ( sum == 0 ) { count ++ ; } return count ; } count = subsetSum ( arr , n , i + 1 , sum - arr [ i ] , count ) ; count = subsetSum ( arr , n , i + 1 , sum , count ) ; return count ; }
int nthTerm ( int N ) { int nth = 0 ; if ( N % 2 == 1 ) nth = ( N * N ) + 1 ; else nth = ( N * N ) - 1 ; return nth ; }
void swapThree ( ref int a , ref int b , ref int c ) { a = a ^ b ^ c ; b = a ^ b ^ c ; c = a ^ b ^ c ; a = a ^ b ^ c ; }
void rearrange ( int [ ] A , int [ ] B , int N , int X ) { bool flag = true ; Array . Sort ( A ) ; Array . Sort ( B ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] + B [ N - 1 - i ] > X ) { flag = false ; break ; } } if ( flag == true ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; }
int findMinDenomin ( int n ) { return ( ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) + 1 ) ; }
void fibonacci ( double n ) { double fib ; for ( double i = 0 ; i < n ; i ++ ) { fib = ( Math . Pow ( ( 1 + Math . Sqrt ( 5 ) ) , i ) - Math . Pow ( ( 1 - Math . Sqrt ( 5 ) ) , i ) ) / ( Math . Pow ( 2 , i ) * Math . Sqrt ( 5 ) ) ; Console . Write ( ( int ) fib + " ▁ " ) ; } }
int findFirstMissing ( int [ ] array , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }
void minimumOperations ( string S , int N ) { int ans = 0 ; int cntOne = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( S [ i ] == '0' ) { ans += cntOne ; cntOne *= 2 ; } else cntOne ++ ; } Console . WriteLine ( ans ) ; }
int countSubsequences ( int [ ] arr ) { int odd = 0 ; int even = 0 ; for ( int i = 0 ; i < arr . Length ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) odd ++ ; else even ++ ; } return ( ( 1 << odd ) - 1 ) * ( 1 << even ) ; }
void sumOfSubarrayProd ( int [ ] arr , int n ) { int ans = 0 ; int res = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int incr = arr [ i ] * ( 1 + res ) ; ans += incr ; res = incr ; } Console . WriteLine ( ans ) ; }
int minElements ( int [ ] arr , int n ) { int halfSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = halfSum / 2 ; Array . Sort ( arr ) ; int res = 0 , curr_sum = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } return res ; }
void Count_numbers ( int L , int R ) { int count = ( R - L ) / 2 ; if ( R % 2 != 0 L % 2 != 0 ) count += 1 ; Console . Write ( count ) ; }
void XOROfElements ( int [ ] arr , int n ) { int FirstHalfXOR = 0 ; int SecondHalfXOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) FirstHalfXOR ^= arr [ i ] ; else SecondHalfXOR ^= arr [ i ] ; } Console . Write ( FirstHalfXOR + " , " + SecondHalfXOR + " STRNEWLINE " ) ; }
String separateChar ( String str ) { int n = str . Length , digitSum = 0 ; int alphabetSum = 0 , j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] >= '0' && str [ i ] <= '9' ) { digitSum += ( int ) ( str [ i ] - '0' ) ; } else { alphabetSum += str [ i ] - ' a ' + 1 ; alphabetSum %= 26 ; } } String sumStr = " " + ( digitSum ) ; char alphabetStr = ( char ) ( alphabetSum + ' a ' - 1 ) ; sumStr += alphabetStr ; return sumStr ; }
float squarearea ( float r ) { if ( r < 0 ) return - 1 ; float a = 4 * ( float ) ( Math . Pow ( r , 2 ) / 5 ) ; return a ; }
int getFirstElement ( int [ ] a , int N , int K , int M ) { K %= N ; int index ; if ( K >= M ) index = ( N - K ) + ( M - 1 ) ; else index = ( M - K - 1 ) ; int result = a [ index ] ; return result ; }
int maxCost ( int [ , ] mat , int N ) { int [ , ] dp = new int [ N , N ] ; dp [ 0 , 0 ] = mat [ 0 , 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i , 0 ] = mat [ i , 0 ] + dp [ i - 1 , 0 ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < i + 1 && j < N ; j ++ ) dp [ i , j ] = mat [ i , j ] + Math . Max ( dp [ i - 1 , j - 1 ] , dp [ i - 1 , j ] ) ; int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 , i ] ) result = dp [ N - 1 , i ] ; return result ; }
void convertToDecimal ( int N ) { Console . Write ( " Decimal ▁ number ▁ of ▁ " + N + " ▁ is : ▁ " ) ; if ( N != 0 ) { int decimalNumber = 0 ; int i = 0 , remainder ; while ( N != 0 ) { remainder = N % 10 ; N /= 10 ; decimalNumber += remainder * ( int ) Math . Pow ( 3 , i ) ; ++ i ; } Console . Write ( decimalNumber + " STRNEWLINE " ) ; } else Console . Write ( "0" + " STRNEWLINE " ) ; }
bool isCheck ( string str ) { int len = str . Length ; string lowerStr = " " , upperStr = " " ; char [ ] str1 = str . ToCharArray ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( ( int ) ( str1 [ i ] ) >= 65 && ( int ) str1 [ i ] <= 91 ) upperStr = upperStr + str1 [ i ] ; else lowerStr = lowerStr + str1 [ i ] ; } String transformStr = lowerStr . ToUpper ( ) ; return ( transformStr . Equals ( upperStr ) ) ; }
int maxValue ( int [ ] arr , int n , int moves ) { for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > 0 ) { int distance = n - 1 - i ; if ( moves < distance ) break ; int can_take = moves / distance ; int take = Math . Min ( arr [ i ] , can_take ) ; arr [ n - 1 ] += take ; moves -= take * distance ; } } return arr [ n - 1 ] ; }
float cyl ( float a ) { if ( a < 0 ) return - 1 ; float r = ( 2 * a * ( float ) ( Math . Sqrt ( 2 ) ) / 3 ) ; float h = ( 2 * a ) / 3 ; float V = ( 3.14f * ( float ) ( Math . Pow ( r , 2 ) * h ) ) ; return V ; }
void printArray ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int l = 0 , r = n - 1 , flag = 0 , i ; int k = 2 ; while ( l <= r ) { if ( flag == 0 ) { for ( i = l ; i < l + k && i <= r ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; flag = 1 ; l = i ; } else { for ( i = r ; i > r - k && i >= l ; i -- ) Console . Write ( arr [ i ] + " ▁ " ) ; flag = 0 ; r = i ; } k ++ ; } }
> getArray ( int n ) { List < long > ans = new List < long > ( ) ; long p2 = 1 ; while ( n > 0 ) { if ( n % 2 == 1 ) ans . Add ( p2 ) ; n >>= 1 ; p2 *= 2 ; } return ans ; }
int numberOfSticks ( int x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }
double maxAverageOfPath ( int [ , ] cost , int N ) { int [ , ] dp = new int [ N + 1 , N + 1 ] ; dp [ 0 , 0 ] = cost [ 0 , 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i , 0 ] = dp [ i - 1 , 0 ] + cost [ i , 0 ] ; for ( int j = 1 ; j < N ; j ++ ) dp [ 0 , j ] = dp [ 0 , j - 1 ] + cost [ 0 , j ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < N ; j ++ ) dp [ i , j ] = Math . Max ( dp [ i - 1 , j ] , dp [ i , j - 1 ] ) + cost [ i , j ] ; return ( double ) dp [ N - 1 , N - 1 ] / ( 2 * N - 1 ) ; }
void FindRank ( int [ ] arr , int length ) { Console . Write ( "1" + " ▁ " ) ; for ( int i = 1 ; i < arr . Length ; i ++ ) { int rank = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) rank ++ ; } Console . Write ( rank + " ▁ " ) ; } }
void checkSolution ( int a , int b , int c ) { if ( b == 0 ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; }
int binomialCoeffSum ( int n ) { return ( 1 << n ) ; }
void findMissing ( int [ ] a , int [ ] b , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < m ; j ++ ) if ( a [ i ] == b [ j ] ) break ; if ( j == m ) Console . Write ( a [ i ] + " ▁ " ) ; } }
float areaOfKite ( int d1 , int d2 ) { float area = ( d1 * d2 ) / 2 ; return area ; }
int minOR ( int [ ] arr , int n ) { if ( n == 1 ) return 0 ; int [ ] pre = new int [ n ] ; int [ ] suf = new int [ n ] ; pre [ 0 ] = arr [ 0 ] ; suf [ n - 1 ] = arr [ n - 1 ] ; for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = ( pre [ i - 1 ] arr [ i ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) suf [ i ] = ( suf [ i + 1 ] arr [ i ] ) ; int ans = Math . Min ( pre [ n - 2 ] , suf [ 1 ] ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) ans = Math . Min ( ans , ( pre [ i - 1 ] suf [ i + 1 ] ) ) ; return ans ; }
int findCount ( int [ ] arr , int N , int K ) { Array . Sort ( arr ) ; int result = 1 ; int cur_max = arr [ 0 ] ; int cur_min = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { cur_max = arr [ i ] ; if ( cur_max - cur_min > K ) { result ++ ; cur_max = arr [ i ] ; cur_min = arr [ i ] ; } } return result ; }
void printSorted ( int [ ] arr , int start , int end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; Console . Write ( arr [ start ] + " ▁ " ) ; printSorted ( arr , start * 2 + 2 , end ) ; }
int checkpoint ( int h , int k , int x , int y , int a ) { int p = ( int ) Math . Pow ( ( y - k ) , 2 ) - 4 * a * ( x - h ) ; return p ; }
bool isOverflow ( long a , long b ) { if ( a == 0 b == 0 ) return false ; long result = a * b ; if ( a == result / b ) return false ; else return true ; }
int numberofways ( int n , int m ) { int [ , ] dp = new int [ n + 2 , n + 2 ] ; dp [ 0 , n + 1 ] = 1 ; for ( int k = n ; k >= m ; k -- ) { for ( int i = 0 ; i <= n ; i ++ ) { dp [ i , k ] = dp [ i , k + 1 ] ; if ( i - k >= 0 ) dp [ i , k ] = ( dp [ i , k ] + dp [ i - k , k ] ) ; } } return dp [ n , m ] ; }
int count_numbers ( int k , int n , bool flag ) { if ( n == 1 ) { if ( flag ) { return ( k - 1 ) ; } else { return 1 ; } } if ( flag ) return ( k - 1 ) * ( count_numbers ( k , n - 1 , false ) + count_numbers ( k , n - 1 , true ) ) ; else return count_numbers ( k , n - 1 , true ) ; }
int countPairs ( int [ ] arr1 , int [ ] arr2 , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ; return count ; }
int countOfBase ( int N ) { int count = 0 ; for ( int i = 2 ; i <= N ; ++ i ) { int highestPower = ( int ) ( Math . Log ( N ) / Math . Log ( i ) ) ; int firstDigit = N / ( int ) Math . Pow ( i , highestPower ) ; if ( firstDigit == 1 ) { ++ count ; } } return count ; }
void longestSubsequence ( int [ ] arr , int N ) { int count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != arr [ i - 1 ] ) { count ++ ; } } Console . WriteLine ( count ) ; }
int countOddSum ( int [ ] ar , int n ) { int result = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { int val = 0 ; for ( int j = i ; j <= n - 1 ; j ++ ) { val = val + ar [ j ] ; if ( val % 2 != 0 ) result ++ ; } } return ( result ) ; }
int turnOnK ( int n , int k ) { if ( k <= 0 ) return n ; return ( n | ( 1 << ( k - 1 ) ) ) ; }
int sumOfFactors ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { int first = i ; int last = ( N / i ) * i ; int factors = ( last - first ) / i + 1 ; int totalContribution = ( ( ( factors ) * ( factors + 1 ) ) / 2 ) * i ; ans += totalContribution ; } return ans ; }
bool checkPandigital ( int b , string n ) { if ( n . Length < b ) return false ; bool [ ] hash = new bool [ b ] ; for ( int i = 0 ; i < b ; i ++ ) hash [ i ] = false ; for ( int i = 0 ; i < n . Length ; i ++ ) { if ( n [ i ] >= '0' && n [ i ] <= '9' ) hash [ n [ i ] - '0' ] = true ; else if ( n [ i ] - ' A ' <= b - 11 ) hash [ n [ i ] - ' A ' + 10 ] = true ; } for ( int i = 0 ; i < b ; i ++ ) if ( hash [ i ] == false ) return false ; return true ; }
Boolean validQuadruple ( int [ ] arr , int n ) { if ( n >= MAX ) return true ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) for ( int l = k + 1 ; l < n ; l ++ ) { if ( ( arr [ i ] ^ arr [ j ] ^ arr [ k ] ^ arr [ l ] ) == 0 ) { return true ; } } return false ; }
void printCombination ( int n ) { System . Console . Write ( 1 + " ▁ " ) ; if ( ( n - 2 ) % 3 == 0 ) System . Console . Write ( 2 + " ▁ " + ( n - 3 ) ) ; else System . Console . Write ( 1 + " ▁ " + ( n - 2 ) ) ; }
int getPositionCount ( int [ ] a , int n ) { int count = 1 ; int min = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= min ) { min = a [ i ] ; count ++ ; } } return count ; }
int maxDifference ( int [ ] arr , int N , int k ) { int M , S = 0 , S1 = 0 , max_difference = 0 ; for ( int i = 0 ; i < N ; i ++ ) S += arr [ i ] ; int temp ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } M = Math . Max ( k , N - k ) ; for ( int i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; }
int addOne ( int x ) { int m = 1 ; while ( ( int ) ( x & m ) == 1 ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
bool findPair ( int [ ] a , int n , int z ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( i != j && a [ i ] + a [ j ] == z ) return true ; return false ; }
