void findWays ( int N ) { int dp [ N + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ] = 0 ; for ( int j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 ) { dp [ i ] = dp [ i ] + dp [ i - j ] ; } } } cout << dp [ N ] ; }
int numberOfPairs ( int n ) { int count = 0 ; int i = 1 , j = n - 1 ; while ( i < j ) { if ( i + j == n ) { count ++ ; } i ++ ; j -- ; } return count ; }
int findkey ( int A , int B , int C ) { int ans = 0 ; int cur = 1 ; while ( A > 0 ) { int a = A % 10 ; int b = B % 10 ; int c = C % 10 ; A = A / 10 ; B = B / 10 ; C = C / 10 ; int m = max ( a , max ( c , b ) ) ; ans += cur * m ; cur = cur * 10 ; } return ans ; }
int count ( string a , string b , int m , int n ) { if ( ( m == 0 && n == 0 ) n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( a [ m - 1 ] == b [ n - 1 ] ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; }
void checkRightAngled ( int X1 , int Y1 , int X2 , int Y2 , int X3 , int Y3 ) { int A = ( int ) pow ( ( X2 - X1 ) , 2 ) + ( int ) pow ( ( Y2 - Y1 ) , 2 ) ; int B = ( int ) pow ( ( X3 - X2 ) , 2 ) + ( int ) pow ( ( Y3 - Y2 ) , 2 ) ; int C = ( int ) pow ( ( X3 - X1 ) , 2 ) + ( int ) pow ( ( Y3 - Y1 ) , 2 ) ; if ( ( A > 0 and B > 0 and C > 0 ) and ( A == ( B + C ) or B == ( A + C ) or C == ( A + B ) ) ) cout << " Yes " ; else cout << " No " ; }
void find_winner ( string str , int n ) { string str1 = " " , str2 = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { str1 += str [ i ] ; } else { str2 += str [ i ] ; } } sort ( str1 . begin ( ) , str1 . end ( ) ) ; sort ( str2 . begin ( ) , str2 . end ( ) ) ; if ( str1 < str2 ) cout << " A " ; else if ( str2 < str1 ) cout << " B " ; else cout << " Tie " ; }
int findBitwiseORGivenXORAND ( int X , int Y ) { return X + Y ; }
void findDirection ( int n , int m ) { if ( n > m ) { if ( m % 2 == 0 ) printf ( " Up STRNEWLINE " ) ; else printf ( " Down STRNEWLINE " ) ; } else { if ( n % 2 == 0 ) printf ( " Left STRNEWLINE " ) ; else printf ( " Right STRNEWLINE " ) ; } }
bool doMatch ( string A , string B ) { for ( int i = 0 ; i < A . length ( ) ; i ++ ) if ( A [ i ] != ' * ' && B [ i ] != ' * ' ) if ( A [ i ] != B [ i ] ) return false ; return true ; }
char first ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( isupper ( str [ i ] ) ) return str [ i ] ; return 0 ; }
float rectanglearea ( float a , float b ) { if ( a < 0 b < 0 ) return -1 ; return 2 * a * b ; }
void calculateAngle ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 ) { int ABx = x1 - x2 ; int ABy = y1 - y2 ; int ABz = z1 - z2 ; int BCx = x3 - x2 ; int BCy = y3 - y2 ; int BCz = z3 - z2 ; double dotProduct = ABx * BCx + ABy * BCy + ABz * BCz ; double magnitudeAB = ABx * ABx + ABy * ABy + ABz * ABz ; double magnitudeBC = BCx * BCx + BCy * BCy + BCz * BCz ; double angle = dotProduct ; angle /= sqrt ( magnitudeAB * magnitudeBC ) ; angle = ( angle * 180 ) / PI ; cout << abs ( angle ) << endl ; }
void countPairs ( int arr [ ] , int N ) { int answer = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] + arr [ j ] == i + j ) { answer ++ ; } } } cout << answer ; }
int permutationCoeff ( int n , int k ) { int fact [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; return fact [ n ] / fact [ n - k ] ; }
int findSum ( string s ) { int sum = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < s . size ( ) ; j ++ ) { if ( s [ i ] == s [ j ] ) { sum += ( j - i ) ; } } } return sum ; }
int findMinInsertions ( char str [ ] , int l , int h ) { if ( l > h ) return INT_MAX ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; }
int numberofterm ( int n , int number ) { int firstnum = pow ( 10 , n - 1 ) ; int lastnum = pow ( 10 , n ) ; int count = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) count ++ ; return count ; }
float octadiagonal ( float a ) { if ( a < 0 ) return -1 ; return a * sqrt ( 4 + ( 2 * sqrt ( 2 ) ) ) ; }
int submatrixXor ( int arr [ ] [ n ] ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int top_left = ( i + 1 ) * ( j + 1 ) ; int bottom_right = ( n - i ) * ( n - j ) ; if ( ( top_left % 2 == 1 ) && ( bottom_right % 2 == 1 ) ) ans = ( ans ^ arr [ i ] [ j ] ) ; } } return ans ; }
float cyl ( float r , float h ) { if ( r < 0 && h < 0 ) return -1 ; float R = ( 2 * r ) / 3 ; float H = ( 2 * h ) / 3 ; float V = 3.14 * pow ( R , 2 ) * H ; return V ; }
int StepstoReachTarget ( int target ) { target = abs ( target ) ; int n = ceil ( ( -1.0 + sqrt ( 1 + 8.0 * target ) ) / 2 ) ; int sum = n * ( n + 1 ) / 2 ; if ( sum == target ) return n ; int d = sum - target ; if ( ( d & 1 ) == 0 ) return n ; else return n + ( ( n & 1 ) ? 2 : 1 ) ; }
bool can_empty ( ll a , ll b , ll c ) { if ( ( a + b + c ) % 4 != 0 ) return false ; else { int m = min ( a , min ( b , c ) ) ; if ( m < ( ( a + b + c ) / 4 ) ) return false ; } return true ; }
int cntRect ( int points [ ] [ 2 ] , int N , int rectangle [ ] [ 2 ] ) { unordered_set < int > cntHor ; unordered_set < int > cntVer ; cntHor . insert ( 0 ) ; cntVer . insert ( 0 ) ; cntHor . insert ( rectangle [ 3 ] [ 0 ] ) ; cntVer . insert ( rectangle [ 3 ] [ 1 ] ) ; for ( int i = 0 ; i < N ; i ++ ) { cntHor . insert ( points [ i ] [ 0 ] ) ; cntVer . insert ( points [ i ] [ 1 ] ) ; } return ( cntHor . size ( ) - 1 ) * ( cntVer . size ( ) - 1 ) ; }
int FirstRepeated ( string str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { int val = ( str [ i ] - ' a ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return i ; checker |= ( 1 << val ) ; } return -1 ; }
void constructArray ( int N , int K , int X ) { vector < int > ans ( K , 0 ) ; ans [ 0 ] = X ; for ( int i = 0 ; i < N ; ++ i ) { cout << ans [ i % K ] << " ▁ " ; } cout << endl ; }
int nthTerm ( int n ) { return 4 * pow ( n , 2 ) - 3 * n + 2 ; }
int minRadius ( int k , int x [ ] , int y [ ] , int n ) { int dis [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; sort ( dis , dis + n ) ; return dis [ k - 1 ] ; }
void printRLE ( string s ) { for ( int i = 0 ; s [ i ] != ' \0' ; i ++ ) { int count = 1 ; while ( s [ i ] == s [ i + 1 ] ) { i ++ ; count ++ ; } cout << s [ i ] << count << " ▁ " ; } cout << endl ; }
int nthMagicNo ( int n ) { int pow = 1 , answer = 0 ; while ( n ) { pow = pow * 5 ; if ( n & 1 ) answer += pow ; } return answer ; }
int maxDiff ( int arr [ ] , int n ) { int diff = arr [ 1 ] - arr [ 0 ] ; int curr_sum = diff ; int max_sum = curr_sum ; for ( int i = 1 ; i < n - 1 ; i ++ ) { diff = arr [ i + 1 ] - arr [ i ] ; if ( curr_sum > 0 ) curr_sum += diff ; else curr_sum = diff ; if ( curr_sum > max_sum ) max_sum = curr_sum ; } return max_sum ; }
int findSubArray ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = -1 , startindex ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? -1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { ( arr [ j ] == 0 ) ? ( sum += -1 ) : ( sum += 1 ) ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } if ( maxsize == -1 ) cout << " No ▁ such ▁ subarray " ; else cout << startindex << " ▁ to ▁ " << startindex + maxsize - 1 ; return maxsize ; }
int averageEven ( int n ) { if ( n % 2 != 0 ) { cout << " Invalid ▁ Input " ; return -1 ; } return ( n + 2 ) / 2 ; }
void printRoots ( long a , long b , long c ) { cout << 1 << " , ▁ " << c / ( a * 1.0 ) ; }
int maxGCD ( int N ) { for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { return N / i ; } } return 1 ; }
void numbersWith3Divisors ( int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; prime [ 0 ] = prime [ 1 ] = 0 ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } cout << " Numbers ▁ with ▁ 3 ▁ divisors ▁ : STRNEWLINE " ; for ( int i = 0 ; i * i <= n ; i ++ ) if ( prime [ i ] ) cout << i * i << " ▁ " ; }
void findEquation ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int d , int e , int f ) { double a = x2 - x1 ; double b = y2 - y1 ; double c = z2 - z1 ; int A = ( b * f - c * e ) ; int B = ( a * f - c * d ) ; int C = ( a * e - b * d ) ; int D = - ( A * d - B * e + C * f ) ; cout << A << " x ▁ + ▁ " << B << " y ▁ + ▁ " << C << " z ▁ + ▁ " << D << " = ▁ 0" ; }
int min_modulo ( int l , int r ) { if ( r - l >= MOD ) return 0 ; else { int ans = MOD - 1 ; for ( int i = l ; i <= r ; i ++ ) { for ( int j = i + 1 ; j <= r ; j ++ ) { ans = min ( ans , ( i * j ) % MOD ) ; } } return ans ; } }
int findTwoThreePrime ( int l , int r ) { if ( l == 1 ) l ++ ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ; while ( num % 2 == 0 ) num /= 2 ; while ( num % 3 == 0 ) num /= 3 ; if ( num == 1 ) count ++ ; } return count ; }
int count_min_length ( string s ) { int hash [ 26 ] ; int ans = INT_MAX ; for ( int i = 0 ; i < 26 ; i ++ ) hash [ i ] = -1 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( hash [ s [ i ] - ' a ' ] == -1 ) hash [ s [ i ] - ' a ' ] = i ; else { if ( hash [ s [ i ] - ' a ' ] == i - 1 hash [ s [ i ] - ' a ' ] == i - 2 ) return 0 ; ans = min ( ans , i - hash [ s [ i ] - ' a ' ] - 1 ) ; hash [ s [ i ] - ' a ' ] = i ; } } if ( ans == INT_MAX ) return -1 ; return ans ; }
int countMinSteps ( int arr [ ] , int target , int n ) { sort ( arr , arr + n ) ; int minimumSteps = 0 ; int i = 0 , j = n - 1 ; while ( i <= j ) { if ( arr [ i ] + arr [ j ] <= target ) { i ++ ; j -- ; } else { j -- ; } minimumSteps ++ ; } return minimumSteps ; }
double Avgdifference ( double arr [ ] , int N , int K ) { double sum = 0 ; for ( int i = 0 ; i < K ; i ++ ) sum += arr [ i ] ; double min = sum ; double max = sum ; for ( int i = K ; i <= N - K + 1 ; i ++ ) { sum += arr [ i ] - arr [ i - K ] ; if ( min > sum ) min = sum ; if ( max < sum ) max = sum ; } return ( max - min ) / K ; }
int find_greatest_divisor ( int l , int r ) { if ( l == r ) return l ; return 1 ; }
string areAllBitsSet ( int n ) { if ( n == 0 ) return " No " ; if ( ( ( n + 1 ) & n ) == 0 ) return " Yes " ; return " No " ; }
string noAdjacentDup ( string s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { s [ i ] = ' a ' ; while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] ++ ; i ++ ; } } return s ; }
int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
void findDay ( int Y , int B ) { int lyear , rest , totaldays , day ; Y = ( Y - 1 ) - B ; lyear = Y / 4 ; rest = Y - lyear ; totaldays = ( rest * 365 ) + ( lyear * 366 ) + 1 ; day = ( totaldays % 7 ) ; if ( day == 0 ) printf ( " Monday " ) ; else if ( day == 1 ) printf ( " Tuesday " ) ; else if ( day == 2 ) printf ( " Wednesday " ) ; else if ( day == 3 ) printf ( " Thursday " ) ; else if ( day == 4 ) printf ( " Friday " ) ; else if ( day == 5 ) printf ( " Saturday " ) ; else if ( day == 6 ) printf ( " Sunday " ) ; else printf ( " INPUT ▁ YEAR ▁ IS ▁ WRONG ! " ) ; }
int getInvCount ( int arr [ ] , int n ) { int invcount = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int small = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ; int great = 0 ; for ( int j = i - 1 ; j >= 0 ; j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ; invcount += great * small ; } return invcount ; }
int findMinDifference ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int diff1 = arr [ n - 1 ] - arr [ 1 ] ; int diff2 = arr [ n - 2 ] - arr [ 0 ] ; return min ( diff1 , diff2 ) ; }
int maxPointOfIntersection ( int x , int y ) { int k = y * ( y - 1 ) / 2 ; k = k + x * ( 2 * y + x - 1 ) ; return k ; }
bool isPossible ( int A [ ] , int B [ ] , int n , int m , int x , int y ) { if ( x > n y > m ) return false ; sort ( A , A + n ) ; sort ( B , B + m ) ; if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; }
int subsetSum ( int arr [ ] , int n , int i , int sum , int count ) { if ( i == n ) { if ( sum == 0 ) { count ++ ; } return count ; } count = subsetSum ( arr , n , i + 1 , sum - arr [ i ] , count ) ; count = subsetSum ( arr , n , i + 1 , sum , count ) ; return count ; }
int nthTerm ( int N ) { int nth = 0 ; if ( N % 2 == 1 ) nth = ( N * N ) + 1 ; else nth = ( N * N ) - 1 ; return nth ; }
void swapThree ( int & a , int & b , int & c ) { a = a ^ b ^ c ; b = a ^ b ^ c ; c = a ^ b ^ c ; a = a ^ b ^ c ; }
void rearrange ( int A [ ] , int B [ ] , int N , int X ) { bool flag = true ; sort ( A , A + N ) ; sort ( B , B + N , greater < int > ( ) ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] + B [ i ] > X ) { flag = false ; break ; } } if ( flag ) cout << " Yes " ; else cout << " No " ; }
int findMinDenomin ( int n ) { return log2 ( n ) + 1 ; }
void fibonacci ( int n ) { long long int fib ; for ( long long int i = 0 ; i < n ; i ++ ) { fib = ( pow ( ( 1 + sqrt ( 5 ) ) , i ) - pow ( ( 1 - sqrt ( 5 ) ) , i ) ) / ( pow ( 2 , i ) * sqrt ( 5 ) ) ; cout << fib << " ▁ " ; } }
int findFirstMissing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }
void minimumOperations ( string S , int N ) { int ans = 0 ; int cntOne = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( S [ i ] == '0' ) { ans += cntOne ; cntOne *= 2 ; } else cntOne ++ ; } cout << ans ; }
int countSubsequences ( vector < int > arr ) { int odd = 0 ; int even = 0 ; for ( int x : arr ) { if ( x & 1 ) odd ++ ; else even ++ ; } return ( ( 1 << odd ) - 1 ) * ( 1 << even ) ; }
void sumOfSubarrayProd ( int arr [ ] , int n ) { int ans = 0 ; int res = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int incr = arr [ i ] * ( 1 + res ) ; ans += incr ; res = incr ; } cout << ( ans ) ; }
int minElements ( int arr [ ] , int n ) { int halfSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = halfSum / 2 ; sort ( arr , arr + n , greater < int > ( ) ) ; int res = 0 , curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } return res ; }
void Count_numbers ( int L , int R ) { int count = ( R - L ) / 2 ; if ( R % 2 != 0 L % 2 != 0 ) count += 1 ; cout << count << endl ; }
void XOROfElements ( int arr [ ] , int n ) { int FirstHalfXOR = 0 ; int SecondHalfXOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) FirstHalfXOR ^= arr [ i ] ; else SecondHalfXOR ^= arr [ i ] ; } cout << FirstHalfXOR << " , " << SecondHalfXOR << endl ; }
string separateChar ( string str ) { int n = str . size ( ) , digitSum = 0 ; int alphabetSum = 0 , j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isdigit ( str [ i ] ) ) digitSum += str [ i ] - '0' ; else { alphabetSum += str [ i ] - ' a ' + 1 ; alphabetSum %= 26 ; } } string sumStr = to_string ( digitSum ) ; char alphabetStr = char ( alphabetSum + ' a ' - 1 ) ; sumStr += alphabetStr ; return sumStr ; }
float squarearea ( float r ) { if ( r < 0 ) return -1 ; float a = 4 * ( pow ( r , 2 ) / 5 ) ; return a ; }
int getFirstElement ( int a [ ] , int N , int K , int M ) { K %= N ; int index ; if ( K >= M ) index = ( N - K ) + ( M - 1 ) ; else index = ( M - K - 1 ) ; int result = a [ index ] ; return result ; }
int maxCost ( int mat [ ] [ MAX ] , int N ) { int dp [ N ] [ N ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < i + 1 && j < N ; j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 1 ] [ i ] ; return result ; }
void convertToDecimal ( int N ) { cout << " Decimal ▁ number ▁ of ▁ " << N << " ▁ is : ▁ " ; if ( N != 0 ) { int decimalNumber = 0 , i = 0 , remainder ; while ( N != 0 ) { remainder = N % 10 ; N /= 10 ; decimalNumber += remainder * pow ( 3 , i ) ; ++ i ; } cout << decimalNumber << endl ; } else cout << "0" << endl ; }
bool isCheck ( string str ) { int len = str . length ( ) ; string lowerStr = " " , upperStr = " " ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] >= 65 && str [ i ] <= 91 ) upperStr = upperStr + str [ i ] ; else lowerStr = lowerStr + str [ i ] ; } transform ( lowerStr . begin ( ) , lowerStr . end ( ) , lowerStr . begin ( ) , :: toupper ) ; return lowerStr == upperStr ; }
int maxValue ( int arr [ ] , int n , int moves ) { for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > 0 ) { int distance = n - 1 - i ; if ( moves < distance ) break ; int can_take = moves / distance ; int take = min ( arr [ i ] , can_take ) ; arr [ n - 1 ] += take ; moves -= take * distance ; } } return arr [ n - 1 ] ; }
float cyl ( float a ) { if ( a < 0 ) return -1 ; float r = ( 2 * a * sqrt ( 2 ) ) / 3 ; float h = ( 2 * a ) / 3 ; float V = 3.14 * pow ( r , 2 ) * h ; return V ; }
void printArray ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int l = 0 , r = n - 1 , flag = 0 , i ; int k = 2 ; while ( l <= r ) { if ( flag == 0 ) { for ( i = l ; i < l + k && i <= r ; i ++ ) cout << arr [ i ] << " ▁ " ; flag = 1 ; l = i ; } { for ( i = r ; i > r - k && i >= l ; i -- ) cout << arr [ i ] << " ▁ " ; flag = 0 ; r = i ; } k ++ ; } }
> getArray ( int n ) { vector < long > ans ; long p2 = 1 ; while ( n > 0 ) { if ( n & 1 ) ans . push_back ( p2 ) ; n >>= 1 ; p2 *= 2 ; } return ans ; }
int numberOfSticks ( int x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }
double maxAverageOfPath ( int cost [ M ] [ M ] , int N ) { int dp [ N + 1 ] [ N + 1 ] ; dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( int j = 1 ; j < N ; j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return ( double ) dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; }
void FindRank ( int arr [ ] , int length ) { cout << "1" << " ▁ " ; for ( int i = 1 ; i < length ; i ++ ) { int rank = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) rank ++ ; } cout << rank << " ▁ " ; } }
void checkSolution ( int a , int b , int c ) { if ( b == 0 ) cout << " Yes " ; else cout << " No " ; }
int binomialCoeffSum ( int n ) { return ( 1 << n ) ; }
void findMissing ( int a [ ] , int b [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < m ; j ++ ) if ( a [ i ] == b [ j ] ) break ; if ( j == m ) cout << a [ i ] << " ▁ " ; } }
float areaOfKite ( int d1 , int d2 ) { float area = ( d1 * d2 ) / 2 ; return area ; }
int minOR ( int * arr , int n ) { if ( n == 1 ) return 0 ; int pre [ n ] , suf [ n ] ; pre [ 0 ] = arr [ 0 ] , suf [ n - 1 ] = arr [ n - 1 ] ; for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = ( pre [ i - 1 ] arr [ i ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) suf [ i ] = ( suf [ i + 1 ] arr [ i ] ) ; int ans = min ( pre [ n - 2 ] , suf [ 1 ] ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) ans = min ( ans , ( pre [ i - 1 ] suf [ i + 1 ] ) ) ; return ans ; }
int findCount ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; int result = 1 ; int cur_max = arr [ 0 ] ; int cur_min = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { cur_max = arr [ i ] ; if ( cur_max - cur_min > K ) { result ++ ; cur_max = arr [ i ] ; cur_min = arr [ i ] ; } } return result ; }
void printSorted ( int arr [ ] , int start , int end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; cout << arr [ start ] << " ▁ " ; printSorted ( arr , start * 2 + 2 , end ) ; }
int checkpoint ( int h , int k , int x , int y , int a ) { int p = pow ( ( y - k ) , 2 ) - 4 * a * ( x - h ) ; return p ; }
bool isOverflow ( long long a , long long b ) { if ( a == 0 b == 0 ) return false ; long long result = a * b ; if ( a == result / b ) return false ; else return true ; }
int numberofways ( int n , int m ) { int dp [ n + 2 ] [ n + 2 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ n + 1 ] = 1 ; for ( int k = n ; k >= m ; k -- ) { for ( int i = 0 ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; }
int count_numbers ( int k , int n , bool flag ) { if ( n == 1 ) { if ( flag ) { return ( k - 1 ) ; } else { return 1 ; } } if ( flag ) return ( k - 1 ) * ( count_numbers ( k , n - 1 , 0 ) + count_numbers ( k , n - 1 , 1 ) ) ; else return count_numbers ( k , n - 1 , 1 ) ; }
int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ; return count ; }
int countOfBase ( int N ) { int count = 0 ; for ( int i = 2 ; i <= N ; ++ i ) { int highestPower = ( int ) ( log ( N ) / log ( i ) ) ; int firstDigit = N / ( int ) pow ( i , highestPower ) ; if ( firstDigit == 1 ) { ++ count ; } } return count ; }
void longestSubsequence ( int arr [ ] , int N ) { int count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != arr [ i - 1 ] ) { count ++ ; } } cout << count << endl ; }
int countOddSum ( int ar [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { int val = 0 ; for ( int j = i ; j <= n - 1 ; j ++ ) { val = val + ar [ j ] ; if ( val % 2 != 0 ) result ++ ; } } return ( result ) ; }
int turnOnK ( int n , int k ) { if ( k <= 0 ) return n ; return ( n | ( 1 << ( k - 1 ) ) ) ; }
long sumOfFactors ( int N ) { long long ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { long long first = i ; long long last = ( N / i ) * i ; long long factors = ( last - first ) / i + 1 ; long long totalContribution = ( ( ( factors ) * ( factors + 1 ) ) / 2 ) * i ; ans += totalContribution ; } return ans ; }
bool checkPandigital ( int b , char n [ ] ) { if ( strlen ( n ) < b ) return false ; bool hash [ b ] ; memset ( hash , false , sizeof ( hash ) ) ; for ( int i = 0 ; i < strlen ( n ) ; i ++ ) { if ( n [ i ] >= '0' && n [ i ] <= '9' ) hash [ n [ i ] - '0' ] = true ; else if ( n [ i ] - ' A ' <= b - 11 ) hash [ n [ i ] - ' A ' + 10 ] = true ; } for ( int i = 0 ; i < b ; i ++ ) if ( hash [ i ] == false ) return false ; return true ; }
bool validQuadruple ( int arr [ ] , int n ) { if ( n >= MAX ) return true ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) for ( int l = k + 1 ; l < n ; l ++ ) { if ( ( arr [ i ] ^ arr [ j ] ^ arr [ k ] ^ arr [ l ] ) == 0 ) { return true ; } } return false ; }
void printCombination ( int n ) { cout << 1 << " ▁ " ; if ( ( n - 2 ) % 3 == 0 ) cout << 2 << " ▁ " << n - 3 ; else cout << 1 << " ▁ " << n - 2 ; }
int getPositionCount ( int a [ ] , int n ) { int count = 1 ; int min = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= min ) { min = a [ i ] ; count ++ ; } } return count ; }
int maxDifference ( int arr [ ] , int N , int k ) { int M , S = 0 , S1 = 0 , max_difference = 0 ; for ( int i = 0 ; i < N ; i ++ ) S += arr [ i ] ; sort ( arr , arr + N , greater < int > ( ) ) ; M = max ( k , N - k ) ; for ( int i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; }
int addOne ( int x ) { int m = 1 ; while ( x & m ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
bool findPair ( int a [ ] , int n , int z ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( i != j && a [ i ] + a [ j ] == z ) return true ; return false ; }
