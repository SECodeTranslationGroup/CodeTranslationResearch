def power ( x , y ) : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT return 1 NEW_LINE temp = power ( x , y // 2 ) NEW_LINE if y % 2 == 0 : NEW_LINE INDENT return temp * temp NEW_LINE else : NEW_LINE INDENT if y > 0 : NEW_LINE INDENT return x * temp * temp NEW_LINE else : NEW_LINE INDENT return ( temp * temp ) / x NEW_LINE DEDENT DEDENT DEDENT
def print_dist_sum ( arr , n ) : NEW_LINE INDENT sum_ = sum ( arr ) NEW_LINE dp = [ [ False ] * ( sum_ + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = True NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ arr [ i - 1 ] ] = True NEW_LINE for j in range ( 1 , sum_ + 1 ) : NEW_LINE INDENT if dp [ i - 1 ] [ j ] == True : NEW_LINE INDENT dp [ i ] [ j ] = True NEW_LINE dp [ i ] [ j + arr [ i - 1 ] ] = True NEW_LINE for j in range ( sum_ + 1 ) : NEW_LINE INDENT if dp [ n ] [ j ] == True : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def count_ways ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 4 NEW_LINE count_b = 1 NEW_LINE count_s = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT prev_count_b = count_b NEW_LINE prev_count_s = count_s NEW_LINE count_s = prev_count_b + prev_count_s NEW_LINE count_b = prev_count_s NEW_LINE result = count_s + count_b NEW_LINE return result * result NEW_LINE DEDENT
def scalar_product_mat ( mat , k ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i ] [ j ] * k NEW_LINE DEDENT DEDENT DEDENT
def max_sum ( arr ) : NEW_LINE INDENT arr_sum = 0 NEW_LINE curr_val = 0 NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr_sum = arr_sum + arr [ i ] NEW_LINE curr_val = curr_val + ( i * arr [ i ] ) NEW_LINE max_val = curr_val NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT curr_val = curr_val + arr_sum - n * arr [ n - j ] NEW_LINE if curr_val > max_val : NEW_LINE INDENT max_val = curr_val NEW_LINE return max_val NEW_LINE DEDENT
def lower_insertion_point ( arr , n , x ) : NEW_LINE INDENT if x < arr [ 0 ] : NEW_LINE INDENT return 0 NEW_LINE elif x > arr [ n - 1 ] : NEW_LINE INDENT return n NEW_LINE lower_pnt = 0 NEW_LINE i = 1 NEW_LINE while i < n and arr [ i ] < x : NEW_LINE INDENT lower_pnt = i NEW_LINE i = i * 2 NEW_LINE while lower_pnt < n and arr [ lower_pnt ] < x : NEW_LINE INDENT lower_pnt += 1 NEW_LINE return lower_pnt NEW_LINE DEDENT
def find_min_diff ( arr , n , m ) : NEW_LINE INDENT if m == 0 or n == 0 : NEW_LINE INDENT return 0 NEW_LINE arr . sort ( ) NEW_LINE if n < m : NEW_LINE INDENT return - 1 NEW_LINE min_diff = sys . maxsize NEW_LINE first = 0 NEW_LINE last = 0 NEW_LINE i = 0 NEW_LINE while i + m - 1 < n : NEW_LINE INDENT diff = arr [ i + m - 1 ] - arr [ i ] NEW_LINE if diff < min_diff : NEW_LINE INDENT min_diff = diff NEW_LINE first = i NEW_LINE last = i + m - 1 NEW_LINE i += 1 NEW_LINE return arr [ last ] - arr [ first ] NEW_LINE DEDENT
def min_remove ( a , b , n , m ) : NEW_LINE INDENT count_a = dict ( ) NEW_LINE count_b = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count_a [ a [ i ] ] = count_a . get ( a [ i ] , 0 ) + 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT count_b [ b [ i ] ] = count_b . get ( b [ i ] , 0 ) + 1 NEW_LINE res = 0 NEW_LINE for x in count_a : NEW_LINE INDENT if x in count_b . keys ( ) : NEW_LINE INDENT res += min ( count_a [ x ] , count_b [ x ] ) NEW_LINE return res NEW_LINE DEDENT
def knap_sack ( w0 , wt , val , n ) : NEW_LINE INDENT k = [ [ 0 ] * ( w0 + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( w0 + 1 ) : NEW_LINE INDENT if i == 0 or w == 0 : NEW_LINE INDENT k [ i ] [ w ] = 0 NEW_LINE elif wt [ i - 1 ] <= w : NEW_LINE INDENT k [ i ] [ w ] = max ( val [ i - 1 ] + k [ i - 1 ] [ w - wt [ i - 1 ] ] , k [ i - 1 ] [ w ] ) NEW_LINE else : NEW_LINE INDENT k [ i ] [ w ] = k [ i - 1 ] [ w ] NEW_LINE return k [ n ] [ w0 ] NEW_LINE DEDENT
def array_sorted_or_not ( arr , n ) : NEW_LINE INDENT if n == 1 or n == 0 : NEW_LINE INDENT return 1 NEW_LINE if arr [ n - 1 ] < arr [ n - 2 ] : NEW_LINE INDENT return 0 NEW_LINE return array_sorted_or_not ( arr , n - 1 ) NEW_LINE DEDENT
def min_time ( n , k , a ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE min_time = 0 NEW_LINE for i in range ( 0 , n , k ) : NEW_LINE INDENT min_time += 2 * a [ i ] NEW_LINE return min_time NEW_LINE DEDENT
def find_element ( arr , n , key ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == key : NEW_LINE INDENT return i NEW_LINE return - 1 NEW_LINE DEDENT
def find_max ( a , n , k ) : NEW_LINE INDENT count = SortedDict ( ) NEW_LINE for i in range ( k - 1 ) : NEW_LINE INDENT count [ a [ i ] ] = count . get ( a [ i ] , 0 ) + 1 NEW_LINE my_set = SortedSet ( ) NEW_LINE for key , value in count . items ( ) : NEW_LINE INDENT if value == 1 : NEW_LINE INDENT my_set . add ( key ) NEW_LINE for i in range ( k - 1 , n ) : NEW_LINE INDENT count [ a [ i ] ] = count . get ( a [ i ] , 0 ) + 1 NEW_LINE if count [ a [ i ] ] == 1 : NEW_LINE INDENT my_set . add ( a [ i ] ) NEW_LINE else : NEW_LINE INDENT my_set . discard ( a [ i ] ) NEW_LINE if len ( my_set ) == 0 : NEW_LINE INDENT print ( " Nothing " ) NEW_LINE else : NEW_LINE INDENT print ( my_set [ - 1 ] ) NEW_LINE x = a [ i - k + 1 ] NEW_LINE count [ x ] = count . get ( x , 0 ) - 1 NEW_LINE if count [ x ] == 1 : NEW_LINE INDENT my_set . add ( x ) NEW_LINE if count [ x ] == 0 : NEW_LINE INDENT my_set . discard ( x ) NEW_LINE DEDENT DEDENT DEDENT
def count_p ( n , k ) : NEW_LINE INDENT if n == 0 or k == 0 or k > n : NEW_LINE INDENT return 0 NEW_LINE if k == 1 or k == n : NEW_LINE INDENT return 1 NEW_LINE return k * count_p ( n - 1 , k ) + count_p ( n - 1 , k - 1 ) NEW_LINE DEDENT
def total_nodes ( adjac , n , x , y ) : NEW_LINE INDENT visited = [ 0 ] * ( n + 1 ) NEW_LINE p = [ None ] * n NEW_LINE q = Queue ( ) NEW_LINE q . put ( x ) NEW_LINE visited [ x ] = True NEW_LINE m = None NEW_LINE while not q . empty ( ) : NEW_LINE INDENT m = q . get ( ) NEW_LINE for i in range ( len ( adjac [ m ] ) ) : NEW_LINE INDENT h = adjac [ m ] [ i ] NEW_LINE if not visited [ h ] : NEW_LINE INDENT visited [ h ] = True NEW_LINE p [ h ] = m NEW_LINE q . put ( h ) NEW_LINE count = 0 NEW_LINE i = p [ y ] NEW_LINE while i != x : NEW_LINE INDENT count += 1 NEW_LINE i = p [ i ] NEW_LINE return count NEW_LINE DEDENT
def solve ( a , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE parent = [ - 1 ] * ( n + 1 ) NEW_LINE vis = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = i NEW_LINE if parent [ j ] == - 1 : NEW_LINE INDENT while parent [ j ] == - 1 : NEW_LINE INDENT parent [ j ] = i NEW_LINE j = ( j + a [ j ] + 1 ) % n NEW_LINE if parent [ j ] == i : NEW_LINE INDENT while vis [ j ] == 0 : NEW_LINE INDENT vis [ j ] = 1 NEW_LINE cnt = cnt + 1 NEW_LINE j = ( j + a [ j ] + 1 ) % n NEW_LINE return cnt NEW_LINE DEDENT
def count_distinct_subarray ( arr , n ) : NEW_LINE INDENT vis = SortedDict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT vis [ arr [ i ] ] = 1 NEW_LINE k = len ( vis ) NEW_LINE vis . clear ( ) NEW_LINE ans = 0 NEW_LINE right = 0 NEW_LINE window = 0 NEW_LINE for left in range ( n ) : NEW_LINE INDENT while right < n and window < k : NEW_LINE INDENT vis [ arr [ right ] ] = vis . get ( arr [ right ] , 0 ) + 1 NEW_LINE if vis [ arr [ right ] ] == 1 : NEW_LINE INDENT window += 1 NEW_LINE right += 1 NEW_LINE if window == k : NEW_LINE INDENT ans += n - right + 1 NEW_LINE vis [ arr [ left ] ] -= 1 NEW_LINE if vis [ arr [ left ] ] == 0 : NEW_LINE INDENT window -= 1 NEW_LINE return ans NEW_LINE DEDENT
def min_operation ( a , b , n ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE b . sort ( reverse = False ) NEW_LINE result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT result = result + abs ( a [ i ] - b [ i ] ) NEW_LINE return result NEW_LINE DEDENT
def min_height ( area , base ) : NEW_LINE INDENT return math . ceil ( ( 2 * area ) / base ) NEW_LINE DEDENT
def check_sentence ( str_ ) : NEW_LINE INDENT length = len ( str_ ) NEW_LINE if str_ [ 0 ] < ' A ' or str_ [ 0 ] > ' Z ' : NEW_LINE INDENT return False NEW_LINE if str_ [ length - 1 ] != ' . ' : NEW_LINE INDENT return False NEW_LINE prev_state = 0 NEW_LINE curr_state = 0 NEW_LINE index = 1 NEW_LINE while str_ [ index ] : NEW_LINE INDENT if ' A ' <= str_ [ index ] <= ' Z ' : NEW_LINE INDENT curr_state = 0 NEW_LINE elif str_ [ index ] == ' ▁ ' : NEW_LINE INDENT curr_state = 1 NEW_LINE elif ' a ' <= str_ [ index ] <= ' z ' : NEW_LINE INDENT curr_state = 2 NEW_LINE elif str_ [ index ] == ' . ' : NEW_LINE INDENT curr_state = 3 NEW_LINE if prev_state == curr_state and curr_state != 2 : NEW_LINE INDENT return False NEW_LINE if prev_state == 2 and curr_state == 0 : NEW_LINE INDENT return False NEW_LINE if curr_state == 3 and prev_state != 1 : NEW_LINE INDENT return True NEW_LINE index += 1 NEW_LINE prev_state = curr_state NEW_LINE return False NEW_LINE DEDENT
def alternate_sort ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while i < j : NEW_LINE INDENT print ( arr [ j ] , end = " ▁ " ) NEW_LINE j -= 1 NEW_LINE print ( arr [ i ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE if n % 2 != 0 : NEW_LINE INDENT print ( arr [ i ] ) NEW_LINE DEDENT DEDENT
def get_first_set_bit_pos ( n ) : NEW_LINE INDENT return int ( math . log2 ( n & - n ) ) + 1 NEW_LINE DEDENT
def find_nth ( n ) : NEW_LINE INDENT count = 0 NEW_LINE curr = 19 NEW_LINE while True : NEW_LINE INDENT sum_ = 0 NEW_LINE x = curr NEW_LINE while x > 0 : NEW_LINE INDENT sum_ = sum_ + x % 10 NEW_LINE x = x // 10 NEW_LINE if sum_ == 10 : NEW_LINE INDENT count += 1 NEW_LINE if count == n : NEW_LINE INDENT return curr NEW_LINE curr += 9 NEW_LINE return - 1 NEW_LINE DEDENT
def find_max_sum ( arr , n ) : NEW_LINE INDENT res = - sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefix_sum = arr [ i ] NEW_LINE for j in range ( i ) : NEW_LINE INDENT prefix_sum += arr [ j ] NEW_LINE suffix_sum = arr [ i ] NEW_LINE j = n - 1 NEW_LINE while j > i : NEW_LINE INDENT suffix_sum += arr [ j ] NEW_LINE j -= 1 NEW_LINE if prefix_sum == suffix_sum : NEW_LINE INDENT res = max ( res , prefix_sum ) NEW_LINE return res NEW_LINE DEDENT
def section ( x1 , x2 , y1 , y2 , m , n ) : NEW_LINE INDENT x = float ( ( n * x1 ) + ( m * x2 ) ) / ( m + n ) NEW_LINE y = float ( ( n * y1 ) + ( m * y2 ) ) / ( m + n ) NEW_LINE print ( " ( " , x , " , ▁ " , y , " ) " , sep = " " ) NEW_LINE DEDENT
def check_pair ( arr , n ) : NEW_LINE INDENT sum_ = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum_ += arr [ i ] NEW_LINE if sum_ % 2 != 0 : NEW_LINE INDENT return False NEW_LINE sum_ = sum_ / 2 NEW_LINE s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = sum_ - arr [ i ] NEW_LINE if val in s : NEW_LINE INDENT print ( " Pair ▁ elements ▁ are ▁ % d ▁ and ▁ % d " , arr [ i ] , val ) NEW_LINE s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT
def count_fibs ( low , high ) : NEW_LINE INDENT f1 , f2 , f3 = 0 , 1 , 1 NEW_LINE result = 0 NEW_LINE while f1 <= high : NEW_LINE INDENT if f1 >= low : NEW_LINE INDENT result += 1 NEW_LINE f1 = f2 NEW_LINE f2 = f3 NEW_LINE f3 = f1 + f2 NEW_LINE return result NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT if n < 4 : NEW_LINE INDENT return - 1 NEW_LINE rem = n % 4 NEW_LINE if rem == 0 : NEW_LINE INDENT return n // 4 NEW_LINE if rem == 1 : NEW_LINE INDENT if n < 9 : NEW_LINE INDENT return - 1 NEW_LINE return ( n - 9 ) // 4 + 1 NEW_LINE if rem == 2 : NEW_LINE INDENT return ( n - 6 ) // 4 + 1 NEW_LINE if rem == 3 : NEW_LINE INDENT if n < 15 : NEW_LINE INDENT return - 1 NEW_LINE return ( n - 15 ) // 4 + 2 NEW_LINE DEDENT DEDENT
def kth_non_repeating ( str_ , k ) : NEW_LINE INDENT n = len ( str_ ) NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE index = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT count [ i ] = 0 NEW_LINE index [ i ] = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = str_ [ i ] NEW_LINE count [ ord ( x ) ] += 1 NEW_LINE if count [ ord ( x ) ] == 1 : NEW_LINE INDENT index [ ord ( x ) ] = i NEW_LINE if count [ ord ( x ) ] == 2 : NEW_LINE INDENT index [ ord ( x ) ] = n NEW_LINE index . sort ( ) NEW_LINE return index [ k - 1 ] if ( index [ k - 1 ] != n ) else - 1 NEW_LINE DEDENT
def find ( p ) : NEW_LINE INDENT return math . ceil ( math . sqrt ( 2 * 365 * math . log ( 1 / ( 1 - p ) ) ) ) NEW_LINE DEDENT
def midpoint ( x1 , x2 , y1 , y2 ) : NEW_LINE INDENT print ( ( x1 + x2 ) // 2 , " ▁ , ▁ " , ( y1 + y2 ) // 2 , sep = " " ) NEW_LINE DEDENT
def group_elements ( arr , n ) : NEW_LINE INDENT visited = [ False ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if not visited [ i ] : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE visited [ j ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def are_k_anagrams ( str1 , str2 , k ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE if len ( str2 ) != n : NEW_LINE INDENT return False NEW_LINE count1 = [ 0 ] * MAX_CHAR NEW_LINE count2 = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE count = 0 NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if count1 [ i ] > count2 [ i ] : NEW_LINE INDENT count = count + abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE return count <= k NEW_LINE DEDENT
def print_prev_smaller ( arr , n ) : NEW_LINE INDENT print ( " _ , ▁ " , end = " " ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i - 1 , - 2 , - 1 ) : NEW_LINE INDENT if arr [ j ] < arr [ i ] : NEW_LINE INDENT print ( arr [ j ] , " , ▁ " , end = " " , sep = " " ) NEW_LINE break NEW_LINE if j == - 1 : NEW_LINE INDENT print ( " _ , ▁ " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def lcs ( i , j , count ) : NEW_LINE INDENT if i == 0 or j == 0 : NEW_LINE INDENT return count NEW_LINE if x [ i - 1 ] == y [ j - 1 ] : NEW_LINE INDENT count = lcs ( i - 1 , j - 1 , count + 1 ) NEW_LINE count = max ( count , max ( lcs ( i , j - 1 , 0 ) , lcs ( i - 1 , j , 0 ) ) ) NEW_LINE return count NEW_LINE DEDENT
def find_largest_sum_pair ( arr , n ) : NEW_LINE INDENT if arr [ 0 ] > arr [ 1 ] : NEW_LINE INDENT first = arr [ 0 ] NEW_LINE second = arr [ 1 ] NEW_LINE else : NEW_LINE INDENT first = arr [ 1 ] NEW_LINE second = arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if arr [ i ] > first : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE elif arr [ i ] > second and arr [ i ] != first : NEW_LINE INDENT second = arr [ i ] NEW_LINE return first + second NEW_LINE DEDENT
def check_duck ( num ) : NEW_LINE INDENT l = len ( num ) NEW_LINE count_zero = 0 NEW_LINE i = 1 NEW_LINE while i < l : NEW_LINE INDENT ch = num [ i ] NEW_LINE if ch == " 0 " : NEW_LINE INDENT count_zero = count_zero + 1 NEW_LINE i = i + 1 NEW_LINE return count_zero NEW_LINE DEDENT
def check_if_all_together ( s , c ) : NEW_LINE INDENT oneSeen = False NEW_LINE i = 0 NEW_LINE n = len ( s ) NEW_LINE while i < n : NEW_LINE INDENT if s [ i ] == c : NEW_LINE INDENT if oneSeen == True : NEW_LINE INDENT return False NEW_LINE while i < n and s [ i ] == c : NEW_LINE INDENT i += 1 NEW_LINE oneSeen = True NEW_LINE else : NEW_LINE INDENT i += 1 NEW_LINE return True NEW_LINE DEDENT
def are_elements_contiguous ( arr ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in arr : NEW_LINE INDENT us . add ( i ) NEW_LINE count = 1 NEW_LINE curr_ele = arr [ 0 ] - 1 NEW_LINE while curr_ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_ele -= 1 NEW_LINE curr_ele = arr [ 0 ] + 1 NEW_LINE while curr_ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_ele += 1 NEW_LINE return count == len ( us ) NEW_LINE DEDENT
def find_min_sum ( num ) : NEW_LINE INDENT sum_ = 0 NEW_LINE i = 2 NEW_LINE while i * i <= num : NEW_LINE INDENT while num % i == 0 : NEW_LINE INDENT sum_ += i NEW_LINE num //= i NEW_LINE i += 1 NEW_LINE sum_ += num NEW_LINE return sum_ NEW_LINE DEDENT
def min_string_value ( str_ , k ) : NEW_LINE INDENT l = len ( str_ ) NEW_LINE if k >= l : NEW_LINE INDENT return 0 NEW_LINE frequency = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( l ) : NEW_LINE INDENT frequency [ ord ( str_ [ i ] ) - ' a ' ] += 1 NEW_LINE q = PriorityQueue ( ) NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT q . put ( - frequency [ i ] ) NEW_LINE while k > 0 : NEW_LINE INDENT temp = q . get ( ) NEW_LINE temp = temp + 1 NEW_LINE q . put ( temp , temp ) NEW_LINE k = k - 1 NEW_LINE result = 0 NEW_LINE while not q . empty ( ) : NEW_LINE INDENT temp = q . get ( ) NEW_LINE temp = temp * ( - 1 ) NEW_LINE result += temp * temp NEW_LINE return result NEW_LINE DEDENT
def reverse_fibonacci ( n ) : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE a [ 0 ] = 0 NEW_LINE a [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT a [ i ] = a [ i - 2 ] + a [ i - 1 ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def count_subarr_with_equal_zero_and_one ( arr , n ) : NEW_LINE INDENT um = dict ( ) NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sum += ( - 1 if ( arr [ i ] == 0 ) else arr [ i ] ) NEW_LINE um [ curr_sum ] = um . get ( curr_sum , 0 ) + 1 NEW_LINE count = 0 NEW_LINE for itr in um : NEW_LINE INDENT if um [ itr ] > 1 : NEW_LINE INDENT count += ( um [ itr ] * ( um [ itr ] - 1 ) ) // 2 NEW_LINE if 0 in um . keys ( ) : NEW_LINE INDENT count += um [ 0 ] NEW_LINE return count NEW_LINE DEDENT
def is_lucky ( n ) : NEW_LINE INDENT next_position = n NEW_LINE if counter > n : NEW_LINE INDENT return 1 NEW_LINE if n % counter == 0 : NEW_LINE INDENT return 0 NEW_LINE next_position -= next_position // counter NEW_LINE counter += 1 NEW_LINE return is_lucky ( next_position ) NEW_LINE DEDENT
def count ( s , len_ ) : NEW_LINE INDENT cur = 0 NEW_LINE dig = 0 NEW_LINE sum_ = [ 0 ] * MAX NEW_LINE dp = [ [ 0 ] * 3 for _ in range ( MAX ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , len_ + 1 ) : NEW_LINE INDENT dig = ord ( s [ i - 1 ] ) - 48 NEW_LINE cur += dig NEW_LINE cur %= 3 NEW_LINE sum_ [ i ] = cur NEW_LINE dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ] NEW_LINE dp [ i ] [ sum_ [ i ] ] += 1 NEW_LINE ans = 0 NEW_LINE dprev = 0 NEW_LINE value = 0 NEW_LINE dprev2 = 0 NEW_LINE for i in range ( 1 , len_ + 1 ) : NEW_LINE INDENT dig = ord ( s [ i - 1 ] ) - 48 NEW_LINE if dig == 8 : NEW_LINE INDENT ans += 1 NEW_LINE if i - 2 >= 0 : NEW_LINE INDENT dprev = ord ( s [ i - 2 ] ) - 48 NEW_LINE value = dprev * 10 + dig NEW_LINE if ( value % 8 == 0 ) and ( value % 3 != 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE if i - 3 >= 0 : NEW_LINE INDENT dprev2 = ord ( s [ i - 3 ] ) - 48 NEW_LINE dprev = ord ( s [ i - 2 ] ) - 48 NEW_LINE value = ( dprev2 * 100 + dprev * 10 + dig ) NEW_LINE if value % 8 != 0 : NEW_LINE INDENT continue NEW_LINE ans += ( i - 2 ) NEW_LINE ans -= ( dp [ i - 3 ] [ sum_ [ i ] ] ) NEW_LINE return ans NEW_LINE DEDENT
def next_power_of2 ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if n and not ( n & ( n - 1 ) ) : NEW_LINE INDENT return n NEW_LINE while n != 0 : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE return 1 << count NEW_LINE DEDENT
def can_form_palindrome ( st ) : NEW_LINE INDENT count = [ 0 ] * NO_OF_CHARS NEW_LINE for i in range ( len ( st ) ) : NEW_LINE INDENT count [ ord ( st [ i ] ) ] += 1 NEW_LINE odd = 0 NEW_LINE for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if count [ i ] & 1 : NEW_LINE INDENT odd = odd + 1 NEW_LINE if odd > 1 : NEW_LINE INDENT return False NEW_LINE return True NEW_LINE DEDENT
def square_root ( n ) : NEW_LINE INDENT x = n NEW_LINE y = 1 NEW_LINE e = 0.000001 NEW_LINE while x - y > e : NEW_LINE INDENT x = ( x + y ) / 2 NEW_LINE y = n / x NEW_LINE return x NEW_LINE DEDENT
def binary_search ( arr , low , high ) : NEW_LINE INDENT if high >= low : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if mid is arr [ mid ] : NEW_LINE INDENT return mid NEW_LINE if mid > arr [ mid ] : NEW_LINE INDENT return binary_search ( arr , ( mid + 1 ) , high ) NEW_LINE else : NEW_LINE INDENT return binary_search ( arr , low , ( mid - 1 ) ) NEW_LINE return - 1 NEW_LINE DEDENT
def count_dyck_paths ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res *= 2 * n - i NEW_LINE res //= i + 1 NEW_LINE return res / ( n + 1 ) NEW_LINE DEDENT
def push_zeros_to_end ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE while count < n : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT
def is_convertible ( str1 , str2 , k ) : NEW_LINE INDENT if ( len ( str1 ) + len ( str2 ) ) < k : NEW_LINE INDENT return True NEW_LINE common_length = 0 NEW_LINE for i in range ( min ( len ( str1 ) , len ( str2 ) ) ) : NEW_LINE INDENT if str1 [ i ] == str2 [ i ] : NEW_LINE INDENT common_length += 1 NEW_LINE else : NEW_LINE INDENT break NEW_LINE if ( k - len ( str1 ) - len ( str2 ) + 2 * common_length ) % 2 == 0 : NEW_LINE INDENT return True NEW_LINE return False NEW_LINE DEDENT
def answer_query ( a , n , l , r ) : NEW_LINE INDENT count = 0 NEW_LINE l = l - 1 NEW_LINE for i in range ( l , r ) : NEW_LINE INDENT element = a [ i ] NEW_LINE divisors = 0 NEW_LINE for j in range ( l , r ) : NEW_LINE INDENT if a [ j ] % a [ i ] == 0 : NEW_LINE INDENT divisors += 1 NEW_LINE else : NEW_LINE INDENT break NEW_LINE if divisors == r - l : NEW_LINE INDENT count += 1 NEW_LINE return count NEW_LINE DEDENT
def swap ( xp , yp ) : NEW_LINE INDENT if xp [ 0 ] == yp [ 0 ] : NEW_LINE INDENT return NEW_LINE xp [ 0 ] = xp [ 0 ] + yp [ 0 ] NEW_LINE yp [ 0 ] = xp [ 0 ] - yp [ 0 ] NEW_LINE xp [ 0 ] = xp [ 0 ] - yp [ 0 ] NEW_LINE DEDENT
def max_profit ( price , n , k ) : NEW_LINE INDENT profit = [ [ 0 ] * ( n + 1 ) for _ in range ( k + 1 ) ] NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT prev_diff = - sys . maxsize NEW_LINE for j in range ( n ) : NEW_LINE INDENT prev_diff = max ( prev_diff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) NEW_LINE profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ] , price [ j ] + prev_diff ) NEW_LINE return profit [ k ] [ n - 1 ] NEW_LINE DEDENT
def find_missing ( a , b , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if a [ i ] == b [ j ] : NEW_LINE INDENT break NEW_LINE if j == m - 1 : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def count_number_of_triangles ( n ) : NEW_LINE INDENT return n * ( n - 1 ) * ( n - 2 ) // 6 NEW_LINE DEDENT
def print_sorted ( arr , start , end ) : NEW_LINE INDENT if start > end : NEW_LINE INDENT return NEW_LINE print_sorted ( arr , start * 2 + 1 , end ) NEW_LINE print ( arr [ start ] , end = " ▁ " ) NEW_LINE print_sorted ( arr , start * 2 + 2 , end ) NEW_LINE DEDENT
def search ( mat , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE smallest = a [ 0 ] [ 0 ] NEW_LINE largest = a [ n - 1 ] [ n - 1 ] NEW_LINE if x < smallest or x > largest : NEW_LINE INDENT return - 1 NEW_LINE while i < n and j >= 0 : NEW_LINE INDENT if mat [ i ] [ j ] == x : NEW_LINE INDENT print ( " n ▁ Found ▁ at ▁ " , i , " , ▁ " , j ) NEW_LINE return 1 NEW_LINE if mat [ i ] [ j ] > x : NEW_LINE INDENT j -= 1 NEW_LINE else : NEW_LINE INDENT i += 1 NEW_LINE print ( " Element ▁ not ▁ found " ) NEW_LINE return 0 NEW_LINE DEDENT
def find_integer ( arr , n ) : NEW_LINE INDENT neg = 0 NEW_LINE pos = 0 NEW_LINE sum_ = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum_ += arr [ i ] NEW_LINE if arr [ i ] < 0 : NEW_LINE INDENT neg += 1 NEW_LINE else : NEW_LINE INDENT pos += 1 NEW_LINE return sum_ // abs ( neg - pos ) NEW_LINE DEDENT
def count_groups ( position , previous_sum , length , num ) : NEW_LINE INDENT if position == length : NEW_LINE INDENT return 1 NEW_LINE res = 0 NEW_LINE sum_ = 0 NEW_LINE for i in range ( position , length ) : NEW_LINE INDENT sum_ += ord ( num [ i ] ) NEW_LINE if sum_ >= previous_sum : NEW_LINE INDENT res = res + count_groups ( i + 1 , sum_ , length , num ) NEW_LINE return res NEW_LINE DEDENT
def digits_num ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT print ( " 0 " ) NEW_LINE if n % 9 != 0 : NEW_LINE INDENT print ( n % 9 , end = " " ) NEW_LINE for i in range ( 1 , n // 9 + 1 ) : NEW_LINE INDENT print ( " 9 " , end = " " ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( " 0 " , end = " " ) NEW_LINE print ( ) NEW_LINE DEDENT
def check_collision ( a , b , c , x , y , radius ) : NEW_LINE INDENT dist = abs ( a * x + b * y + c ) / math . sqrt ( a * a + b * b ) NEW_LINE if radius == dist : NEW_LINE INDENT print ( " Touch " ) NEW_LINE elif radius > dist : NEW_LINE INDENT print ( " Intersect " ) NEW_LINE else : NEW_LINE INDENT print ( " Outside " ) NEW_LINE DEDENT DEDENT
def difference ( arr , n ) : NEW_LINE INDENT d1 = 0 NEW_LINE d2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT d1 = d1 + arr [ i ] [ i ] NEW_LINE d2 = d2 + arr [ i ] [ n - i - 1 ] NEW_LINE return abs ( d1 - d2 ) NEW_LINE DEDENT
def area_circumscribed ( a ) : NEW_LINE INDENT return a * a * ( math . pi / 2 ) NEW_LINE DEDENT
def count_rotations ( arr , n ) : NEW_LINE INDENT min = arr [ 0 ] NEW_LINE min_index = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if min > arr [ i ] : NEW_LINE INDENT min = arr [ i ] NEW_LINE min_index = i NEW_LINE return min_index NEW_LINE DEDENT
def lps ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE a = [ 0 ] * n NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT back_up = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if j == i : NEW_LINE INDENT a [ j ] = 1 NEW_LINE elif s [ i ] == s [ j ] : NEW_LINE INDENT temp = a [ j ] NEW_LINE a [ j ] = back_up + 2 NEW_LINE back_up = temp NEW_LINE else : NEW_LINE INDENT back_up = a [ j ] NEW_LINE a [ j ] = max ( a [ j - 1 ] , a [ j ] ) NEW_LINE return a [ n - 1 ] NEW_LINE DEDENT
def square_root ( n ) : NEW_LINE INDENT return 2 ** ( 0.5 * math . log2 ( n ) ) NEW_LINE DEDENT
def print_small ( arr , n , k ) : NEW_LINE INDENT for i in range ( k , n ) : NEW_LINE INDENT max_var = arr [ k - 1 ] NEW_LINE pos = k - 1 NEW_LINE for j in range ( k - 2 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ j ] > max_var : NEW_LINE INDENT max_var = arr [ j ] NEW_LINE pos = j NEW_LINE if max_var > arr [ i ] : NEW_LINE INDENT j = pos NEW_LINE while j < k - 1 : NEW_LINE INDENT arr [ j ] = arr [ j + 1 ] NEW_LINE j += 1 NEW_LINE arr [ k - 1 ] = arr [ i ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def best_approximate ( x , y , n ) : NEW_LINE INDENT sum_x = 0 NEW_LINE sum_y = 0 NEW_LINE sum_xy = 0 NEW_LINE sum_x2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum_x += x [ i ] NEW_LINE sum_y += y [ i ] NEW_LINE sum_xy += x [ i ] * y [ i ] NEW_LINE sum_x2 += x [ i ] ** 2 NEW_LINE m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - sum_x ** 2 ) NEW_LINE c = ( sum_y - m * sum_x ) / n NEW_LINE print ( " m ▁ = ▁ " , m , sep = " " ) NEW_LINE print ( " c ▁ = ▁ " , c , sep = " " ) NEW_LINE DEDENT
def cos_x_serties_sum ( x , n ) : NEW_LINE INDENT x = x * ( math . pi / 180.0 ) NEW_LINE res = 1 NEW_LINE sign = 1 NEW_LINE fact = 1 NEW_LINE pow = 1 NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT sign = sign * - 1 NEW_LINE fact = fact * ( 2 * i - 1 ) * ( 2 * i ) NEW_LINE pow = pow * x * x NEW_LINE res = res + sign * pow / fact NEW_LINE return res NEW_LINE DEDENT
def print_array ( arr , row , col ) : NEW_LINE INDENT uset = set ( ) NEW_LINE for i in range ( row ) : NEW_LINE INDENT s = [ ] NEW_LINE for j in range ( col ) : NEW_LINE INDENT s . append ( str ( arr [ i ] [ j ] ) ) NEW_LINE if " " . join ( s ) not in uset : NEW_LINE INDENT uset . add ( " " . join ( s ) ) NEW_LINE print ( " " . join ( s ) ) NEW_LINE DEDENT DEDENT DEDENT
def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) NEW_LINE DEDENT
def count_ways ( n , k ) : NEW_LINE INDENT total = k NEW_LINE mod = 1000000007 NEW_LINE same = 0 NEW_LINE diff = k NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT same = diff NEW_LINE diff = total * ( k - 1 ) NEW_LINE diff = diff % mod NEW_LINE total = ( same + diff ) % mod NEW_LINE return total NEW_LINE DEDENT
def linear_search ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == i : NEW_LINE INDENT return i NEW_LINE return - 1 NEW_LINE DEDENT
def pad ( n ) : NEW_LINE INDENT p_prev_prev , p_prev , p_curr , p_next = 1 , 1 , 1 , 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT p_next = p_prev_prev + p_prev NEW_LINE p_prev_prev = p_prev NEW_LINE p_prev = p_curr NEW_LINE p_curr = p_next NEW_LINE return p_next NEW_LINE DEDENT
def max_level ( boxes , n ) : NEW_LINE INDENT boxes . sort ( ) NEW_LINE ans = 1 NEW_LINE prev_width = boxes [ 0 ] NEW_LINE prev_count = 1 NEW_LINE curr_count = 0 NEW_LINE curr_width = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_width += boxes [ i ] NEW_LINE curr_count += 1 NEW_LINE if curr_width > prev_width and curr_count > prev_count : NEW_LINE INDENT prev_width = curr_width NEW_LINE prev_count = curr_count NEW_LINE curr_count = 0 NEW_LINE curr_width = 0 NEW_LINE ans += 1 NEW_LINE return ans NEW_LINE DEDENT
def maximum_height ( n ) : NEW_LINE INDENT return math . floor ( - 1 + math . sqrt ( 1 + ( 8 * n ) ) ) // 2 NEW_LINE DEDENT
def compute ( graph , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if len ( graph [ i ] ) == 0 : NEW_LINE INDENT count += 1 NEW_LINE return count NEW_LINE DEDENT
def product_at_kth_level ( tree , k ) : NEW_LINE INDENT level = - 1 NEW_LINE product = 1 NEW_LINE n = len ( tree ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if tree [ i ] == ' ( ' : NEW_LINE INDENT level += 1 NEW_LINE elif tree [ i ] == ' ) ' : NEW_LINE INDENT level -= 1 NEW_LINE else : NEW_LINE INDENT if level == k : NEW_LINE INDENT product *= ( ord ( tree [ i ] ) - ord ( ' 0 ' ) ) NEW_LINE return product NEW_LINE DEDENT
def product_array ( arr , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE left = [ 0 ] * n NEW_LINE right = [ 0 ] * n NEW_LINE prod = [ 0 ] * n NEW_LINE left [ 0 ] = 1 NEW_LINE right [ n - 1 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT left [ i ] = arr [ i - 1 ] * left [ i - 1 ] NEW_LINE for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT right [ j ] = arr [ j + 1 ] * right [ j + 1 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prod [ i ] = left [ i ] * right [ i ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( prod [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def find_pairs ( arr1 , arr2 , n , m , x ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr1 [ i ] ) NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( x - arr2 [ j ] ) in s : NEW_LINE INDENT print ( x - arr2 [ j ] , " ▁ " , arr2 [ j ] , sep = " " ) NEW_LINE DEDENT DEDENT DEDENT
def sum_of_series ( n ) : NEW_LINE INDENT return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) // 3 NEW_LINE DEDENT
def print_k_distinct ( arr , size , k ) : NEW_LINE INDENT h = dict ( ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT h [ arr [ i ] ] = h . get ( arr [ i ] , 0 ) + 1 NEW_LINE if len ( h ) < k : NEW_LINE INDENT return - 1 NEW_LINE dist_count = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if h [ arr [ i ] ] > 1 : NEW_LINE INDENT dist_count += 1 NEW_LINE if dist_count == k : NEW_LINE INDENT return arr [ i ] NEW_LINE return - 1 NEW_LINE DEDENT
def min_insertion ( str_ ) : NEW_LINE INDENT n = len ( str_ ) NEW_LINE res = 0 NEW_LINE count = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( str_ [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if count [ i ] % 2 == 1 : NEW_LINE INDENT res += 1 NEW_LINE return 0 if res == 0 else res - 1 NEW_LINE DEDENT
def print_string_alternate ( string ) : NEW_LINE INDENT occ = dict ( ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT temp = string [ i ] . lower ( ) NEW_LINE occ [ temp ] = occ . get ( temp , 0 ) + 1 NEW_LINE if occ [ temp ] & 1 : NEW_LINE INDENT print ( string [ i ] , end = " " ) NEW_LINE print ( ) NEW_LINE DEDENT
def max_triplet_sum ( arr , n ) : NEW_LINE INDENT max_a = - sys . maxsize NEW_LINE max_b = - sys . maxsize NEW_LINE max_c = - sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] > max_a : NEW_LINE INDENT max_c = max_b NEW_LINE max_b = max_a NEW_LINE max_a = arr [ i ] NEW_LINE elif arr [ i ] > max_b : NEW_LINE INDENT max_c = max_b NEW_LINE max_b = arr [ i ] NEW_LINE elif arr [ i ] > max_c : NEW_LINE INDENT max_c = arr [ i ] NEW_LINE return max_a + max_b + max_c NEW_LINE DEDENT
def day_of_week ( d , m , y ) : NEW_LINE INDENT t = [ 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ] NEW_LINE y -= 1 if m < 3 else 0 NEW_LINE return ( y + y // 4 - y // 100 + y // 400 + t [ m - 1 ] + d ) % 7 NEW_LINE DEDENT
def longest_subsequence ( a , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE dp = [ 0 ] * n NEW_LINE maximum = - sys . maxsize NEW_LINE index = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] - 1 ) in mp : NEW_LINE INDENT last_index = mp [ a [ i ] - 1 ] - 1 NEW_LINE dp [ i ] = 1 + dp [ last_index ] NEW_LINE else : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE mp [ a [ i ] ] = i + 1 NEW_LINE if maximum < dp [ i ] : NEW_LINE INDENT maximum = dp [ i ] NEW_LINE index = i NEW_LINE for curr in range ( a [ index ] - maximum + 1 , a [ index ] + 1 ) : NEW_LINE INDENT print ( curr , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def is_power_of_k ( n , k ) : NEW_LINE INDENT one_seen = False NEW_LINE while n > 0 : NEW_LINE INDENT digit = n % k NEW_LINE if digit > 1 : NEW_LINE INDENT return False NEW_LINE if digit == 1 : NEW_LINE INDENT if one_seen : NEW_LINE INDENT return False NEW_LINE one_seen = True NEW_LINE n //= k NEW_LINE return True NEW_LINE DEDENT
def calculate ( a ) : NEW_LINE INDENT a . sort ( ) NEW_LINE count = 1 NEW_LINE answer = 0 NEW_LINE for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT if a [ i ] == a [ i - 1 ] : NEW_LINE INDENT count += 1 NEW_LINE else : NEW_LINE INDENT answer = answer + count * ( count - 1 ) // 2 NEW_LINE count = 1 NEW_LINE answer = answer + count * ( count - 1 ) // 2 NEW_LINE return answer NEW_LINE DEDENT
def find_index ( str_ ) : NEW_LINE INDENT len_ = len ( str_ ) NEW_LINE open = [ 0 ] * ( len_ + 1 ) NEW_LINE close = [ 0 ] * ( len_ + 1 ) NEW_LINE index = - 1 NEW_LINE open [ 0 ] = 0 NEW_LINE close [ len_ ] = 0 NEW_LINE if str_ [ 0 ] == ' ( ' : NEW_LINE INDENT open [ 1 ] = 1 NEW_LINE if str_ [ len_ - 1 ] == ' ) ' : NEW_LINE INDENT close [ len_ - 1 ] = 1 NEW_LINE for i in range ( 1 , len_ ) : NEW_LINE INDENT if str_ [ i ] == ' ( ' : NEW_LINE INDENT open [ i + 1 ] = open [ i ] + 1 NEW_LINE else : NEW_LINE INDENT open [ i + 1 ] = open [ i ] NEW_LINE for i in range ( len_ - 2 , - 1 , - 1 ) : NEW_LINE INDENT if str_ [ i ] == ' ) ' : NEW_LINE INDENT close [ i ] = close [ i + 1 ] + 1 NEW_LINE else : NEW_LINE INDENT close [ i ] = close [ i + 1 ] NEW_LINE if open [ len_ ] == 0 : NEW_LINE INDENT return len_ NEW_LINE if close [ 0 ] == 0 : NEW_LINE INDENT return 0 NEW_LINE for i in range ( len_ + 1 ) : NEW_LINE INDENT if open [ i ] == close [ i ] : NEW_LINE INDENT index = i NEW_LINE return index NEW_LINE DEDENT
def find_triplets ( arr , n ) : NEW_LINE INDENT found = True NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if arr [ i ] + arr [ j ] + arr [ k ] == 0 : NEW_LINE INDENT print ( arr [ i ] , arr [ j ] , arr [ k ] ) NEW_LINE found = True NEW_LINE if found == False : NEW_LINE INDENT print ( " ▁ not ▁ exist ▁ " ) NEW_LINE DEDENT DEDENT
def get_index_in_sorted_array ( arr , n , idx ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] < arr [ idx ] : NEW_LINE INDENT result += 1 NEW_LINE if arr [ i ] == arr [ idx ] and i < idx : NEW_LINE INDENT result += 1 NEW_LINE return result NEW_LINE DEDENT
def longest_repeated_substring ( str_ ) : NEW_LINE INDENT n = len ( str_ ) NEW_LINE lcs_re = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] NEW_LINE res = [ ] NEW_LINE res_length = 0 NEW_LINE index = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT if str_ [ i - 1 ] == str_ [ j - 1 ] and lcs_re [ i - 1 ] [ j - 1 ] < ( j - i ) : NEW_LINE INDENT lcs_re [ i ] [ j ] = lcs_re [ i - 1 ] [ j - 1 ] + 1 NEW_LINE if lcs_re [ i ] [ j ] > res_length : NEW_LINE INDENT res_length = lcs_re [ i ] [ j ] NEW_LINE index = max ( i , index ) NEW_LINE else : NEW_LINE INDENT lcs_re [ i ] [ j ] = 0 NEW_LINE if res_length > 0 : NEW_LINE INDENT for i in range ( index - res_length + 1 , index + 1 ) : NEW_LINE INDENT res = res . append ( str_ [ i - 1 ] ) NEW_LINE return " " . join ( res ) NEW_LINE DEDENT
def bubble_sort ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT swapped = False NEW_LINE for j in range ( n - i - 1 ) : NEW_LINE INDENT if arr [ j ] > arr [ j + 1 ] : NEW_LINE INDENT arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] NEW_LINE swapped = True NEW_LINE if swapped == False : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
def min_step_to_delete_string ( str_ ) : NEW_LINE INDENT n = len ( str_ ) NEW_LINE dp = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for l in range ( 1 , n + 1 ) : NEW_LINE INDENT i = 0 NEW_LINE j = l - 1 NEW_LINE while j < n : NEW_LINE INDENT if l == 1 : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] NEW_LINE if str_ [ i ] == str_ [ i + 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE for k in range ( i + 2 , j + 1 ) : NEW_LINE INDENT if str_ [ i ] == str_ [ k ] : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i + 1 ] [ k - 1 ] + dp [ k + 1 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE return dp [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def floor_search ( arr , low , high , x ) : NEW_LINE INDENT if low > high : NEW_LINE INDENT return - 1 NEW_LINE if x >= arr [ high ] : NEW_LINE INDENT return high NEW_LINE mid = ( low + high ) // 2 NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE if mid > 0 and arr [ mid - 1 ] <= x < arr [ mid ] : NEW_LINE INDENT return mid - 1 NEW_LINE if x < arr [ mid ] : NEW_LINE INDENT return floor_search ( arr , low , mid - 1 , x ) NEW_LINE return floor_search ( arr , mid + 1 , high , x ) NEW_LINE DEDENT
def are_anagram ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE if n1 != n2 : NEW_LINE INDENT return False NEW_LINE str1. sort ( ) NEW_LINE str2. sort ( ) NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if str1 [ i ] != str2 [ i ] : NEW_LINE INDENT return False NEW_LINE return True NEW_LINE DEDENT
def find_max_segment ( s , k ) : NEW_LINE INDENT seg_len = len ( s ) - k NEW_LINE res = 0 NEW_LINE for i in range ( seg_len ) : NEW_LINE INDENT res = res * 10 + ( ord ( s [ i ] ) - ord ( ' 0 ' ) ) NEW_LINE seg_len_pow = 10 ** ( seg_len - 1 ) NEW_LINE curr_val = res NEW_LINE for i in range ( 1 , len ( s ) - seg_len ) : NEW_LINE INDENT curr_val = curr_val - ( ord ( s [ i - 1 ] ) - ord ( ' 0 ' ) ) * seg_len_pow NEW_LINE curr_val = ( curr_val * 10 + ( ord ( s [ i + seg_len - 1 ] ) - ord ( ' 0 ' ) ) ) NEW_LINE res = max ( res , curr_val ) NEW_LINE return res NEW_LINE DEDENT
def rearrange_array ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE temp_arr = [ 0 ] * ( n + 1 ) NEW_LINE arr_index = 0 NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while i <= n // 2 or j > n // 2 : NEW_LINE INDENT temp_arr [ arr_index ] = arr [ i ] NEW_LINE arr_index += 1 NEW_LINE temp_arr [ arr_index ] = arr [ j ] NEW_LINE arr_index += 1 NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = temp_arr [ i ] NEW_LINE DEDENT DEDENT
def most_frequent ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE max_count = 1 NEW_LINE res = arr [ 0 ] NEW_LINE curr_count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] == arr [ i - 1 ] : NEW_LINE INDENT curr_count += 1 NEW_LINE else : NEW_LINE INDENT if curr_count > max_count : NEW_LINE INDENT max_count = curr_count NEW_LINE res = arr [ i - 1 ] NEW_LINE curr_count = 1 NEW_LINE if curr_count > max_count : NEW_LINE INDENT max_count = curr_count NEW_LINE res = arr [ n - 1 ] NEW_LINE return res NEW_LINE DEDENT
def sum_of_series ( n ) : NEW_LINE INDENT return int ( 0.6172 * ( 10 ** n - 1 ) - 0.55 * n ) NEW_LINE DEDENT
def min_sum ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE num1 = 0 NEW_LINE num2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT num1 = num1 * 10 + a [ i ] NEW_LINE else : NEW_LINE INDENT num2 = num2 * 10 + a [ i ] NEW_LINE return num2 + num1 NEW_LINE DEDENT
def perfect_square ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = - 1 NEW_LINE num = " " NEW_LINE for i in range ( 1 , ( 1 << n ) ) : NEW_LINE INDENT str_ = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( i >> j ) & 1 : NEW_LINE INDENT str_ = str_ . append ( s [ j ] ) NEW_LINE if str_ [ 0 ] != ' 0 ' : NEW_LINE INDENT temp = 0 NEW_LINE for j in range ( len ( str_ ) ) : NEW_LINE INDENT temp = ( temp * 10 + ( ord ( str_ [ j ] ) - ord ( ' 0 ' ) ) ) NEW_LINE k = int ( math . sqrt ( temp ) ) NEW_LINE if k * k == temp : NEW_LINE INDENT if ans < len ( str_ ) : NEW_LINE INDENT ans = len ( str_ ) NEW_LINE num = " " . join ( str_ ) NEW_LINE if ans == - 1 : NEW_LINE INDENT return ans NEW_LINE else : NEW_LINE INDENT print ( " num " , end = " ▁ " ) NEW_LINE return n - ans NEW_LINE DEDENT DEDENT
def check_plus_perfect ( x ) : NEW_LINE INDENT temp = x NEW_LINE n = 0 NEW_LINE while x != 0 : NEW_LINE INDENT x = x // 10 NEW_LINE n += 1 NEW_LINE x = temp NEW_LINE sum_ = 0 NEW_LINE while x != 0 : NEW_LINE INDENT sum_ += ( x % 10 ) ** n NEW_LINE x = x // 10 NEW_LINE return sum_ == temp NEW_LINE DEDENT
def check_stack_permutation ( ip , op , n ) : NEW_LINE INDENT input_ = Queue ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT input_ . put ( ip [ i ] ) NEW_LINE output = Queue ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT output . put ( op [ i ] ) NEW_LINE temp_stack = LifoQueue ( ) NEW_LINE while not input_ . empty ( ) : NEW_LINE INDENT ele = input_ . get ( ) NEW_LINE if ele == output . queue [ 0 ] : NEW_LINE INDENT output . get ( ) NEW_LINE while not temp_stack . empty ( ) : NEW_LINE INDENT if temp_stack . queue [ - 1 ] == output . queue [ 0 ] : NEW_LINE INDENT temp_stack . get ( ) NEW_LINE output . get ( ) NEW_LINE else : NEW_LINE INDENT break NEW_LINE else : NEW_LINE INDENT temp_stack . append ( ele ) NEW_LINE return input_ . empty ( ) and temp_stack . empty ( ) NEW_LINE DEDENT
def replace_spaces ( str_ ) : NEW_LINE INDENT space_count = 0 NEW_LINE i = 0 NEW_LINE for i in range ( len ( str_ ) ) : NEW_LINE INDENT if str [ i ] == ' ▁ ' : NEW_LINE INDENT space_count += 1 NEW_LINE while str [ i - 1 ] == ' ▁ ' : NEW_LINE INDENT space_count -= 1 NEW_LINE i -= 1 NEW_LINE new_length = i + space_count * 2 NEW_LINE if new_length > MAX : NEW_LINE INDENT return str_ NEW_LINE index = new_length - 1 NEW_LINE str_ = list ( str_ ) NEW_LINE for f in range ( i - 2 , new_length - 2 ) : NEW_LINE INDENT str_ . append ( ' 0 ' ) NEW_LINE for j in range ( i - 1 , 0 , - 1 ) : NEW_LINE INDENT if str_ [ j ] == ' ▁ ' : NEW_LINE INDENT str_ [ index ] = ' 0 ' NEW_LINE str_ [ index - 1 ] = ' 2 ' NEW_LINE str_ [ index - 2 ] = ' % ' NEW_LINE index = index - 3 NEW_LINE else : NEW_LINE INDENT str_ [ index ] = str_ [ j ] NEW_LINE index -= 1 NEW_LINE return " " . join ( str_ ) NEW_LINE DEDENT
def nth_palindrome ( n , k ) : NEW_LINE INDENT temp = ( k // 2 ) if k & 1 else ( k // 2 - 1 ) NEW_LINE palindrome = 10 ** temp NEW_LINE palindrome += n - 1 NEW_LINE print ( palindrome , end = " " ) NEW_LINE if k & 1 : NEW_LINE INDENT palindrome //= 10 NEW_LINE while palindrome : NEW_LINE INDENT print ( palindrome % 10 , end = " " ) NEW_LINE palindrome //= 10 NEW_LINE DEDENT DEDENT
def get_odd_occurrence ( arr , size ) : NEW_LINE INDENT hash = dict ( ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT hash [ arr [ i ] ] = hash . get ( arr [ i ] , 0 ) + 1 NEW_LINE for key , value in hash . items ( ) : NEW_LINE INDENT if value % 2 != 0 : NEW_LINE INDENT return key NEW_LINE return - 1 NEW_LINE DEDENT
def find_common ( mat ) : NEW_LINE INDENT cnt = dict ( ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT cnt [ mat [ i ] [ 0 ] ] = cnt . get ( mat [ i ] [ 0 ] , 0 ) + 1 NEW_LINE j = 1 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if mat [ i ] [ j ] != mat [ i ] [ j - 1 ] : NEW_LINE INDENT cnt [ mat [ i ] [ j ] ] = cnt . get ( mat [ i ] [ j ] , 0 ) + 1 NEW_LINE for key , value in cnt . items ( ) : NEW_LINE INDENT if value == M : NEW_LINE INDENT return key NEW_LINE return - 1 NEW_LINE DEDENT
def min_cost ( coin , n , k ) : NEW_LINE INDENT coin . sort ( ) NEW_LINE coins_needed = math . ceil ( 1.0 * n // ( k + 1 ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( coins_needed - 1 + 1 ) : NEW_LINE INDENT ans += coin [ i ] NEW_LINE return ans NEW_LINE DEDENT
def find_sum ( str1 , str2 ) : NEW_LINE INDENT if len ( str1 ) > len ( str2 ) : NEW_LINE INDENT return " " NEW_LINE str_ = [ ] NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE diff = n2 - n1 NEW_LINE carry = 0 NEW_LINE for i in range ( n1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum_ = ( ord ( str1 [ i ] ) - ord ( ' 0 ' ) ) + ( ord ( str2 [ i + diff ] ) - ord ( ' 0 ' ) ) + carry NEW_LINE str_ = str_ . append ( chr ( sum_ % 10 + ord ( ' 0 ' ) ) ) NEW_LINE carry = sum_ // 10 NEW_LINE for i in range ( n2 - n1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum_ = ( ord ( str2 [ i ] ) - ord ( ' 0 ' ) ) + carry NEW_LINE str_ = str_ . append ( chr ( sum_ % 10 + ord ( ' 0 ' ) ) ) NEW_LINE carry = sum_ // 10 NEW_LINE if carry > 0 : NEW_LINE INDENT str_ . append ( chr ( carry + ord ( ' 0 ' ) ) ) NEW_LINE str_ . reverse ( ) NEW_LINE return " " . join ( str_ ) NEW_LINE DEDENT
def find_repeat_first_n2 ( s ) : NEW_LINE INDENT p = - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == s [ j ] : NEW_LINE INDENT p = i NEW_LINE break NEW_LINE if p != - 1 : NEW_LINE INDENT break NEW_LINE return p NEW_LINE DEDENT
def unit_number ( x , y ) : NEW_LINE INDENT x = x % 10 NEW_LINE if y != 0 : NEW_LINE INDENT y = y % 4 + 4 NEW_LINE return int ( x ** y ) % 10 NEW_LINE DEDENT
def police_thief ( arr , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE thi = [ ] NEW_LINE pol = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == ' P ' : NEW_LINE INDENT pol . append ( i ) NEW_LINE elif arr [ i ] == ' T ' : NEW_LINE INDENT thi . append ( i ) NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE while l < len ( thi ) and r < len ( pol ) : NEW_LINE INDENT if abs ( thi [ l ] - pol [ r ] ) <= k : NEW_LINE INDENT res += 1 NEW_LINE l += 1 NEW_LINE r += 1 NEW_LINE elif thi [ l ] < pol [ r ] : NEW_LINE INDENT l += 1 NEW_LINE else : NEW_LINE INDENT r += 1 NEW_LINE return res NEW_LINE DEDENT
def calculate ( a , b , c , m ) : NEW_LINE INDENT res = power ( b , c , m - 1 ) NEW_LINE ans = power ( a , res , m ) NEW_LINE return ans NEW_LINE DEDENT
def number_of_ways ( x ) : NEW_LINE INDENT if x == 0 or x == 1 : NEW_LINE INDENT return 1 NEW_LINE else : NEW_LINE INDENT return number_of_ways ( x - 1 ) + ( x - 1 ) * number_of_ways ( x - 2 ) NEW_LINE DEDENT DEDENT
def unique ( mat , n , m ) : NEW_LINE INDENT maximum = 0 NEW_LINE flag = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if maximum < mat [ i ] [ j ] : NEW_LINE INDENT maximum = mat [ i ] [ j ] NEW_LINE unique_element_dict = [ 0 ] * ( maximum + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT unique_element_dict [ mat [ i ] [ j ] ] += 1 NEW_LINE for key in range ( maximum + 1 ) : NEW_LINE INDENT if unique_element_dict [ key ] == 1 : NEW_LINE INDENT print ( key , end = " ▁ " ) NEW_LINE flag = 1 NEW_LINE if flag == 0 : NEW_LINE INDENT print ( " No ▁ unique ▁ element ▁ in ▁ the ▁ matrix " ) NEW_LINE DEDENT DEDENT
def knap_sack ( w , wt , val , n ) : NEW_LINE INDENT if n == 0 or w == 0 : NEW_LINE INDENT return 0 NEW_LINE if wt [ n - 1 ] > w : NEW_LINE INDENT return knap_sack ( w , wt , val , n - 1 ) NEW_LINE else : NEW_LINE INDENT return max ( val [ n - 1 ] + knap_sack ( w - wt [ n - 1 ] , wt , val , n - 1 ) , knap_sack ( w , wt , val , n - 1 ) ) NEW_LINE DEDENT DEDENT
def count_sub_sets ( arr , n ) : NEW_LINE INDENT us = set ( ) NEW_LINE even_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT us . add ( arr [ i ] ) NEW_LINE even_count = len ( us ) NEW_LINE return 2 ** even_count - 1 NEW_LINE DEDENT
def find_subarray_sum ( arr , n , sum_ ) : NEW_LINE INDENT prev_sum = dict ( ) NEW_LINE res = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE if curr_sum == sum_ : NEW_LINE INDENT res += 1 NEW_LINE if ( curr_sum - sum_ ) in prev_sum : NEW_LINE INDENT res += prev_sum [ curr_sum - sum_ ] NEW_LINE prev_sum [ curr_sum ] = prev_sum . get ( curr_sum , 0 ) + 1 NEW_LINE return res NEW_LINE DEDENT
def summing_series ( n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s += i * i - ( i - 1 ) * ( i - 1 ) NEW_LINE return s NEW_LINE DEDENT
def shuffle_array ( a , f , l ) : NEW_LINE INDENT if l > f : NEW_LINE INDENT return NEW_LINE if l - f == 1 : NEW_LINE INDENT return NEW_LINE mid = ( f + l ) // 2 NEW_LINE temp = mid + 1 NEW_LINE mmid = ( f + mid ) // 2 NEW_LINE for i in range ( mmid + 1 , mid + 1 ) : NEW_LINE INDENT ( a [ i ] , a [ temp ] ) = ( a [ temp ] , a [ i ] ) NEW_LINE temp += 1 NEW_LINE shuffle_array ( a , f , mid ) NEW_LINE shuffle_array ( a , mid + 1 , l ) NEW_LINE DEDENT
def gcd_extended ( a , b , x , y ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT x [ 0 ] = 0 NEW_LINE y [ 0 ] = 1 NEW_LINE return b NEW_LINE x1 = [ 1 ] NEW_LINE y1 = [ 1 ] NEW_LINE gcd = gcd_extended ( b % a , a , x1 , y1 ) NEW_LINE x [ 0 ] = y1 [ 0 ] - ( b / a ) * x1 [ 0 ] NEW_LINE y [ 0 ] = x1 [ 0 ] NEW_LINE return gcd NEW_LINE DEDENT
def generate_gray_arr ( n ) : NEW_LINE INDENT if n <= 0 : NEW_LINE INDENT return NEW_LINE arr = list ( ) NEW_LINE arr . append ( " 0 " ) NEW_LINE arr . append ( " 1 " ) NEW_LINE i = 2 NEW_LINE j = 0 NEW_LINE while i < ( 1 << n ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT arr . append ( arr [ j ] ) NEW_LINE for j in range ( i ) : NEW_LINE INDENT arr [ j ] = " 0 " + arr [ j ] NEW_LINE for j in range ( i , 2 * i ) : NEW_LINE INDENT arr [ j ] = " 1 " + arr [ j ] NEW_LINE i = i << 1 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT print ( arr [ i ] ) NEW_LINE DEDENT DEDENT
def div_sum ( num ) : NEW_LINE INDENT result = 0 NEW_LINE i = 2 NEW_LINE while i <= math . sqrt ( num ) : NEW_LINE INDENT if num % i == 0 : NEW_LINE INDENT if i == num / i : NEW_LINE INDENT result += i NEW_LINE else : NEW_LINE INDENT result += i + num / i NEW_LINE i = i + 1 NEW_LINE return result + 1 NEW_LINE DEDENT
def lcis ( arr1 , n , arr2 , m ) : NEW_LINE INDENT table = [ 0 ] * m NEW_LINE for j in range ( m ) : NEW_LINE INDENT table [ j ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT current = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if arr1 [ i ] == arr2 [ j ] : NEW_LINE INDENT if current + 1 > table [ j ] : NEW_LINE INDENT table [ j ] = current + 1 NEW_LINE if arr1 [ i ] > arr2 [ j ] : NEW_LINE INDENT if table [ j ] > current : NEW_LINE INDENT current = table [ j ] NEW_LINE result = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if table [ i ] > result : NEW_LINE INDENT result = table [ i ] NEW_LINE return result NEW_LINE DEDENT
def find_3_numbers ( a , arr_size , sum_ ) : NEW_LINE INDENT for i in range ( arr_size - 1 ) : NEW_LINE INDENT s = set ( ) NEW_LINE curr_sum = sum_ - a [ i ] NEW_LINE for j in range ( i + 1 , arr_size ) : NEW_LINE INDENT if ( curr_sum - a [ j ] ) in s : NEW_LINE INDENT print ( " Triplet ▁ is ▁ { } , ▁ { } , ▁ { } " . format ( a [ i ] , a [ j ] , curr_sum - a [ j ] ) ) NEW_LINE return True NEW_LINE s . add ( a [ j ] ) NEW_LINE return False NEW_LINE DEDENT
def multiply ( num1 , num2 ) : NEW_LINE INDENT len1 = len ( num1 ) NEW_LINE len2 = len ( num2 ) NEW_LINE if len1 == 0 or len2 == 0 : NEW_LINE INDENT return " 0 " NEW_LINE result = [ 0 ] * ( len1 + len2 ) NEW_LINE i_n1 = 0 NEW_LINE i_n2 = 0 NEW_LINE for i in range ( len1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT carry = 0 NEW_LINE n1 = ord ( num1 [ i ] ) - 48 NEW_LINE i_n2 = 0 NEW_LINE for j in range ( len2 - 1 , - 1 , - 1 ) : NEW_LINE INDENT n2 = ord ( num2 [ j ] ) - 48 NEW_LINE sum_ = n1 * n2 + result [ i_n1 + i_n2 ] + carry NEW_LINE carry = sum_ // 10 NEW_LINE result [ i_n1 + i_n2 ] = sum_ % 10 NEW_LINE i_n2 += 1 NEW_LINE if carry > 0 : NEW_LINE INDENT result [ i_n1 + i_n2 ] += carry NEW_LINE i_n1 += 1 NEW_LINE i = len ( result ) - 1 NEW_LINE while i >= 0 and result [ i ] == 0 : NEW_LINE INDENT i -= 1 NEW_LINE if i == - 1 : NEW_LINE INDENT return " 0 " NEW_LINE s = " " NEW_LINE while i >= 0 : NEW_LINE INDENT s += chr ( result [ i ] + 48 ) NEW_LINE i -= 1 NEW_LINE return s NEW_LINE DEDENT
def mod_fact ( n , p ) : NEW_LINE INDENT if n >= p : NEW_LINE INDENT return 0 NEW_LINE result = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT result = ( result * i ) % p NEW_LINE return result NEW_LINE DEDENT
def sort_string ( str_ ) : NEW_LINE INDENT char_count = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( len ( str_ ) ) : NEW_LINE INDENT char_count [ ord ( str_ [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE for i in range ( MAX_CHAR - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( char_count [ i ] ) : NEW_LINE INDENT print ( chr ( 97 + i ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def count_fact ( low , high ) : NEW_LINE INDENT fact = 1 NEW_LINE x = 1 NEW_LINE while fact < low : NEW_LINE INDENT fact = fact * x NEW_LINE x += 1 NEW_LINE res = 0 NEW_LINE while fact <= high : NEW_LINE INDENT res += 1 NEW_LINE fact = fact * x NEW_LINE x += 1 NEW_LINE return res NEW_LINE DEDENT
def area_of_segment ( radius , angle ) : NEW_LINE INDENT area_of_sector = math . pi * ( radius * radius ) * ( angle / 360 ) NEW_LINE area_of_triangle = 1 / 2 * ( radius * radius ) * math . sin ( ( angle * math . pi ) / 180 ) NEW_LINE return area_of_sector - area_of_triangle NEW_LINE DEDENT
def print_prev_smaller ( arr , n ) : NEW_LINE INDENT s = LifoQueue ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT while not s . empty ( ) and s [ - 1 ] >= arr [ i ] : NEW_LINE INDENT s . get ( ) NEW_LINE if s . empty ( ) : NEW_LINE INDENT print ( " _ , ▁ " , end = " " ) NEW_LINE else : NEW_LINE INDENT print ( s [ - 1 ] , end = " , ▁ " ) NEW_LINE s . put ( arr [ i ] ) NEW_LINE DEDENT DEDENT
def check_star ( mat ) : NEW_LINE INDENT vertex_d1 = 0 NEW_LINE vertex_dn_1 = 0 NEW_LINE if arr_size == 1 : NEW_LINE INDENT return ( mat [ 0 ] [ 0 ] == 0 ) NEW_LINE if arr_size == 2 : NEW_LINE INDENT return ( mat [ 0 ] [ 0 ] == 0 and mat [ 0 ] [ 1 ] == 1 and mat [ 1 ] [ 0 ] == 1 and mat [ 1 ] [ 1 ] == 0 ) NEW_LINE for i in range ( arr_size ) : NEW_LINE INDENT degree_i = 0 NEW_LINE for j in range ( arr_size ) : NEW_LINE INDENT if mat [ i ] [ j ] : NEW_LINE INDENT degree_i += 1 NEW_LINE if degree_i == 1 : NEW_LINE INDENT vertex_d1 += 1 NEW_LINE elif degree_i == arr_size - 1 : NEW_LINE INDENT vertex_dn_1 += 1 NEW_LINE return vertex_d1 == ( arr_size - 1 ) and vertex_dn_1 == 1 NEW_LINE DEDENT
def compute_totient ( n ) : NEW_LINE INDENT phi = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT phi [ i ] = i NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if phi [ p ] == p : NEW_LINE INDENT phi [ p ] = p - 1 NEW_LINE for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT phi [ i ] = ( phi [ i ] // p ) * ( p - 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( " Totient ▁ of ▁ " , i , " ▁ is ▁ " , phi [ i ] ) NEW_LINE DEDENT DEDENT
def find_index ( n ) : NEW_LINE INDENT fibo = 2.078087 * math . log ( n ) + 1.672276 NEW_LINE return round ( fibo ) NEW_LINE DEDENT
def mid_point ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT dx = x2 - x1 NEW_LINE dy = y2 - y1 NEW_LINE d = dy - ( dx / 2 ) NEW_LINE x = x1 NEW_LINE y = y1 NEW_LINE print ( x , " , " , y , sep = " " ) NEW_LINE while x < x2 : NEW_LINE INDENT x += 1 NEW_LINE if d < 0 : NEW_LINE INDENT d = d + dy NEW_LINE else : NEW_LINE INDENT d = d + ( dy - dx ) NEW_LINE y = y + 1 NEW_LINE print ( x , " , " , y , sep = " " ) NEW_LINE DEDENT DEDENT
def is_possible ( n , index , sum_ , m , arr , dp ) : NEW_LINE INDENT if index == n : NEW_LINE INDENT if ( sum_ % m ) == 0 : NEW_LINE INDENT return True NEW_LINE return False NEW_LINE elif sum < 0 or sum >= MAX : NEW_LINE INDENT return False NEW_LINE if dp [ index ] [ sum_ ] != - 1 : NEW_LINE INDENT return dp [ index ] [ sum_ ] NEW_LINE place_add = is_possible ( n , index + 1 , sum_ + arr [ index ] , m , arr , dp ) NEW_LINE place_minus = is_possible ( n , index + 1 , sum_ - arr [ index ] , m , arr , dp ) NEW_LINE res = place_add or place_minus NEW_LINE dp [ index ] [ sum_ ] = res NEW_LINE return res NEW_LINE DEDENT
def rearrange_arr ( arr , n ) : NEW_LINE INDENT even_pos = n // 2 NEW_LINE odd_pos = n - even_pos NEW_LINE temp_arr = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp_arr [ i ] = arr [ i ] NEW_LINE temp_arr . sort ( ) NEW_LINE j = odd_pos - 1 NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT arr [ i ] = temp_arr [ j ] NEW_LINE j = j - 1 NEW_LINE j = odd_pos NEW_LINE for i in range ( 1 , n , 2 ) : NEW_LINE INDENT arr [ i ] = temp_arr [ j ] NEW_LINE j = j + 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def print_first_negative_integer ( arr , n , k ) : NEW_LINE INDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT flag = False NEW_LINE for j in range ( k ) : NEW_LINE INDENT if arr [ i + j ] < 0 : NEW_LINE INDENT print ( arr [ i + j ] , end = " ▁ " ) NEW_LINE flag = True NEW_LINE break NEW_LINE if not ( flag ) : NEW_LINE INDENT print ( " 0 " , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def sort_string ( str_ ) : NEW_LINE INDENT temp_array = list ( str_ ) NEW_LINE temp_array . sort ( ) NEW_LINE return NEW_LINE DEDENT
def pair_wise_consecutive ( s ) : NEW_LINE INDENT aux = LifoQueue ( ) NEW_LINE while not s . empty ( ) : NEW_LINE INDENT aux . put ( s [ - 1 ] ) NEW_LINE s . get ( ) NEW_LINE result = True NEW_LINE while not s . empty ( ) : NEW_LINE INDENT x = aux . queue [ - 1 ] NEW_LINE aux . get ( ) NEW_LINE y = aux . queue [ - 1 ] NEW_LINE aux . get ( ) NEW_LINE if abs ( x - y ) != 1 : NEW_LINE INDENT result = False NEW_LINE s . put ( x ) NEW_LINE s . put ( y ) NEW_LINE if aux . qsize ( ) == 1 : NEW_LINE INDENT s . put ( aux . queue [ - 1 ] ) NEW_LINE return result NEW_LINE DEDENT
def next_greater ( str_ ) : NEW_LINE INDENT num = list ( str_ ) NEW_LINE l = len ( str_ ) NEW_LINE i = l - 1 NEW_LINE for i in range ( l - 1 , - 1 , - 1 ) : NEW_LINE INDENT if num [ i ] == ' 0 ' : NEW_LINE INDENT num [ i ] = ' 1 ' NEW_LINE break NEW_LINE else : NEW_LINE INDENT num [ i ] = ' 0 ' NEW_LINE if i < 0 : NEW_LINE INDENT num . insert ( 0 , ' 1 ' ) NEW_LINE return " " . join ( num ) NEW_LINE DEDENT
def restore_tree ( start , end ) : NEW_LINE INDENT identity = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT identity [ start [ i ] ] = i NEW_LINE parent = [ - 1 ] * N NEW_LINE curr_parent = identity [ 0 ] NEW_LINE for j in range ( 1 , N ) : NEW_LINE INDENT child = identity [ j ] NEW_LINE if end [ child ] - j > 1 : NEW_LINE INDENT parent [ child ] = curr_parent NEW_LINE curr_parent = child NEW_LINE else : NEW_LINE INDENT parent [ child ] = curr_parent NEW_LINE while end [ child ] == end [ parent [ child ] ] : NEW_LINE INDENT child = parent [ child ] NEW_LINE curr_parent = parent [ child ] NEW_LINE if curr_parent == identity [ 0 ] : NEW_LINE INDENT break NEW_LINE for i in range ( N ) : NEW_LINE INDENT parent [ i ] += 1 NEW_LINE return parent NEW_LINE DEDENT
def print_pascal ( n ) : NEW_LINE INDENT for line in range ( 1 , n + 1 ) : NEW_LINE INDENT c = 1 NEW_LINE for i in range ( 1 , line + 1 ) : NEW_LINE INDENT print ( c , end = " ▁ " ) NEW_LINE c = c * ( line - i ) // i NEW_LINE print ( ) NEW_LINE DEDENT DEDENT
def max_sum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum_ = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum_ += arr [ i ] * i NEW_LINE return sum_ NEW_LINE DEDENT
def subset_difference ( n ) : NEW_LINE INDENT s = n * ( n + 1 ) // 2 NEW_LINE if n % 4 == 0 : NEW_LINE INDENT print ( " First ▁ subset ▁ sum ▁ = ▁ " , s // 2 ) NEW_LINE print ( " Second ▁ subset ▁ sum ▁ = ▁ " , s // 2 ) NEW_LINE print ( " Difference ▁ = ▁ " , 0 ) NEW_LINE else : NEW_LINE INDENT if n % 4 == 1 or n % 4 == 2 : NEW_LINE INDENT print ( " First ▁ subset ▁ sum ▁ = ▁ " , s // 2 ) NEW_LINE print ( " Second ▁ subset ▁ sum ▁ = ▁ " , s // 2 + 1 ) NEW_LINE print ( " Difference ▁ = ▁ " , 1 ) NEW_LINE else : NEW_LINE INDENT print ( " First ▁ subset ▁ sum ▁ = ▁ " , s // 2 ) NEW_LINE print ( " Second ▁ subset ▁ sum ▁ = ▁ " , s // 2 ) NEW_LINE print ( " Difference ▁ = ▁ " , 0 ) NEW_LINE DEDENT DEDENT DEDENT
def is_reversible ( str_ ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( str_ ) - 1 NEW_LINE while i < j : NEW_LINE INDENT if str_ [ i ] != str_ [ j ] : NEW_LINE INDENT return False NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE return True NEW_LINE DEDENT
def get_parity ( n ) : NEW_LINE INDENT parity = 0 NEW_LINE while n : NEW_LINE INDENT parity = not parity NEW_LINE n = n & ( n - 1 ) NEW_LINE return parity NEW_LINE DEDENT
def max_repeating ( str_ ) : NEW_LINE INDENT len_ = len ( str_ ) NEW_LINE count = 0 NEW_LINE res = str_ [ 0 ] NEW_LINE for i in range ( len_ ) : NEW_LINE INDENT cur_count = 1 NEW_LINE for j in range ( i + 1 , len_ ) : NEW_LINE INDENT if str_ [ i ] != str_ [ j ] : NEW_LINE INDENT break NEW_LINE cur_count += 1 NEW_LINE if cur_count > count : NEW_LINE INDENT count = cur_count NEW_LINE res = str_ [ i ] NEW_LINE return res NEW_LINE DEDENT
def seires_sum ( n , a ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 2 * n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT res += a [ i ] * a [ i ] NEW_LINE else : NEW_LINE INDENT res -= a [ i ] * a [ i ] NEW_LINE return res NEW_LINE DEDENT
def print_two_elements ( arr , size ) : NEW_LINE INDENT print ( " The ▁ repeating ▁ element ▁ is " , end = " " ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if arr [ abs ( arr [ i ] ) - 1 ] > 0 : NEW_LINE INDENT arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] NEW_LINE else : NEW_LINE INDENT print ( abs ( arr [ i ] ) ) NEW_LINE print ( " and ▁ the ▁ missing ▁ element ▁ is " , end = " " ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT print ( i + 1 ) NEW_LINE DEDENT DEDENT DEDENT
def is_sub_sequence ( str1 , str2 , m , n ) : NEW_LINE INDENT j = 0 NEW_LINE i = 0 NEW_LINE while j < m and i < n : NEW_LINE INDENT if str1 [ j ] == str2 [ i ] : NEW_LINE INDENT j = j + 1 NEW_LINE i = i + 1 NEW_LINE return j == m NEW_LINE DEDENT
def sieve_of_sundaram ( n ) : NEW_LINE INDENT n_new = ( n - 2 ) // 2 NEW_LINE marked = [ False ] * ( n_new + 1 ) NEW_LINE for i in range ( 1 , n_new + 1 ) : NEW_LINE INDENT j = i NEW_LINE while ( i + j + 2 * i * j ) <= n_new : NEW_LINE INDENT marked [ i + j + 2 * i * j ] = True NEW_LINE j += 1 NEW_LINE if n > 2 : NEW_LINE INDENT print ( 2 , end = " ▁ " ) NEW_LINE for i in range ( 1 , n_new + 1 ) : NEW_LINE INDENT if marked [ i ] == False : NEW_LINE INDENT print ( ( 2 * i + 1 ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def find_twoscomplement ( s ) : NEW_LINE INDENT str_ = list ( s ) NEW_LINE n = len ( str_ ) NEW_LINE i = n - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if str_ [ i ] == ' 1 ' : NEW_LINE INDENT break NEW_LINE if i == - 1 : NEW_LINE INDENT return " 1 " + " " . join ( str_ ) NEW_LINE k = i - 1 NEW_LINE for k in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if str_ [ k ] == ' 1 ' : NEW_LINE INDENT str_ [ k ] = ' 0 ' NEW_LINE else : NEW_LINE INDENT str_ [ k ] = ' 1 ' NEW_LINE return " " . join ( str_ ) NEW_LINE DEDENT
def smallest_sub_with_sum ( arr , n , x ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE min_len = n + 1 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE while end < n : NEW_LINE INDENT while curr_sum <= x and end < n : NEW_LINE INDENT curr_sum += arr [ end ] NEW_LINE end += 1 NEW_LINE while curr_sum > x and start < n : NEW_LINE INDENT if end - start < min_len : NEW_LINE INDENT min_len = end - start NEW_LINE curr_sum -= arr [ start ] NEW_LINE start += 1 NEW_LINE return min_len NEW_LINE DEDENT
def circumference ( l , w ) : NEW_LINE INDENT return 2 * ( l + w ) NEW_LINE DEDENT
def sort_string ( str_ ) : NEW_LINE INDENT arr = list ( str_ ) NEW_LINE arr . sort ( ) NEW_LINE print ( " " . join ( arr ) ) NEW_LINE DEDENT
def count_pair ( a , b ) : NEW_LINE INDENT s = str ( b ) NEW_LINE i = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] != ' 9 ' : NEW_LINE INDENT break NEW_LINE result = 0 NEW_LINE if i == len ( s ) : NEW_LINE INDENT result = a * len ( s ) NEW_LINE else : NEW_LINE INDENT result = a * ( len ( s ) - 1 ) NEW_LINE return result NEW_LINE DEDENT
def min_operations ( str_ , n ) : NEW_LINE INDENT last_upper = - 1 NEW_LINE first_lower = - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if str_ [ i ] . isupper ( ) : NEW_LINE INDENT last_upper = i NEW_LINE break NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str_ [ i ] . islower ( ) : NEW_LINE INDENT first_lower = i NEW_LINE break NEW_LINE if last_upper == - 1 or first_lower == - 1 : NEW_LINE INDENT return 0 NEW_LINE count_upper = 0 NEW_LINE for i in range ( first_lower , n ) : NEW_LINE INDENT if str_ [ i ] . isupper ( ) : NEW_LINE INDENT count_upper += 1 NEW_LINE count_lower = 0 NEW_LINE for i in range ( last_upper ) : NEW_LINE INDENT if str_ [ i ] . islower ( ) : NEW_LINE INDENT count_lower += 1 NEW_LINE return min ( count_lower , count_upper ) NEW_LINE DEDENT
def find_smallest ( arr , n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] <= res : NEW_LINE INDENT res = res + arr [ i ] NEW_LINE else : NEW_LINE INDENT break NEW_LINE return res NEW_LINE DEDENT
def print_max_of_min ( arr , n ) : NEW_LINE INDENT s = LifoQueue ( ) NEW_LINE left = [ - 1 ] * ( n + 1 ) NEW_LINE right = [ n ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT while not s . empty ( ) and arr [ s . queue [ - 1 ] ] >= arr [ i ] : NEW_LINE INDENT s . get ( ) NEW_LINE if not s . empty ( ) : NEW_LINE INDENT left [ i ] = s . queue [ - 1 ] NEW_LINE s . put ( i ) NEW_LINE while not s . empty ( ) : NEW_LINE INDENT s . get ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT while not s . empty ( ) and arr [ s . queue [ - 1 ] ] >= arr [ i ] : NEW_LINE INDENT s . get ( ) NEW_LINE if not s . empty ( ) : NEW_LINE INDENT right [ i ] = s . queue [ - 1 ] NEW_LINE s . put ( i ) NEW_LINE ans = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT ans [ i ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT len_ = right [ i ] - left [ i ] - 1 NEW_LINE ans [ len_ ] = max ( ans [ len_ ] , arr [ i ] ) NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT ans [ i ] = max ( ans [ i ] , ans [ i + 1 ] ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) NEW_LINE DEDENT
def add ( x , y ) : NEW_LINE INDENT while y != 0 : NEW_LINE INDENT carry = x & y NEW_LINE x = x ^ y NEW_LINE y = carry << 1 NEW_LINE return x NEW_LINE DEDENT
def reverse_spiral_print ( m , n , a ) : NEW_LINE INDENT b = [ 0 ] * 100 NEW_LINE k = 0 NEW_LINE l = 0 NEW_LINE z = 0 NEW_LINE size = m * n NEW_LINE while k < m and l < n : NEW_LINE INDENT val = 0 NEW_LINE for i in range ( l , n ) : NEW_LINE INDENT val = a [ k ] [ i ] NEW_LINE b [ z ] = val NEW_LINE z += 1 NEW_LINE k += 1 NEW_LINE for i in range ( k , m ) : NEW_LINE INDENT val = a [ i ] [ n - 1 ] NEW_LINE b [ z ] = val NEW_LINE z += 1 NEW_LINE n -= 1 NEW_LINE if k < m : NEW_LINE INDENT for i in range ( n - 1 , l - 1 , - 1 ) : NEW_LINE INDENT val = a [ m - 1 ] [ i ] NEW_LINE b [ z ] = val NEW_LINE z += 1 NEW_LINE m -= 1 NEW_LINE if l < n : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT val = a [ i ] [ l ] NEW_LINE b [ z ] = val NEW_LINE z += 1 NEW_LINE l += 1 NEW_LINE for i in range ( size - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( b [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def maximum_height ( a , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT y = ( i * ( i + 1 ) ) // 2 NEW_LINE if y < n : NEW_LINE INDENT result = i NEW_LINE else : NEW_LINE INDENT break NEW_LINE return result NEW_LINE DEDENT
def pair_in_sorted_rotated ( arr , n , x ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT break NEW_LINE l = ( i + 1 ) % n NEW_LINE r = i NEW_LINE while l != r : NEW_LINE INDENT if arr [ l ] + arr [ r ] == x : NEW_LINE INDENT return True NEW_LINE if arr [ l ] + arr [ r ] < x : NEW_LINE INDENT l = ( l + 1 ) % n NEW_LINE else : NEW_LINE INDENT r = ( n + r - 1 ) % n NEW_LINE return False NEW_LINE DEDENT
def max_sub_array_sum ( a , size ) : NEW_LINE INDENT max_so_far = a [ 0 ] NEW_LINE curr_max = a [ 0 ] NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT curr_max = max ( a [ i ] , curr_max + a [ i ] ) NEW_LINE max_so_far = max ( max_so_far , curr_max ) NEW_LINE return max_so_far NEW_LINE DEDENT
def min_operation ( a , n , k ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] != 1 and a [ i ] > k : NEW_LINE INDENT result = result + min ( a [ i ] % k , k - a [ i ] % k ) NEW_LINE else : NEW_LINE INDENT result = result + k - a [ i ] NEW_LINE return result NEW_LINE DEDENT
def min_elements ( arr , n ) : NEW_LINE INDENT half_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT half_sum = half_sum + arr [ i ] NEW_LINE half_sum = half_sum // 2 NEW_LINE arr . sort ( reverse = True ) NEW_LINE res = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE res += 1 NEW_LINE if curr_sum > half_sum : NEW_LINE INDENT return res NEW_LINE return res NEW_LINE DEDENT
def area_of_inscribed_circle ( a ) : NEW_LINE INDENT return ( math . pi / 4 ) * a * a NEW_LINE DEDENT
def max_sub_array_sum ( a , size ) : NEW_LINE INDENT max_so_far = - sys . maxsize NEW_LINE max_ending_here = 0 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE s = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here += a [ i ] NEW_LINE if max_so_far < max_ending_here : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE start = s NEW_LINE end = i NEW_LINE if max_ending_here < 0 : NEW_LINE INDENT max_ending_here = 0 NEW_LINE s = i + 1 NEW_LINE print ( " Maximum ▁ contiguous ▁ sum ▁ is ▁ " , max_so_far , sep = " " ) NEW_LINE print ( " Starting ▁ Index ▁ " , start , sep = " " ) NEW_LINE print ( " Ending ▁ Index ▁ " , nd , sep = " " ) NEW_LINE DEDENT
def subset_graph ( c ) : NEW_LINE INDENT vertices = SortedSet ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT vertices . add ( i ) NEW_LINE while len ( vertices ) != 0 : NEW_LINE INDENT if len ( vertices ) == 1 : NEW_LINE INDENT return 1 NEW_LINE someone_removed = False NEW_LINE for x in vertices : NEW_LINE INDENT values = SortedSet ( ) NEW_LINE for y in vertices : NEW_LINE INDENT if y != x : NEW_LINE INDENT values . add ( c [ x ] [ y ] ) NEW_LINE if len ( values ) == 1 : NEW_LINE INDENT vertices . remove ( x ) NEW_LINE someone_removed = True NEW_LINE break NEW_LINE if not someone_removed : NEW_LINE INDENT break NEW_LINE return len ( vertices ) NEW_LINE DEDENT
def max_xor ( mat , n ) : NEW_LINE INDENT max_xor = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT r_xor = 0 NEW_LINE c_xor = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT r_xor = r_xor ^ mat [ i ] [ j ] NEW_LINE c_xor = c_xor ^ mat [ j ] [ i ] NEW_LINE if max_xor < max ( r_xor , c_xor ) : NEW_LINE INDENT max_xor = max ( r_xor , c_xor ) NEW_LINE return max_xor NEW_LINE DEDENT
def count_subsequences ( s ) : NEW_LINE INDENT a_count = 0 NEW_LINE b_count = 0 NEW_LINE c_count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' a ' : NEW_LINE INDENT a_count = 1 + 2 * a_count NEW_LINE elif s [ i ] == ' b ' : NEW_LINE INDENT b_count = a_count + 2 * b_count NEW_LINE elif s [ i ] == ' c ' : NEW_LINE INDENT c_count = b_count + 2 * c_count NEW_LINE return c_count NEW_LINE DEDENT
def maximum_chars ( str_ ) : NEW_LINE INDENT n = len ( str_ ) NEW_LINE res = - 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if str_ [ i ] == str_ [ j ] : NEW_LINE INDENT res = max ( res , abs ( j - i - 1 ) ) NEW_LINE return res NEW_LINE DEDENT
def print_roots ( n ) : NEW_LINE INDENT theta = math . pi * 2 / n NEW_LINE for k in range ( n ) : NEW_LINE INDENT real = math . cos ( k * theta ) NEW_LINE img = math . sin ( k * theta ) NEW_LINE print ( real ) NEW_LINE if img >= 0 : NEW_LINE INDENT print ( " ▁ + ▁ i ▁ " , end = " " ) NEW_LINE else : NEW_LINE INDENT print ( " ▁ - ▁ i ▁ " , end = " " ) NEW_LINE print ( abs ( img ) ) NEW_LINE DEDENT DEDENT
def sieve_of_atkin ( limit ) : NEW_LINE INDENT if limit > 2 : NEW_LINE INDENT print ( 2 , end = " ▁ " ) NEW_LINE if limit > 3 : NEW_LINE INDENT print ( 3 , end = " ▁ " ) NEW_LINE sieve = [ False ] * limit NEW_LINE x = 1 NEW_LINE while x * x < limit : NEW_LINE INDENT y = 1 NEW_LINE while y * y < limit : NEW_LINE INDENT n = ( 4 * x * x ) + ( y * y ) NEW_LINE if n <= limit and ( n % 12 == 1 or n % 12 == 5 ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE n = ( 3 * x * x ) + ( y * y ) NEW_LINE if n <= limit and n % 12 == 7 : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE n = ( 3 * x * x ) - ( y * y ) NEW_LINE if x > y and n <= limit and n % 12 == 11 : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE y += 1 NEW_LINE x += 1 NEW_LINE r = 5 NEW_LINE while r * r < limit : NEW_LINE INDENT if sieve [ r ] : NEW_LINE INDENT for i in range ( r * r , limit , r * r ) : NEW_LINE INDENT sieve [ i ] = False NEW_LINE for a in range ( 5 , limit ) : NEW_LINE INDENT if sieve [ a ] : NEW_LINE INDENT print ( a , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def smallest_k_freq ( arr , n , k ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE res = sys . maxsize NEW_LINE res1 = sys . maxsize NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT if value == k : NEW_LINE INDENT res = min ( res , key ) NEW_LINE return res if res != res1 else - 1 NEW_LINE DEDENT
def minimum_flip ( mat , n ) : NEW_LINE INDENT transpose = [ [ 0 ] * n for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT transpose [ i ] [ j ] = mat [ j ] [ i ] NEW_LINE flip = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if transpose [ i ] [ j ] != mat [ i ] [ j ] : NEW_LINE INDENT flip += 1 NEW_LINE return flip // 2 NEW_LINE DEDENT
def min_abs_sum_pair ( arr , arr_size ) : NEW_LINE INDENT inv_count = 0 NEW_LINE if arr_size < 2 : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE return NEW_LINE min_l = 0 NEW_LINE min_r = 1 NEW_LINE min_sum = arr [ 0 ] + arr [ 1 ] NEW_LINE for l in range ( arr_size - 1 ) : NEW_LINE INDENT for r in range ( l + 1 , arr_size ) : NEW_LINE INDENT sum_ = arr [ l ] + arr [ r ] NEW_LINE if abs ( min_sum ) > abs ( sum_ ) : NEW_LINE INDENT min_sum = sum_ NEW_LINE min_l = l NEW_LINE min_r = r NEW_LINE print ( " The ▁ two ▁ elements ▁ whose ▁ sum ▁ is ▁ minimum ▁ are " , arr [ min_l ] , " and ▁ " , arr [ min_r ] ) NEW_LINE DEDENT
def max_product ( arr , n ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT print ( " No ▁ pairs ▁ exists " ) NEW_LINE return NEW_LINE a = arr [ 0 ] NEW_LINE b = arr [ 1 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] * arr [ j ] > a * b : NEW_LINE INDENT a = arr [ i ] NEW_LINE b = arr [ j ] NEW_LINE print ( " Max ▁ product ▁ pair ▁ is ▁ { " , a , " , " , b , " } " , sep = " " ) NEW_LINE DEDENT
def page_faults ( pages , n , capacity ) : NEW_LINE INDENT s = set ( ) NEW_LINE indexes = Queue ( ) NEW_LINE page_faults = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if len ( s ) < capacity : NEW_LINE INDENT if pages [ i ] not in s : NEW_LINE INDENT s . add ( pages [ i ] ) NEW_LINE page_faults += 1 NEW_LINE indexes . put ( pages [ i ] ) NEW_LINE else : NEW_LINE INDENT if pages [ i ] not in s : NEW_LINE INDENT val = indexes . queue [ 0 ] NEW_LINE indexes . get ( ) NEW_LINE s . remove ( val ) NEW_LINE s . add ( pages [ i ] ) NEW_LINE indexes . put ( pages [ i ] ) NEW_LINE page_faults += 1 NEW_LINE return page_faults NEW_LINE DEDENT
def next_fit ( weight , n , c ) : NEW_LINE INDENT res = 0 NEW_LINE bin_rem = c NEW_LINE for i in range ( n ) : NEW_LINE INDENT if weight [ i ] > bin_rem : NEW_LINE INDENT res += 1 NEW_LINE bin_rem = c - weight [ i ] NEW_LINE else : NEW_LINE INDENT bin_rem -= weight [ i ] NEW_LINE return res NEW_LINE DEDENT
def count_pairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE while l < m and r >= 0 : NEW_LINE INDENT if ( arr1 [ l ] + arr2 [ r ] ) == x : NEW_LINE INDENT l += 1 NEW_LINE r -= 1 NEW_LINE count += 1 NEW_LINE elif ( arr1 [ l ] + arr2 [ r ] ) < x : NEW_LINE INDENT l += 1 NEW_LINE else : NEW_LINE INDENT r -= 1 NEW_LINE return count NEW_LINE DEDENT
def circumference_parallelogram ( a , b ) : NEW_LINE INDENT return ( 2 * a ) + ( 2 * b ) NEW_LINE DEDENT
def print ( n , k ) : NEW_LINE INDENT rem = 1 NEW_LINE for i in range ( k ) : NEW_LINE INDENT print ( ( 10 * rem ) // n , end = " " ) NEW_LINE rem = ( 10 * rem ) % n NEW_LINE DEDENT DEDENT
def find_string ( n , k ) : NEW_LINE INDENT res = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT res . append ( chr ( ord ( ' a ' ) + i ) ) NEW_LINE count = 0 NEW_LINE for i in range ( n - k ) : NEW_LINE INDENT res . append ( chr ( ord ( ' a ' ) + count ) ) NEW_LINE count += 1 NEW_LINE if count == k : NEW_LINE INDENT count = 0 NEW_LINE return res NEW_LINE DEDENT
def check_for_sorting ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT if arr [ i ] - arr [ i + 1 ] == 1 : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE else : NEW_LINE INDENT return False NEW_LINE return True NEW_LINE DEDENT
def round ( n ) : NEW_LINE INDENT a = ( n // 10 ) * 10 NEW_LINE b = a + 10 NEW_LINE return b if n - a > b - n else a NEW_LINE DEDENT
def get_remainder ( num , divisor ) : NEW_LINE INDENT if divisor == 0 : NEW_LINE INDENT print ( " Error : ▁ divisor ▁ can ' t ▁ be ▁ zero ▁ " ) NEW_LINE return - 1 NEW_LINE if divisor < 0 : NEW_LINE INDENT divisor = - divisor NEW_LINE if num < 0 : NEW_LINE INDENT num = - num NEW_LINE i = 1 NEW_LINE product = 0 NEW_LINE while product <= num : NEW_LINE INDENT product = divisor * i NEW_LINE i += 1 NEW_LINE return num - ( product - divisor ) NEW_LINE DEDENT
def unit_digit_x_raised_y ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( y ) : NEW_LINE INDENT res = ( res * x ) % 10 NEW_LINE return res NEW_LINE DEDENT
def cost_to_balance ( s ) : NEW_LINE INDENT if len ( s ) == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE ans = 0 NEW_LINE o = 0 NEW_LINE c = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' ( ' : NEW_LINE INDENT o += 1 NEW_LINE if s [ i ] == ' ) ' : NEW_LINE INDENT c += 1 NEW_LINE if o != c : NEW_LINE INDENT return - 1 NEW_LINE a = [ 0 ] * len ( s ) NEW_LINE if s [ 0 ] == ' ( ' : NEW_LINE INDENT a [ 0 ] = 1 NEW_LINE else : NEW_LINE INDENT a [ 0 ] = - 1 NEW_LINE if a [ 0 ] < 0 : NEW_LINE INDENT ans += abs ( a [ 0 ] ) NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' ( ' : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + 1 NEW_LINE else : NEW_LINE INDENT a [ i ] = a [ i - 1 ] - 1 NEW_LINE if a [ i ] < 0 : NEW_LINE INDENT ans += abs ( a [ i ] ) NEW_LINE return ans NEW_LINE DEDENT
def max_sub_array_sum ( a , size ) : NEW_LINE INDENT max_so_far = - sys . maxsize NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if max_so_far < max_ending_here : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE if max_ending_here < 0 : NEW_LINE INDENT max_ending_here = 0 NEW_LINE return max_so_far NEW_LINE DEDENT
def count_sub ( arr , n ) : NEW_LINE INDENT count = [ 0 ] * 10 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( arr [ i ] - 1 , - 1 , - 1 ) : NEW_LINE INDENT count [ arr [ i ] ] += count [ j ] NEW_LINE count [ arr [ i ] ] += 1 NEW_LINE result = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT result += count [ i ] NEW_LINE return result NEW_LINE DEDENT
def count_min_reversals ( expr ) : NEW_LINE INDENT len_ = len ( expr ) NEW_LINE if len_ % 2 : NEW_LINE INDENT return - 1 NEW_LINE s = LifoQueue ( ) NEW_LINE for i in range ( len_ ) : NEW_LINE INDENT if expr [ i ] == ' } ' and not s . empty ( ) : NEW_LINE INDENT if s . queue [ - 1 ] == ' { ' : NEW_LINE INDENT s . get ( ) NEW_LINE else : NEW_LINE INDENT s . put ( expr [ i ] ) NEW_LINE else : NEW_LINE INDENT s . put ( expr [ i ] ) NEW_LINE red_len = s . qsize ( ) NEW_LINE n = 0 NEW_LINE while not s . empty ( ) and s . queue [ - 1 ] == ' { ' : NEW_LINE INDENT s . get ( ) NEW_LINE n += 1 NEW_LINE return red_len // 2 + n % 2 NEW_LINE DEDENT
def print_pairs ( arr , n , k ) : NEW_LINE INDENT is_pair_found = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if i != j and arr [ i ] % arr [ j ] == k : NEW_LINE INDENT print ( " ( " , arr [ i ] , " , ▁ " , arr [ j ] , " ) " , sep = " " , end = " ▁ " ) NEW_LINE is_pair_found = True NEW_LINE return is_pair_found NEW_LINE DEDENT
def find_repeat_first ( s ) : NEW_LINE INDENT p = - 1 NEW_LINE hash = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE pos = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT k = ord ( s [ i ] ) NEW_LINE if hash [ k ] == 0 : NEW_LINE INDENT hash [ k ] += 1 NEW_LINE pos [ k ] = i NEW_LINE elif hash [ k ] == 1 : NEW_LINE INDENT hash [ k ] += 1 NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if hash [ i ] == 2 : NEW_LINE INDENT if p == - 1 : NEW_LINE INDENT p = pos [ i ] NEW_LINE elif p > pos [ i ] : NEW_LINE INDENT p = pos [ i ] NEW_LINE return p NEW_LINE DEDENT
def count_set_bits_rec ( num ) : NEW_LINE INDENT nibble = 0 NEW_LINE if 0 == num : NEW_LINE INDENT return num_to_bits [ 0 ] NEW_LINE nibble = num & 0xf NEW_LINE return num_to_bits [ nibble ] + count_set_bits_rec ( num >> 4 ) NEW_LINE DEDENT
def get_sum ( n ) : NEW_LINE INDENT sum_ = 0 NEW_LINE while n > 0 : NEW_LINE INDENT sum_ += n % 10 NEW_LINE n = n // 10 NEW_LINE return sum_ NEW_LINE DEDENT
def count_paths ( n , m ) : NEW_LINE INDENT dp = [ [ 0 ] * ( m + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] NEW_LINE return dp [ n ] [ m ] NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res *= i NEW_LINE return res NEW_LINE DEDENT
def print_diagonal_sums ( mat , n ) : NEW_LINE INDENT principal = 0 NEW_LINE secondary = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT principal += mat [ i ] [ j ] NEW_LINE if ( i + j ) == ( n - 1 ) : NEW_LINE INDENT secondary += mat [ i ] [ j ] NEW_LINE print ( " Principal ▁ Diagonal : " , principal ) NEW_LINE print ( " Secondary ▁ Diagonal : " , secondary ) NEW_LINE DEDENT
def count_integral_solutions ( n ) : NEW_LINE INDENT return ( n + 1 ) * ( n + 2 ) // 2 NEW_LINE DEDENT
def find_platform ( arr , dep , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE dep . sort ( ) NEW_LINE plat_needed = 1 NEW_LINE result = 1 NEW_LINE i = 1 NEW_LINE j = 0 NEW_LINE while i < n and j < n : NEW_LINE INDENT if arr [ i ] < dep [ j ] : NEW_LINE INDENT plat_needed += 1 NEW_LINE i += 1 NEW_LINE if plat_needed > result : NEW_LINE INDENT result = plat_needed NEW_LINE else : NEW_LINE INDENT plat_needed -= 1 NEW_LINE j += 1 NEW_LINE return result NEW_LINE DEDENT
def modular_sum ( arr , n , m ) : NEW_LINE INDENT if n > m : NEW_LINE INDENT return True NEW_LINE dp = [ False ] * m NEW_LINE for i in range ( n ) : NEW_LINE INDENT if dp [ 0 ] : NEW_LINE INDENT return True NEW_LINE temp = [ False ] * m NEW_LINE for j in range ( m ) : NEW_LINE INDENT if dp [ j ] == True : NEW_LINE INDENT if dp [ ( j + arr [ i ] ) % m ] == False : NEW_LINE INDENT temp [ ( j + arr [ i ] ) % m ] = True NEW_LINE for j in range ( m ) : NEW_LINE INDENT if temp [ j ] : NEW_LINE INDENT dp [ j ] = True NEW_LINE dp [ arr [ i ] % m ] = True NEW_LINE return dp [ 0 ] NEW_LINE DEDENT
def sum_of_large_prime_factor ( n ) : NEW_LINE INDENT prime = [ 0 ] * ( n + 1 ) NEW_LINE sum_ = 0 NEW_LINE max_ = n // 2 NEW_LINE for p in range ( 2 , max_ + 1 ) : NEW_LINE INDENT if prime [ p ] == 0 : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = p NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT sum_ += prime [ p ] NEW_LINE else : NEW_LINE INDENT sum_ += p NEW_LINE return sum_ NEW_LINE DEDENT
def min_jumps ( a , b , d ) : NEW_LINE INDENT temp = a NEW_LINE a = min ( a , b ) NEW_LINE b = max ( temp , b ) NEW_LINE if d >= b : NEW_LINE INDENT return ( d + b - 1 ) / b NEW_LINE if d == 0 : NEW_LINE INDENT return 0 NEW_LINE if d == a : NEW_LINE INDENT return 1 NEW_LINE return 2 NEW_LINE DEDENT
def count_set_bits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE return count NEW_LINE DEDENT
def permutated_rows ( mat , m , n , r ) : NEW_LINE INDENT s = set ( ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT s . add ( mat [ r ] [ j ] ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT if i == r : NEW_LINE INDENT continue NEW_LINE for j in range ( n ) : NEW_LINE INDENT if mat [ i ] [ j ] not in s : NEW_LINE INDENT j = j - 2 NEW_LINE break NEW_LINE if j + 1 != n : NEW_LINE INDENT continue NEW_LINE print ( i ) NEW_LINE DEDENT DEDENT
def print_series ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num = i * ( i + 1 ) * ( i + 2 ) // 6 NEW_LINE print ( num , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def zig_zag ( rows , columns , numbers ) : NEW_LINE INDENT k = 0 NEW_LINE arr = [ [ 0 ] * columns for _ in range ( rows ) ] NEW_LINE for i in range ( rows ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT j = 0 NEW_LINE while j < columns and numbers [ k ] > 0 : NEW_LINE INDENT arr [ i ] [ j ] = k + 1 NEW_LINE numbers [ k ] -= 1 NEW_LINE if numbers [ k ] == 0 : NEW_LINE INDENT k += 1 NEW_LINE j += 1 NEW_LINE else : NEW_LINE INDENT j = columns - 1 NEW_LINE while j >= 0 and numbers [ k ] > 0 : NEW_LINE INDENT arr [ i ] [ j ] = k + 1 NEW_LINE numbers [ k ] -= 1 NEW_LINE if numbers [ k ] == 0 : NEW_LINE INDENT k += 1 NEW_LINE j -= 1 NEW_LINE for i in arr : NEW_LINE INDENT for j in i : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE print ( ) NEW_LINE DEDENT DEDENT
def find_element ( arr , ranges , rotations , index ) : NEW_LINE INDENT for i in range ( rotations - 1 , - 1 , - 1 ) : NEW_LINE INDENT left = ranges [ i ] [ 0 ] NEW_LINE right = ranges [ i ] [ 1 ] NEW_LINE if left <= index <= right : NEW_LINE INDENT if index == left : NEW_LINE INDENT index = right NEW_LINE else : NEW_LINE INDENT index -= 1 NEW_LINE return arr [ index ] NEW_LINE DEDENT
def smallest_number ( str_ ) : NEW_LINE INDENT num = list ( str_ ) NEW_LINE n = len ( str_ ) NEW_LINE right_min = [ 0 ] * n NEW_LINE right = 0 NEW_LINE right_min [ n - 1 ] = - 1 NEW_LINE right = n - 1 NEW_LINE for i in range ( n - 2 , 0 , - 1 ) : NEW_LINE INDENT if num [ i ] > num [ right ] : NEW_LINE INDENT right_min [ i ] = right NEW_LINE else : NEW_LINE INDENT right_min [ i ] = - 1 NEW_LINE right = i NEW_LINE small = - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if num [ i ] != ' 0 ' : NEW_LINE INDENT if small == - 1 : NEW_LINE INDENT if num [ i ] < num [ 0 ] : NEW_LINE INDENT small = i NEW_LINE elif num [ i ] < num [ small ] : NEW_LINE INDENT small = i NEW_LINE if small != - 1 : NEW_LINE INDENT num [ 0 ] , num [ small ] = num [ small ] , num [ 0 ] NEW_LINE else : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if right_min [ i ] != - 1 : NEW_LINE INDENT num [ i ] , num [ right_min [ i ] ] = num [ right_min [ i ] ] , num [ i ] NEW_LINE break NEW_LINE return ' ' . join ( num ) NEW_LINE DEDENT
def count_paths ( maze ) : NEW_LINE INDENT if maze [ 0 ] [ 0 ] == - 1 : NEW_LINE INDENT return 0 NEW_LINE for i in range ( ROW ) : NEW_LINE INDENT if maze [ i ] [ 0 ] == 0 : NEW_LINE INDENT maze [ i ] [ 0 ] = 1 NEW_LINE else : NEW_LINE INDENT break NEW_LINE for i in range ( 1 , COL ) : NEW_LINE INDENT if maze [ 0 ] [ i ] == 0 : NEW_LINE INDENT maze [ 0 ] [ i ] = 1 NEW_LINE else : NEW_LINE INDENT break NEW_LINE for i in range ( 1 , ROW ) : NEW_LINE INDENT for j in range ( 1 , COL ) : NEW_LINE INDENT if maze [ i ] [ j ] == - 1 : NEW_LINE INDENT continue NEW_LINE if maze [ i - 1 ] [ j ] > 0 : NEW_LINE INDENT maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) NEW_LINE if maze [ i ] [ j - 1 ] > 0 : NEW_LINE INDENT maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) NEW_LINE if maze [ ROW - 1 ] [ COL - 1 ] > 0 : NEW_LINE INDENT return maze [ ROW - 1 ] [ COL - 1 ] NEW_LINE else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def min_max_length_words ( input_ , min_word , max_word ) : NEW_LINE INDENT len_ = len ( input_ ) NEW_LINE si = 0 NEW_LINE ei = 0 NEW_LINE min_length = len_ NEW_LINE min_start_index = max_length = max_start_index = 0 NEW_LINE while ei <= len_ : NEW_LINE INDENT if ( ei < len_ ) and ( input_ [ ei ] != " ▁ " ) : NEW_LINE INDENT ei += 1 NEW_LINE else : NEW_LINE INDENT curr_length = ei - si NEW_LINE if curr_length < min_length : NEW_LINE INDENT min_length = curr_length NEW_LINE min_start_index = si NEW_LINE if curr_length > max_length : NEW_LINE INDENT max_length = curr_length NEW_LINE max_start_index = si NEW_LINE ei += 1 NEW_LINE si = ei NEW_LINE min_word [ 0 ] = input_ [ min_start_index : min_start_index + min_length ] NEW_LINE max_word [ 0 ] = input_ [ max_start_index : max_length ] NEW_LINE DEDENT
def find_volume ( l , b , h ) : NEW_LINE INDENT volume = ( l * b * h ) / 2 NEW_LINE return volume NEW_LINE DEDENT
def sort_string ( str_ , n ) : NEW_LINE INDENT new_str = [ ] NEW_LINE for i in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if str_ [ j ] == chr ( i ) : NEW_LINE INDENT new_str . append ( str_ [ j ] ) NEW_LINE return " " . join ( new_str ) NEW_LINE DEDENT
def count_trees ( n ) : NEW_LINE INDENT bt = [ 0 ] * ( n + 1 ) NEW_LINE bt [ 0 ] = bt [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT bt [ i ] += bt [ j ] * bt [ i - j - 1 ] NEW_LINE return bt [ n ] NEW_LINE DEDENT
def get_pairs_count ( arr , n , sum_ ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] + arr [ j ] == sum_ : NEW_LINE INDENT count += 1 NEW_LINE return count NEW_LINE DEDENT
def check ( str_ ) : NEW_LINE INDENT n = len ( str_ ) NEW_LINE digit_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT digit_sum += ord ( str_ [ i ] ) - ord ( ' 0 ' ) NEW_LINE return digit_sum % 3 == 0 NEW_LINE DEDENT
def lc_substr ( x , y ) : NEW_LINE INDENT m = len ( x ) NEW_LINE n = len ( y ) NEW_LINE result = 0 NEW_LINE len_mat = [ [ 0 ] * n for _ in range ( 2 ) ] NEW_LINE curr_row = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if i == 0 | j == 0 : NEW_LINE INDENT len_mat [ curr_row ] [ j ] = 0 NEW_LINE elif x [ i - 1 ] == y [ j - 1 ] : NEW_LINE INDENT len_mat [ curr_row ] [ j ] = len_mat [ 1 - curr_row ] [ j - 1 ] + 1 NEW_LINE result = max ( result , len_mat [ curr_row ] [ j ] ) NEW_LINE else : NEW_LINE INDENT len_mat [ curr_row ] [ j ] = 0 NEW_LINE curr_row = 1 - curr_row NEW_LINE return result NEW_LINE DEDENT
def remove_consecutive_same ( v ) : NEW_LINE INDENT n = len ( v ) NEW_LINE i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT if v [ i ] == v [ i + 1 ] : NEW_LINE INDENT v . pop ( i ) NEW_LINE v . pop ( i ) NEW_LINE if i > 0 : NEW_LINE INDENT i -= 1 NEW_LINE n = n - 2 NEW_LINE else : NEW_LINE INDENT i += 1 NEW_LINE return len ( v ) NEW_LINE DEDENT
def perimeter ( diameter , height ) : NEW_LINE INDENT return 2 * ( diameter + height ) NEW_LINE DEDENT
def is_possible_to_make_divisible ( arr , n ) : NEW_LINE INDENT remainder = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT remainder = ( remainder + arr [ i ] ) % 3 NEW_LINE return remainder == 0 NEW_LINE DEDENT
def get_inv_count ( arr , n ) : NEW_LINE INDENT inv_count = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT if arr [ i ] > arr [ j ] : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if arr [ j ] > arr [ k ] : NEW_LINE INDENT inv_count += 1 NEW_LINE return inv_count NEW_LINE DEDENT
def bin ( n ) : NEW_LINE INDENT if n > 1 : NEW_LINE INDENT bin ( n // 2 ) NEW_LINE print ( n % 2 , end = " " ) NEW_LINE DEDENT
def min_sum ( ar , n ) : NEW_LINE INDENT if n <= 4 : NEW_LINE INDENT return min ( ar ) NEW_LINE sum_ = [ 0 ] * n NEW_LINE sum_ [ 0 ] = ar [ 0 ] NEW_LINE sum_ [ 1 ] = ar [ 1 ] NEW_LINE sum_ [ 2 ] = ar [ 2 ] NEW_LINE sum_ [ 3 ] = ar [ 3 ] NEW_LINE for i in range ( 4 , n ) : NEW_LINE INDENT sum_ [ i ] = ar [ i ] + min ( sum_ [ i - 4 : i ] ) NEW_LINE return min ( sum_ [ n - 4 : n ] ) NEW_LINE DEDENT
def find_triplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum_ ) : NEW_LINE INDENT for i in range ( n1 ) : NEW_LINE INDENT for j in range ( n2 ) : NEW_LINE INDENT for k in range ( n3 ) : NEW_LINE INDENT if a1 [ i ] + a2 [ j ] + a3 [ k ] == sum_ : NEW_LINE INDENT return True NEW_LINE return False NEW_LINE DEDENT
def min_dist ( arr , n , x , y ) : NEW_LINE INDENT i = 0 NEW_LINE min_dist = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == x or arr [ i ] == y : NEW_LINE INDENT prev = i NEW_LINE break NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] == x or arr [ i ] == y : NEW_LINE INDENT if arr [ prev ] != arr [ i ] and ( i - prev ) < min_dist : NEW_LINE INDENT min_dist = i - prev NEW_LINE prev = i NEW_LINE else : NEW_LINE INDENT prev = i NEW_LINE i += 1 NEW_LINE return min_dist NEW_LINE DEDENT
def solve ( a , b , n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += a [ i ] + b [ i ] NEW_LINE if n == 1 : NEW_LINE INDENT return a [ 0 ] + b [ 0 ] NEW_LINE if s % n != 0 : NEW_LINE INDENT return - 1 NEW_LINE x = s // n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > x : NEW_LINE INDENT return - 1 NEW_LINE if i > 0 : NEW_LINE INDENT a [ i ] += b [ i - 1 ] NEW_LINE b [ i - 1 ] = 0 NEW_LINE if a [ i ] == x : NEW_LINE INDENT continue NEW_LINE y = a [ i ] + b [ i ] NEW_LINE if i + 1 < n : NEW_LINE INDENT y += b [ i + 1 ] NEW_LINE if y == x : NEW_LINE INDENT a [ i ] = y NEW_LINE b [ i ] = 0 NEW_LINE if i + 1 < n : NEW_LINE INDENT b [ i + 1 ] = 0 NEW_LINE continue NEW_LINE if a [ i ] + b [ i ] == x : NEW_LINE INDENT a [ i ] += b [ i ] NEW_LINE b [ i ] = 0 NEW_LINE continue NEW_LINE if i + 1 < n and a [ i ] + b [ i + 1 ] == x : NEW_LINE INDENT a [ i ] += b [ i + 1 ] NEW_LINE b [ i + 1 ] = 0 NEW_LINE continue NEW_LINE return - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if b [ i ] != 0 : NEW_LINE INDENT return - 1 NEW_LINE return x NEW_LINE DEDENT
def find_string ( str_ , n , k ) : NEW_LINE INDENT if k == 0 : NEW_LINE INDENT print ( str_ ) NEW_LINE return NEW_LINE str2 = list ( str_ ) NEW_LINE p = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if str2 [ i ] != ' a ' : NEW_LINE INDENT str2 [ i ] = ' a ' NEW_LINE p += 1 NEW_LINE if p == k : NEW_LINE INDENT break NEW_LINE if p < k : NEW_LINE INDENT i = n - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT if str_ [ i ] == ' a ' : NEW_LINE INDENT str2 [ i ] = ' b ' NEW_LINE p += 1 NEW_LINE if p == k : NEW_LINE INDENT break NEW_LINE i -= 1 NEW_LINE print ( " " . join ( str2 ) ) NEW_LINE DEDENT
def find_longest_repeating_sub_seq ( x , m , n ) : NEW_LINE INDENT if dp [ m ] [ n ] != - 1 : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE if m == 0 or n == 0 : NEW_LINE INDENT dp [ m ] [ n ] = 0 NEW_LINE return dp [ m ] [ n ] NEW_LINE if x [ m - 1 ] == x [ n - 1 ] and m != n : NEW_LINE INDENT dp [ m ] [ n ] = find_longest_repeating_sub_seq ( x , m - 1 , n - 1 ) + 1 NEW_LINE return dp [ m ] [ n ] NEW_LINE dp [ m ] [ n ] = max ( find_longest_repeating_sub_seq ( x , m , n - 1 ) , find_longest_repeating_sub_seq ( x , m - 1 , n ) ) NEW_LINE return dp [ m ] [ n ] NEW_LINE DEDENT
def product_sub_seq_count ( arr , k ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE dp = [ [ 0 ] * ( n + 1 ) for _ in range ( k + 1 ) ] NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE if arr [ j - 1 ] <= i and arr [ j - 1 ] > 0 : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i // arr [ j - 1 ] ] [ j - 1 ] + 1 NEW_LINE return dp [ k ] [ n ] NEW_LINE DEDENT
def pow ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return 1 NEW_LINE answer = a NEW_LINE increment = a NEW_LINE for i in range ( 1 , b ) : NEW_LINE INDENT for j in range ( 1 , a ) : NEW_LINE INDENT answer += increment NEW_LINE increment = answer NEW_LINE return answer NEW_LINE DEDENT
def fix ( a , len_ ) : NEW_LINE INDENT for i in range ( len_ ) : NEW_LINE INDENT if a [ i ] != - 1 and a [ i ] != i : NEW_LINE INDENT x = a [ i ] NEW_LINE while a [ x ] != - 1 and a [ x ] != x : NEW_LINE INDENT y = a [ x ] NEW_LINE a [ x ] = x NEW_LINE x = y NEW_LINE a [ x ] = x NEW_LINE if a [ i ] != i : NEW_LINE INDENT a [ i ] = - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def calculate ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE s = [ ] NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while i < j : NEW_LINE INDENT s . append ( ( a [ i ] + a [ j ] ) ) NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE min_i = min ( s ) NEW_LINE max_i = max ( s ) NEW_LINE return abs ( max_i - min_i ) NEW_LINE DEDENT
def sum_of_series ( n ) : NEW_LINE INDENT return 0.0246 * ( 10 ** n - 1 - ( 9 * n ) ) NEW_LINE DEDENT
def calculate ( s ) : NEW_LINE INDENT ans = 6 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT for k in range ( 10 ) : NEW_LINE INDENT for l in range ( 10 ) : NEW_LINE INDENT for m in range ( 10 ) : NEW_LINE INDENT for n in range ( 10 ) : NEW_LINE INDENT if i + j + k == l + m + n : NEW_LINE INDENT c = 0 NEW_LINE if i != ord ( s [ 0 ] ) - ord ( ' 0 ' ) : NEW_LINE INDENT c += 1 NEW_LINE if j != ord ( s [ 1 ] ) - ord ( ' 0 ' ) : NEW_LINE INDENT c += 1 NEW_LINE if k != ord ( s [ 2 ] ) - ord ( ' 0 ' ) : NEW_LINE INDENT c += 1 NEW_LINE if l != ord ( s [ 3 ] ) - ord ( ' 0 ' ) : NEW_LINE INDENT c += 1 NEW_LINE if m != ord ( s [ 4 ] ) - ord ( ' 0 ' ) : NEW_LINE INDENT c += 1 NEW_LINE if n != ord ( s [ 5 ] ) - ord ( ' 0 ' ) : NEW_LINE INDENT c += 1 NEW_LINE if c < ans : NEW_LINE INDENT ans = c NEW_LINE return ans NEW_LINE DEDENT
def get_total_number_of_sequences ( m , n ) : NEW_LINE INDENT if m < n : NEW_LINE INDENT return 0 NEW_LINE if n == 0 : NEW_LINE INDENT return 1 NEW_LINE res = ( get_total_number_of_sequences ( m - 1 , n ) + get_total_number_of_sequences ( m // 2 , n - 1 ) ) NEW_LINE return res NEW_LINE DEDENT
def sort_in_wave ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 , 2 ) : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE DEDENT DEDENT
def search ( arr , low , high ) : NEW_LINE INDENT if low > high : NEW_LINE INDENT return NEW_LINE if low == high : NEW_LINE INDENT print ( " The ▁ required ▁ element ▁ is ▁ % d ▁ " , arr [ low ] , sep = " " ) NEW_LINE return NEW_LINE mid = ( low + high ) / 2 NEW_LINE if mid % 2 == 0 : NEW_LINE INDENT if arr [ mid ] == arr [ mid + 1 ] : NEW_LINE INDENT return search ( arr , mid + 2 , high ) NEW_LINE else : NEW_LINE INDENT return search ( arr , low , mid ) NEW_LINE else : NEW_LINE INDENT if arr [ mid ] == arr [ mid - 1 ] : NEW_LINE INDENT return search ( arr , mid + 1 , high ) NEW_LINE else : NEW_LINE INDENT return search ( arr , low , mid - 1 ) NEW_LINE DEDENT DEDENT DEDENT
def check ( str_ ) : NEW_LINE INDENT n = len ( str_ ) NEW_LINE if ( ord ( str_ [ n - 1 ] ) - ord ( ' 0 ' ) ) % 2 != 0 : NEW_LINE INDENT return False NEW_LINE digit_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT digit_sum += ( ord ( str_ [ i ] ) - ord ( ' 0 ' ) ) NEW_LINE return digit_sum % 3 == 0 NEW_LINE DEDENT
def stirling_factorial ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE e = 2.71 NEW_LINE z = ( math . sqrt ( 2 * 3.14 * n ) * math . pow ( ( n / e ) , n ) ) NEW_LINE return int ( z ) NEW_LINE DEDENT
def check_count ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if arr [ j ] == arr [ i ] : NEW_LINE INDENT count += 1 NEW_LINE if count > 2 * k : NEW_LINE INDENT return False NEW_LINE return True NEW_LINE DEDENT
def are_elements_contiguous ( arr , n ) : NEW_LINE INDENT max_ = max ( arr ) NEW_LINE min_ = min ( arr ) NEW_LINE m = max_ - min_ + 1 NEW_LINE if m > n : NEW_LINE INDENT return False NEW_LINE visited = [ False ] * m NEW_LINE for i in range ( n ) : NEW_LINE INDENT visited [ arr [ i ] - min_ ] = True NEW_LINE for i in range ( m ) : NEW_LINE INDENT if visited [ i ] == False : NEW_LINE INDENT return False NEW_LINE return True NEW_LINE DEDENT
def zigzag ( n , k ) : NEW_LINE INDENT if n == 0 and k == 0 : NEW_LINE INDENT return 1 NEW_LINE if k == 0 : NEW_LINE INDENT return 0 NEW_LINE return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) NEW_LINE DEDENT
def lcs ( x , y ) : NEW_LINE INDENT m = len ( x ) NEW_LINE n = len ( y ) NEW_LINE l = [ [ 0 ] * ( n + 1 ) for _ in range ( 2 ) ] NEW_LINE bi = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT bi = i & 1 NEW_LINE for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 or j == 0 : NEW_LINE INDENT l [ bi ] [ j ] = 0 NEW_LINE elif x [ i ] == y [ j - 1 ] : NEW_LINE INDENT l [ bi ] [ j ] = l [ 1 - bi ] [ j - 1 ] + 1 NEW_LINE else : NEW_LINE INDENT l [ bi ] [ j ] = max ( l [ 1 - bi ] [ j ] , l [ bi ] [ j - 1 ] ) NEW_LINE return l [ bi ] [ n ] NEW_LINE DEDENT
def print_first_negative_integer ( arr , n , k ) : NEW_LINE INDENT di = deque ( ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT if arr [ i ] < 0 : NEW_LINE INDENT di . append ( i ) NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT if di : NEW_LINE INDENT print ( arr [ di [ 0 ] ] , end = " ▁ " ) NEW_LINE else : NEW_LINE INDENT print ( 0 , end = " ▁ " ) NEW_LINE while di and di [ 0 ] < ( i - k + 1 ) : NEW_LINE INDENT di . popleft ( ) NEW_LINE if arr [ i ] < 0 : NEW_LINE INDENT di . append ( i ) NEW_LINE if di : NEW_LINE INDENT print ( arr [ di [ 0 ] ] , end = " ▁ " ) NEW_LINE else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT
def find_root ( arr , n ) : NEW_LINE INDENT root = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT root += ( arr [ i ] [ 0 ] - arr [ i ] [ 1 ] ) NEW_LINE return root NEW_LINE DEDENT
def find_area ( arr , n ) : NEW_LINE INDENT s = SortedSet ( ) NEW_LINE first = 0 NEW_LINE second = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE continue NEW_LINE if arr [ i ] > first : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE elif arr [ i ] > second : NEW_LINE INDENT second = arr [ i ] NEW_LINE return first * second NEW_LINE DEDENT
def rearrange ( arr , n ) : NEW_LINE INDENT max_ele = arr [ n - 1 ] NEW_LINE min_ele = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT arr [ i ] = max_ele NEW_LINE max_ele -= 1 NEW_LINE else : NEW_LINE INDENT arr [ i ] = min_ele NEW_LINE min_ele += 1 NEW_LINE DEDENT DEDENT DEDENT
def find_max_product ( arr , n ) : NEW_LINE INDENT max_ = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( j - 3 ) >= 0 : NEW_LINE INDENT result = ( arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ) NEW_LINE if max_ < result : NEW_LINE INDENT max_ = result NEW_LINE if ( i - 3 ) >= 0 : NEW_LINE INDENT result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ) NEW_LINE if max_ < result : NEW_LINE INDENT max_ = result NEW_LINE if ( i - 3 ) >= 0 and ( j - 3 ) >= 0 : NEW_LINE INDENT result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ) NEW_LINE if max_ < result : NEW_LINE INDENT max_ = result NEW_LINE return max_ NEW_LINE DEDENT
def is_triangular ( num ) : NEW_LINE INDENT if num < 0 : NEW_LINE INDENT return False NEW_LINE c = - 2 * num NEW_LINE b = 1 NEW_LINE a = 1 NEW_LINE d = b * b - 4 * a * c NEW_LINE if d < 0 : NEW_LINE INDENT return False NEW_LINE root1 = ( - b + math . sqrt ( d ) ) / ( 2 * a ) NEW_LINE root2 = ( - b - math . sqrt ( d ) ) / ( 2 * a ) NEW_LINE if root1 > 0 and math . floor ( root1 ) == root1 : NEW_LINE INDENT return True NEW_LINE if root2 > 0 and math . floor ( root2 ) == root2 : NEW_LINE INDENT return True NEW_LINE return False NEW_LINE DEDENT
def count_lattice ( r ) : NEW_LINE INDENT if r <= 0 : NEW_LINE INDENT return 0 NEW_LINE result = 4 NEW_LINE for x in range ( 1 , r ) : NEW_LINE INDENT y_square = r * r - x * x NEW_LINE y = math . sqrt ( y_square ) NEW_LINE if y * y == y_square : NEW_LINE INDENT result += 4 NEW_LINE return result NEW_LINE DEDENT
def max_ones_index ( arr , n ) : NEW_LINE INDENT max_count = 0 NEW_LINE max_index = 0 NEW_LINE prev_zero = - 1 NEW_LINE prev_prev_zero = - 1 NEW_LINE for curr in range ( n ) : NEW_LINE INDENT if arr [ curr ] == False : NEW_LINE INDENT if curr - prev_prev_zero > max_count : NEW_LINE INDENT max_count = curr - prev_prev_zero NEW_LINE max_index = prev_zero NEW_LINE prev_prev_zero = prev_zero NEW_LINE prev_zero = curr NEW_LINE if n - prev_prev_zero > max_count : NEW_LINE INDENT max_index = prev_zero NEW_LINE return max_index NEW_LINE DEDENT
def leaf_node ( pre_order , n ) : NEW_LINE INDENT s = LifoQueue ( ) NEW_LINE i = 0 NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT found = False NEW_LINE if pre_order [ i ] > pre_order [ j ] : NEW_LINE INDENT s . put ( pre_order [ i ] ) NEW_LINE else : NEW_LINE INDENT while not s . empty ( ) : NEW_LINE INDENT if pre_order [ j ] > s . queue [ - 1 ] : NEW_LINE INDENT s . get ( ) NEW_LINE found = True NEW_LINE else : NEW_LINE INDENT break NEW_LINE if found : NEW_LINE INDENT print ( pre_order [ i ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE print ( pre_order [ n - 1 ] ) NEW_LINE DEDENT
def is_subset ( arr1 , arr2 , m , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if arr2 [ i ] == arr1 [ j ] : NEW_LINE INDENT break NEW_LINE if j == m : NEW_LINE INDENT return 0 NEW_LINE return 1 NEW_LINE DEDENT
def multiply_by_seven ( n ) : NEW_LINE INDENT return ( n << 3 ) - n NEW_LINE DEDENT
def unbounded_knapsack ( w , n , val , wt ) : NEW_LINE INDENT dp = [ 0 ] * ( w + 1 ) NEW_LINE ans = 0 NEW_LINE for i in range ( w + 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if wt [ j ] <= i : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] ) NEW_LINE return dp [ w ] NEW_LINE DEDENT
def alternate_subarray ( arr , n ) : NEW_LINE INDENT count = 1 NEW_LINE prev = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if not ( arr [ i ] ^ prev ) : NEW_LINE INDENT while count : NEW_LINE INDENT print ( count , end = " ▁ " ) NEW_LINE count -= 1 NEW_LINE count += 1 NEW_LINE prev = arr [ i ] NEW_LINE while count : NEW_LINE INDENT print ( count , end = " ▁ " ) NEW_LINE count -= 1 NEW_LINE DEDENT DEDENT
def count_k_dist ( str_ , k ) : NEW_LINE INDENT n = len ( str_ ) NEW_LINE res = 0 NEW_LINE cnt = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dist_count = 0 NEW_LINE cnt = [ 0 ] * 26 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if cnt [ ord ( str_ [ j ] ) - ord ( ' a ' ) ] == 0 : NEW_LINE INDENT dist_count += 1 NEW_LINE cnt [ ord ( str_ [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE if dist_count == k : NEW_LINE INDENT res += 1 NEW_LINE if dist_count > k : NEW_LINE INDENT break NEW_LINE return res NEW_LINE DEDENT
def modular_inverse ( n , prime ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ prime % i ] * ( prime - prime // i ) % prime NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( dp [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def count_ways ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = dp [ 1 ] = dp [ 2 ] = 1 NEW_LINE dp [ 3 ] = 2 NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + dp [ i - 4 ] NEW_LINE return dp [ n ] NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return n NEW_LINE elif n >= 3 and n < 10 : NEW_LINE INDENT return n - 1 NEW_LINE po = 1 NEW_LINE while n / po > 9 : NEW_LINE INDENT po = po * 10 NEW_LINE msd = n / po NEW_LINE if msd != 3 : NEW_LINE INDENT return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) NEW_LINE else : NEW_LINE INDENT return count ( msd * po - 1 ) NEW_LINE DEDENT DEDENT
def count_pattern ( s ) : NEW_LINE INDENT len_ = len ( s ) NEW_LINE one_seen = False NEW_LINE count = 0 NEW_LINE for i in range ( len_ ) : NEW_LINE INDENT if s [ i ] == ' 1 ' and one_seen : NEW_LINE INDENT if s [ i - 1 ] == ' 0 ' : NEW_LINE INDENT count += 1 NEW_LINE if s [ i ] == ' 1 ' and one_seen == 0 : NEW_LINE INDENT one_seen = True NEW_LINE if s [ i ] != ' 0 ' and s [ i ] != ' 1 ' : NEW_LINE INDENT one_seen = False NEW_LINE return count NEW_LINE DEDENT
def max_removal ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE cummulative_sum = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] >= cummulative_sum : NEW_LINE INDENT count += 1 NEW_LINE cummulative_sum += arr [ i ] NEW_LINE return count NEW_LINE DEDENT
def lexicographical_max_string ( str_ ) : NEW_LINE INDENT mx = " " NEW_LINE for i in range ( len ( str_ ) ) : NEW_LINE INDENT if mx <= str [ i : ] : NEW_LINE INDENT mx = str [ i : ] NEW_LINE return mx NEW_LINE DEDENT
