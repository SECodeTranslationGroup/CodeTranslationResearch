int sumDigits ( int no ) { return no == 0 ? 0 : no % 10 + sumDigits ( no / 10 ) ; }
int findSum ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { ans += i / j ; } } return ans ; }
boolean isPalindrome ( String s ) { int l = s . length ( ) ; for ( int i = 0 , j = l - 1 ; i <= j ; i ++ , j -- ) { if ( s . charAt ( i ) != s . charAt ( j ) ) { return false ; } } return true ; }
int getMinStepToReachEnd ( int [ ] arr , int n ) { boolean [ ] visit = new boolean [ n ] ; int [ ] distance = new int [ n ] ; List < Integer > [ ] digit = new ArrayList [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { digit [ i ] = new ArrayList <> ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { visit [ i ] = false ; } for ( int i = 1 ; i < n ; i ++ ) { digit [ arr [ i ] ] . add ( i ) ; } distance [ 0 ] = 0 ; visit [ 0 ] = true ; Queue < Integer > q = new ArrayDeque <> ( ) ; q . add ( 0 ) ; while ( ! q . isEmpty ( ) ) { int idx = q . peek ( ) ; q . remove ( ) ; if ( idx == n - 1 ) { break ; } int d = arr [ idx ] ; for ( int i = 0 ; i < digit [ d ] . size ( ) ; i ++ ) { int nextIdx = digit [ d ] . get ( i ) ; if ( ! visit [ nextIdx ] ) { visit [ nextIdx ] = true ; q . add ( nextIdx ) ; distance [ nextIdx ] = distance [ idx ] + 1 ; } } digit [ d ] . clear ( ) ; if ( idx - 1 >= 0 && ! visit [ idx - 1 ] ) { visit [ idx - 1 ] = true ; q . add ( idx - 1 ) ; distance [ idx - 1 ] = distance [ idx ] + 1 ; } if ( idx + 1 < n && ! visit [ idx + 1 ] ) { visit [ idx + 1 ] = true ; q . add ( idx + 1 ) ; distance [ idx + 1 ] = distance [ idx ] + 1 ; } } return distance [ n - 1 ] ; }
long findWays ( int f , int d , int s ) { long [ ] [ ] mem = new long [ d + 1 ] [ s + 1 ] ; mem [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= d ; i ++ ) { for ( int j = i ; j <= s ; j ++ ) { mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] ; if ( j - f - 1 >= 0 ) { mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] ; } } } return mem [ d ] [ s ] ; }
int maxVolume ( int s ) { int maxValue = 0 ; for ( int i = 1 ; i <= s - 2 ; i ++ ) { for ( int j = 1 ; j <= s - 1 ; j ++ ) { int k = s - i - j ; maxValue = Math . max ( maxValue , i * j * k ) ; } } return maxValue ; }
int minDaysToEmpty ( int c , int l ) { if ( l >= c ) { return c ; } double eqRoot = ( Math . sqrt ( 1 + 8 * ( c - l ) ) - 1 ) / 2 ; return ( int ) ( Math . ceil ( eqRoot ) + l ) ; }
int minDiff ( int [ ] arr , int n , int k ) { int result = Integer . MAX_VALUE ; Arrays . sort ( arr ) ; for ( int i = 0 ; i <= n - k ; i ++ ) { result = Math . min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; } return result ; }
void concatenate ( char [ ] a , char [ ] b , char [ ] c , int n1 , int n2 ) { int i ; for ( i = 0 ; i < n1 ; i ++ ) { c [ i ] = a [ i ] ; } for ( int j = 0 ; j < n2 ; j ++ ) { c [ i ++ ] = b [ j ] ; } }
int ceilSearch ( int [ ] arr , int low , int high , int x ) { if ( x <= arr [ low ] ) { return low ; } for ( int i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) { return i ; } if ( arr [ i ] < x && arr [ i + 1 ] >= x ) { return i + 1 ; } } return - 1 ; }
void printMaxSubSquare ( int [ ] [ ] m ) { int [ ] [ ] s = new int [ ROW ] [ COL ] ; int maxOfS , maxI , maxJ ; for ( int i = 0 ; i < ROW ; i ++ ) { s [ i ] [ 0 ] = m [ i ] [ 0 ] ; } for ( int j = 0 ; j < COL ; j ++ ) { s [ 0 ] [ j ] = m [ 0 ] [ j ] ; } for ( int i = 1 ; i < ROW ; i ++ ) { for ( int j = 1 ; j < COL ; j ++ ) { if ( m [ i ] [ j ] == 1 ) { s [ i ] [ j ] = Math . min ( s [ i ] [ j - 1 ] , Math . min ( s [ i - 1 ] [ j ] , s [ i - 1 ] [ j - 1 ] ) ) + 1 ; } else { s [ i ] [ j ] = 0 ; } } } maxOfS = s [ 0 ] [ 0 ] ; maxI = 0 ; maxJ = 0 ; for ( int i = 0 ; i < ROW ; i ++ ) { for ( int j = 0 ; j < COL ; j ++ ) { if ( maxOfS < s [ i ] [ j ] ) { maxOfS = s [ i ] [ j ] ; maxI = i ; maxJ = j ; } } } System . out . println ( " Maximum ▁ size ▁ sub - matrix ▁ is : ▁ " ) ; for ( int i = maxI ; i > maxI - maxOfS ; i -- ) { for ( int j = maxJ ; j > maxJ - maxOfS ; j -- ) { System . out . print ( m [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; } }
int minMaxProduct ( int [ ] arr1 , int [ ] arr2 , int n1 , int n2 ) { int max = arr1 [ 0 ] ; int min = arr2 [ 0 ] ; int i ; for ( i = 1 ; i < n1 && i < n2 ; ++ i ) { if ( arr1 [ i ] > max ) { max = arr1 [ i ] ; } if ( arr2 [ i ] < min ) { min = arr2 [ i ] ; } } while ( i < n1 ) { if ( arr1 [ i ] > max ) { max = arr1 [ i ] ; } i ++ ; } while ( i < n2 ) { if ( arr2 [ i ] < min ) { min = arr2 [ i ] ; } i ++ ; } return max * min ; }
boolean isComposite ( int n ) { if ( n <= 1 ) { return false ; } if ( n <= 3 ) { return false ; } if ( n % 2 == 0 || n % 3 == 0 ) { return true ; } for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return true ; } } return false ; }
void findMaxGuests ( int [ ] arrl , int [ ] exit , int n ) { Arrays . sort ( arrl ) ; Arrays . sort ( exit ) ; int guestsIn = 1 , maxGuests = 1 , time = arrl [ 0 ] ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guestsIn ++ ; if ( guestsIn > maxGuests ) { maxGuests = guestsIn ; time = arrl [ i ] ; } i ++ ; } else { guestsIn -- ; j ++ ; } } System . out . println ( " Maximum ▁ Number ▁ of ▁ Guests ▁ = ▁ " + maxGuests + " ▁ at ▁ time ▁ " + time ) ; }
int identity ( int num ) { int row , col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) { System . out . print ( 1 + " ▁ " ) ; } else { System . out . print ( 0 + " ▁ " ) ; } } System . out . println ( ) ; } return 0 ; }
int printKDistinct ( int [ ] arr , int n , int k ) { int distCount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) { if ( i != j && arr [ j ] == arr [ i ] ) { break ; } } if ( j == n ) { distCount ++ ; } if ( distCount == k ) { return arr [ i ] ; } } return - 1 ; }
void reorder ( int [ ] arr , int [ ] index , int n ) { int [ ] temp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { temp [ index [ i ] ] = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = temp [ i ] ; index [ i ] = i ; } }
int printCountDp ( int dist ) { int [ ] count = new int [ dist + 1 ] ; count [ 0 ] = 1 ; count [ 1 ] = 1 ; count [ 2 ] = 2 ; for ( int i = 3 ; i <= dist ; i ++ ) { count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ; } return count [ dist ] ; }
int maximumChars ( String str ) { int n = str . length ( ) ; int res = - 1 ; int [ ] firstInds = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { firstInds [ i ] = - 1 ; } for ( int i = 0 ; i < n ; i ++ ) { int firstInd = firstInds [ str . charAt ( i ) ] ; if ( firstInd == - 1 ) { firstInds [ str . charAt ( i ) ] = i ; } else { res = Math . max ( res , Math . abs ( i - firstInd - 1 ) ) ; } } return res ; }
int firstRepeated ( String str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { int val = ( str . charAt ( i ) - ' a ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) { return i ; } checker |= ( 1 << val ) ; } return - 1 ; }
int findMaxProduct ( int [ ] arr , int n ) { int i ; int ans = Integer . MIN_VALUE ; int maxVal = 1 ; int minVal = 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { maxVal = maxVal * arr [ i ] ; minVal = Math . min ( 1 , minVal * arr [ i ] ) ; } else if ( arr [ i ] == 0 ) { minVal = 1 ; maxVal = 0 ; } else if ( arr [ i ] < 0 ) { int prevMax = maxVal ; maxVal = minVal * arr [ i ] ; minVal = prevMax * arr [ i ] ; } ans = Math . max ( ans , maxVal ) ; if ( maxVal <= 0 ) { maxVal = 1 ; } } return ans ; }
void survival ( int s , int n , int m ) { if ( ( ( n * 6 ) < ( m * 7 ) && s > 6 ) || m > n ) { System . out . println ( " No " ) ; } else { int days = ( m * s ) / n ; if ( ( ( m * s ) % n ) != 0 ) { days ++ ; } System . out . println ( " Yes ▁ " + days ) ; } }
void firstNonRepeating ( String str ) { int [ ] charCount = new int [ MAX_CHAR ] ; Queue < Character > q = new ArrayDeque <> ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; q . add ( ch ) ; charCount [ ch - ' a ' ] ++ ; while ( ! q . isEmpty ( ) ) { if ( charCount [ q . peek ( ) - ' a ' ] > 1 ) { q . remove ( ) ; } else { System . out . print ( q . peek ( ) + " ▁ " ) ; break ; } } if ( q . isEmpty ( ) ) { System . out . print ( - 1 + " ▁ " ) ; } } System . out . println ( ) ; }
void dfs ( List < Integer > [ ] list , int node , int arrival ) { System . out . println ( node ) ; for ( int i = 0 ; i < list [ node ] . size ( ) ; i ++ ) { if ( list [ node ] . get ( i ) != arrival ) { dfs ( list , list [ node ] . get ( i ) , node ) ; } } }
int findRepeating ( int [ ] arr , int n ) { int res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { res = res ^ ( i + 1 ) ^ arr [ i ] ; } res = res ^ arr [ n - 1 ] ; return res ; }
int getCount ( char [ ] [ ] keypad , int n ) { if ( keypad == null || n <= 0 ) { return 0 ; } if ( n == 1 ) { return 10 ; } int [ ] odd = new int [ 10 ] ; int [ ] even = new int [ 10 ] ; int useOdd = 0 , totalCount = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) { odd [ i ] = 1 ; } for ( int j = 2 ; j <= n ; j ++ ) { useOdd = 1 - useOdd ; if ( useOdd == 1 ) { even [ 0 ] = odd [ 0 ] + odd [ 8 ] ; even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ] ; even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] ; even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ] ; even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] ; even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] ; even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] ; even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] ; even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] ; even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ] ; } else { odd [ 0 ] = even [ 0 ] + even [ 8 ] ; odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ] ; odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ] ; odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ] ; odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ] ; odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ] ; odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ] ; odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ] ; odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ] ; odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ] ; } } totalCount = 0 ; if ( useOdd == 1 ) { for ( int i = 0 ; i <= 9 ; i ++ ) { totalCount += even [ i ] ; } } else { for ( int i = 0 ; i <= 9 ; i ++ ) { totalCount += odd [ i ] ; } } return totalCount ; }
int countSubarrWithEqualZeroAndOne ( int [ ] arr , int n ) { TreeMap < Integer , Integer > myMap = new TreeMap <> ( ) ; int sum = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { arr [ i ] = - 1 ; } sum += arr [ i ] ; if ( sum == 0 ) { count ++ ; } if ( myMap . containsKey ( sum ) ) { count += myMap . get ( sum ) ; } myMap . put ( sum , myMap . getOrDefault ( sum , 0 ) + 1 ) ; } return count ; }
void search ( int [ ] [ ] mat , int fromRow , int toRow , int fromCol , int toCol , int key ) { int i = fromRow + ( toRow - fromRow ) / 2 ; int j = fromCol + ( toCol - fromCol ) / 2 ; if ( mat [ i ] [ j ] == key ) { System . out . println ( " Found ▁ " + key + " ▁ at ▁ " + i + " ▁ " + j ) ; } else { if ( i != toRow || j != fromCol ) { search ( mat , fromRow , i , j , toCol , key ) ; } if ( fromRow == toRow && fromCol + 1 == toCol ) { if ( mat [ fromRow ] [ toCol ] == key ) { System . out . println ( " Found ▁ " + key + " ▁ at ▁ " + fromRow + " ▁ " + toCol ) ; } } if ( mat [ i ] [ j ] < key ) { if ( i + 1 <= toRow ) { search ( mat , i + 1 , toRow , fromCol , toCol , key ) ; } } else { if ( j - 1 >= fromCol ) { search ( mat , fromRow , toRow , fromCol , j - 1 , key ) ; } } } }
int kthGroupSum ( int k ) { return k * k * k ; }
boolean areKAnagrams ( String str1 , String str2 , int k ) { int n = str1. length ( ) ; if ( str2. length ( ) != n ) { return false ; } int [ ] hashStr1 = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { hashStr1 [ str1. charAt ( i ) - ' a ' ] ++ ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hashStr1 [ str2. charAt ( i ) - ' a ' ] > 0 ) { hashStr1 [ str2. charAt ( i ) - ' a ' ] -- ; } else { count ++ ; } if ( count > k ) { return false ; } } return true ; }
void bonacciSeries ( int n , int m ) { int [ ] a = new int [ m ] ; a [ n - 1 ] = 1 ; for ( int i = n ; i < m ; i ++ ) { for ( int j = i - n ; j < i ; j ++ ) { a [ i ] += a [ j ] ; } } for ( int i = 0 ; i < m ; i ++ ) { System . out . print ( a [ i ] + " ▁ " ) ; } }
void printMinIndexChar ( String str , String patt ) { int minIndex = Integer . MAX_VALUE ; int m = str . length ( ) ; int n = patt . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( patt . charAt ( i ) == str . charAt ( j ) && j < minIndex ) { minIndex = j ; break ; } } } if ( minIndex != Integer . MAX_VALUE ) { System . out . println ( " Minimum ▁ Index ▁ Character ▁ = ▁ " + str . charAt ( minIndex ) ) ; } else { System . out . println ( " No ▁ character ▁ present " ) ; } }
boolean negCycleFloydWarshall ( int [ ] [ ] graph ) { int [ ] [ ] dist = new int [ V_NUM ] [ V_NUM ] ; for ( int i = 0 ; i < V_NUM ; i ++ ) { for ( int j = 0 ; j < V_NUM ; j ++ ) { dist [ i ] [ j ] = graph [ i ] [ j ] ; } } for ( int k = 0 ; k < V_NUM ; k ++ ) { for ( int i = 0 ; i < V_NUM ; i ++ ) { for ( int j = 0 ; j < V_NUM ; j ++ ) { if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) { dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] ; } } } } for ( int i = 0 ; i < V_NUM ; i ++ ) { if ( dist [ i ] [ i ] < 0 ) { return true ; } } return false ; }
String lexNext ( String str , int n ) { char [ ] s = str . toCharArray ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] != ' z ' ) { s [ i ] ++ ; return String . valueOf ( s ) ; } s [ i ] = ' a ' ; } return null ; }
void printDuo ( String str ) { int [ ] countChar = new int [ MAX_CHAR ] ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { countChar [ str . charAt ( i ) - ' a ' ] ++ ; } StringBuilder str1 = new StringBuilder ( ) ; StringBuilder str2 = new StringBuilder ( ) ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( countChar [ i ] > 1 ) { str2. append ( ( char ) ( i + ' a ' ) ) ; } else if ( countChar [ i ] == 1 ) { str1. append ( ( char ) ( i + ' a ' ) ) ; } } System . out . println ( " String ▁ with ▁ characters ▁ occurring ▁ " + " once : " ) ; System . out . println ( str1. toString ( ) ) ; System . out . println ( " String ▁ with ▁ characters ▁ occurring ▁ multiple ▁ times : " ) ; System . out . println ( str2. toString ( ) ) ; }
void roundOff ( double n0 , double n ) { int h ; double b , c , d , e , i , j , m , f ; b = n ; c = Math . floor ( n ) ; for ( i = 0 ; b >= 1 ; ++ i ) { b = b / 10 ; } d = n - i ; b = n ; b = b * Math . pow ( 10 , d ) ; e = b + 0.5 ; if ( ( float ) e == ( float ) Math . ceil ( b ) ) { f = Math . ceil ( b ) ; h = ( int ) ( f - 2 ) ; if ( h % 2 != 0 ) { e = e - 1 ; } } j = Math . floor ( e ) ; m = Math . pow ( 10 , d ) ; j = j / m ; System . out . println ( " The ▁ number ▁ after ▁ rounding - off ▁ is ▁ " + j ) ; }
void printRotatedString ( String str ) { int len = str . length ( ) ; StringBuffer temp ; for ( int i = 0 ; i < len ; i ++ ) { temp = new StringBuffer ( ) ; int j = i ; int k = 0 ; while ( j < len ) { temp . insert ( k , str . charAt ( j ) ) ; k ++ ; j ++ ; } j = 0 ; while ( j < i ) { temp . insert ( k , str . charAt ( j ) ) ; j ++ ; k ++ ; } System . out . println ( temp ) ; } }
int difference ( int [ ] [ ] arr , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) { d1 += arr [ i ] [ j ] ; } if ( i == n - j - 1 ) { d2 += arr [ i ] [ j ] ; } } } return Math . abs ( d1 - d2 ) ; }
int calculate ( String n ) { int len = n . length ( ) ; int l = len / 2 ; int count = 0 ; for ( int i = 1 ; i <= l ; i ++ ) { String s = n . substring ( 0 , i ) ; int l1 = s . length ( ) ; String t = n . substring ( i , l1 + i ) ; if ( s . charAt ( 0 ) == ' 0 ' || t . charAt ( 0 ) == ' 0 ' ) { continue ; } if ( s . compareTo ( t ) == 0 ) { count ++ ; } } return count ; }
int printUnion ( int [ ] arr1 , int [ ] arr2 , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) { System . out . print ( arr1 [ i ++ ] + " ▁ " ) ; } else if ( arr2 [ j ] < arr1 [ i ] ) { System . out . print ( arr2 [ j ++ ] + " ▁ " ) ; } else { System . out . print ( arr2 [ j ++ ] + " ▁ " ) ; i ++ ; } } while ( i < m ) { System . out . print ( arr1 [ i ++ ] + " ▁ " ) ; } while ( j < n ) { System . out . print ( arr2 [ j ++ ] + " ▁ " ) ; } return 0 ; }
void printDistinct ( String str ) { int n = str . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; int [ ] index = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { index [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { char x = str . charAt ( i ) ; ++ count [ x ] ; if ( count [ x ] == 1 && x != ' ▁ ' ) { index [ x ] = i ; } if ( count [ x ] == 2 ) { index [ x ] = n ; } } Arrays . sort ( index ) ; for ( int i = 0 ; i < MAX_CHAR && index [ i ] != n ; i ++ ) { System . out . print ( str . charAt ( index [ i ] ) ) ; } }
int findCommon ( int [ ] [ ] mat ) { int [ ] column = new int [ M ] ; for ( int i = 0 ; i < M ; i ++ ) { column [ i ] = N - 1 ; } int minRow = 0 ; while ( column [ minRow ] >= 0 ) { for ( int i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] < mat [ minRow ] [ column [ minRow ] ] ) { minRow = i ; } } int eqCount = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] > mat [ minRow ] [ column [ minRow ] ] ) { if ( column [ i ] == 0 ) { return - 1 ; } column [ i ] -= 1 ; } else { eqCount ++ ; } } if ( eqCount == M ) { return mat [ minRow ] [ column [ minRow ] ] ; } } return - 1 ; }
double polygonArea ( double [ ] x , double [ ] y , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( x [ j ] + x [ i ] ) * ( y [ j ] - y [ i ] ) ; j = i ; } return Math . abs ( area / 2.0 ) ; }
int maxProfit ( int [ ] price , int n , int k ) { int [ ] [ ] profit = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= k ; i ++ ) { profit [ i ] [ 0 ] = 0 ; } for ( int j = 0 ; j <= n ; j ++ ) { profit [ 0 ] [ j ] = 0 ; } for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { int maxSoFar = Integer . MIN_VALUE ; for ( int m = 0 ; m < j ; m ++ ) { maxSoFar = Math . max ( maxSoFar , price [ j ] - price [ m ] + profit [ i - 1 ] [ m ] ) ; } profit [ i ] [ j ] = Math . max ( profit [ i ] [ j - 1 ] , maxSoFar ) ; } } return profit [ k ] [ n - 1 ] ; }
boolean match ( String first , String second ) { if ( first . length ( ) == 0 && second . length ( ) == 0 ) { return true ; } if ( first . length ( ) > 1 && first . charAt ( 0 ) == ' * ' && second . length ( ) == 0 ) { return false ; } if ( ( first . length ( ) > 1 && first . charAt ( 0 ) == ' ? ' ) || ( first . length ( ) != 0 && second . length ( ) != 0 && first . charAt ( 0 ) == second . charAt ( 0 ) ) ) { return match ( first . substring ( 1 ) , second . substring ( 1 ) ) ; } if ( first . length ( ) > 0 && first . charAt ( 0 ) == ' * ' ) { return match ( first . substring ( 1 ) , second ) || match ( first , second . substring ( 1 ) ) ; } return false ; }
int findSum ( int n , int k ) { int ans = 0 ; int y = n / k ; int x = n % k ; ans = ( k * ( k - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; }
boolean isPermutedMatrix ( int [ ] [ ] mat , int n ) { StringBuilder strCat = new StringBuilder ( ) ; for ( int i = 0 ; i < n ; i ++ ) { strCat . append ( " - " ) . append ( String . valueOf ( mat [ 0 ] [ i ] ) ) ; } strCat . append ( strCat ) ; for ( int i = 1 ; i < n ; i ++ ) { StringBuilder currStr = new StringBuilder ( ) ; for ( int j = 0 ; j < n ; j ++ ) { currStr . append ( " - " ) . append ( String . valueOf ( mat [ i ] [ j ] ) ) ; } if ( ! strCat . toString ( ) . contains ( currStr . toString ( ) ) ) { return false ; } } return true ; }
boolean isSparse ( int [ ] [ ] array , int m , int n ) { int counter = 0 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( array [ i ] [ j ] == 0 ) { ++ counter ; } } } return counter > ( ( m * n ) / 2 ) ; }
double findArea ( int r ) { return Math . PI * Math . pow ( r , 2 ) ; }
int countObtuseAngles ( int a , int b , int k ) { int c1 = b - a - 1 ; int c2 = k - b + a - 1 ; if ( c1 == c2 ) { return 0 ; } return Math . min ( c1 , c2 ) ; }
void counterClockSpiralPrint ( int m , int n , int [ ] [ ] arr ) { int k = 0 , l = 0 , cnt = 0 ; int total = m * n ; while ( k < m && l < n ) { if ( cnt == total ) { break ; } for ( int i = k ; i < m ; ++ i ) { System . out . print ( arr [ i ] [ l ] + " ▁ " ) ; cnt ++ ; } l ++ ; if ( cnt == total ) { break ; } for ( int i = l ; i < n ; ++ i ) { System . out . print ( arr [ m - 1 ] [ i ] + " ▁ " ) ; cnt ++ ; } m -- ; if ( cnt == total ) { break ; } if ( k < m ) { for ( int i = m - 1 ; i >= k ; -- i ) { System . out . print ( arr [ i ] [ n - 1 ] + " ▁ " ) ; cnt ++ ; } n -- ; } if ( cnt == total ) { break ; } if ( l < n ) { for ( int i = n - 1 ; i >= l ; -- i ) { System . out . print ( arr [ k ] [ i ] + " ▁ " ) ; cnt ++ ; } k ++ ; } } }
double numberOfTriangles ( int n ) { double ans = 2 * Math . pow ( 3 , n ) - 1 ; return ans ; }
int minMaxProduct ( int [ ] arr1 , int [ ] arr2 , int n1 , int n2 ) { Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; return arr1 [ n1 - 1 ] * arr2 [ 0 ] ; }
void timeToMeet ( double s , double v0 ) { double v = 3 * v0 / 2 ; double time = s / v ; System . out . println ( time ) ; }
int countToMake01Alternate ( String s ) { int result = 0 ; for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) { result ++ ; } } return result ; }
int printCountRec ( int dist ) { if ( dist < 0 ) { return 0 ; } if ( dist == 0 ) { return 1 ; } return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ; }
int computeAverage ( int a , int b ) { return ( a / 2 ) + ( b / 2 ) + ( ( a % 2 + b % 2 ) / 2 ) ; }
int countSubStr ( char [ ] str , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' 1 ' ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( str [ j ] == ' 1 ' ) { res ++ ; } } } } return res ; }
boolean isDivisibleBy10 ( String bin ) { int n = bin . length ( ) ; if ( bin . charAt ( n - 1 ) == ' 1 ' ) { return false ; } int sum = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( bin . charAt ( i ) == ' 1 ' ) { int posFromRight = n - i - 1 ; if ( posFromRight % 4 == 1 ) { sum = sum + 2 ; } else if ( posFromRight % 4 == 2 ) { sum = sum + 4 ; } else if ( posFromRight % 4 == 3 ) { sum = sum + 8 ; } else if ( posFromRight % 4 == 0 ) { sum = sum + 6 ; } } } if ( sum % 10 == 0 ) { return true ; } return false ; }
void search ( int [ ] arr , int low , int high ) { if ( low > high ) { return ; } if ( low == high ) { System . out . println ( " The ▁ required ▁ element ▁ is ▁ " + arr [ low ] ) ; return ; } int mid = ( low + high ) / 2 ; if ( mid % 2 == 0 ) { if ( arr [ mid ] == arr [ mid + 1 ] ) { search ( arr , mid + 2 , high ) ; } else { search ( arr , low , mid ) ; } } else if ( mid % 2 == 1 ) { if ( arr [ mid ] == arr [ mid - 1 ] ) { search ( arr , mid + 1 , high ) ; } else { search ( arr , low , mid - 1 ) ; } } }
boolean find3Numbers ( int [ ] a , int arrSize , int sum ) { Arrays . sort ( a ) ; for ( int i = 0 ; i < arrSize - 2 ; i ++ ) { int l = i + 1 ; int r = arrSize - 1 ; while ( l < r ) { if ( a [ i ] + a [ l ] + a [ r ] == sum ) { System . out . print ( " Triplet ▁ is ▁ " + a [ i ] + " , ▁ " + a [ l ] + " , ▁ " + a [ r ] ) ; return true ; } else if ( a [ i ] + a [ l ] + a [ r ] < sum ) { l ++ ; } else { r -- ; } } } return false ; }
void makePermutation ( int [ ] a , int n ) { HashMap < Integer , Integer > count = new HashMap <> ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . containsKey ( a [ i ] ) ) { count . put ( a [ i ] , count . get ( a [ i ] ) + 1 ) ; } else { count . put ( a [ i ] , 1 ) ; } } int nextMissing = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . containsKey ( a [ i ] ) && count . get ( a [ i ] ) != 1 || a [ i ] > n || a [ i ] < 1 ) { count . put ( a [ i ] , count . get ( a [ i ] ) - 1 ) ; while ( count . containsKey ( nextMissing ) ) { nextMissing ++ ; } a [ i ] = nextMissing ; count . put ( nextMissing , 1 ) ; } } }
int optimalStrategyOfGame ( int [ ] arr , int n ) { int [ ] [ ] table = new int [ n ] [ n ] ; for ( int gap = 0 ; gap < n ; ++ gap ) { for ( int i = 0 , j = gap ; j < n ; ++ i , ++ j ) { int x = ( i + 2 <= j ) ? table [ i + 2 ] [ j ] : 0 ; int y = ( i + 1 <= j - 1 ) ? table [ i + 1 ] [ j - 1 ] : 0 ; int z = ( i <= j - 2 ) ? table [ i ] [ j - 2 ] : 0 ; table [ i ] [ j ] = Math . max ( arr [ i ] + Math . min ( x , y ) , arr [ j ] + Math . min ( y , z ) ) ; } } return table [ 0 ] [ n - 1 ] ; }
long findSumSubsets ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; }
int seiresSum ( int n , int [ ] a ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; }
void interchangeFirstLast ( int [ ] [ ] m ) { int rows = n ; for ( int i = 0 ; i < n ; i ++ ) { int t = m [ 0 ] [ i ] ; m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] ; m [ rows - 1 ] [ i ] = t ; } }
int cutRod ( int [ ] price , int n ) { int [ ] val = new int [ n + 1 ] ; val [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int maxVal = Integer . MIN_VALUE ; for ( int j = 0 ; j < i ; j ++ ) { maxVal = Math . max ( maxVal , price [ j ] + val [ i - j - 1 ] ) ; } val [ i ] = maxVal ; } return val [ n ] ; }
void maxOverlap ( List < Integer > start , List < Integer > end ) { int n = start . size ( ) ; int maxA = start . stream ( ) . mapToInt ( v -> v ) . max ( ) . getAsInt ( ) ; int maxB = end . stream ( ) . mapToInt ( v -> v ) . max ( ) . getAsInt ( ) ; int maxC = Math . max ( maxA , maxB ) ; int [ ] x = new int [ maxC + 2 ] ; int cur = 0 , idx = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ++ x [ start . get ( i ) ] ; -- x [ end . get ( i ) + 1 ] ; } int maxY = Integer . MIN_VALUE ; for ( int i = 0 ; i <= maxC ; i ++ ) { cur += x [ i ] ; if ( maxY < cur ) { maxY = cur ; idx = i ; } } System . out . println ( " Maximum ▁ value ▁ is : " + maxY + " ▁ at ▁ position : ▁ " + idx + " " ) ; }
boolean canFormPalindrome ( String str ) { List < Character > list = new ArrayList <> ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( list . contains ( str . charAt ( i ) ) ) { list . remove ( ( Character ) str . charAt ( i ) ) ; } else { list . add ( str . charAt ( i ) ) ; } } if ( ( str . length ( ) % 2 == 0 && list . isEmpty ( ) ) || ( str . length ( ) % 2 == 1 && list . size ( ) == 1 ) ) { return true ; } else { return false ; } }
int fib ( int n , int a , int b ) { if ( n == 0 ) { return a ; } if ( n == 1 ) { return b ; } return fib ( n - 1 , b , a + b ) ; }
int countPairs ( int [ ] a , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( a [ i ] & a [ j ] ) == 0 ) { count += 2 ; } } } return count ; }
void kMax ( int [ ] arr , int k , int n ) { for ( int c = 0 ; c < k ; c ++ ) { int maxSoFar = Integer . MIN_VALUE ; int maxHere = 0 , start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { maxHere += arr [ i ] ; if ( maxSoFar < maxHere ) { maxSoFar = maxHere ; start = s ; end = i ; } if ( maxHere < 0 ) { maxHere = 0 ; s = i + 1 ; } } System . out . println ( " Maximum ▁ non - overlapping ▁ sub - arraysum " + ( c + 1 ) + " : ▁ " + maxSoFar + " , ▁ starting ▁ index : ▁ " + start + " , ▁ ending ▁ index : ▁ " + end + " . " ) ; for ( int l = start ; l <= end ; l ++ ) { arr [ l ] = Integer . MIN_VALUE ; } } System . out . println ( ) ; }
int minimumCostOfBreaking ( Integer [ ] x , Integer [ ] y , int m , int n ) { int res = 0 ; Arrays . sort ( x , Collections . reverseOrder ( ) ) ; Arrays . sort ( y , Collections . reverseOrder ( ) ) ; int hzntl = 1 , vert = 1 ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( x [ i ] > y [ j ] ) { res += x [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += y [ j ] * hzntl ; vert ++ ; j ++ ; } } int total = 0 ; while ( i < m ) { total += x [ i ++ ] ; } res += total * vert ; total = 0 ; while ( j < n ) { total += y [ j ++ ] ; } res += total * hzntl ; return res ; }
int kSmallest ( int [ ] arr , int n , int k ) { int [ ] b = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ arr [ i ] ] = 1 ; } for ( int j = 1 ; j < MAX ; j ++ ) { if ( b [ j ] != 1 ) { k -- ; } if ( k == 0 ) { return j ; } } return Integer . MAX_VALUE ; }
int minPalPartion ( String str ) { int n = str . length ( ) ; int [ ] c = new int [ n ] ; boolean [ ] [ ] p = new boolean [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { p [ i ] [ i ] = true ; } for ( int l = 2 ; l <= n ; l ++ ) { for ( int i = 0 ; i < n - l + 1 ; i ++ ) { int j = i + l - 1 ; if ( l == 2 ) { p [ i ] [ j ] = str . charAt ( i ) == str . charAt ( j ) ; } else { p [ i ] [ j ] = str . charAt ( i ) == str . charAt ( j ) && p [ i + 1 ] [ j - 1 ] ; } } } for ( int i = 0 ; i < n ; i ++ ) { if ( p [ 0 ] [ i ] == true ) { c [ i ] = 0 ; } else { c [ i ] = Integer . MAX_VALUE ; for ( int j = 0 ; j < i ; j ++ ) { if ( p [ j + 1 ] [ i ] == true && 1 + c [ j ] < c [ i ] ) { c [ i ] = 1 + c [ j ] ; } } } } return c [ n - 1 ] ; }
boolean isProduct ( int [ ] arr , int n , int x ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] * arr [ j ] == x ) { return true ; } } } return false ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += i * ( n - i ) ; } return 2 * sum ; }
void printLevels ( List < Integer > [ ] graph , int v , int x ) { int [ ] level = new int [ v ] ; boolean [ ] marked = new boolean [ v ] ; Queue < Integer > que = new ArrayDeque <> ( ) ; que . add ( x ) ; level [ x ] = 0 ; marked [ x ] = true ; while ( que . size ( ) > 0 ) { x = que . peek ( ) ; que . remove ( ) ; for ( int i = 0 ; i < graph [ x ] . size ( ) ; i ++ ) { int b = graph [ x ] . get ( i ) ; if ( ! marked [ b ] ) { que . add ( b ) ; level [ b ] = level [ x ] + 1 ; marked [ b ] = true ; } } } System . out . println ( " Nodes " + " ▁ " + " Level " ) ; for ( int i = 0 ; i < v ; i ++ ) { System . out . println ( " ▁ " + i + " ▁ - - > ▁ " + level [ i ] ) ; } }
int numOfWays ( int n , int k ) { int p = 1 ; if ( k % 2 != 0 ) { p = - 1 ; } return ( int ) ( Math . pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ; }
int dealnnoy ( int n , int m ) { if ( m == 0 || n == 0 ) { return 1 ; } return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) ; }
boolean subArrayExists ( int [ ] arr , int n ) { HashSet < Integer > sumSet = new HashSet <> ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum == 0 || sumSet . contains ( sum ) ) { return true ; } sumSet . add ( sum ) ; } return false ; }
void merge ( int [ ] ar1 , int [ ] ar2 , int m , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int j , last = ar1 [ m - 1 ] ; for ( j = m - 2 ; j >= 0 && ar1 [ j ] > ar2 [ i ] ; j -- ) { ar1 [ j + 1 ] = ar1 [ j ] ; } if ( j != m - 2 || last > ar2 [ i ] ) { ar1 [ j + 1 ] = ar2 [ i ] ; ar2 [ i ] = last ; } } }
void longestString ( String str1 , String str2 ) { int [ ] count1 = new int [ 26 ] , count2 = new int [ 26 ] ; for ( int i = 0 ; i < str1. length ( ) ; i ++ ) { count1 [ str1. charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < str2. length ( ) ; i ++ ) { count2 [ str2. charAt ( i ) - ' a ' ] ++ ; } StringBuilder result = new StringBuilder ( ) ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 1 ; j <= Math . min ( count1 [ i ] , count2 [ i ] ) ; j ++ ) { result . append ( ( char ) ( ' a ' + i ) ) ; } } System . out . println ( result ) ; }
int fact ( int n ) { if ( n == 0 ) { return 1 ; } return n * fact ( n - 1 ) ; }
String decodeMedianString ( String s ) { int l = s . length ( ) ; StringBuilder s1 = new StringBuilder ( ) ; boolean isEven = ( l % 2 == 0 ) ? true : false ; for ( int i = 0 ; i < l ; i += 2 ) { if ( isEven ) { s1. insert ( 0 , s . charAt ( i ) ) ; s1. append ( s . charAt ( i + 1 ) ) ; } else { if ( l - i > 1 ) { s1. append ( s . charAt ( i ) ) ; s1. insert ( 0 , s . charAt ( i + 1 ) ) ; } else { s1. append ( s . charAt ( i ) ) ; } } } return s1. toString ( ) ; }
int maximumPath ( int [ ] [ ] mat ) { int result = 0 ; int [ ] [ ] dp = new int [ N ] [ N + 2 ] ; for ( int i = 0 ; i < N ; i ++ ) { dp [ 0 ] [ i + 1 ] = mat [ 0 ] [ i ] ; } for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j - 1 ] , Math . max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + mat [ i ] [ j - 1 ] ; } } for ( int i = 0 ; i <= N ; i ++ ) { result = Math . max ( result , dp [ N - 1 ] [ i ] ) ; } return result ; }
int minSwap ( int [ ] arr , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] <= k ) { ++ count ; } } int bad = 0 ; for ( int i = 0 ; i < count ; ++ i ) { if ( arr [ i ] > k ) { ++ bad ; } } int ans = bad ; for ( int i = 0 , j = count ; j < n ; ++ i , ++ j ) { if ( arr [ i ] > k ) { -- bad ; } if ( arr [ j ] > k ) { ++ bad ; } ans = Math . min ( ans , bad ) ; } return ans ; }
void decToOctal ( int n ) { int [ ] octalNum = new int [ 100 ] ; int i = 0 ; while ( n != 0 ) { octalNum [ i ] = n % 8 ; n = n / 8 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) { System . out . print ( octalNum [ j ] ) ; } }
int sumOfDigitsFrom1ToN ( int n ) { if ( n < 10 ) { return n * ( n + 1 ) / 2 ; } int d = ( int ) ( Math . log10 ( n ) ) ; int [ ] a = new int [ d + 1 ] ; a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( int i = 2 ; i <= d ; i ++ ) { a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( Math . ceil ( Math . pow ( 10 , i - 1 ) ) ) ; } int p = ( int ) ( Math . ceil ( Math . pow ( 10 , d ) ) ) ; int msd = n / p ; return msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ; }
double volTetra ( int side ) { double volume = Math . pow ( side , 3 ) / ( 6 * Math . sqrt ( 2 ) ) ; return volume ; }
void myCopy ( char [ ] s1 , char [ ] s2 , int index ) { s2 [ index ] = s1 [ index ] ; if ( index == s1. length - 1 ) { return ; } myCopy ( s1 , s2 , index + 1 ) ; }
int findFlips ( String str , int n ) { char last = ' ▁ ' ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( last != str . charAt ( i ) ) { res ++ ; } last = str . charAt ( i ) ; } return res / 2 ; }
void interLeaveQueue ( Queue < Integer > q ) { if ( q . size ( ) % 2 != 0 ) { System . out . println ( " Input ▁ even ▁ number ▁ of ▁ integers . " ) ; } Stack < Integer > s = new Stack <> ( ) ; int halfSize = q . size ( ) / 2 ; for ( int i = 0 ; i < halfSize ; i ++ ) { s . push ( q . peek ( ) ) ; q . poll ( ) ; } while ( ! s . empty ( ) ) { q . add ( s . peek ( ) ) ; s . pop ( ) ; } for ( int i = 0 ; i < halfSize ; i ++ ) { q . add ( q . peek ( ) ) ; q . poll ( ) ; } for ( int i = 0 ; i < halfSize ; i ++ ) { s . push ( q . peek ( ) ) ; q . poll ( ) ; } while ( ! s . empty ( ) ) { q . add ( s . peek ( ) ) ; s . pop ( ) ; q . add ( q . peek ( ) ) ; q . poll ( ) ; } }
void oddEvenSort ( int [ ] arr , int n ) { boolean isSorted = false ; while ( ! isSorted ) { isSorted = true ; for ( int i = 1 ; i <= n - 2 ; i = i + 2 ) { if ( arr [ i ] > arr [ i + 1 ] ) { int temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; isSorted = false ; } } for ( int i = 0 ; i <= n - 2 ; i = i + 2 ) { if ( arr [ i ] > arr [ i + 1 ] ) { int temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; isSorted = false ; } } } return ; }
int shortestSeq ( String s , String t ) { int m = s . length ( ) , n = t . length ( ) ; int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { dp [ i ] [ 0 ] = 1 ; } for ( int i = 0 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = MAX ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { char ch = s . charAt ( i - 1 ) ; int k ; for ( k = j - 1 ; k >= 0 ; k -- ) { if ( t . charAt ( k ) == ch ) { break ; } } if ( k == - 1 ) { dp [ i ] [ j ] = 1 ; } else { dp [ i ] [ j ] = Math . min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 ) ; } } } int ans = dp [ m ] [ n ] ; if ( ans >= MAX ) { ans = - 1 ; } return ans ; }
int findLongestConseqSubseq ( int [ ] arr , int n ) { HashSet < Integer > s = new HashSet <> ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( arr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ! s . contains ( arr [ i ] - 1 ) ) { int j = arr [ i ] ; while ( s . contains ( j ) ) { j ++ ; } ans = Math . max ( ans , j - arr [ i ] ) ; } } return ans ; }
void printPowerSet ( char [ ] set , int setSize ) { long powSetSize = ( long ) Math . pow ( 2 , setSize ) ; for ( int counter = 0 ; counter < powSetSize ; counter ++ ) { for ( int j = 0 ; j < setSize ; j ++ ) { if ( ( counter & ( 1 << j ) ) != 0 ) { System . out . print ( set [ j ] ) ; } } System . out . println ( ) ; } }
int getMissingNo ( int [ ] a , int n ) { int x1 = a [ 0 ] ; int x2 = 1 ; for ( int i = 1 ; i < n ; i ++ ) { x1 = x1 ^ a [ i ] ; } for ( int i = 2 ; i <= n + 1 ; i ++ ) { x2 = x2 ^ i ; } return x1 ^ x2 ; }
void printRotatedString ( String str ) { int n = str . length ( ) ; String temp = str + str ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j != n ; j ++ ) { System . out . print ( temp . charAt ( i + j ) ) ; } System . out . println ( ) ; } }
int getMaxGold ( int [ ] [ ] gold , int m , int n ) { int [ ] [ ] goldTable = new int [ m ] [ n ] ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) { int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; int rightUp = ( row == 0 || col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; int rightDown = ( row == m - 1 || col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + Math . max ( right , Math . max ( rightUp , rightDown ) ) ; ; } } int res = goldTable [ 0 ] [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) { res = Math . max ( res , goldTable [ i ] [ 0 ] ) ; } return res ; }
int possibleWays ( int n , int m , int k ) { int [ ] [ ] dp = new int [ N ] [ N ] ; int [ ] [ ] preSum = new int [ N ] [ N ] ; for ( int i = 1 ; i < n + 1 ; i ++ ) { dp [ 0 ] [ i ] = 0 ; preSum [ 0 ] [ i ] = 1 ; } for ( int i = 0 ; i < m + 1 ; i ++ ) { preSum [ i ] [ 0 ] = dp [ i ] [ 0 ] = 1 ; } for ( int i = 1 ; i < m + 1 ; i ++ ) { for ( int j = 1 ; j < n + 1 ; j ++ ) { dp [ i ] [ j ] = preSum [ i - 1 ] [ j ] ; if ( j > k ) { dp [ i ] [ j ] -= preSum [ i - 1 ] [ j - k - 1 ] ; } } for ( int j = 1 ; j < n + 1 ; j ++ ) { preSum [ i ] [ j ] = dp [ i ] [ j ] + preSum [ i ] [ j - 1 ] ; } } return dp [ m ] [ n ] ; }
void findRoots ( int a , int b , int c ) { if ( a == 0 ) { System . out . println ( " Invalid " ) ; return ; } int d = b * b - 4 * a * c ; double sqrtVal = Math . sqrt ( Math . abs ( d ) ) ; if ( d > 0 ) { System . out . println ( " Roots ▁ are ▁ real ▁ and ▁ different ▁ " ) ; System . out . println ( ( - b + sqrtVal ) / ( 2 * a ) ) ; System . out . println ( ( - b - sqrtVal ) / ( 2 * a ) ) ; } else if ( d == 0 ) { System . out . println ( " Roots ▁ are ▁ real ▁ and ▁ same ▁ " ) ; System . out . println ( - ( double ) b / ( 2 * a ) ) ; } else { System . out . println ( " Roots ▁ are ▁ complex ▁ " ) ; System . out . println ( - ( double ) b / ( 2 * a ) + " ▁ + ▁ i " + sqrtVal ) ; System . out . println ( - ( double ) b / ( 2 * a ) + " ▁ - ▁ i " + sqrtVal ) ; } }
int binaryToDecimal ( int n ) { int num = n ; int decValue = 0 ; int base = 1 ; int temp = num ; while ( temp > 0 ) { int lastDigit = temp % 10 ; temp = temp / 10 ; decValue += lastDigit * base ; base = base * 2 ; } return decValue ; }
int sum ( int [ ] a , int n ) { HashMap < Integer , Integer > cnt = new HashMap <> ( ) ; int ans = 0 , preSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += ( i * a [ i ] ) - preSum ; preSum += a [ i ] ; if ( cnt . containsKey ( a [ i ] - 1 ) ) { ans -= cnt . get ( a [ i ] - 1 ) ; } if ( cnt . containsKey ( a [ i ] + 1 ) ) { ans += cnt . get ( a [ i ] + 1 ) ; } cnt . put ( a [ i ] , cnt . getOrDefault ( a [ i ] , 0 ) + 1 ) ; } return ans ; }
int minimumSquare ( int m , int n ) { int verticalMin = Integer . MAX_VALUE ; int horizontalMin = Integer . MAX_VALUE ; if ( m == n ) { return 1 ; } if ( dp [ m ] [ n ] != 0 ) { return dp [ m ] [ n ] ; } for ( int i = 1 ; i <= m / 2 ; i ++ ) { horizontalMin = Math . min ( minimumSquare ( i , n ) + minimumSquare ( m - i , n ) , horizontalMin ) ; } for ( int j = 1 ; j <= n / 2 ; j ++ ) { verticalMin = Math . min ( minimumSquare ( m , j ) + minimumSquare ( m , n - j ) , verticalMin ) ; } dp [ m ] [ n ] = Math . min ( verticalMin , horizontalMin ) ; return dp [ m ] [ n ] ; }
void cycleSort ( int [ ] arr , int n ) { int writes = 0 ; for ( int cycleStart = 0 ; cycleStart <= n - 2 ; cycleStart ++ ) { int item = arr [ cycleStart ] ; int pos = cycleStart ; for ( int i = cycleStart + 1 ; i < n ; i ++ ) { if ( arr [ i ] < item ) { pos ++ ; } } if ( pos == cycleStart ) { continue ; } while ( item == arr [ pos ] ) { pos += 1 ; } if ( pos != cycleStart ) { int temp = item ; item = arr [ pos ] ; arr [ pos ] = temp ; writes ++ ; } while ( pos != cycleStart ) { pos = cycleStart ; for ( int i = cycleStart + 1 ; i < n ; i ++ ) { if ( arr [ i ] < item ) { pos += 1 ; } } while ( item == arr [ pos ] ) { pos += 1 ; } if ( item != arr [ pos ] ) { int temp = item ; item = arr [ pos ] ; arr [ pos ] = temp ; writes ++ ; } } } }
int countNonDecreasing ( int n ) { int [ ] [ ] dp = new int [ 10 ] [ n + 1 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { dp [ i ] [ 1 ] = 1 ; } for ( int digit = 0 ; digit <= 9 ; digit ++ ) { for ( int len = 2 ; len <= n ; len ++ ) { for ( int x = 0 ; x <= digit ; x ++ ) { dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] ; } } } int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { count += dp [ i ] [ n ] ; } return count ; }
int count ( int [ ] s , int m , int n ) { if ( n == 0 ) { return 1 ; } if ( n < 0 ) { return 0 ; } if ( m <= 0 && n >= 1 ) { return 0 ; } return count ( s , m - 1 , n ) + count ( s , m , n - s [ m - 1 ] ) ; }
void sectorArea ( double radius , double angle ) { if ( angle >= 360 ) { System . out . println ( " Angle ▁ not ▁ possible " ) ; } else { double sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; System . out . println ( sector ) ; } }
void kSwapMaximum ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) { int indexPosition = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( k <= j - i ) { break ; } if ( arr [ j ] > arr [ indexPosition ] ) { indexPosition = j ; } } for ( int j = indexPosition ; j > i ; -- j ) { int tmp = arr [ j ] ; arr [ j ] = arr [ j - 1 ] ; arr [ j - 1 ] = tmp ; } k -= indexPosition - i ; } }
int positionRightmostSetbit ( int n ) { int position = 1 ; int m = 1 ; while ( ( n & m ) == 0 ) { m = m << 1 ; position ++ ; } return position ; }
void findPairs ( int [ ] arr1 , int [ ] arr2 , int n , int m , int x ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] + arr2 [ j ] == x ) { System . out . println ( arr1 [ i ] + " ▁ " + arr2 [ j ] ) ; } } } }
int sparseSearch ( String [ ] arr , String x , int n ) { return binarySearch ( arr , 0 , n - 1 , x ) ; }
void printDiagonalSums ( int [ ] [ ] mat , int n ) { int principal = 0 , secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { principal += mat [ i ] [ i ] ; secondary += mat [ i ] [ n - i - 1 ] ; } System . out . println ( " Principal ▁ Diagonal : " + principal ) ; System . out . println ( " Secondary ▁ Diagonal : " + secondary ) ; }
int countSeq ( int n , int diff ) { if ( Math . abs ( diff ) > n ) { return 0 ; } if ( n == 1 && diff == 0 ) { return 2 ; } if ( n == 1 && Math . abs ( diff ) == 1 ) { return 1 ; } int res = countSeq ( n - 1 , diff + 1 ) + 2 * countSeq ( n - 1 , diff ) + countSeq ( n - 1 , diff - 1 ) ; return res ; }
void transpose ( int [ ] [ ] a , int [ ] [ ] b ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < M ; j ++ ) { b [ i ] [ j ] = a [ j ] [ i ] ; } } }
int longestCommonSum ( int [ ] arr1 , int [ ] arr2 , int n ) { int maxLen = 0 ; int preSum1 = 0 , preSum2 = 0 ; int [ ] diff = new int [ 2 * n + 1 ] ; for ( int i = 0 ; i < diff . length ; i ++ ) { diff [ i ] = - 1 ; } for ( int i = 0 ; i < n ; i ++ ) { preSum1 += arr1 [ i ] ; preSum2 += arr2 [ i ] ; int currDiff = preSum1 - preSum2 ; int diffIndex = n + currDiff ; if ( currDiff == 0 ) { maxLen = i + 1 ; } else if ( diff [ diffIndex ] == - 1 ) { diff [ diffIndex ] = i ; } else { int len = i - diff [ diffIndex ] ; if ( len > maxLen ) { maxLen = len ; } } } return maxLen ; }
void shuffleArray ( int [ ] a , int n ) { for ( int i = 0 , q = 1 , k = n ; i < n ; i ++ , k ++ , q ++ ) { for ( int j = k ; j > i + q ; j -- ) { int temp = a [ j - 1 ] ; a [ j - 1 ] = a [ j ] ; a [ j ] = temp ; } } }
int findCount ( String str ) { int result = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( i == str . charAt ( i ) - ' a ' || i == str . charAt ( i ) - ' A ' ) { result ++ ; } } return result ; }
void printSumTricky ( int [ ] [ ] mat , int k ) { if ( k > n ) { return ; } int [ ] [ ] stripSum = new int [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) { sum += mat [ i ] [ j ] ; } stripSum [ 0 ] [ j ] = sum ; for ( int i = 1 ; i < n - k + 1 ; i ++ ) { sum += mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ; stripSum [ i ] [ j ] = sum ; } } for ( int i = 0 ; i < n - k + 1 ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) { sum += stripSum [ i ] [ j ] ; } System . out . print ( sum + " ▁ " ) ; for ( int j = 1 ; j < n - k + 1 ; j ++ ) { sum += stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ; System . out . print ( sum + " ▁ " ) ; } System . out . println ( ) ; } }
int countPairs ( String s ) { int [ ] cnt = new int [ MAX ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { cnt [ s . charAt ( i ) ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { ans += cnt [ i ] * cnt [ i ] ; } return ans ; }
int eulerian ( int n , int m ) { int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) { dp [ i ] [ j ] = 1 ; } else { dp [ i ] [ j ] = ( i - j ) * dp [ i - 1 ] [ j - 1 ] + ( j + 1 ) * dp [ i - 1 ] [ j ] ; } } } } return dp [ n ] [ m ] ; }
int countWords ( String str ) { int state = OUT ; int wc = 0 ; int i = 0 ; while ( i < str . length ( ) ) { if ( str . charAt ( i ) == ' ▁ ' || str . charAt ( i ) == ' \ n ' || str . charAt ( i ) == ' \ t ' ) { state = OUT ; } else if ( state == OUT ) { state = IN ; ++ wc ; } ++ i ; } return wc ; }
int findPossibleMoves ( int [ ] [ ] mat , int p , int q ) { int [ ] xs = { 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 } ; int [ ] ys = { 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 } ; int count = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { int x = p + xs [ i ] ; int y = q + ys [ i ] ; if ( x >= 0 && y >= 0 && x < n && y < m && mat [ x ] [ y ] == 0 ) { count ++ ; } } return count ; }
int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
boolean pythagoreanQuadruple ( int a , int b , int c , int d ) { int sum = a * a + b * b + c * c ; if ( d * d == sum ) { return true ; } else { return false ; } }
void performQueries ( List < Integer > a , List < Pair < Long , Integer >> vec ) { List < Integer > ans = new ArrayList <> ( ) ; int n = a . size ( ) - 1 ; int q = vec . size ( ) ; for ( int i = 0 ; i < q ; ++ i ) { long t = vec . get ( i ) . getValue0 ( ) ; int m = vec . get ( i ) . getValue1 ( ) ; if ( m > n ) { ans . add ( - 1 ) ; continue ; } int turn = ( int ) ( t / n ) ; int rem = ( int ) ( t % n ) ; if ( rem == 0 && turn % 2 == 1 ) { ans . add ( - 1 ) ; continue ; } if ( rem == 0 && turn % 2 == 0 ) { ans . add ( a . get ( m ) ) ; continue ; } if ( turn % 2 == 0 ) { int curSize = n - rem ; if ( curSize < m ) { ans . add ( - 1 ) ; continue ; } ans . add ( a . get ( m + rem ) ) ; } else { int curSize = rem ; if ( curSize < m ) { ans . add ( - 1 ) ; continue ; } ans . add ( a . get ( m ) ) ; } } for ( int i : ans ) { System . out . println ( i ) ; } }
int findSum ( int [ ] arr , int n ) { int sum = 0 ; HashSet < Integer > s = new HashSet <> ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! s . contains ( arr [ i ] ) ) { sum += arr [ i ] ; s . add ( arr [ i ] ) ; } } return sum ; }
int count9s ( String number ) { int n = number . length ( ) ; int [ ] d = new int [ 9 ] ; d [ 0 ] = 1 ; int result = 0 , modSum = 0 , continuousZero = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( number . charAt ( i ) - ' 0 ' ) == 0 ) { continuousZero ++ ; } else { continuousZero = 0 ; } modSum += ( number . charAt ( i ) - ' 0 ' ) ; modSum %= 9 ; result += d [ modSum ] ; d [ modSum ] ++ ; result -= continuousZero ; } return result ; }
boolean areDisjoint ( int [ ] set1 , int [ ] set2 , int m , int n ) { for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( set1 [ i ] == set2 [ j ] ) { return false ; } } } return true ; }
int getNthUglyNo ( int n ) { int [ ] ugly = new int [ n ] ; int i2 = 0 , i3 = 0 , i5 = 0 ; int nextMultipleOf2 = 2 ; int nextMultipleOf3 = 3 ; int nextMultipleOf5 = 5 ; int nextUglyNo = 1 ; ugly [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { nextUglyNo = Math . min ( nextMultipleOf2 , Math . min ( nextMultipleOf3 , nextMultipleOf5 ) ) ; ugly [ i ] = nextUglyNo ; if ( nextUglyNo == nextMultipleOf2 ) { i2 = i2 + 1 ; nextMultipleOf2 = ugly [ i2 ] * 2 ; } if ( nextUglyNo == nextMultipleOf3 ) { i3 = i3 + 1 ; nextMultipleOf3 = ugly [ i3 ] * 3 ; } if ( nextUglyNo == nextMultipleOf5 ) { i5 = i5 + 1 ; nextMultipleOf5 = ugly [ i5 ] * 5 ; } } return nextUglyNo ; }
int binarySearch ( int [ ] arr , int left , int right ) { if ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) { return mid ; } if ( arr [ mid ] < arr [ mid + 1 ] ) { return binarySearch ( arr , mid + 1 , right ) ; } else { return binarySearch ( arr , left , mid - 1 ) ; } } return - 1 ; }
int minTime ( int [ ] arr , int n ) { if ( n <= 0 ) { return 0 ; } int incl = arr [ 0 ] ; int excl = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int inclNew = arr [ i ] + Math . min ( excl , incl ) ; int exclNew = incl ; incl = inclNew ; excl = exclNew ; } return Math . min ( incl , excl ) ; }
int findLength ( String str , int n ) { int currentSum = 0 ; int maxSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currentSum += ( str . charAt ( i ) == ' 0 ' ? 1 : - 1 ) ; if ( currentSum < 0 ) { currentSum = 0 ; } maxSum = Math . max ( currentSum , maxSum ) ; } return maxSum == 0 ? - 1 : maxSum ; }
int modInverse ( int a , int m ) { int m0 = m ; int y = 0 , x = 1 ; if ( m == 1 ) { return 0 ; } while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m ; a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) { x += m0 ; } return x ; }
boolean isPrime ( int n ) { if ( n <= 1 ) { return false ; } for ( int i = 2 ; i < n ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; }
void find3largest ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int check = 0 , count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( count < 4 ) { if ( check != arr [ n - i ] ) { System . out . print ( arr [ n - i ] + " ▁ " ) ; check = arr [ n - i ] ; count ++ ; } } else { break ; } } }
void countCurrency ( int amount ) { int [ ] notes = new int [ ] { 2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 } ; int [ ] noteCounter = new int [ 9 ] ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( amount >= notes [ i ] ) { noteCounter [ i ] = amount / notes [ i ] ; amount = amount - noteCounter [ i ] * notes [ i ] ; } } System . out . println ( " Currency ▁ Count ▁ - > " ) ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( noteCounter [ i ] != 0 ) { System . out . println ( notes [ i ] + " ▁ : ▁ " + noteCounter [ i ] ) ; } } }
void translate ( char [ ] str ) { for ( int i = 1 ; i < str . length ; i ++ ) { if ( str [ i - 1 ] == ' A ' && str [ i ] == ' B ' ) { str [ i - 1 ] = ' C ' ; int j ; for ( j = i ; j < str . length - 1 ; j ++ ) { str [ j ] = str [ j + 1 ] ; } str [ j ] = ' ▁ ' ; } } return ; }
void printMinNumberForPattern ( String arr ) { int currMax = 0 ; int lastEntry = 0 ; for ( int i = 0 ; i < arr . length ( ) ; i ++ ) { int noOfNextD = 0 ; switch ( arr . charAt ( i ) ) { case ' I ' : int j = i + 1 ; while ( j < arr . length ( ) && arr . charAt ( j ) == ' D ' ) { noOfNextD ++ ; j ++ ; } if ( i == 0 ) { currMax = noOfNextD + 2 ; System . out . print ( " ▁ " + ++ lastEntry ) ; System . out . print ( " ▁ " + currMax ) ; lastEntry = currMax ; } else { currMax = currMax + noOfNextD + 1 ; lastEntry = currMax ; System . out . print ( " ▁ " + lastEntry ) ; } for ( int k = 0 ; k < noOfNextD ; k ++ ) { System . out . print ( " ▁ " + -- lastEntry ) ; i ++ ; } break ; case ' D ' : if ( i == 0 ) { int j = i + 1 ; while ( j < arr . length ( ) && arr . charAt ( j ) == ' D ' ) { noOfNextD ++ ; j ++ ; } currMax = noOfNextD + 2 ; System . out . print ( " ▁ " + currMax + " ▁ " + ( currMax - 1 ) ) ; lastEntry = currMax - 1 ; } else { System . out . print ( " ▁ " + ( lastEntry - 1 ) ) ; lastEntry -- ; } break ; } } System . out . println ( ) ; }
int countSubstr ( String s ) { int n = s . length ( ) ; int [ ] auxArr = new int [ n ] ; if ( s . charAt ( 0 ) == ' 1 ' ) { auxArr [ 0 ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' 1 ' ) { auxArr [ i ] = auxArr [ i - 1 ] + 1 ; } else { auxArr [ i ] = auxArr [ i - 1 ] ; } } int count = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == ' 1 ' ) { count += auxArr [ i ] ; } } return count ; }
int countDivisbleBy4 ( String s ) { int n = s . length ( ) ; int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( s . charAt ( i ) == ' 4 ' || s . charAt ( i ) == ' 8 ' || s . charAt ( i ) == ' 0 ' ) { count ++ ; } } for ( int i = 0 ; i < n - 1 ; ++ i ) { int h = ( s . charAt ( i ) - ' 0 ' ) * 10 + ( s . charAt ( i + 1 ) - ' 0 ' ) ; if ( h % 4 == 0 ) { count = count + i + 1 ; } } return count ; }
boolean areDisjoint ( int [ ] set1 , int [ ] set2 , int m , int n ) { int i = 0 , j = 0 ; Arrays . sort ( set1 ) ; Arrays . sort ( set2 ) ; while ( i < m && j < n ) { if ( set1 [ i ] < set2 [ j ] ) { i ++ ; } else if ( set1 [ i ] > set2 [ j ] ) { j ++ ; } else { return false ; } } return true ; }
long countStrs ( int n ) { long [ ] [ ] dp = new long [ n + 1 ] [ 27 ] ; for ( int i = 0 ; i <= 25 ; i ++ ) { dp [ 1 ] [ i ] = 1 ; } for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 25 ; j ++ ) { if ( j == 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; } else { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) ; } } } long sum = 0 ; for ( int i = 0 ; i <= 25 ; i ++ ) { sum = sum + dp [ n ] [ i ] ; } return sum ; }
int findCountOfSolutions ( int n , int p ) { int ans = 0 ; for ( int x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { int last = x + p * ( n / p ) ; if ( last > n ) { last -= p ; } ans += ( last - x ) / p + 1 ; } } return ans ; }
boolean checkJumbled ( int num ) { if ( num / 10 == 0 ) { return true ; } while ( num != 0 ) { if ( num / 10 == 0 ) { return true ; } int digit1 = num % 10 ; int digit2 = ( num / 10 ) % 10 ; if ( Math . abs ( digit2 - digit1 ) > 1 ) { return false ; } num = num / 10 ; } return true ; }
int maxProd ( int n ) { if ( n == 0 || n == 1 ) { return 0 ; } int maxVal = 0 ; for ( int i = 1 ; i < n ; i ++ ) { maxVal = Math . max ( maxVal , Math . max ( i * ( n - i ) , maxProd ( n - i ) * i ) ) ; } return maxVal ; }
String printNumbers ( int [ ] numbers , int n ) { List < Integer > oneTwoThree = new ArrayList <> ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( findContainsOneTwoThree ( numbers [ i ] ) ) { oneTwoThree . add ( numbers [ i ] ) ; } } Collections . sort ( oneTwoThree ) ; StringBuffer result = new StringBuffer ( ) ; for ( var number : oneTwoThree ) { int value = number ; if ( result . length ( ) > 0 ) { result . append ( " , ▁ " ) ; } result . append ( String . valueOf ( value ) ) ; } return ( result . length ( ) > 0 ) ? result . toString ( ) : " - 1 " ; }
int swapBits ( int x ) { int evenBits = x & 0xAAAAAAAA ; int oddBits = x & 0x55555555 ; evenBits >>= 1 ; oddBits <<= 1 ; return evenBits | oddBits ; }
int matrixChainOrder ( int [ ] p , int n ) { int [ ] [ ] m = new int [ n ] [ n ] ; for ( int i = 1 ; i < n ; i ++ ) { m [ i ] [ i ] = 0 ; } for ( int l = 2 ; l < n ; l ++ ) { for ( int i = 1 ; i < n - l + 1 ; i ++ ) { int j = i + l - 1 ; if ( j == n ) { continue ; } m [ i ] [ j ] = Integer . MAX_VALUE ; for ( int k = i ; k <= j - 1 ; k ++ ) { int q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) { m [ i ] [ j ] = q ; } } } } return m [ 1 ] [ n - 1 ] ; }
int minDifferenceAmongMaxMin ( int [ ] arr , int n , int k ) { Arrays . sort ( arr ) ; int res = Integer . MAX_VALUE ; for ( int i = 0 ; i <= n - k ; i ++ ) { int curSeqDiff = arr [ i + k - 1 ] - arr [ i ] ; res = Math . min ( res , curSeqDiff ) ; } return res ; }
int bellNumber ( int n ) { int [ ] [ ] bell = new int [ n + 1 ] [ n + 1 ] ; bell [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] ; for ( int j = 1 ; j <= i ; j ++ ) { bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] ; } } return bell [ n ] [ 0 ] ; }
int smallestSumSubarr ( int [ ] arr , int n ) { int minEndingHere = Integer . MAX_VALUE ; int minSoFar = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( minEndingHere > 0 ) { minEndingHere = arr [ i ] ; } else { minEndingHere += arr [ i ] ; } minSoFar = Math . min ( minSoFar , minEndingHere ) ; } return minSoFar ; }
int countDer ( int n ) { if ( n == 1 ) { return 0 ; } if ( n == 0 ) { return 1 ; } if ( n == 2 ) { return 1 ; } return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ; }
void myCopy ( char [ ] s1 , char [ ] s2 ) { for ( int i = 0 ; i < s1. length ; i ++ ) { s2 [ i ] = s1 [ i ] ; } }
int sumOfFactors ( int n ) { int res = 1 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { int currSum = 1 ; int currTerm = 1 ; while ( n % i == 0 ) { n = n / i ; currTerm *= i ; currSum += currTerm ; } res *= currSum ; } if ( n > 2 ) { res *= 1 + n ; } return res ; }
String convert ( String s ) { int n = s . length ( ) ; StringBuilder s1 = new StringBuilder ( ) ; s1 = s1. append ( Character . toLowerCase ( s . charAt ( 0 ) ) ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' ▁ ' && i < n ) { s1 = s1. append ( Character . toLowerCase ( s . charAt ( i + 1 ) ) ) ; i ++ ; } else { s1 = s1. append ( Character . toUpperCase ( s . charAt ( i ) ) ) ; } } return s1. toString ( ) ; }
void manipulatedSeive ( int N ) { isPrime . set ( 0 , false ) ; isPrime . set ( 1 , false ) ; for ( int i = 2 ; i < N ; i ++ ) { if ( isPrime . get ( i ) ) { prime . add ( i ) ; spf . set ( i , i ) ; } for ( int j = 0 ; j < prime . size ( ) && i * prime . get ( j ) < N && prime . get ( j ) <= spf . get ( i ) ; j ++ ) { isPrime . set ( i * prime . get ( j ) , false ) ; spf . set ( i * prime . get ( j ) , prime . get ( j ) ) ; } } }
long findDigits ( int n ) { if ( n < 0 ) { return 0 ; } if ( n <= 1 ) { return 1 ; } double x = n * Math . log10 ( n / Math . E ) + Math . log10 ( 2 * Math . PI * n ) / 2.0 ; return ( long ) Math . floor ( x ) + 1 ; }
int countSubSeq ( int [ ] a , int n , int m ) { int ans = 0 ; int [ ] h = new int [ m ] ; Arrays . fill ( h , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = a [ i ] % m ; h [ a [ i ] ] ++ ; } for ( int i = 0 ; i < m ; i ++ ) { for ( int j = i ; j < m ; j ++ ) { int rem = ( m - ( i + j ) % m ) % m ; if ( rem < j ) { continue ; } if ( i == j && rem == j ) { ans += h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6 ; } else if ( i == j ) { ans += h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 ; } else if ( i == rem ) { ans += h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 ; } else if ( rem == j ) { ans += h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2 ; } else { ans = ans + h [ i ] * h [ j ] * h [ rem ] ; } } } return ans ; }
void search ( String txt , String pat ) { int m = pat . length ( ) ; int n = txt . length ( ) ; for ( int i = 0 ; i <= n - m ; i ++ ) { int j ; for ( j = 0 ; j < m ; j ++ ) { if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) { break ; } } if ( j == m ) { System . out . println ( " Pattern ▁ found ▁ at ▁ index ▁ " + i ) ; } } }
long calculateSum ( int n ) { long sum = 0 ; for ( int row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; }
boolean isSubset ( int [ ] arr1 , int [ ] arr2 , int m , int n ) { int i = 0 , j = 0 ; if ( m < n ) { return false ; } Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; while ( i < n && j < m ) { if ( arr1 [ j ] < arr2 [ i ] ) { j ++ ; } else if ( arr1 [ j ] == arr2 [ i ] ) { j ++ ; i ++ ; } else if ( arr1 [ j ] > arr2 [ i ] ) { return false ; } } return ! ( i < n ) ; }
int getRemainder ( int num , int divisor ) { while ( num >= divisor ) { num -= divisor ; } return num ; }
int maxSum ( int [ ] arr , int n ) { int sum = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) { sum -= 2 * arr [ i ] ; sum += 2 * arr [ n - i - 1 ] ; } return sum ; }
int numOffBt ( int [ ] arr , int n ) { int maxValue = Integer . MIN_VALUE ; int minValue = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { maxValue = Math . max ( maxValue , arr [ i ] ) ; minValue = Math . min ( minValue , arr [ i ] ) ; } int [ ] mark = new int [ maxValue + 2 ] ; int [ ] value = new int [ maxValue + 2 ] ; Arrays . fill ( mark , 0 ) ; Arrays . fill ( value , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { mark [ arr [ i ] ] = 1 ; value [ arr [ i ] ] = 1 ; } int ans = 0 ; for ( int i = minValue ; i <= maxValue ; i ++ ) { if ( mark [ i ] != 0 ) { for ( int j = i + i ; j <= maxValue && j / i <= i ; j += i ) { if ( mark [ j ] == 0 ) { continue ; } value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] ) ; if ( i != j / i ) { value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] ) ; } } } ans += value [ i ] ; } return ans ; }
void printSpiral ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int x ; x = Math . min ( Math . min ( i , j ) , Math . min ( n - 1 - i , n - 1 - j ) ) ; if ( i <= j ) { System . out . print ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) + " \ t " ) ; } else { System . out . print ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) + " \ t " ) ; } } System . out . println ( ) ; } }
void printBinomial ( int max ) { for ( int m = 0 ; m <= max ; m ++ ) { System . out . print ( m + " ▁ " ) ; int binom = 1 ; for ( int x = 0 ; x <= m ; x ++ ) { if ( m != 0 && x != 0 ) { binom = binom * ( m - x + 1 ) / x ; } System . out . print ( binom + " ▁ " ) ; } System . out . println ( ) ; } }
int coutSubSeq ( int [ ] a , int n , int m ) { int sum = 0 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { sum = a [ i ] + a [ j ] + a [ k ] ; if ( sum % m == 0 ) { ans ++ ; } } } } return ans ; }
int solve ( int [ ] a , int [ ] b , int [ ] c , int i , int j , int k ) { int minDiff , currentDiff , maxTerm ; minDiff = Math . abs ( Math . max ( a [ i ] , Math . max ( b [ j ] , c [ k ] ) ) - Math . min ( a [ i ] , Math . min ( b [ j ] , c [ k ] ) ) ) ; while ( i != - 1 && j != - 1 && k != - 1 ) { currentDiff = Math . abs ( Math . max ( a [ i ] , Math . max ( b [ j ] , c [ k ] ) ) - Math . min ( a [ i ] , Math . min ( b [ j ] , c [ k ] ) ) ) ; if ( currentDiff < minDiff ) { minDiff = currentDiff ; } maxTerm = Math . max ( a [ i ] , Math . max ( b [ j ] , c [ k ] ) ) ; if ( a [ i ] == maxTerm ) { i -= 1 ; } else if ( b [ j ] == maxTerm ) { j -= 1 ; } else { k -= 1 ; } } return minDiff ; }
int maxSumDifference ( int [ ] a , int n ) { List < Integer > finalSequence = new ArrayList <> ( ) ; Arrays . sort ( a ) ; for ( int i = 0 ; i < n / 2 ; ++ i ) { finalSequence . add ( a [ i ] ) ; finalSequence . add ( a [ n - i - 1 ] ) ; } int maximumSum = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { maximumSum = maximumSum + Math . abs ( finalSequence . get ( i ) - finalSequence . get ( i + 1 ) ) ; } maximumSum = maximumSum + Math . abs ( finalSequence . get ( n - 1 ) - finalSequence . get ( 0 ) ) ; return maximumSum ; }
int numberOfSquares ( int base ) { base = base - 2 ; base = base / 2 ; return base * ( base + 1 ) / 2 ; }
double hexagonArea ( double s ) { return ( 3 * Math . sqrt ( 3 ) * ( s * s ) ) / 2 ; }
void drawPattern ( int n0 ) { int n = n0 ; int row = 1 ; int nst = 1 ; int nsp1 = n - 1 ; int nsp2 = - 1 ; int val1 = row ; int val2 = 1 ; while ( row <= n ) { int csp1 = 1 ; while ( csp1 <= nsp1 ) { System . out . print ( " ▁ ▁ " ) ; csp1 = csp1 + 1 ; } int cst1 = 1 ; while ( cst1 <= nst ) { System . out . print ( val1 + " ▁ " ) ; val1 = val1 - 1 ; cst1 = cst1 + 1 ; } int csp2 = 1 ; while ( csp2 <= nsp2 ) { System . out . print ( " ▁ ▁ " ) ; csp2 = csp2 + 1 ; } if ( row != 1 && row != n ) { int cst2 = 1 ; while ( cst2 <= nst ) { System . out . print ( val2 + " ▁ " ) ; val2 = val2 + 1 ; cst2 = cst2 + 1 ; } } System . out . println ( ) ; if ( row <= n / 2 ) { nst = nst + 1 ; nsp1 = nsp1 - 2 ; nsp2 = nsp2 + 2 ; val1 = row + 1 ; val2 = 1 ; } else { nst = nst - 1 ; nsp1 = nsp1 + 2 ; nsp2 = nsp2 - 2 ; val1 = n - row ; val2 = 1 ; } row = row + 1 ; } }
boolean findWinner ( int x , int y , int n ) { boolean [ ] dp = new boolean [ n + 1 ] ; dp [ 0 ] = false ; dp [ 1 ] = true ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i - 1 >= 0 && dp [ i - 1 ] == false ) { dp [ i ] = true ; } else if ( i - x >= 0 && dp [ i - x ] == false ) { dp [ i ] = true ; } else if ( i - y >= 0 && dp [ i - y ] == false ) { dp [ i ] = true ; } else { dp [ i ] = false ; } } return dp [ n ] ; }
int findDifference ( int [ ] arr , int n , int m ) { int max = 0 , min = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 , j = n - 1 ; i < m ; i ++ , j -- ) { min += arr [ i ] ; max += arr [ j ] ; } return max - min ; }
boolean ifPossible ( int [ ] arr , int n ) { int [ ] copy = Arrays . copyOf ( arr , arr . length ) ; Arrays . sort ( copy ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( arr [ i ] == copy [ i ] ) && ! ( arr [ n - 1 - i ] == copy [ i ] ) ) { return false ; } } return true ; }
long doubleFactorial ( long n ) { if ( n == 0 || n == 1 ) { return 1 ; } return n * doubleFactorial ( n - 2 ) ; }
int floorSqrt ( int x ) { if ( x == 0 || x == 1 ) { return x ; } int start = 1 , end = x , ans = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( mid * mid == x ) { return mid ; } if ( mid * mid < x ) { start = mid + 1 ; ans = mid ; } else { end = mid - 1 ; } } return ans ; }
String wordReverse ( String str ) { int i = str . length ( ) - 1 ; int start = i + 1 ; int end = i + 1 ; StringBuilder result = new StringBuilder ( ) ; while ( i >= 0 ) { if ( str . charAt ( i ) == ' ▁ ' ) { start = i + 1 ; while ( start != end ) { result . append ( str . charAt ( start ++ ) ) ; } result . append ( ' ▁ ' ) ; end = i ; } i -- ; } start = 0 ; while ( start != end ) { result . append ( str . charAt ( start ++ ) ) ; } return result . toString ( ) ; }
int shortestPath ( int [ ] [ ] graph , int u , int v , int k ) { int [ ] [ ] [ ] sp = new int [ V_NUM ] [ V_NUM ] [ k + 1 ] ; for ( int e = 0 ; e <= k ; e ++ ) { for ( int i = 0 ; i < V_NUM ; i ++ ) { for ( int j = 0 ; j < V_NUM ; j ++ ) { sp [ i ] [ j ] [ e ] = INF ; if ( e == 0 && i == j ) { sp [ i ] [ j ] [ e ] = 0 ; } if ( e == 1 && graph [ i ] [ j ] != INF ) { sp [ i ] [ j ] [ e ] = graph [ i ] [ j ] ; } if ( e > 1 ) { for ( int a = 0 ; a < V_NUM ; a ++ ) { if ( graph [ i ] [ a ] != INF && i != a && j != a && sp [ a ] [ j ] [ e - 1 ] != INF ) { sp [ i ] [ j ] [ e ] = Math . min ( sp [ i ] [ j ] [ e ] , graph [ i ] [ a ] + sp [ a ] [ j ] [ e - 1 ] ) ; } } } } } } return sp [ u ] [ v ] [ k ] ; }
void overflow ( int h0 , int r , int h , int n , int r0 ) { double tankCap = 3.14 * r * r * h0 ; double waterVol = 3.14 * r * r * h ; double ballsVol = n * ( ( double ) 4 / 3 ) * 3.14 * r0 * r0 * r0 ; double vol = waterVol + ballsVol ; if ( vol > tankCap ) { System . out . println ( " Overflow " ) ; } else { System . out . println ( " Not ▁ in ▁ overflow ▁ state " ) ; } }
float calcExpectation ( float [ ] a , float n ) { float prb = 1 / n ; float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] * prb ; } return sum ; }
void findAndPrintUncommonChars ( String str1 , String str2 ) { int [ ] present = new int [ MAX_CHAR ] ; int l1 = str1. length ( ) ; int l2 = str2. length ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) { present [ str1. charAt ( i ) - ' a ' ] = 1 ; } for ( int i = 0 ; i < l2 ; i ++ ) { if ( present [ str2. charAt ( i ) - ' a ' ] == 1 || present [ str2. charAt ( i ) - ' a ' ] == - 1 ) { present [ str2. charAt ( i ) - ' a ' ] = - 1 ; } else { present [ str2. charAt ( i ) - ' a ' ] = 2 ; } } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( present [ i ] == 1 || present [ i ] == 2 ) { System . out . print ( ( char ) ( i + ' a ' ) + " ▁ " ) ; } } }
void printDistinct ( String str ) { int [ ] count = new int [ NO_OF_CHARS ] ; int i ; for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) != ' ▁ ' ) { count [ str . charAt ( i ) ] ++ ; } } int n = i ; for ( i = 0 ; i < n ; i ++ ) { if ( count [ str . charAt ( i ) ] == 1 ) { System . out . print ( str . charAt ( i ) ) ; } } }
int findExtra ( int [ ] arr1 , int [ ] arr2 , int n ) { int index = n ; int left = 0 , right = n - 1 ; while ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr2 [ mid ] == arr1 [ mid ] ) { left = mid + 1 ; } else { index = mid ; right = mid - 1 ; } } return index ; }
int nobleInteger ( int [ ] arr , int size ) { for ( int i = 0 ; i < size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < size ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { count ++ ; } } if ( count == arr [ i ] ) { return arr [ i ] ; } } return - 1 ; }
int countStr ( int n , int bCount , int cCount ) { if ( bCount < 0 || cCount < 0 ) { return 0 ; } if ( n == 0 ) { return 1 ; } if ( bCount == 0 && cCount == 0 ) { return 1 ; } int res = countStr ( n - 1 , bCount , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount ) ; res += countStr ( n - 1 , bCount , cCount - 1 ) ; return res ; }
int gcdOfFactorial ( int m , int n ) { return factorial ( Math . min ( m , n ) ) ; }
void subArraySum ( int [ ] arr , int n , int sum ) { HashMap < Integer , Integer > hashMap = new HashMap <> ( ) ; int currSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currSum = currSum + arr [ i ] ; if ( currSum == sum ) { System . out . println ( " Sum ▁ found ▁ between ▁ indexes ▁ " + 0 + " ▁ to ▁ " + i ) ; return ; } if ( hashMap . containsKey ( currSum - sum ) ) { System . out . println ( " Sum ▁ found ▁ between ▁ indexes ▁ " + hashMap . get ( currSum - sum ) + 1 + " ▁ to ▁ " + i ) ; break ; } hashMap . put ( currSum , i ) ; } System . out . println ( " No ▁ subarray ▁ with ▁ given ▁ sum ▁ exists " ) ; }
boolean checkReverse ( int [ ] arr , int n ) { int [ ] temp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { temp [ i ] = arr [ i ] ; } Arrays . sort ( temp ) ; int front ; for ( front = 0 ; front < n ; front ++ ) { if ( temp [ front ] != arr [ front ] ) { break ; } } int back ; for ( back = n - 1 ; back >= 0 ; back -- ) { if ( temp [ back ] != arr [ back ] ) { break ; } } if ( front >= back ) { return true ; } while ( front != back ) { front ++ ; if ( arr [ front - 1 ] < arr [ front ] ) { return false ; } } return true ; }
void freq ( int [ ] [ ] ar , int m , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( ( ar [ i ] [ j ] % 2 ) == 0 ) { ++ even ; } else { ++ odd ; } } } System . out . println ( " ▁ Frequency ▁ of ▁ odd ▁ number ▁ = " + odd ) ; System . out . println ( " ▁ Frequency ▁ of ▁ even ▁ number ▁ = " + even ) ; }
int longLenStrictBitonicSub ( int [ ] arr , int n ) { TreeMap < Integer , Integer > inc = new TreeMap <> ( ) ; TreeMap < Integer , Integer > dcr = new TreeMap <> ( ) ; int [ ] lenInc = new int [ n ] ; int [ ] lenDcr = new int [ n ] ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( inc . containsKey ( arr [ i ] - 1 ) ) { len = inc . get ( arr [ i ] - 1 ) ; } lenInc [ i ] = len + 1 ; inc . put ( arr [ i ] , lenInc [ i ] ) ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { int len = 0 ; if ( dcr . containsKey ( arr [ i ] - 1 ) ) { len = dcr . get ( arr [ i ] - 1 ) ; } lenDcr [ i ] = len + 1 ; dcr . put ( arr [ i ] , lenDcr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( longLen < ( lenInc [ i ] + lenDcr [ i ] - 1 ) ) { longLen = lenInc [ i ] + lenDcr [ i ] - 1 ; } } return longLen ; }
int mod ( String num , int a ) { int res = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) { res = ( res * 10 + ( int ) num . charAt ( i ) - ' 0 ' ) % a ; } return res ; }
String printShortestSuperSeq ( String x , String y ) { int m = x . length ( ) ; int n = y . length ( ) ; int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) { dp [ i ] [ j ] = j ; } else if ( j == 0 ) { dp [ i ] [ j ] = i ; } else if ( x . charAt ( i - 1 ) == y . charAt ( j - 1 ) ) { dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } } int index = dp [ m ] [ n ] ; StringBuilder str = new StringBuilder ( ) ; int i = m , j = n ; while ( i > 0 && j > 0 ) { if ( x . charAt ( i - 1 ) == y . charAt ( j - 1 ) ) { str . append ( x . charAt ( i - 1 ) ) ; i -- ; j -- ; index -- ; } else if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] ) { str . append ( y . charAt ( j - 1 ) ) ; j -- ; index -- ; } else { str . append ( x . charAt ( i - 1 ) ) ; i -- ; index -- ; } } while ( i > 0 ) { str . append ( x . charAt ( i - 1 ) ) ; i -- ; index -- ; } while ( j > 0 ) { str . append ( y . charAt ( j - 1 ) ) ; j -- ; index -- ; } str . reverse ( ) ; return str . toString ( ) ; }
void findElements ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } }
int count ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= 1 && i <= 3 ) { dp [ i ] = 1 ; } else if ( i == 4 ) { dp [ i ] = 2 ; } else { dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ; } } return dp [ n ] ; }
int numberOfTriangles ( int n ) { int [ ] answer = new int [ n + 1 ] ; answer [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { answer [ i ] = answer [ i - 1 ] * 3 + 2 ; } return answer [ n ] ; }
int power ( int x , int y ) { if ( y == 0 ) { return 1 ; } else if ( y % 2 == 0 ) { return power ( x , y / 2 ) * power ( x , y / 2 ) ; } else { return x * power ( x , y / 2 ) * power ( x , y / 2 ) ; } }
boolean checkOrigin ( int x1 , int y1 , int x2 , int y2 ) { return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) ; }