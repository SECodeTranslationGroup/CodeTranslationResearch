def sum_digits ( no ) : NEW_LINE INDENT return 0 if no == 0 else no % 10 + sum_digits ( no // 10 ) NEW_LINE DEDENT
def find_sum ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += i // j NEW_LINE return ans NEW_LINE DEDENT
def is_palindrome ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE i = 0 NEW_LINE j = l - 1 NEW_LINE while i <= j : NEW_LINE INDENT if s [ i ] != s [ j ] : NEW_LINE INDENT return False NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE return True NEW_LINE DEDENT
def get_min_step_to_reach_end ( arr , n ) : NEW_LINE INDENT visit = [ False ] * n NEW_LINE distance = [ 0 ] * n NEW_LINE digit = [ [ ] for _ in range ( 10 ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT digit [ arr [ i ] ] . append ( i ) NEW_LINE distance [ 0 ] = 0 NEW_LINE visit [ 0 ] = True NEW_LINE q = Queue ( ) NEW_LINE q . put ( 0 ) NEW_LINE while len ( q ) > 0 : NEW_LINE INDENT idx = q . get ( ) NEW_LINE if idx == n - 1 : NEW_LINE INDENT break NEW_LINE d = arr [ idx ] NEW_LINE for i in range ( len ( digit [ d ] ) ) : NEW_LINE INDENT next_idx = digit [ d ] [ i ] NEW_LINE if not visit [ next_idx ] : NEW_LINE INDENT visit [ next_idx ] = True NEW_LINE q . put ( next_idx ) NEW_LINE distance [ next_idx ] = distance [ idx ] + 1 NEW_LINE if idx - 1 >= 0 and visit [ idx - 1 ] == False : NEW_LINE INDENT visit [ idx - 1 ] = True NEW_LINE q . put ( idx - 1 ) NEW_LINE distance [ idx - 1 ] = distance [ idx ] + 1 NEW_LINE if idx + 1 < n and visit [ idx + 1 ] == False : NEW_LINE INDENT visit [ idx + 1 ] = True NEW_LINE q . put ( idx + 1 ) NEW_LINE distance [ idx + 1 ] = distance [ idx ] + 1 NEW_LINE return distance [ n - 1 ] NEW_LINE DEDENT
def find_ways ( f , d , s ) : NEW_LINE INDENT mem = [ [ 0 ] * ( s + 1 ) for _ in range ( d + 1 ) ] NEW_LINE mem [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , d + 1 ) : NEW_LINE INDENT for j in range ( 1 , s + 1 ) : NEW_LINE INDENT mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] NEW_LINE if j - f - 1 >= 0 : NEW_LINE INDENT mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] NEW_LINE return mem [ d ] [ s ] NEW_LINE DEDENT
def max_volume ( s ) : NEW_LINE INDENT max_value = 0 NEW_LINE for i in range ( 1 , s - 1 ) : NEW_LINE INDENT for j in range ( 1 , s ) : NEW_LINE INDENT k = s - i - j NEW_LINE max_value = max ( max_value , i * j * k ) NEW_LINE return max_value NEW_LINE DEDENT
def min_days_to_empty ( c , l ) : NEW_LINE INDENT if l >= c : NEW_LINE INDENT return c NEW_LINE eq_root = ( math . sqrt ( 1 + 8 * ( c - l ) ) - 1 ) / 2 NEW_LINE return math . ceil ( eq_root ) + l NEW_LINE DEDENT
def min_diff ( arr , n , k ) : NEW_LINE INDENT result = sys . maxsize NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT result = min ( result , arr [ i + k - 1 ] - arr [ i ] ) NEW_LINE return result NEW_LINE DEDENT
def concatenate ( a , b , c , n1 , n2 ) : NEW_LINE INDENT i = - 1 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT c [ i ] = a [ i ] NEW_LINE for j in range ( n2 ) : NEW_LINE INDENT c [ i ] = b [ j ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def ceil_search ( arr , low , high , x ) : NEW_LINE INDENT if x <= arr [ low ] : NEW_LINE INDENT return low NEW_LINE for i in range ( low , high ) : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE if arr [ i ] < x and arr [ i + 1 ] >= x : NEW_LINE INDENT return i + 1 NEW_LINE return - 1 NEW_LINE DEDENT
def print_max_sub_square ( m ) : NEW_LINE INDENT s = [ [ 0 ] * COL for _ in range ( ROW ) ] NEW_LINE for i in range ( 1 , ROW ) : NEW_LINE INDENT for j in range ( 1 , COL ) : NEW_LINE INDENT if m [ i ] [ j ] == 1 : NEW_LINE INDENT s [ i ] [ j ] = min ( s [ i ] [ j - 1 ] , s [ i - 1 ] [ j ] , s [ i - 1 ] [ j - 1 ] ) + 1 NEW_LINE else : NEW_LINE INDENT s [ i ] [ j ] = 0 NEW_LINE max_of_s = s [ 0 ] [ 0 ] NEW_LINE max_i = 0 NEW_LINE max_j = 0 NEW_LINE for i in range ( ROW ) : NEW_LINE INDENT for j in range ( COL ) : NEW_LINE INDENT if max_of_s < s [ i ] [ j ] : NEW_LINE INDENT max_of_s = s [ i ] [ j ] NEW_LINE max_i = i NEW_LINE max_j = j NEW_LINE print ( " Maximum ▁ size ▁ sub - matrix ▁ is : ▁ " ) NEW_LINE for i in range ( max_i , max_i - max_of_s , - 1 ) : NEW_LINE INDENT for j in range ( max_j , max_j - max_of_s , - 1 ) : NEW_LINE INDENT print ( m [ i ] [ j ] , end = " ▁ " ) NEW_LINE print ( ) NEW_LINE DEDENT DEDENT
def min_max_product ( arr1 , arr2 , n1 , n2 ) : NEW_LINE INDENT max = arr1 [ 0 ] NEW_LINE min = arr2 [ 0 ] NEW_LINE i = 1 NEW_LINE while i < n1 and i < n2 : NEW_LINE INDENT if arr1 [ i ] > max : NEW_LINE INDENT max = arr1 [ i ] NEW_LINE if arr2 [ i ] < min : NEW_LINE INDENT min = arr2 [ i ] NEW_LINE i += 1 NEW_LINE while i < n1 : NEW_LINE INDENT if arr1 [ i ] > max : NEW_LINE INDENT max = arr1 [ i ] NEW_LINE i += 1 NEW_LINE while i < n2 : NEW_LINE INDENT if arr2 [ i ] < min : NEW_LINE INDENT min = arr2 [ i ] NEW_LINE i += 1 NEW_LINE return max * min NEW_LINE DEDENT
def is_composite ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE if n <= 3 : NEW_LINE INDENT return False NEW_LINE if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return True NEW_LINE i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 or n % ( i + 2 ) == 0 : NEW_LINE INDENT return True NEW_LINE i = i + 6 NEW_LINE return False NEW_LINE DEDENT
def find_max_guests ( arrl , exit , n ) : NEW_LINE INDENT arrl . sort ( ) NEW_LINE exit . sort ( ) NEW_LINE guests_in = 1 NEW_LINE max_guests = 1 NEW_LINE time = arrl [ 0 ] NEW_LINE i = 1 NEW_LINE j = 0 NEW_LINE while i < n and j < n : NEW_LINE INDENT if arrl [ i ] <= exit [ j ] : NEW_LINE INDENT guests_in = guests_in + 1 NEW_LINE if guests_in > max_guests : NEW_LINE INDENT max_guests = guests_in NEW_LINE time = arrl [ i ] NEW_LINE i = i + 1 NEW_LINE else : NEW_LINE INDENT guests_in = guests_in - 1 NEW_LINE j = j + 1 NEW_LINE print ( " Maximum ▁ Number ▁ of ▁ Guests ▁ = ▁ " , max_guests , " ▁ at ▁ time ▁ " , time , sep = " " ) NEW_LINE DEDENT
def identity ( size ) : NEW_LINE INDENT for row in range ( size ) : NEW_LINE INDENT for col in range ( size ) : NEW_LINE INDENT if row == col : NEW_LINE INDENT print ( 1 , end = " ▁ " ) NEW_LINE else : NEW_LINE INDENT print ( 0 , end = " ▁ " ) NEW_LINE print ( ) NEW_LINE DEDENT DEDENT
def print_k_distinct ( arr , n , k ) : NEW_LINE INDENT dist_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = 0 NEW_LINE while j < n : NEW_LINE INDENT if i != j and arr [ j ] == arr [ i ] : NEW_LINE INDENT break NEW_LINE j += 1 NEW_LINE if j == n : NEW_LINE INDENT dist_count += 1 NEW_LINE if dist_count == k : NEW_LINE INDENT return arr [ i ] NEW_LINE return - 1 NEW_LINE DEDENT
def reorder ( arr , index , n ) : NEW_LINE INDENT temp = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp [ index [ i ] ] = arr [ i ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE index [ i ] = i NEW_LINE DEDENT DEDENT
def print_count_dp ( dist ) : NEW_LINE INDENT count = [ 0 ] * ( dist + 1 ) NEW_LINE count [ 0 ] = 1 NEW_LINE count [ 1 ] = 1 NEW_LINE count [ 2 ] = 2 NEW_LINE for i in range ( 3 , dist + 1 ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] NEW_LINE return count [ dist ] NEW_LINE DEDENT
def maximum_chars ( str_ ) : NEW_LINE INDENT n = len ( str_ ) NEW_LINE res = - 1 NEW_LINE first_inds = [ - 1 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT first_ind = first_inds [ ord ( str_ [ i ] ) ] NEW_LINE if first_ind == - 1 : NEW_LINE INDENT first_inds [ ord ( str_ [ i ] ) ] = i NEW_LINE else : NEW_LINE INDENT res = max ( res , abs ( i - first_ind - 1 ) ) NEW_LINE return res NEW_LINE DEDENT
def first_repeated ( str_ ) : NEW_LINE INDENT checker = 0 NEW_LINE pos = 0 NEW_LINE for i in str_ : NEW_LINE INDENT val = ord ( i ) - ord ( ' a ' ) NEW_LINE if checker & ( 1 << val ) > 0 : NEW_LINE INDENT return pos NEW_LINE checker |= ( 1 << val ) NEW_LINE pos += 1 NEW_LINE return - 1 NEW_LINE DEDENT
def find_max_product ( arr , n ) : NEW_LINE INDENT ans = - sys . maxsize NEW_LINE max_val = 1 NEW_LINE min_val = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT max_val = max_val * arr [ i ] NEW_LINE min_val = min ( 1 , min_val * arr [ i ] ) NEW_LINE elif arr [ i ] == 0 : NEW_LINE INDENT min_val = 1 NEW_LINE max_val = 0 NEW_LINE elif arr [ i ] < 0 : NEW_LINE INDENT prev_max = max_val NEW_LINE max_val = min_val * arr [ i ] NEW_LINE min_val = prev_max * arr [ i ] NEW_LINE ans = max ( ans , max_val ) NEW_LINE if max_val <= 0 : NEW_LINE INDENT max_val = 1 NEW_LINE return ans NEW_LINE DEDENT
def survival ( s , n , m ) : NEW_LINE INDENT if ( ( n * 6 ) < ( m * 7 ) and s > 6 ) or m > n : NEW_LINE INDENT print ( " No " ) NEW_LINE else : NEW_LINE INDENT days = ( m * s ) / n NEW_LINE if ( m * s ) % n != 0 : NEW_LINE INDENT days += 1 NEW_LINE print ( " Yes ▁ " , days , sep = " " ) NEW_LINE DEDENT DEDENT
def first_non_repeating ( str_ ) : NEW_LINE INDENT char_count = [ 0 ] * MAX_CHAR NEW_LINE q = Queue ( ) NEW_LINE for i in range ( len ( str_ ) ) : NEW_LINE INDENT q . put ( str_ [ i ] ) NEW_LINE char_count [ ord ( str_ [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE while q : NEW_LINE INDENT if char_count [ ord ( q . queue [ 0 ] ) - ord ( ' a ' ) ] > 1 : NEW_LINE INDENT q . get ( ) NEW_LINE else : NEW_LINE INDENT print ( q [ 0 ] , end = " ▁ " ) NEW_LINE break NEW_LINE if not q : NEW_LINE INDENT print ( - 1 , end = " ▁ " ) NEW_LINE print ( ) NEW_LINE DEDENT
def dfs ( list , node , arrival ) : NEW_LINE INDENT print ( node ) NEW_LINE for i in range ( len ( list [ node ] ) ) : NEW_LINE INDENT if list [ node ] [ i ] != arrival : NEW_LINE INDENT dfs ( list , list [ node ] [ i ] , node ) NEW_LINE DEDENT DEDENT DEDENT
def find_repeating ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT res = res ^ ( i + 1 ) ^ arr [ i ] NEW_LINE res = res ^ arr [ n - 1 ] NEW_LINE return res NEW_LINE DEDENT
def get_count ( keypad , n ) : NEW_LINE INDENT if not keypad or n <= 0 : NEW_LINE INDENT return 0 NEW_LINE if n == 1 : NEW_LINE INDENT return 10 NEW_LINE odd = [ 0 ] * 10 NEW_LINE even = [ 0 ] * 10 NEW_LINE use_odd = 0 NEW_LINE total_count = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT odd [ i ] = 1 NEW_LINE for j in range ( 2 , n + 1 ) : NEW_LINE INDENT use_odd = 1 - use_odd NEW_LINE if use_odd == 1 : NEW_LINE INDENT even [ 0 ] = odd [ 0 ] + odd [ 8 ] NEW_LINE even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ] NEW_LINE even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] NEW_LINE even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ] NEW_LINE even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] NEW_LINE even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] NEW_LINE even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] NEW_LINE even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] NEW_LINE even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] NEW_LINE even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ] NEW_LINE else : NEW_LINE INDENT odd [ 0 ] = even [ 0 ] + even [ 8 ] NEW_LINE odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ] NEW_LINE odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ] NEW_LINE odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ] NEW_LINE odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ] NEW_LINE odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ] NEW_LINE odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ] NEW_LINE odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ] NEW_LINE odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ] NEW_LINE odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ] NEW_LINE total_count = 0 NEW_LINE if use_odd == 1 : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT total_count += even [ i ] NEW_LINE else : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT total_count += odd [ i ] NEW_LINE return total_count NEW_LINE DEDENT
def count_subarr_with_equal_zero_and_one ( arr , n ) : NEW_LINE INDENT my_map = dict ( ) NEW_LINE sum_ = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == 0 : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE sum_ += arr [ i ] NEW_LINE if sum_ == 0 : NEW_LINE INDENT count += 1 NEW_LINE if sum_ in my_map . keys ( ) : NEW_LINE INDENT count += my_map [ sum_ ] NEW_LINE my_map [ sum_ ] = my_map . get ( sum_ , 0 ) + 1 NEW_LINE return count NEW_LINE DEDENT
def search ( mat , from_row , to_row , from_col , to_col , key ) : NEW_LINE INDENT i = from_row + ( to_row - from_row ) // 2 NEW_LINE j = from_col + ( to_col - from_col ) // 2 NEW_LINE if mat [ i ] [ j ] == key : NEW_LINE INDENT print ( " Found ▁ " , key , " ▁ at ▁ " , i , " ▁ " , j , sep = " " ) NEW_LINE else : NEW_LINE INDENT if i != to_row or j != from_col : NEW_LINE INDENT search ( mat , from_row , i , j , to_col , key ) NEW_LINE if from_row == to_row and from_col + 1 == to_col : NEW_LINE INDENT if mat [ from_row ] [ to_col ] == key : NEW_LINE INDENT print ( " Found ▁ " , key , " ▁ at ▁ " , from_row , " ▁ " , to_col , sep = " " ) NEW_LINE if mat [ i ] [ j ] < key : NEW_LINE INDENT if i + 1 <= to_row : NEW_LINE INDENT search ( mat , i + 1 , to_row , from_col , to_col , key ) NEW_LINE else : NEW_LINE INDENT if j - 1 >= from_col : NEW_LINE INDENT search ( mat , from_row , to_row , from_col , j - 1 , key ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def kth_group_sum ( k ) : NEW_LINE INDENT return k * k * k NEW_LINE DEDENT
def are_k_anagrams ( str1 , str2 , k ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE if len ( str2 ) != n : NEW_LINE INDENT return False NEW_LINE hash_str1 = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash_str1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if hash_str1 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] > 0 : NEW_LINE INDENT hash_str1 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE else : NEW_LINE INDENT count += 1 NEW_LINE if count > k : NEW_LINE INDENT return False NEW_LINE return True NEW_LINE DEDENT
def bonacci_series ( n , m ) : NEW_LINE INDENT a = [ 0 ] * m NEW_LINE a [ n - 1 ] = 1 NEW_LINE for i in range ( n , m ) : NEW_LINE INDENT for j in range ( i - n , i ) : NEW_LINE INDENT a [ i ] = a [ i ] + a [ j ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def print_min_index_char ( str_ , patt ) : NEW_LINE INDENT min_index = sys . maxsize NEW_LINE m = len ( str_ ) NEW_LINE n = len ( patt ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if patt [ i ] == str_ [ j ] and j < min_index : NEW_LINE INDENT min_index = j NEW_LINE break NEW_LINE if min_index != sys . maxsize : NEW_LINE INDENT print ( " Minimum ▁ Index ▁ Character ▁ = ▁ " , str_ [ min_index ] , sep = " " ) NEW_LINE else : NEW_LINE INDENT print ( " No ▁ character ▁ present " ) NEW_LINE DEDENT DEDENT
def neg_cycle_floyd_warshall ( graph ) : NEW_LINE INDENT dist = [ [ 0 ] * V_NUM for _ in range ( V_NUM ) ] NEW_LINE for i in range ( V_NUM ) : NEW_LINE INDENT for j in range ( V_NUM ) : NEW_LINE INDENT dist [ i ] [ j ] = graph [ i ] [ j ] NEW_LINE for k in range ( V_NUM ) : NEW_LINE INDENT for i in range ( V_NUM ) : NEW_LINE INDENT for j in range ( V_NUM ) : NEW_LINE INDENT if dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] : NEW_LINE INDENT dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] NEW_LINE for i in range ( V_NUM ) : NEW_LINE INDENT if dist [ i ] [ i ] < 0 : NEW_LINE INDENT return True NEW_LINE return False NEW_LINE DEDENT
def lex_next ( str_ , n ) : NEW_LINE INDENT s = list ( str_ ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] != ' z ' : NEW_LINE INDENT s [ i ] = chr ( ord ( s [ i ] ) + 1 ) NEW_LINE return " " . join ( s ) NEW_LINE s [ i ] = ' a ' NEW_LINE DEDENT DEDENT
def print_duo ( str_ ) : NEW_LINE INDENT count_char = [ 0 ] * MAX_CHAR NEW_LINE n = len ( str_ ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count_char [ ord ( str_ [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE str_ = [ ] NEW_LINE str2 = [ ] NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if count_char [ i ] > 1 : NEW_LINE INDENT str2. append ( chr ( i + ord ( ' a ' ) ) ) NEW_LINE elif count_char [ i ] == 1 : NEW_LINE INDENT str_ . append ( chr ( i + ord ( ' a ' ) ) ) NEW_LINE print ( " String ▁ with ▁ characters ▁ occurring ▁ once : " ) NEW_LINE print ( " " . join ( str_ ) ) NEW_LINE print ( " String ▁ with ▁ characters ▁ occurring ▁ multiple ▁ times : " ) NEW_LINE print ( " " . join ( str2 ) ) NEW_LINE DEDENT
def round_off ( n0 , n ) : NEW_LINE INDENT b = n0 NEW_LINE c = math . floor ( n0 ) NEW_LINE i = 0 NEW_LINE while b >= 1 : NEW_LINE INDENT b = b / 10 NEW_LINE i = i + 1 NEW_LINE d = n - i NEW_LINE b = n0 NEW_LINE b = b * 10 ** d NEW_LINE e = b + 0.5 NEW_LINE if float ( e ) == float ( math . ceil ( b ) ) : NEW_LINE INDENT f = math . ceil ( b ) NEW_LINE h = f - 2 NEW_LINE if h % 2 != 0 : NEW_LINE INDENT e = e - 1 NEW_LINE j = math . floor ( e ) NEW_LINE m = 10 ** d NEW_LINE j = j / m NEW_LINE print ( " The ▁ number ▁ after ▁ rounding - off ▁ is ▁ " , j , sep = " " ) NEW_LINE DEDENT
def print_rotated_string ( str_ ) : NEW_LINE INDENT len_ = len ( str_ ) NEW_LINE temp = [ 0 ] * len_ NEW_LINE for i in range ( len_ ) : NEW_LINE INDENT j = i NEW_LINE k = 0 NEW_LINE while j < len ( str_ ) : NEW_LINE INDENT temp [ k ] = str_ [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE j = 0 NEW_LINE while j < i : NEW_LINE INDENT temp [ k ] = str_ [ j ] NEW_LINE j += 1 NEW_LINE k += 1 NEW_LINE print ( temp ) NEW_LINE DEDENT DEDENT
def difference ( arr , n ) : NEW_LINE INDENT d1 = 0 NEW_LINE d2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT d1 += arr [ i ] [ j ] NEW_LINE if i == n - j - 1 : NEW_LINE INDENT d2 += arr [ i ] [ j ] NEW_LINE return abs ( d1 - d2 ) NEW_LINE DEDENT
def calculate ( n ) : NEW_LINE INDENT length = len ( n ) NEW_LINE l = length // 2 NEW_LINE count = 0 NEW_LINE for i in range ( l + 1 ) : NEW_LINE INDENT s = n [ 0 : 0 + i ] NEW_LINE l1 = len ( s ) NEW_LINE t = n [ i : l1 + i ] NEW_LINE if s [ 0 ] == ' 0 ' or t [ 0 ] == ' 0 ' : NEW_LINE INDENT continue NEW_LINE if s == t : NEW_LINE INDENT count += 1 NEW_LINE return count NEW_LINE DEDENT
def print_union ( arr1 , arr2 , m , n ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE while i < m and j < n : NEW_LINE INDENT if arr1 [ i ] < arr2 [ j ] : NEW_LINE INDENT print ( arr1 [ i ] ) NEW_LINE i += 1 NEW_LINE elif arr2 [ j ] < arr1 [ i ] : NEW_LINE INDENT print ( arr2 [ j ] ) NEW_LINE j += 1 NEW_LINE else : NEW_LINE INDENT print ( arr2 [ j ] ) NEW_LINE j += 1 NEW_LINE i += 1 NEW_LINE while i < m : NEW_LINE INDENT print ( arr1 [ i ] ) NEW_LINE i += 1 NEW_LINE while j < n : NEW_LINE INDENT print ( arr2 [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT
def print_distinct ( str_ ) : NEW_LINE INDENT n = len ( str_ ) NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE index = [ n ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = str_ [ i ] NEW_LINE count [ ord ( x ) ] += 1 NEW_LINE if count [ ord ( x ) ] == 1 and x != ' ▁ ' : NEW_LINE INDENT index [ ord ( x ) ] = i NEW_LINE if count [ ord ( x ) ] == 2 : NEW_LINE INDENT index [ ord ( x ) ] = n NEW_LINE index . sort ( ) NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if index [ i ] == n : NEW_LINE INDENT break NEW_LINE print ( str_ [ index [ i ] ] , end = " " ) NEW_LINE DEDENT DEDENT
def find_common ( mat ) : NEW_LINE INDENT column = [ N - 1 ] * M NEW_LINE min_row = 0 NEW_LINE while column [ min_row ] >= 0 : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT if mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] : NEW_LINE INDENT min_row = i NEW_LINE eq_count = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT if mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] : NEW_LINE INDENT if column [ i ] == 0 : NEW_LINE INDENT return - 1 NEW_LINE column [ i ] -= 1 NEW_LINE else : NEW_LINE INDENT eq_count += 1 NEW_LINE if eq_count == M : NEW_LINE INDENT return mat [ min_row ] [ column [ min_row ] ] NEW_LINE return - 1 NEW_LINE DEDENT
def polygon_area ( x , y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT area = area + ( x [ j ] + x [ i ] ) * ( y [ j ] - y [ i ] ) NEW_LINE j = i NEW_LINE return abs ( area // 2.0 ) NEW_LINE DEDENT
def max_profit ( price , n , k ) : NEW_LINE INDENT profit = [ [ 0 ] * n + 1 for _ in range ( k + 1 ) ] NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT profit [ i ] [ 0 ] = 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT profit [ 0 ] [ j ] = 0 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT max_so_far = - sys . maxsize NEW_LINE for m in range ( j ) : NEW_LINE INDENT max_so_far = max ( max_so_far , price [ j ] - price [ m ] + profit [ i - 1 ] [ m ] ) NEW_LINE profit [ i ] [ j ] = max ( profit [ i - 1 ] [ j ] , max_so_far ) NEW_LINE return profit [ k ] [ n - 1 ] NEW_LINE DEDENT
def match ( first , second ) : NEW_LINE INDENT if len ( first ) == 0 and len ( second ) == 0 : NEW_LINE INDENT return True NEW_LINE if len ( first ) > 1 and first [ 0 ] == ' * ' and len ( second ) == 0 : NEW_LINE INDENT return False NEW_LINE if ( len ( first ) > 1 and first [ 0 ] == ' ? ' ) or ( len ( first ) > 0 and len ( second ) > 0 and first [ 0 ] == second [ 0 ] ) : NEW_LINE INDENT return match ( first [ 1 : ] , second [ 1 : ] ) NEW_LINE if len ( first ) != 0 and first [ 0 ] == ' * ' : NEW_LINE INDENT return match ( first [ 1 : ] , second ) or match ( first , second [ 1 : ] ) NEW_LINE return False NEW_LINE DEDENT
def find_sum ( n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE y = n // k NEW_LINE x = n % k NEW_LINE ans = ( k * ( k - 1 ) // 2 ) * y + ( x * ( x + 1 ) ) // 2 NEW_LINE return ans NEW_LINE DEDENT
def is_permuted_matrix ( mat , n ) : NEW_LINE INDENT str_cat = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT str_cat . append ( " - " ) NEW_LINE str_cat . append ( str ( mat [ 0 ] [ i ] ) ) NEW_LINE str_cat . extend ( str_cat ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_str = " " NEW_LINE for j in range ( n ) : NEW_LINE INDENT str_cat . append ( " - " ) NEW_LINE str_cat . append ( str ( mat [ i ] [ j ] ) ) NEW_LINE if not " " . join ( str_cat ) . contains ( " " . join ( curr_str ) ) : NEW_LINE INDENT return False NEW_LINE return True NEW_LINE DEDENT
def is_sparse ( array , m , n ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if array [ i ] [ j ] == 0 : NEW_LINE INDENT counter = counter + 1 NEW_LINE return counter > ( ( m * n ) // 2 ) NEW_LINE DEDENT
def find_area ( r ) : NEW_LINE INDENT return math . pi * r ** 2 NEW_LINE DEDENT
def count_obtuse_angles ( a , b , k ) : NEW_LINE INDENT c1 = b - a - 1 NEW_LINE c2 = k - b + a - 1 NEW_LINE if c1 == c2 : NEW_LINE INDENT return 0 NEW_LINE return min ( c1 , c2 ) NEW_LINE DEDENT
def counter_clock_spiral_print ( m , n , arr ) : NEW_LINE INDENT k = 0 NEW_LINE l = 0 NEW_LINE cnt = 0 NEW_LINE total = m * n NEW_LINE while k < m and l < n : NEW_LINE INDENT if cnt == total : NEW_LINE INDENT break NEW_LINE for i in range ( k , m ) : NEW_LINE INDENT print ( arr [ i ] [ l ] , end = " ▁ " ) NEW_LINE cnt += 1 NEW_LINE l += 1 NEW_LINE if cnt == total : NEW_LINE INDENT break NEW_LINE for i in range ( l , n ) : NEW_LINE INDENT print ( arr [ m - 1 ] [ i ] , end = " ▁ " ) NEW_LINE cnt += 1 NEW_LINE m -= 1 NEW_LINE if cnt == total : NEW_LINE INDENT break NEW_LINE if k < m : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT print ( arr [ i ] [ n - 1 ] , end = " ▁ " ) NEW_LINE cnt += 1 NEW_LINE n -= 1 NEW_LINE if cnt == total : NEW_LINE INDENT break NEW_LINE if l < n : NEW_LINE INDENT for i in range ( n - 1 , l - 1 , - 1 ) : NEW_LINE INDENT print ( arr [ k ] [ i ] , end = " ▁ " ) NEW_LINE cnt += 1 NEW_LINE k += 1 NEW_LINE DEDENT DEDENT DEDENT
def number_of_triangles ( n ) : NEW_LINE INDENT ans = 2 * 3 ** n - 1 NEW_LINE return ans NEW_LINE DEDENT
def minmax_product ( arr1 , arr2 , n1 , n2 ) : NEW_LINE INDENT arr1. sort ( ) NEW_LINE arr2. sort ( ) NEW_LINE return arr1 [ n1 - 1 ] * arr2 [ 0 ] NEW_LINE DEDENT
def time_to_meet ( s , v0 ) : NEW_LINE INDENT v = 3 * v0 / 2 NEW_LINE time = s / v NEW_LINE print ( time ) NEW_LINE DEDENT
def count_to_make_01_alternate ( s ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT result += 1 NEW_LINE return result NEW_LINE DEDENT
def print_count_rec ( dist ) : NEW_LINE INDENT if dist < 0 : NEW_LINE INDENT return 0 NEW_LINE if dist == 0 : NEW_LINE INDENT return 1 NEW_LINE return print_count_rec ( dist - 1 ) + print_count_rec ( dist - 2 ) + print_count_rec ( dist - 3 ) NEW_LINE DEDENT
def compute_average ( a , b ) : NEW_LINE INDENT return ( a // 2 ) + ( b // 2 ) + ( ( a % 2 + b % 2 ) // 2 ) NEW_LINE DEDENT
def count_sub_str ( str_ , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str_ [ i ] == ' 1 ' : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if str_ [ j ] == ' 1 ' : NEW_LINE INDENT res = res + 1 NEW_LINE return res NEW_LINE DEDENT
def is_divisible_by10 ( bin ) : NEW_LINE INDENT n = len ( bin ) NEW_LINE if bin [ n - 1 ] == ' 1 ' : NEW_LINE INDENT return False NEW_LINE sum_ = 0 NEW_LINE i = n - 2 NEW_LINE while i >= 0 : NEW_LINE INDENT if bin [ i ] == ' 1 ' : NEW_LINE INDENT pos_from_right = n - i - 1 NEW_LINE if pos_from_right % 4 == 1 : NEW_LINE INDENT sum_ = sum_ + 2 NEW_LINE elif pos_from_right % 4 == 2 : NEW_LINE INDENT sum_ = sum_ + 4 NEW_LINE elif pos_from_right % 4 == 3 : NEW_LINE INDENT sum_ = sum_ + 8 NEW_LINE elif pos_from_right % 4 == 0 : NEW_LINE INDENT sum_ = sum_ + 6 NEW_LINE i = i - 1 NEW_LINE if sum_ % 10 == 0 : NEW_LINE INDENT return True NEW_LINE return False NEW_LINE DEDENT
def search ( arr , low , high ) : NEW_LINE INDENT if low > high : NEW_LINE INDENT return NEW_LINE if low == high : NEW_LINE INDENT print ( " The ▁ required ▁ element ▁ is ▁ " , arr [ low ] , sep = " " ) NEW_LINE return NEW_LINE mid = ( low + high ) / 2 NEW_LINE if mid % 2 == 0 : NEW_LINE INDENT if arr [ mid ] == arr [ mid + 1 ] : NEW_LINE INDENT return search ( arr , mid + 2 , high ) NEW_LINE else : NEW_LINE INDENT return search ( arr , low , mid ) NEW_LINE else : NEW_LINE INDENT if arr [ mid ] == arr [ mid - 1 ] : NEW_LINE INDENT return search ( arr , mid + 1 , high ) NEW_LINE else : NEW_LINE INDENT return search ( arr , low , mid - 1 ) NEW_LINE DEDENT DEDENT DEDENT
def find_3_mumbers ( a , arr_size , sum_ ) : NEW_LINE INDENT a . sort ( ) NEW_LINE for i in range ( arr_size - 2 ) : NEW_LINE INDENT l = i + 1 NEW_LINE r = arr_size - 1 NEW_LINE while l < r : NEW_LINE INDENT if a [ i ] + a [ l ] + a [ r ] == sum_ : NEW_LINE INDENT print ( " Triplet ▁ is ▁ " , a [ i ] , " , ▁ " , a [ l ] , " , ▁ " , a [ r ] , sep = " " ) NEW_LINE return True NEW_LINE elif a [ i ] + a [ l ] + a [ r ] < sum_ : NEW_LINE INDENT l += 1 NEW_LINE else : NEW_LINE INDENT r -= 1 NEW_LINE return False NEW_LINE DEDENT
def make_permutation ( a , n ) : NEW_LINE INDENT count = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ a [ i ] ] = count . get ( a [ i ] , 0 ) + 1 NEW_LINE next_missing = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if count [ a [ i ] ] != 1 or a [ i ] > n or a [ i ] < 1 : NEW_LINE INDENT count [ a [ i ] ] -= 1 NEW_LINE while next_missing in count . keys ( ) : NEW_LINE INDENT next_missing += 1 NEW_LINE a [ i ] = next_missing NEW_LINE count [ next_missing ] = 1 NEW_LINE DEDENT DEDENT DEDENT
def optimal_strategy_of_game ( arr , n ) : NEW_LINE INDENT table = [ [ 0 ] * n for _ in range ( n ) ] NEW_LINE for gap in range ( n ) : NEW_LINE INDENT for j in range ( gap , n ) : NEW_LINE INDENT i = j - gap NEW_LINE x = table [ i + 2 ] [ j ] if i + 2 <= j else 0 NEW_LINE y = table [ i + 1 ] [ j - 1 ] if i + 1 <= j - 1 else 0 NEW_LINE z = table [ i ] [ j - 2 ] if i <= ( j - 2 ) else 0 NEW_LINE table [ i ] [ j ] = max ( arr [ i ] + min ( x , y ) , arr [ j ] + min ( y , z ) ) NEW_LINE return table [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def find_sum_subsets ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) NEW_LINE DEDENT
def seires_sum ( n , a ) : NEW_LINE INDENT return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) NEW_LINE DEDENT
def interchange_first_last ( m ) : NEW_LINE INDENT rows = N NEW_LINE for i in range ( N ) : NEW_LINE INDENT t = m [ 0 ] [ i ] NEW_LINE m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] NEW_LINE m [ rows - 1 ] [ i ] = t NEW_LINE DEDENT DEDENT
def cut_rod ( price , n ) : NEW_LINE INDENT val = [ 0 ] * ( n + 1 ) NEW_LINE val [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT max_val = - sys . maxsize NEW_LINE for j in range ( i ) : NEW_LINE INDENT max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) NEW_LINE val [ i ] = max_val NEW_LINE return val [ n ] NEW_LINE DEDENT
def max_overlap ( start , end ) : NEW_LINE INDENT n = len ( start ) NEW_LINE max_a = max ( start ) NEW_LINE max_b = max ( end ) NEW_LINE max_c = max ( max_a , max_b ) NEW_LINE x = [ 0 ] * ( max_c + 2 ) NEW_LINE cur = 0 NEW_LINE idx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x [ start [ i ] ] += 1 NEW_LINE x [ end [ i ] + 1 ] -= 1 NEW_LINE max_y = - 1 NEW_LINE for i in range ( max_c + 1 ) : NEW_LINE INDENT cur += x [ i ] NEW_LINE if max_y < cur : NEW_LINE INDENT max_y = cur NEW_LINE idx = i NEW_LINE print ( " Maximum ▁ value ▁ is : ▁ " , max_y , " ▁ at ▁ position : ▁ " , idx , sep = " " ) NEW_LINE DEDENT
def can_form_palindrome ( str_ ) : NEW_LINE INDENT list1 = [ ] NEW_LINE for i in range ( len ( str_ ) ) : NEW_LINE INDENT if str_ [ i ] in list1 : NEW_LINE INDENT list1. remove ( str_ [ i ] ) NEW_LINE else : NEW_LINE INDENT list1. append ( str_ [ i ] ) NEW_LINE if ( len ( str_ ) % 2 == 0 and len ( list1 ) == 0 ) or ( len ( str_ ) % 2 == 1 and len ( list1 ) ) == 1 : NEW_LINE INDENT return True NEW_LINE else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def fib ( n , a , b ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return a NEW_LINE if n == 1 : NEW_LINE INDENT return b NEW_LINE return fib ( n - 1 , b , a + b ) NEW_LINE DEDENT
def count_pairs ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( a [ i ] & a [ j ] ) == 0 : NEW_LINE INDENT count += 2 NEW_LINE return count NEW_LINE DEDENT
def k_max ( arr , k , n ) : NEW_LINE INDENT for c in range ( k ) : NEW_LINE INDENT max_so_far = - sys . maxsize NEW_LINE max_here = 0 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_here += arr [ i ] NEW_LINE if max_so_far < max_here : NEW_LINE INDENT max_so_far = max_here NEW_LINE start = s NEW_LINE end = i NEW_LINE if max_here < 0 : NEW_LINE INDENT max_here = 0 NEW_LINE s = i + 1 NEW_LINE print ( " Maximum ▁ non - overlapping ▁ sub - array ▁ sum " , c + 1 , " : ▁ " , max_so_far , NEW_LINE INDENT " , ▁ starting ▁ index : ▁ " , start , " , ▁ ending ▁ index : ▁ " , end , " . " , sep = " " ) NEW_LINE for l in range ( start , end + 1 ) : NEW_LINE INDENT arr [ l ] = - sys . maxsize NEW_LINE print ( ) NEW_LINE DEDENT
def minimum_cost_of_breaking ( x , y , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE x . sort ( reverse = True ) NEW_LINE y . sort ( reverse = True ) NEW_LINE hzntl = 1 NEW_LINE vert = 1 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < m and j < n : NEW_LINE INDENT if x [ i ] > y [ j ] : NEW_LINE INDENT res += x [ i ] * vert NEW_LINE hzntl += 1 NEW_LINE i += 1 NEW_LINE else : NEW_LINE INDENT res += y [ j ] * hzntl NEW_LINE vert += 1 NEW_LINE j += 1 NEW_LINE total = 0 NEW_LINE while i < m : NEW_LINE INDENT total += x [ i ] NEW_LINE i += 1 NEW_LINE res += total * vert NEW_LINE total = 0 NEW_LINE while j < n : NEW_LINE INDENT total += y [ j ] NEW_LINE j += 1 NEW_LINE res += total * hzntl NEW_LINE return res NEW_LINE DEDENT
def k_smallest ( arr , n , k ) : NEW_LINE INDENT b = [ 0 ] * MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ arr [ i ] ] = 1 NEW_LINE for j in range ( 1 , MAX ) : NEW_LINE INDENT if b [ j ] != 1 : NEW_LINE INDENT k -= 1 NEW_LINE if k is not 1 : NEW_LINE INDENT return j NEW_LINE DEDENT DEDENT DEDENT
def min_pal_partion ( str_ ) : NEW_LINE INDENT n = len ( str_ ) NEW_LINE c = [ 0 ] * n NEW_LINE p = [ [ False ] * n for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT p [ i ] [ i ] = True NEW_LINE for L in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE if L == 2 : NEW_LINE INDENT p [ i ] [ j ] = str_ [ i ] == str_ [ j ] NEW_LINE else : NEW_LINE INDENT p [ i ] [ j ] = str_ [ i ] == str_ [ j ] and p [ i + 1 ] [ j - 1 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if p [ 0 ] [ i ] == True : NEW_LINE INDENT c [ i ] = 0 NEW_LINE else : NEW_LINE INDENT c [ i ] = sys . maxsize NEW_LINE for j in range ( i ) : NEW_LINE INDENT if p [ j + 1 ] [ i ] == True and 1 + c [ j ] < c [ i ] : NEW_LINE INDENT c [ i ] = 1 + c [ j ] NEW_LINE return c [ n - 1 ] NEW_LINE DEDENT
def is_product ( arr , n , x ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] * arr [ j ] == x : NEW_LINE INDENT return True NEW_LINE return False NEW_LINE DEDENT
def find_sum ( n ) : NEW_LINE INDENT sum_ = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum_ += i * ( n - i ) NEW_LINE return 2 * sum_ NEW_LINE DEDENT
def print_levels ( graph , v , x ) : NEW_LINE INDENT level = [ None ] * v NEW_LINE marked = [ False ] * v NEW_LINE que = Queue ( ) NEW_LINE que . put ( x ) NEW_LINE level [ x ] = 0 NEW_LINE marked [ x ] = True NEW_LINE while not que . empty ( ) : NEW_LINE INDENT x = que . get ( ) NEW_LINE for i in range ( len ( graph [ x ] ) ) : NEW_LINE INDENT b = graph [ x ] [ i ] NEW_LINE if not marked [ b ] : NEW_LINE INDENT que . put ( b ) NEW_LINE level [ b ] = level [ x ] + 1 NEW_LINE marked [ b ] = True NEW_LINE print ( " Nodes " , " ▁ " , " Level " ) NEW_LINE for i in range ( v ) : NEW_LINE INDENT print ( " ▁ " , i , " ▁ - - > ▁ " , level [ i ] , sep = " " ) NEW_LINE DEDENT DEDENT
def num_of_ways ( n , k ) : NEW_LINE INDENT p = 1 NEW_LINE if k % 2 : NEW_LINE INDENT p = - 1 NEW_LINE return ( ( n - 1 ) ** k + p * ( n - 1 ) ) / n NEW_LINE DEDENT
def dealnnoy ( n , m ) : NEW_LINE INDENT if m == 0 or n == 0 : NEW_LINE INDENT return 1 NEW_LINE return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) NEW_LINE DEDENT
def sub_array_exists ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE sum_ = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum_ += arr [ i ] NEW_LINE if sum_ == 0 or sum_ in s : NEW_LINE INDENT return True NEW_LINE s . add ( sum_ ) NEW_LINE return False NEW_LINE DEDENT
def merge ( ar1 , ar2 , m , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT last = ar1 [ m - 1 ] NEW_LINE j = m - 2 NEW_LINE while j >= 0 and ar1 [ j ] > ar2 [ i ] : NEW_LINE INDENT ar1 [ j + 1 ] = ar1 [ j ] NEW_LINE j -= 1 NEW_LINE if j != m - 2 or last > ar2 [ i ] : NEW_LINE INDENT ar1 [ j + 1 ] = ar2 [ i ] NEW_LINE ar2 [ i ] = last NEW_LINE DEDENT DEDENT DEDENT
def longest_string ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * 26 NEW_LINE count2 = [ 0 ] * 26 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE for i in range ( len ( str2 ) ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE result = " " NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT for j in range ( 1 , min ( count1 [ i ] , count2 [ i ] ) + 1 ) : NEW_LINE INDENT result = result + chr ( ord ( ' a ' ) + i ) NEW_LINE print ( result ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE return n * fact ( n - 1 ) NEW_LINE DEDENT
def decode_median_string ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE s1 = [ ] NEW_LINE is_even = True if l % 2 == 0 else False NEW_LINE for i in range ( 0 , l , 2 ) : NEW_LINE INDENT if is_even : NEW_LINE INDENT s1. insert ( 0 , s [ i ] ) NEW_LINE s1. append ( s [ i + 1 ] ) NEW_LINE else : NEW_LINE INDENT if l - i > 1 : NEW_LINE INDENT s1. append ( s [ i ] ) NEW_LINE s1. insert ( 0 , s [ i + 1 ] ) NEW_LINE else : NEW_LINE INDENT s1. append ( s [ i ] ) NEW_LINE return " " . join ( s1 ) NEW_LINE DEDENT
def maximum_path ( mat ) : NEW_LINE INDENT result = 0 NEW_LINE dp = [ [ 0 ] * ( N + 2 ) for _ in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT dp [ 0 ] [ i + 1 ] = mat [ 0 ] [ i ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ] , max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + mat [ i ] [ j - 1 ] NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT result = max ( result , dp [ N - 1 ] [ i ] ) NEW_LINE return result NEW_LINE DEDENT
def min_swap ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] <= k : NEW_LINE INDENT count = count + 1 NEW_LINE bad = 0 NEW_LINE for i in range ( count ) : NEW_LINE INDENT if arr [ i ] > k : NEW_LINE INDENT bad = bad + 1 NEW_LINE ans = bad NEW_LINE i = 0 NEW_LINE for j in range ( count , n ) : NEW_LINE INDENT if arr [ i ] > k : NEW_LINE INDENT bad = bad - 1 NEW_LINE if arr [ j ] > k : NEW_LINE INDENT bad = bad + 1 NEW_LINE ans = min ( ans , bad ) NEW_LINE return ans NEW_LINE DEDENT
def dec_to_octal ( n ) : NEW_LINE INDENT octal_num = [ 0 ] * 100 NEW_LINE i = 0 NEW_LINE while n != 0 : NEW_LINE INDENT octal_num [ i ] = n % 8 NEW_LINE n = n // 8 NEW_LINE i += 1 NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( octal_num [ j ] , end = " " ) NEW_LINE DEDENT DEDENT
def sum_of_digits_from_1_to_n ( n ) : NEW_LINE INDENT if n < 10 : NEW_LINE INDENT return n * ( n + 1 ) / 2 NEW_LINE d = math . log10 ( n ) ) NEW_LINE a = [ 0 ] * ( d + 1 ) NEW_LINE a [ 0 ] = 0 NEW_LINE a [ 1 ] = 45 NEW_LINE for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 10 + 45 * math . ceil ( 10 ** ( i - 1 ) ) NEW_LINE p = math . ceil ( 10 ** d ) NEW_LINE msd = n // p NEW_LINE return msd * a [ d ] + ( msd * ( msd - 1 ) // 2 ) * p + msd * ( 1 + n % p ) + sum_of_digits_from_1_to_n ( n % p ) NEW_LINE DEDENT
def vol_tetra ( side ) : NEW_LINE INDENT volume = side ** 3 / ( 6 * math . sqrt ( 2 ) ) NEW_LINE return volume NEW_LINE DEDENT
def my_copy ( s1 , s2 , index ) : NEW_LINE INDENT s2 [ index ] = s1 [ index ] NEW_LINE if index == len ( s1 ) - 1 : NEW_LINE INDENT return NEW_LINE my_copy ( s1 , s2 , index + 1 ) NEW_LINE DEDENT
def find_flips ( str_ , n ) : NEW_LINE INDENT last = ' ▁ ' NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if last != str_ [ i ] : NEW_LINE INDENT res += 1 NEW_LINE last = str_ [ i ] NEW_LINE return res // 2 NEW_LINE DEDENT
def inter_leave_queue ( q ) : NEW_LINE INDENT if len ( q ) % 2 != 0 : NEW_LINE INDENT print ( " Input ▁ even ▁ number ▁ of ▁ integers . " ) NEW_LINE s = LifoQueue ( ) NEW_LINE half_size = len ( q ) // 2 NEW_LINE for i in range ( half_size ) : NEW_LINE INDENT s . put ( q . queue [ 0 ] ) NEW_LINE q . get ( ) NEW_LINE while len ( s ) != 0 : NEW_LINE INDENT q . put ( s [ - 1 ] ) NEW_LINE s . get ( ) NEW_LINE for i in range ( half_size ) : NEW_LINE INDENT q . put ( q . queue [ 0 ] ) NEW_LINE q . get ( ) NEW_LINE for i in range ( half_size ) : NEW_LINE INDENT s . put ( q . queue [ 0 ] ) NEW_LINE q . get ( ) NEW_LINE while len ( s ) != 0 : NEW_LINE INDENT q . put ( s [ - 1 ] ) NEW_LINE s . get ( ) NEW_LINE q . get ( q [ 0 ] ) NEW_LINE q . get ( ) NEW_LINE DEDENT DEDENT
def odd_even_sort ( arr , n ) : NEW_LINE INDENT is_sorted = 0 NEW_LINE while is_sorted == 0 : NEW_LINE INDENT is_sorted = 1 NEW_LINE for i in range ( 1 , n - 1 , 2 ) : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE is_sorted = 0 NEW_LINE for i in range ( 0 , n - 1 , 2 ) : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE is_sorted = 0 NEW_LINE return NEW_LINE DEDENT
def shortest_seq ( s , t ) : NEW_LINE INDENT m = len ( s ) NEW_LINE n = len ( t ) NEW_LINE dp = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = MAX NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT ch = s [ i - 1 ] NEW_LINE k = j - 1 NEW_LINE while k >= 0 : NEW_LINE INDENT if t [ k ] == ch : NEW_LINE INDENT break NEW_LINE k -= 1 NEW_LINE if k == - 1 : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE else : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 ) NEW_LINE ans = dp [ m ] [ n ] NEW_LINE if ans >= MAX : NEW_LINE INDENT ans = - 1 NEW_LINE return ans NEW_LINE DEDENT
def find_longest_conseq_subseq ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE ans = 0 NEW_LINE for ele in arr : NEW_LINE INDENT s . add ( ele ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] - 1 ) not in s : NEW_LINE INDENT j = arr [ i ] NEW_LINE while j in s : NEW_LINE INDENT j += 1 NEW_LINE ans = max ( ans , j - arr [ i ] ) NEW_LINE return ans NEW_LINE DEDENT
def print_power_set ( set , set_size ) : NEW_LINE INDENT pow_set_size = 2 ** set_size NEW_LINE for counter in range ( pow_set_size ) : NEW_LINE INDENT for j in range ( set_size ) : NEW_LINE INDENT if ( counter & ( 1 << j ) ) > 0 : NEW_LINE INDENT print ( set [ j ] , end = " " ) NEW_LINE print ( ) NEW_LINE DEDENT DEDENT
def get_missing_no ( a , n ) : NEW_LINE INDENT x1 = a [ 0 ] NEW_LINE x2 = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT x1 = x1 ^ a [ i ] NEW_LINE for i in range ( 2 , n + 2 ) : NEW_LINE INDENT x2 = x2 ^ i NEW_LINE return x1 ^ x2 NEW_LINE DEDENT
def print_rotated_string ( str_ ) : NEW_LINE INDENT n = len ( str_ ) NEW_LINE temp = str_ + str_ NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( temp [ i + j ] , end = " " ) NEW_LINE print ( ) NEW_LINE DEDENT DEDENT
def get_max_gold ( gold , m , n ) : NEW_LINE INDENT gold_table = [ [ 0 ] * n for _ in range ( m ) ] NEW_LINE for col in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for row in range ( m ) : NEW_LINE INDENT if col == n - 1 : NEW_LINE INDENT right = 0 NEW_LINE else : NEW_LINE INDENT right = gold_table [ row ] [ col + 1 ] NEW_LINE if row == 0 or col == n - 1 : NEW_LINE INDENT right_up = 0 NEW_LINE else : NEW_LINE INDENT right_up = gold_table [ row - 1 ] [ col + 1 ] NEW_LINE if row == m - 1 or col == n - 1 : NEW_LINE INDENT right_down = 0 NEW_LINE else : NEW_LINE INDENT right_down = gold_table [ row + 1 ] [ col + 1 ] NEW_LINE gold_table [ row ] [ col ] = gold [ row ] [ col ] + max ( right , right_up , right_down ) NEW_LINE res = gold_table [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT res = max ( res , gold_table [ i ] [ 0 ] ) NEW_LINE return res NEW_LINE DEDENT
def possible_ways ( n , m , k ) : NEW_LINE INDENT dp = [ [ 0 ] * 10 for _ in range ( 10 ) ] NEW_LINE pre_sum = [ [ 0 ] * 10 for _ in range ( 10 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 0 NEW_LINE pre_sum [ 0 ] [ i ] = 1 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT pre_sum [ i ] [ 0 ] = 1 NEW_LINE dp [ i ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = pre_sum [ i - 1 ] [ j ] NEW_LINE if j > k : NEW_LINE INDENT dp [ i ] [ j ] -= pre_sum [ i - 1 ] [ j - k - 1 ] NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT pre_sum [ i ] [ j ] = dp [ i ] [ j ] + pre_sum [ i ] [ j - 1 ] NEW_LINE return dp [ m ] [ n ] NEW_LINE DEDENT
def find_roots ( a , b , c ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE return NEW_LINE d = b * b - 4 * a * c NEW_LINE sqrt_val = math . sqrt ( abs ( d ) ) NEW_LINE if d > 0 : NEW_LINE INDENT print ( " Roots ▁ are ▁ real ▁ and ▁ different ▁ " ) NEW_LINE print ( ( - b + sqrt_val ) / ( 2 * a ) ) NEW_LINE print ( ( - b - sqrt_val ) / ( 2 * a ) ) NEW_LINE elif d == 0 : NEW_LINE INDENT print ( " Roots ▁ are ▁ real ▁ and ▁ same " ) NEW_LINE print ( - b / ( 2 * a ) ) NEW_LINE else : NEW_LINE INDENT print ( " Roots ▁ are ▁ complex " ) NEW_LINE print ( - b / ( 2 * a ) , " ▁ + ▁ i " , sqrt_val , sep = " " ) NEW_LINE print ( - b / ( 2 * a ) , " ▁ - ▁ i " , sqrt_val , sep = " " ) NEW_LINE DEDENT DEDENT
def binary_to_decimal ( n ) : NEW_LINE INDENT num = n NEW_LINE dec_value = 0 NEW_LINE base = 1 NEW_LINE temp = num NEW_LINE while temp : NEW_LINE INDENT last_digit = temp % 10 NEW_LINE temp = temp // 10 NEW_LINE dec_value += last_digit * base NEW_LINE base = base * 2 NEW_LINE return dec_value NEW_LINE DEDENT
def sum ( a , n ) : NEW_LINE INDENT cnt = dict ( ) NEW_LINE ans = 0 NEW_LINE pre_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += ( i * a [ i ] ) - pre_sum NEW_LINE pre_sum += a [ i ] NEW_LINE if ( a [ i ] - 1 ) in cnt : NEW_LINE INDENT ans -= cnt [ a [ i ] - 1 ] NEW_LINE if ( a [ i ] + 1 ) in cnt : NEW_LINE INDENT ans += cnt [ a [ i ] + 1 ] NEW_LINE cnt [ a [ i ] ] = cnt . get ( a [ i ] , 0 ) + 1 NEW_LINE return ans NEW_LINE DEDENT
def minimum_square ( m , n ) : NEW_LINE INDENT vertical_min = sys . maxsize NEW_LINE horizontal_min = sys . maxsize NEW_LINE if m == n : NEW_LINE INDENT return 1 NEW_LINE if dp [ m ] [ n ] != 0 : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE for i in range ( 1 , m // 2 + 1 ) : NEW_LINE INDENT horizontal_min = min ( minimum_square ( i , n ) + minimum_square ( m - i , n ) , horizontal_min ) NEW_LINE for j in range ( 1 , n // 2 + 1 ) : NEW_LINE INDENT vertical_min = min ( minimum_square ( m , j ) + minimum_square ( m , n - j ) , vertical_min ) NEW_LINE dp [ m ] [ n ] = min ( vertical_min , horizontal_min ) NEW_LINE return dp [ m ] [ n ] NEW_LINE DEDENT
def cycle_sort ( arr , n ) : NEW_LINE INDENT writes = 0 NEW_LINE for cycle_start in range ( n - 1 ) : NEW_LINE INDENT item = arr [ cycle_start ] NEW_LINE pos = cycle_start NEW_LINE for i in range ( cycle_start + 1 , n ) : NEW_LINE INDENT if arr [ i ] < item : NEW_LINE INDENT pos += 1 NEW_LINE if pos == cycle_start : NEW_LINE INDENT continue NEW_LINE while item == arr [ pos ] : NEW_LINE INDENT pos += 1 NEW_LINE if pos != cycle_start : NEW_LINE INDENT arr [ pos ] , item = item , arr [ pos ] NEW_LINE writes += 1 NEW_LINE while pos != cycle_start : NEW_LINE INDENT pos = cycle_start NEW_LINE for i in range ( cycle_start + 1 , len ( arr ) ) : NEW_LINE INDENT if arr [ i ] < item : NEW_LINE INDENT pos += 1 NEW_LINE while item == arr [ pos ] : NEW_LINE INDENT pos += 1 NEW_LINE if item != arr [ pos ] : NEW_LINE INDENT arr [ pos ] , item = item , arr [ pos ] NEW_LINE writes += 1 NEW_LINE return writes NEW_LINE DEDENT
def count_non_decreasing ( n ) : NEW_LINE INDENT dp = [ [ 0 ] * ( n + 1 ) for _ in range ( 10 ) ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT dp [ i ] [ 1 ] = 1 NEW_LINE for digit in range ( 10 ) : NEW_LINE INDENT for len in range ( 2 , n + 1 ) : NEW_LINE INDENT for x in range ( digit + 1 ) : NEW_LINE INDENT dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] NEW_LINE count = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT count += dp [ i ] [ n ] NEW_LINE return count NEW_LINE DEDENT
def count ( s , m , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE if n < 0 : NEW_LINE INDENT return 0 NEW_LINE if m <= 0 and n >= 1 : NEW_LINE INDENT return 0 NEW_LINE return count ( s , m - 1 , n ) + count ( s , m , n - s [ m - 1 ] ) NEW_LINE DEDENT
def sector_area ( radius , angle ) : NEW_LINE INDENT if angle >= 360 : NEW_LINE INDENT print ( " Angle ▁ not ▁ possible " ) NEW_LINE return NEW_LINE else : NEW_LINE INDENT sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) NEW_LINE print ( sector ) NEW_LINE return NEW_LINE DEDENT DEDENT
def k_swap_maximum ( arr , n , k ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT index_position = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if k <= j - i : NEW_LINE INDENT break NEW_LINE if arr [ j ] > arr [ index_position ] : NEW_LINE INDENT index_position = j NEW_LINE for j in range ( index_position , i , - 1 ) : NEW_LINE INDENT arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ j ] NEW_LINE k -= index_position - i NEW_LINE if not k > 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
def position_rightmost_setbit ( n ) : NEW_LINE INDENT position = 1 NEW_LINE m = 1 NEW_LINE while not ( n & m ) : NEW_LINE INDENT m = m << 1 NEW_LINE position += 1 NEW_LINE return position NEW_LINE DEDENT
def find_pairs ( arr1 , arr2 , n , m , x ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if arr1 [ i ] + arr2 [ j ] == x : NEW_LINE INDENT print ( arr1 [ i ] , " ▁ " , arr2 [ j ] , sep = " " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def sparse_search ( arr , x , n ) : NEW_LINE INDENT return binary_search ( arr , 0 , n - 1 , x ) NEW_LINE DEDENT
def print_diagonal_sums ( mat , n ) : NEW_LINE INDENT principal = 0 NEW_LINE secondary = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT principal += mat [ i ] [ i ] NEW_LINE secondary += mat [ i ] [ n - i - 1 ] NEW_LINE print ( " Principal ▁ Diagonal : " , principal , sep = " " ) NEW_LINE print ( " Secondary ▁ Diagonal : " , secondary , sep = " " ) NEW_LINE DEDENT
def count_seq ( n , diff ) : NEW_LINE INDENT if abs ( diff ) > n : NEW_LINE INDENT return 0 NEW_LINE if n == 1 and diff == 0 : NEW_LINE INDENT return 2 NEW_LINE if n == 1 and abs ( diff ) == 1 : NEW_LINE INDENT return 1 NEW_LINE res = ( count_seq ( n - 1 , diff + 1 ) + 2 * count_seq ( n - 1 , diff ) + count_seq ( n - 1 , diff - 1 ) ) NEW_LINE return res NEW_LINE DEDENT
def transpose ( a , b ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT b [ i ] [ j ] = a [ j ] [ i ] NEW_LINE DEDENT DEDENT DEDENT
def longest_common_sum ( arr1 , arr2 , n ) : NEW_LINE INDENT max_len = 0 NEW_LINE pre_sum1 = pre_sum2 = 0 NEW_LINE diff = [ - 1 ] * ( 2 * n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT pre_sum1 += arr1 [ i ] NEW_LINE pre_sum2 += arr2 [ i ] NEW_LINE curr_diff = pre_sum1 - pre_sum2 NEW_LINE diff_index = n + curr_diff NEW_LINE if curr_diff == 0 : NEW_LINE INDENT max_len = i + 1 NEW_LINE elif diff [ diff_index ] == - 1 : NEW_LINE INDENT diff [ diff_index ] = i NEW_LINE else : NEW_LINE INDENT length = i - diff [ diff_index ] NEW_LINE max_len = max ( max_len , length ) NEW_LINE return max_len NEW_LINE DEDENT
def shuffle_array ( a , n ) : NEW_LINE INDENT i , q , k = 0 , 1 , n NEW_LINE while i < n : NEW_LINE INDENT for j in range ( k , i + q , - 1 ) : NEW_LINE INDENT a [ j - 1 ] , a [ j ] = a [ j ] , a [ j - 1 ] NEW_LINE i += 1 NEW_LINE k += 1 NEW_LINE q += 1 NEW_LINE DEDENT DEDENT
def find_count ( str_ ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( len ( str_ ) ) : NEW_LINE INDENT if i == ord ( str_ [ i ] ) - ord ( ' a ' ) or i == ord ( str_ [ i ] ) - ord ( ' A ' ) : NEW_LINE INDENT result += 1 NEW_LINE return result NEW_LINE DEDENT
def print_sum_tricky ( mat , k ) : NEW_LINE INDENT if k > n : NEW_LINE INDENT return NEW_LINE strip_sum = [ [ None ] * n for _ in range ( n ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT sum_ = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum_ += mat [ i ] [ j ] NEW_LINE strip_sum [ 0 ] [ j ] = sum_ NEW_LINE for i in range ( 1 , n - k + 1 ) : NEW_LINE INDENT sum_ += mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] NEW_LINE strip_sum [ i ] [ j ] = sum_ NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT sum_ = 0 NEW_LINE for j in range ( k ) : NEW_LINE INDENT sum_ += strip_sum [ i ] [ j ] NEW_LINE print ( sum_ , end = " ▁ " ) NEW_LINE for j in range ( 1 , n - k + 1 ) : NEW_LINE INDENT sum_ += strip_sum [ i ] [ j + k - 1 ] - strip_sum [ i ] [ j - 1 ] NEW_LINE print ( sum_ , end = " ▁ " ) NEW_LINE print ( ) NEW_LINE DEDENT DEDENT
def count_pairs ( s ) : NEW_LINE INDENT cnt = [ 0 for _ in range ( MAX ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) - 97 ] += 1 NEW_LINE ans = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT ans += cnt [ i ] * cnt [ i ] NEW_LINE return ans NEW_LINE DEDENT
def eulerian ( n , m ) : NEW_LINE INDENT dp = [ [ 0 ] * ( m + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT if i > j : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE else : NEW_LINE INDENT dp [ i ] [ j ] = ( i - j ) * dp [ i - 1 ] [ j - 1 ] + ( j + 1 ) * dp [ i - 1 ] [ j ] NEW_LINE return dp [ n ] [ m ] NEW_LINE DEDENT
def count_words ( str_ ) : NEW_LINE INDENT state = OUT NEW_LINE wc = 0 NEW_LINE i = 0 NEW_LINE while i < len ( str_ ) : NEW_LINE INDENT if str_ [ i ] == ' ▁ ' or str_ [ i ] == ' \ n ' or str_ [ i ] == ' \ t ' : NEW_LINE INDENT state = OUT NEW_LINE elif state == OUT : NEW_LINE INDENT state = IN NEW_LINE wc += 1 NEW_LINE i += 1 NEW_LINE return wc NEW_LINE DEDENT
def find_possible_moves ( mat , p , q ) : NEW_LINE INDENT xs = [ 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 ] NEW_LINE ys = [ 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 ] NEW_LINE count = 0 NEW_LINE for i in range ( 8 ) : NEW_LINE INDENT x = p + x [ i ] NEW_LINE y = q + ys [ i ] NEW_LINE if x >= 0 and y >= 0 and x < n and y < m and mat [ x ] [ y ] == 0 : NEW_LINE INDENT count += 1 NEW_LINE return count NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) NEW_LINE DEDENT
def pythagorean_quadruple ( a , b , c , d ) : NEW_LINE INDENT sum_ = a * a + b * b + c * c NEW_LINE if d * d == sum_ : NEW_LINE INDENT return True NEW_LINE else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def perform_queries ( a , vec ) : NEW_LINE INDENT ans = [ ] NEW_LINE n = len ( a ) - 1 NEW_LINE q = len ( vec ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT t = vec [ i ] [ 0 ] NEW_LINE m = vec [ i ] [ 1 ] NEW_LINE if m > n : NEW_LINE INDENT ans . append ( - 1 ) NEW_LINE continue NEW_LINE turn = t // n NEW_LINE rem = t % n NEW_LINE if rem == 0 and turn % 2 == 1 : NEW_LINE INDENT ans . append ( - 1 ) NEW_LINE continue NEW_LINE if rem == 0 and turn % 2 == 0 : NEW_LINE INDENT ans . append ( a [ m ] ) NEW_LINE continue NEW_LINE if turn % 2 == 0 : NEW_LINE INDENT cur_size = n - rem NEW_LINE if cur_size < m : NEW_LINE INDENT ans . append ( - 1 ) NEW_LINE continue NEW_LINE ans . append ( a [ m + rem ] ) NEW_LINE else : NEW_LINE INDENT cur_size = rem NEW_LINE if cur_size < m : NEW_LINE INDENT ans . append ( - 1 ) NEW_LINE continue NEW_LINE ans . append ( a [ m ] ) NEW_LINE for i in ans : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT
def find_sum ( arr , n ) : NEW_LINE INDENT sum_ = 0 NEW_LINE s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT sum_ += arr [ i ] NEW_LINE s . add ( arr [ i ] ) NEW_LINE return sum_ NEW_LINE DEDENT
def count9s ( number ) : NEW_LINE INDENT n = len ( number ) NEW_LINE d = [ 0 ] * 9 NEW_LINE d [ 0 ] = 1 NEW_LINE result = 0 NEW_LINE mod_sum = 0 NEW_LINE continuous_zero = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ord ( number [ i ] ) - ord ( ' 0 ' ) == 0 : NEW_LINE INDENT continuous_zero += 1 NEW_LINE else : NEW_LINE INDENT continuous_zero = 0 NEW_LINE mod_sum += ord ( number [ i ] ) - ord ( ' 0 ' ) NEW_LINE mod_sum %= 9 NEW_LINE result += d [ mod_sum ] NEW_LINE d [ mod_sum ] += 1 NEW_LINE result -= continuous_zero NEW_LINE return result NEW_LINE DEDENT
def are_disjoint ( set1 , set2 , m , n ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if set1 [ i ] == set2 [ j ] : NEW_LINE INDENT return False NEW_LINE return True NEW_LINE DEDENT
def get_nth_ugly_no ( n ) : NEW_LINE INDENT ugly = [ 0 ] * n NEW_LINE i2 = 0 NEW_LINE i3 = 0 NEW_LINE i5 = 0 NEW_LINE next_multiple_of_2 = 2 NEW_LINE next_multiple_of_3 = 3 NEW_LINE next_multiple_of_5 = 5 NEW_LINE next_ugly_no = 1 NEW_LINE ugly [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT next_ugly_no = min ( next_multiple_of_2 , next_multiple_of_3 , next_multiple_of_5 ) NEW_LINE ugly [ i ] = next_ugly_no NEW_LINE if ugly [ i ] == next_multiple_of_2 : NEW_LINE INDENT i2 += 1 NEW_LINE next_multiple_of_2 = ugly [ i2 ] * 2 NEW_LINE if ugly [ i ] == next_multiple_of_3 : NEW_LINE INDENT i3 += 1 NEW_LINE next_multiple_of_3 = ugly [ i3 ] * 3 NEW_LINE if ugly [ i ] == next_multiple_of_5 : NEW_LINE INDENT i5 += 1 NEW_LINE next_multiple_of_5 = ugly [ i5 ] * 5 NEW_LINE return next_ugly_no NEW_LINE DEDENT
def binary_search ( arr , left , right ) : NEW_LINE INDENT if left <= right : NEW_LINE INDENT mid = ( left + right ) // 2 NEW_LINE if arr [ mid - 1 ] < arr [ mid ] and arr [ mid ] > arr [ mid + 1 ] : NEW_LINE INDENT return mid NEW_LINE if arr [ mid ] < arr [ mid + 1 ] : NEW_LINE INDENT return binary_search ( arr , mid + 1 , right ) NEW_LINE else : NEW_LINE INDENT return binary_search ( arr , left , mid - 1 ) NEW_LINE return - 1 NEW_LINE DEDENT
def min_time ( arr , n ) : NEW_LINE INDENT if n <= 0 : NEW_LINE INDENT return 0 NEW_LINE incl = arr [ 0 ] NEW_LINE excl = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT incl_new = arr [ i ] + min ( excl , incl ) NEW_LINE excl_new = incl NEW_LINE incl = incl_new NEW_LINE excl = excl_new NEW_LINE return min ( incl , excl ) NEW_LINE DEDENT
def find_length ( str_ , n ) : NEW_LINE INDENT current_sum = 0 NEW_LINE max_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT current_sum += 1 if str_ [ i ] == ' 0 ' else - 1 NEW_LINE if current_sum < 0 : NEW_LINE INDENT current_sum = 0 NEW_LINE max_sum = max ( current_sum , max_sum ) NEW_LINE return - 1 if max_sum == 0 else max_sum NEW_LINE DEDENT
def mod_inverse ( a , m ) : NEW_LINE INDENT m0 = m NEW_LINE y = 0 NEW_LINE x = 1 NEW_LINE if m == 1 : NEW_LINE INDENT return 0 NEW_LINE while a > 1 : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m = a % m NEW_LINE a = t NEW_LINE t = y NEW_LINE y = x - q * y NEW_LINE x = t NEW_LINE if x < 0 : NEW_LINE INDENT x += m0 NEW_LINE return x NEW_LINE DEDENT
def is_prime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE return True NEW_LINE DEDENT
def find_3_largest ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE check = 0 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if count < 4 : NEW_LINE INDENT if check != arr [ n - i ] : NEW_LINE INDENT print ( arr [ n - i ] , end = " ▁ " ) NEW_LINE check = arr [ n - i ] NEW_LINE count += 1 NEW_LINE else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
def count_currency ( amount ) : NEW_LINE INDENT notes = [ 2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 ] NEW_LINE note_counter = [ 0 ] * 9 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT if amount >= notes [ i ] : NEW_LINE INDENT note_counter [ i ] = amount // notes [ i ] NEW_LINE amount = amount - note_counter [ i ] * notes [ i ] NEW_LINE print ( " Currency ▁ Count ▁ - > ▁ " ) NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT if note_counter [ i ] != 0 : NEW_LINE INDENT print ( i , " ▁ : ▁ " , i , sep = " " ) NEW_LINE DEDENT DEDENT DEDENT
def translate ( str_ ) : NEW_LINE INDENT for i in range ( 1 , len ( str_ ) ) : NEW_LINE INDENT if str_ [ i - 1 ] == ' A ' and str_ [ i ] == ' B ' : NEW_LINE INDENT str_ [ i - 1 ] = ' C ' NEW_LINE j = 0 NEW_LINE for j in range ( i , len ( str_ ) - 1 ) : NEW_LINE INDENT str_ [ j ] = str_ [ j + 1 ] NEW_LINE str_ [ j ] = ' ▁ ' NEW_LINE return NEW_LINE DEDENT
def print_min_number_for_pattern ( arr ) : NEW_LINE INDENT curr_max = 0 NEW_LINE last_entry = 0 NEW_LINE i = 0 NEW_LINE while i < len ( arr ) : NEW_LINE INDENT noOfNextD = 0 NEW_LINE if arr [ i ] == " I " : NEW_LINE INDENT j = i + 1 NEW_LINE while j < len ( arr ) and arr [ j ] == " D " : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE if i == 0 : NEW_LINE INDENT curr_max = noOfNextD + 2 NEW_LINE last_entry += 1 NEW_LINE print ( " " , last_entry , end = " " ) NEW_LINE print ( " " , curr_max , end = " " ) NEW_LINE last_entry = curr_max NEW_LINE else : NEW_LINE INDENT curr_max += noOfNextD + 1 NEW_LINE last_entry = curr_max NEW_LINE print ( " " , last_entry , end = " " ) NEW_LINE for k in range ( noOfNextD ) : NEW_LINE INDENT last_entry -= 1 NEW_LINE print ( " " , last_entry , end = " " ) NEW_LINE i += 1 NEW_LINE elif arr [ i ] == " D " : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT j = i + 1 NEW_LINE while j < len ( arr ) and arr [ j ] == " D " : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE curr_max = noOfNextD + 2 NEW_LINE print ( " " , curr_max , curr_max - 1 , end = " " ) NEW_LINE last_entry = curr_max - 1 NEW_LINE else : NEW_LINE INDENT print ( " " , last_entry - 1 , end = " " ) NEW_LINE last_entry -= 1 NEW_LINE i += 1 NEW_LINE print ( ) NEW_LINE DEDENT
def count_substr ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE aux_arr = [ 0 ] * n NEW_LINE if s [ 0 ] == ' 1 ' : NEW_LINE INDENT aux_arr [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' 1 ' : NEW_LINE INDENT aux_arr [ i ] = aux_arr [ i - 1 ] + 1 NEW_LINE else : NEW_LINE INDENT aux_arr [ i ] = aux_arr [ i - 1 ] NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] == ' 1 ' : NEW_LINE INDENT count += aux_arr [ i ] NEW_LINE return count NEW_LINE DEDENT
def count_divisble_by_4 ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' 4 ' or s [ i ] == ' 8 ' or s [ i ] == ' 0 ' : NEW_LINE INDENT count += 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT h = ( ord ( s [ i ] ) - ord ( ' 0 ' ) ) * 10 + ( ord ( s [ i + 1 ] ) - ord ( ' 0 ' ) ) NEW_LINE if h % 4 == 0 : NEW_LINE INDENT count = count + i + 1 NEW_LINE return count NEW_LINE DEDENT
def are_disjoint ( set1 , set2 , m , n ) : NEW_LINE INDENT set1. sort ( ) NEW_LINE set2. sort ( ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < m and j < n : NEW_LINE INDENT if set1 [ i ] < set2 [ j ] : NEW_LINE INDENT i += 1 NEW_LINE elif set2 [ j ] < set1 [ i ] : NEW_LINE INDENT j += 1 NEW_LINE else : NEW_LINE INDENT return False NEW_LINE return True NEW_LINE DEDENT
def count_strs ( n ) : NEW_LINE INDENT dp = [ [ 0 ] * 27 for _ in range ( n + 1 ) ] NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 26 ) : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] NEW_LINE else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) NEW_LINE sum_ = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT sum_ = sum_ + dp [ n ] [ i ] NEW_LINE return sum_ NEW_LINE DEDENT
def find_count_of_solutions ( n , p ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in range ( 1 , p ) : NEW_LINE INDENT if ( x * x ) % p == 1 : NEW_LINE INDENT last = x + p * ( n // p ) NEW_LINE if last > n : NEW_LINE INDENT last -= p NEW_LINE ans += ( last - x ) // p + 1 NEW_LINE return ans NEW_LINE DEDENT
def check_jumbled ( num ) : NEW_LINE INDENT if num // 10 == 0 : NEW_LINE INDENT return True NEW_LINE while num != 0 : NEW_LINE INDENT if num // 10 == 0 : NEW_LINE INDENT return True NEW_LINE digit1 = num % 10 NEW_LINE digit2 = ( num // 10 ) % 10 NEW_LINE if abs ( digit2 - digit1 ) > 1 : NEW_LINE INDENT return False NEW_LINE num = num // 10 NEW_LINE return True NEW_LINE DEDENT
def max_prod ( n ) : NEW_LINE INDENT if n == 0 or n == 1 : NEW_LINE INDENT return 0 NEW_LINE max_val = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT max_val = max ( max_val , i * ( n - i ) , max_prod ( n - i ) * i ) NEW_LINE return max_val NEW_LINE DEDENT
def print_numbers ( numbers , n ) : NEW_LINE INDENT one_two_three = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if find_contains_one_two_three ( numbers [ i ] ) : NEW_LINE INDENT one_two_three . append ( numbers [ i ] ) NEW_LINE one_two_three . sort ( ) NEW_LINE result = [ ] NEW_LINE for number in one_two_three : NEW_LINE INDENT value = number NEW_LINE if len ( result ) > 0 : NEW_LINE INDENT result . append ( " , ▁ " ) NEW_LINE result . append ( str ( value ) ) NEW_LINE return result if len ( result ) > 0 else - 1 NEW_LINE DEDENT
def swap_bits ( x ) : NEW_LINE INDENT even_bits = x & 0xAAAAAAAA NEW_LINE odd_bits = x & 0x55555555 NEW_LINE even_bits >>= 1 NEW_LINE odd_bits <<= 1 NEW_LINE return even_bits | odd_bits NEW_LINE DEDENT
def matrix_chain_order ( p , n ) : NEW_LINE INDENT m = [ [ 0 ] * n for _ in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT m [ i ] [ i ] = 0 NEW_LINE for l in range ( 2 , n ) : NEW_LINE INDENT for i in range ( 1 , n - l + 1 ) : NEW_LINE INDENT j = i + l - 1 NEW_LINE m [ i ] [ j ] = sys . maxint NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] NEW_LINE if q < m [ i ] [ j ] : NEW_LINE INDENT m [ i ] [ j ] = q NEW_LINE return m [ 1 ] [ n - 1 ] NEW_LINE DEDENT
def min_difference_among_max_min ( arr , n , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE res = sys . maxsize NEW_LINE for i in range ( n - K + 1 ) : NEW_LINE INDENT curSeqDiff = arr [ i + K - 1 ] - arr [ i ] NEW_LINE res = min ( res , curSeqDiff ) NEW_LINE return res NEW_LINE DEDENT
def bell_number ( n ) : NEW_LINE INDENT bell = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] NEW_LINE bell [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] NEW_LINE return bell [ n ] [ 0 ] NEW_LINE DEDENT
def smallest_sum_subarr ( arr , n ) : NEW_LINE INDENT min_ending_here = sys . maxsize NEW_LINE min_so_far = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if min_ending_here > 0 : NEW_LINE INDENT min_ending_here = arr [ i ] NEW_LINE else : NEW_LINE INDENT min_ending_here += arr [ i ] NEW_LINE min_so_far = min ( min_so_far , min_ending_here ) NEW_LINE return min_so_far NEW_LINE DEDENT
def count_der ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 0 NEW_LINE if n == 0 : NEW_LINE INDENT return 1 NEW_LINE if n == 2 : NEW_LINE INDENT return 1 NEW_LINE return ( n - 1 ) * ( count_der ( n - 1 ) + count_der ( n - 2 ) ) NEW_LINE DEDENT
def my_copy ( s1 , s2 ) : NEW_LINE INDENT for i in range ( len ( s1 ) ) : NEW_LINE INDENT s2 [ i ] = s1 [ i ] NEW_LINE DEDENT DEDENT
def sum_of_factors ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , int ( math . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT curr_sum = 1 NEW_LINE curr_term = 1 NEW_LINE while n % i == 0 : NEW_LINE INDENT n = n / i NEW_LINE curr_term = curr_term * i NEW_LINE curr_sum += curr_term NEW_LINE res = res * curr_sum NEW_LINE if n > 2 : NEW_LINE INDENT res *= 1 + n NEW_LINE return res NEW_LINE DEDENT
def convert ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE s1 = [ ] NEW_LINE s1. append ( s [ 0 ] . lower ( ) ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT if s [ i ] == ' ▁ ' and i <= n : NEW_LINE INDENT s1. append ( s [ i + 1 ] . lower ( ) ) NEW_LINE i += 1 NEW_LINE else : NEW_LINE INDENT s1. append ( s [ i ] . lower ( ) ) NEW_LINE i += 1 NEW_LINE return " " . join ( s1 ) NEW_LINE DEDENT
def manipulated_seive ( n ) : NEW_LINE INDENT is_prime [ 0 ] = is_prime [ 1 ] = False NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if is_prime [ i ] : NEW_LINE INDENT prime . append ( i ) NEW_LINE spf [ i ] = i NEW_LINE j = 0 NEW_LINE while j < len ( prime ) and i * prime [ j ] < n and prime [ j ] <= spf [ i ] : NEW_LINE INDENT is_prime [ i * prime [ j ] ] = False NEW_LINE spf [ i * prime [ j ] ] = prime [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT
def find_digits ( n ) : NEW_LINE INDENT if n < 0 : NEW_LINE INDENT return 0 NEW_LINE if n <= 1 : NEW_LINE INDENT return 1 NEW_LINE x = n * math . log10 ( n / math . e ) + math . log10 ( 2 * math . pi * n ) / 2.0 NEW_LINE return math . floor ( x ) + 1 NEW_LINE DEDENT
def count_sub_seq ( a , n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE h = [ 0 ] * m NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = a [ i ] % m NEW_LINE h [ a [ i ] ] += 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( i , m ) : NEW_LINE INDENT rem = ( m - ( i + j ) % m ) % m NEW_LINE if rem < j : NEW_LINE INDENT continue NEW_LINE if i == j and rem == j : NEW_LINE INDENT ans = ans + h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6 NEW_LINE elif i == j : NEW_LINE INDENT ans = ans + ( h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 ) NEW_LINE elif i == rem : NEW_LINE INDENT ans = ans + h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 NEW_LINE elif rem == j : NEW_LINE INDENT ans = ans + h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2 NEW_LINE else : NEW_LINE INDENT ans = ans + h [ i ] * h [ j ] * h [ rem ] NEW_LINE return ans NEW_LINE DEDENT DEDENT
def search ( pat , txt ) : NEW_LINE INDENT m = len ( pat ) NEW_LINE n = len ( txt ) NEW_LINE for i in range ( n - m + 1 ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if txt [ i + j ] != pat [ j ] : NEW_LINE INDENT break NEW_LINE if j == m : NEW_LINE INDENT print ( " Pattern ▁ found ▁ at ▁ index ▁ " , i , sep = " " ) NEW_LINE DEDENT DEDENT DEDENT
def calculate_sum ( n ) : NEW_LINE INDENT sum_ = 0 NEW_LINE for row in range ( n ) : NEW_LINE INDENT sum_ = sum_ + ( 1 << row ) NEW_LINE return sum_ NEW_LINE DEDENT
def is_subset ( arr1 , arr2 , m , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE if m < n : NEW_LINE INDENT return 0 NEW_LINE arr1. sort ( ) NEW_LINE arr2. sort ( ) NEW_LINE while i < n and j < m : NEW_LINE INDENT if arr1 [ j ] < arr2 [ i ] : NEW_LINE INDENT j += 1 NEW_LINE elif arr1 [ j ] == arr2 [ i ] : NEW_LINE INDENT j += 1 NEW_LINE i += 1 NEW_LINE elif arr1 [ j ] > arr2 [ i ] : NEW_LINE INDENT return 0 NEW_LINE return not ( i < n ) NEW_LINE DEDENT
def get_remainder ( num , divisor ) : NEW_LINE INDENT while num >= divisor : NEW_LINE INDENT num -= divisor NEW_LINE return num NEW_LINE DEDENT
def max_sum ( arr , n ) : NEW_LINE INDENT sum_ = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT sum_ -= 2 * arr [ i ] NEW_LINE sum_ += 2 * arr [ n - i - 1 ] NEW_LINE return sum_ NEW_LINE DEDENT
def num_off_bt ( arr , n ) : NEW_LINE INDENT max_value = - sys . maxsize NEW_LINE min_value = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_value = max ( max_value , arr [ i ] ) NEW_LINE min_value = min ( min_value , arr [ i ] ) NEW_LINE mark = [ 0 ] * ( max_value + 2 ) NEW_LINE value = [ 0 ] * ( max_value + 2 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mark [ arr [ i ] ] = 1 NEW_LINE value [ arr [ i ] ] = 1 NEW_LINE ans = 0 NEW_LINE for i in range ( min_value , max_value + 1 ) : NEW_LINE INDENT if mark [ i ] != 0 : NEW_LINE INDENT j = i + i NEW_LINE while j <= max_value and j // i <= i : NEW_LINE INDENT if mark [ j ] == 0 : NEW_LINE INDENT continue NEW_LINE value [ j ] = value [ j ] + ( value [ i ] * value [ j // i ] ) NEW_LINE if i != j // i : NEW_LINE INDENT value [ j ] = value [ j ] + ( value [ i ] * value [ j // i ] ) NEW_LINE j += i NEW_LINE ans += value [ i ] NEW_LINE return ans NEW_LINE DEDENT
def print_spiral ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT x = min ( i , j , n - 1 - i , n - 1 - j ) NEW_LINE if i <= j : NEW_LINE INDENT print ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) , end = " \ t " ) NEW_LINE else : NEW_LINE INDENT print ( ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) ) , end = " \ t " ) NEW_LINE print ( ) NEW_LINE DEDENT DEDENT
def print_binomial ( max ) : NEW_LINE INDENT for m in range ( max + 1 ) : NEW_LINE INDENT print ( m , end = " ▁ " ) NEW_LINE binom = 1 NEW_LINE for x in range ( m + 1 ) : NEW_LINE INDENT if m != 0 and x != 0 : NEW_LINE INDENT binom = binom * ( m - x + 1 ) // x NEW_LINE print ( binom , end = " ▁ " ) NEW_LINE print ( ) NEW_LINE DEDENT DEDENT
def cout_sub_seq ( a , n , m ) : NEW_LINE INDENT sum_ = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT sum_ = a [ i ] + a [ j ] + a [ k ] NEW_LINE if sum_ % m == 0 : NEW_LINE INDENT ans += 1 NEW_LINE return ans NEW_LINE DEDENT
def solve ( a , b , c , i , j , k ) : NEW_LINE INDENT min_diff = abs ( max ( a [ i ] , b [ j ] , c [ k ] ) - min ( a [ i ] , b [ j ] , c [ k ] ) ) NEW_LINE while i != - 1 and j != - 1 and k != - 1 : NEW_LINE INDENT current_diff = abs ( max ( a [ i ] , b [ j ] , c [ k ] ) - min ( a [ i ] , b [ j ] , c [ k ] ) ) NEW_LINE if current_diff < min_diff : NEW_LINE INDENT min_diff = current_diff NEW_LINE max_term = max ( a [ i ] , b [ j ] , c [ k ] ) NEW_LINE if a [ i ] == max_term : NEW_LINE INDENT i -= 1 NEW_LINE elif b [ j ] == max_term : NEW_LINE INDENT j -= 1 NEW_LINE else : NEW_LINE INDENT k -= 1 NEW_LINE return min_diff NEW_LINE DEDENT
def max_sum_difference ( a , n ) : NEW_LINE INDENT final_sequence = [ ] NEW_LINE a . sort ( ) NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT final_sequence . append ( a [ i ] ) NEW_LINE final_sequence . append ( a [ n - i - 1 ] ) NEW_LINE maximum_sum = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT maximum_sum = maximum_sum + abs ( final_sequence [ i ] - final_sequence [ i + 1 ] ) NEW_LINE maximum_sum = maximum_sum + abs ( final_sequence [ n - 1 ] - final_sequence [ 0 ] ) NEW_LINE print ( maximum_sum ) NEW_LINE DEDENT
def number_of_squares ( base ) : NEW_LINE INDENT base = base - 2 NEW_LINE base = base // 2 NEW_LINE return base * ( base + 1 ) // 2 NEW_LINE DEDENT
def hexagon_area ( s ) : NEW_LINE INDENT return ( 3 * math . sqrt ( 3 ) * ( s * s ) ) / 2 NEW_LINE DEDENT
def draw_pattern ( n0 ) : NEW_LINE INDENT n = n0 NEW_LINE row = 1 NEW_LINE nst = 1 NEW_LINE nsp1 = n - 1 NEW_LINE nsp2 = - 1 NEW_LINE val1 = row NEW_LINE val2 = 1 NEW_LINE while row <= n : NEW_LINE INDENT csp1 = 1 NEW_LINE while csp1 <= nsp1 : NEW_LINE INDENT print ( " ▁ " , end = " ▁ " ) NEW_LINE csp1 = csp1 + 1 NEW_LINE cst1 = 1 NEW_LINE while cst1 <= nst : NEW_LINE INDENT print ( val1 , end = " ▁ " ) NEW_LINE val1 = val1 - 1 NEW_LINE cst1 = cst1 + 1 NEW_LINE csp2 = 1 NEW_LINE while csp2 <= nsp2 : NEW_LINE INDENT print ( " ▁ " , end = " ▁ " ) NEW_LINE csp2 = csp2 + 1 NEW_LINE if row != 1 and row != n : NEW_LINE INDENT cst2 = 1 NEW_LINE while cst2 <= nst : NEW_LINE INDENT print ( val2 , end = " ▁ " ) NEW_LINE val2 = val2 + 1 NEW_LINE cst2 = cst2 + 1 NEW_LINE print ( ) NEW_LINE if row <= n // 2 : NEW_LINE INDENT nst = nst + 1 NEW_LINE nsp1 = nsp1 - 2 NEW_LINE nsp2 = nsp2 + 2 NEW_LINE val1 = row + 1 NEW_LINE val2 = 1 NEW_LINE else : NEW_LINE INDENT nst = nst - 1 NEW_LINE nsp1 = nsp1 + 2 NEW_LINE nsp2 = nsp2 - 2 NEW_LINE val1 = n - row NEW_LINE val2 = 1 NEW_LINE row = row + 1 NEW_LINE DEDENT DEDENT
def find_winner ( x , y , n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = False NEW_LINE dp [ 1 ] = True NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i - 1 >= 0 and not dp [ i - 1 ] : NEW_LINE INDENT dp [ i ] = True NEW_LINE elif i - x >= 0 and not dp [ i - x ] : NEW_LINE INDENT dp [ i ] = True NEW_LINE elif i - y >= 0 and not dp [ i - y ] : NEW_LINE INDENT dp [ i ] = True NEW_LINE else : NEW_LINE INDENT dp [ i ] = False NEW_LINE return dp [ n ] NEW_LINE DEDENT
def find_difference ( arr , n , m ) : NEW_LINE INDENT max = 0 NEW_LINE min = 0 NEW_LINE arr . sort ( ) NEW_LINE j = n - 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT min += arr [ i ] NEW_LINE max += arr [ j ] NEW_LINE j = j - 1 NEW_LINE return max - min NEW_LINE DEDENT
def if_possible ( arr , n ) : NEW_LINE INDENT cp = [ 0 ] * n NEW_LINE cp = arr NEW_LINE cp . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if not ( arr [ i ] == cp [ i ] ) and not ( arr [ n - 1 - i ] == cp [ i ] ) : NEW_LINE INDENT return False NEW_LINE return True NEW_LINE DEDENT
def double_factorial ( n ) : NEW_LINE INDENT if n == 0 or n == 1 : NEW_LINE INDENT return 1 NEW_LINE return n * double_factorial ( n - 2 ) NEW_LINE DEDENT
def floor_sqrt ( x ) : NEW_LINE INDENT if x == 0 or x == 1 : NEW_LINE INDENT return x NEW_LINE start = 1 NEW_LINE end = x NEW_LINE while start <= end : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if mid * mid == x : NEW_LINE INDENT return mid NEW_LINE if mid * mid < x : NEW_LINE INDENT start = mid + 1 NEW_LINE ans = mid NEW_LINE else : NEW_LINE INDENT end = mid - 1 NEW_LINE return ans NEW_LINE DEDENT
def word_reverse ( str_ ) : NEW_LINE INDENT i = len ( str_ ) - 1 NEW_LINE start = i + 1 NEW_LINE end = i + 1 NEW_LINE result = [ ] NEW_LINE while i >= 0 : NEW_LINE INDENT if str_ [ i ] == ' ▁ ' : NEW_LINE INDENT start = i + 1 NEW_LINE while start != end : NEW_LINE INDENT result . append ( str_ [ start ] ) NEW_LINE start += 1 NEW_LINE result . append ( ' ▁ ' ) NEW_LINE end = i NEW_LINE i -= 1 NEW_LINE start = 0 NEW_LINE while start != end : NEW_LINE INDENT result . append ( str_ [ start ] ) NEW_LINE start += 1 NEW_LINE return " " . join ( result ) NEW_LINE DEDENT
def shortest_path ( graph , u , v , k ) : NEW_LINE INDENT sp = [ [ [ None ] * ( k + 1 ) for _ in range ( V_NUM ) ] for _ in range ( V_NUM ) ] NEW_LINE for e in range ( k + 1 ) : NEW_LINE INDENT for i in range ( V_NUM ) : NEW_LINE INDENT for j in range ( V_NUM ) : NEW_LINE INDENT sp [ i ] [ j ] [ e ] = INF NEW_LINE if e == 0 and i == j : NEW_LINE INDENT sp [ i ] [ j ] [ e ] = 0 NEW_LINE if e == 1 and graph [ i ] [ j ] != INF : NEW_LINE INDENT sp [ i ] [ j ] [ e ] = graph [ i ] [ j ] NEW_LINE if e > 1 : NEW_LINE INDENT for a in range ( V_NUM ) : NEW_LINE INDENT if graph [ i ] [ a ] != INF and i != a and j != a and sp [ a ] [ j ] [ e - 1 ] != INF : NEW_LINE INDENT sp [ i ] [ j ] [ e ] = min ( sp [ i ] [ j ] [ e ] , graph [ i ] [ a ] + sp [ a ] [ j ] [ e - 1 ] ) NEW_LINE return sp [ u ] [ v ] [ k ] NEW_LINE DEDENT
def overflow ( h0 , r , h , n , r0 ) : NEW_LINE INDENT tank_cap = 3.14 * r * r * h0 NEW_LINE water_vol = 3.14 * r * r * h NEW_LINE balls_vol = n * ( 4 / 3 ) * 3.14 * r0 * r0 * r0 NEW_LINE vol = water_vol + balls_vol NEW_LINE if vol > tank_cap : NEW_LINE INDENT print ( " Overflow " ) NEW_LINE else : NEW_LINE INDENT print ( " Not ▁ in ▁ overflow ▁ state " ) NEW_LINE DEDENT DEDENT
def calc_expectation ( a , n ) : NEW_LINE INDENT prb = 1 / n NEW_LINE sum_ = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum_ += a [ i ] * prb NEW_LINE return float ( sum_ ) NEW_LINE DEDENT
def find_and_print_uncommon_chars ( str1 , str2 ) : NEW_LINE INDENT present = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT present [ i ] = 0 NEW_LINE l1 = len ( str1 ) NEW_LINE l2 = len ( str2 ) NEW_LINE for i in range ( l1 ) : NEW_LINE INDENT present [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE for i in range ( l2 ) : NEW_LINE INDENT if present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] == 1 or present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] == - 1 : NEW_LINE INDENT present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] = - 1 NEW_LINE else : NEW_LINE INDENT present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] = 2 NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if present [ i ] == 1 or present [ i ] == 2 : NEW_LINE INDENT print ( chr ( i + ord ( ' a ' ) ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def print_distinct ( str_ ) : NEW_LINE INDENT count = [ 0 ] * NO_OF_CHARS NEW_LINE for i in range ( len ( str_ ) ) : NEW_LINE INDENT if str_ [ i ] != ' ▁ ' : NEW_LINE INDENT count [ ord ( str_ [ i ] ) ] += 1 NEW_LINE n = i NEW_LINE for i in range ( n ) : NEW_LINE INDENT if count [ ord ( str_ [ i ] ) ] == 1 : NEW_LINE INDENT print ( str_ [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def find_extra ( arr1 , arr2 , n ) : NEW_LINE INDENT index = n NEW_LINE left = 0 NEW_LINE right = n - 1 NEW_LINE while left <= right : NEW_LINE INDENT mid = ( left + right ) // 2 NEW_LINE if arr2 [ mid ] == arr1 [ mid ] : NEW_LINE INDENT left = mid + 1 NEW_LINE else : NEW_LINE INDENT index = mid NEW_LINE right = mid - 1 NEW_LINE return index NEW_LINE DEDENT
def noble_integer ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( size ) : NEW_LINE INDENT if arr [ i ] < arr [ j ] : NEW_LINE INDENT count += 1 NEW_LINE if count == arr [ i ] : NEW_LINE INDENT return arr [ i ] NEW_LINE return - 1 NEW_LINE DEDENT
def count_str ( n , b_count , c_count ) : NEW_LINE INDENT if b_count < 0 or c_count < 0 : NEW_LINE INDENT return 0 NEW_LINE if n == 0 : NEW_LINE INDENT return 1 NEW_LINE if b_count == 0 and c_count == 0 : NEW_LINE INDENT return 1 NEW_LINE res = count_str ( n - 1 , b_count , c_count ) NEW_LINE res += count_str ( n - 1 , b_count - 1 , c_count ) NEW_LINE res += count_str ( n - 1 , b_count , c_count - 1 ) NEW_LINE return res NEW_LINE DEDENT
def gcd_of_factorial ( m , n ) : NEW_LINE INDENT return factorial ( min ( m , n ) ) NEW_LINE DEDENT
def sub_array_sum ( arr , n , sum_ ) : NEW_LINE INDENT hash_map = dict ( ) NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sum = curr_sum + arr [ i ] NEW_LINE if curr_sum == sum_ : NEW_LINE INDENT print ( " Sum ▁ found ▁ between ▁ indexes ▁ 0 ▁ to ▁ " , i , sep = " " ) NEW_LINE return NEW_LINE if ( curr_sum - sum_ ) in hash_map : NEW_LINE INDENT print ( " Sum ▁ found ▁ between ▁ indexes ▁ " , hash_map [ curr_sum - sum_ ] + 1 , " ▁ to ▁ " , i , sep = " " ) NEW_LINE return NEW_LINE hash_map [ curr_sum ] = i NEW_LINE print ( " No ▁ subarray ▁ with ▁ given ▁ sum ▁ exists " ) NEW_LINE DEDENT
def check_reverse ( arr , n ) : NEW_LINE INDENT temp = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp [ i ] = arr [ i ] NEW_LINE temp . sort ( ) NEW_LINE front = 0 NEW_LINE for front in range ( n ) : NEW_LINE INDENT if temp [ front ] != arr [ front ] : NEW_LINE INDENT break NEW_LINE back = 0 NEW_LINE for back in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if temp [ back ] != arr [ back ] : NEW_LINE INDENT break NEW_LINE if front >= back : NEW_LINE INDENT return True NEW_LINE while front != back : NEW_LINE INDENT front += 1 NEW_LINE if arr [ front - 1 ] < arr [ front ] : NEW_LINE INDENT return False NEW_LINE return True NEW_LINE DEDENT
def freq ( ar , m , n ) : NEW_LINE INDENT even = 0 NEW_LINE odd = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ar [ i ] [ j ] % 2 ) == 0 : NEW_LINE INDENT even += 1 NEW_LINE else : NEW_LINE INDENT odd += 1 NEW_LINE print ( " ▁ Frequency ▁ of ▁ odd ▁ number ▁ = " , odd , sep = " " ) NEW_LINE print ( " ▁ Frequency ▁ of ▁ even ▁ number ▁ = " , even , sep = " " ) NEW_LINE DEDENT
def long_len_strict_bitonic_sub ( arr , n ) : NEW_LINE INDENT inc = SortedDict ( ) NEW_LINE dcr = SortedDict ( ) NEW_LINE len_inc , len_dcr = [ 0 ] * n , [ 0 ] * n NEW_LINE long_len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT len_ = 0 NEW_LINE if inc . get ( arr [ i ] - 1 ) in inc . values ( ) : NEW_LINE INDENT len_ = inc . get ( arr [ i ] - 1 ) NEW_LINE len_inc [ i ] = len_ + 1 NEW_LINE inc [ arr [ i ] ] = len_inc [ i ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT len_ = 0 NEW_LINE if dcr . get ( arr [ i ] - 1 ) in dcr . values ( ) : NEW_LINE INDENT len_ = dcr . get ( arr [ i ] - 1 ) NEW_LINE len_dcr [ i ] = len_ + 1 NEW_LINE dcr [ arr [ i ] ] = len_dcr [ i ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if long_len < ( len_inc [ i ] + len_dcr [ i ] - 1 ) : NEW_LINE INDENT long_len = len_inc [ i ] + len_dcr [ i ] - 1 NEW_LINE return long_len NEW_LINE DEDENT
def mod ( num , a ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT res = ( res * 10 + ord ( num [ i ] ) - ord ( ' 0 ' ) ) % a NEW_LINE return res NEW_LINE DEDENT
def print_shortest_super_seq ( x , y ) : NEW_LINE INDENT m = len ( x ) NEW_LINE n = len ( y ) NEW_LINE dp = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT dp [ i ] [ j ] = j NEW_LINE elif j == 0 : NEW_LINE INDENT dp [ i ] [ j ] = i NEW_LINE elif x [ i - 1 ] == y [ j - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE index = dp [ m ] [ n ] NEW_LINE str_ = [ ] NEW_LINE i = m NEW_LINE j = n NEW_LINE while i > 0 and j > 0 : NEW_LINE INDENT if x [ i - 1 ] == y [ j - 1 ] : NEW_LINE INDENT str_ . append ( x [ i - 1 ] ) NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE index -= 1 NEW_LINE elif dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] : NEW_LINE INDENT str_ . append ( y [ j - 1 ] ) NEW_LINE j -= 1 NEW_LINE index -= 1 NEW_LINE else : NEW_LINE INDENT str_ . append ( x [ i - 1 ] ) NEW_LINE i -= 1 NEW_LINE index -= 1 NEW_LINE while i > 0 : NEW_LINE INDENT str_ . append ( x [ i - 1 ] ) NEW_LINE i -= 1 NEW_LINE index -= 1 NEW_LINE while j > 0 : NEW_LINE INDENT str_ . append ( y [ j - 1 ] ) NEW_LINE j -= 1 NEW_LINE index -= 1 NEW_LINE str_ . reverse ( ) NEW_LINE return " " . join ( str_ ) NEW_LINE DEDENT
def find_elements ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def count ( n ) : NEW_LINE INDENT dp = [ None ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i <= 3 : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE elif i == 4 : NEW_LINE INDENT dp [ i ] = 2 NEW_LINE else : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] NEW_LINE return dp [ n ] NEW_LINE DEDENT
def number_of_triangles ( n ) : NEW_LINE INDENT answer = [ None ] * ( n + 1 ) NEW_LINE answer [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) NEW_LINE INDENT answer [ i ] = answer [ i - 1 ] * 3 + 2 NEW_LINE return answer [ n ] NEW_LINE DEDENT
def power ( x , y ) : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT return 1 NEW_LINE elif y % 2 == 0 : NEW_LINE INDENT return power ( x , y // 2 ) * power ( x , y // 2 ) NEW_LINE else : NEW_LINE INDENT return x * power ( x , y // 2 ) * power ( x , y // 2 ) NEW_LINE DEDENT DEDENT
def check_origin ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) NEW_LINE DEDENT