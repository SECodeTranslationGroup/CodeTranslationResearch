int SumDigits ( int no ) { return no == 0 ? 0 : no % 10 + SumDigits ( no / 10 ) ; }
int FindSum ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { ans += i / j ; } } return ans ; }
bool IsPalindrome ( const string & s ) { int l = s . length ( ) ; int j ; for ( int i = 0 , j = l - 1 ; i <= j ; i ++ , j -- ) { if ( s [ i ] != s [ j ] ) { return false ; } } return true ; }
int GetMinStepToReachEnd ( int arr [ ] , int n ) { bool visit [ n ] ; int distance [ n ] ; vector < int > digit [ 10 ] ; memset ( visit , false , sizeof ( visit ) ) ; for ( int i = 1 ; i < n ; i ++ ) { digit [ arr [ i ] ] . push_back ( i ) ; } distance [ 0 ] = 0 ; visit [ 0 ] = true ; queue < int > q ; q . push ( 0 ) ; while ( ! q . empty ( ) ) { int idx = q . front ( ) ; q . pop ( ) ; if ( idx == n - 1 ) { break ; } int d = arr [ idx ] ; for ( int i = 0 ; i < digit [ d ] . size ( ) ; i ++ ) { int next_idx = digit [ d ] [ i ] ; if ( ! visit [ next_idx ] ) { visit [ next_idx ] = true ; q . push ( next_idx ) ; distance [ next_idx ] = distance [ idx ] + 1 ; } } digit [ d ] . clear ( ) ; if ( idx - 1 >= 0 && ! visit [ idx - 1 ] ) { visit [ idx - 1 ] = true ; q . push ( idx - 1 ) ; distance [ idx - 1 ] = distance [ idx ] + 1 ; } if ( idx + 1 < n && ! visit [ idx + 1 ] ) { visit [ idx + 1 ] = true ; q . push ( idx + 1 ) ; distance [ idx + 1 ] = distance [ idx ] + 1 ; } } return distance [ n - 1 ] ; }
long FindWays ( int f , int d , int s ) { long mem [ d + 1 ] [ s + 1 ] ; memset ( mem , 0 , sizeof mem ) ; mem [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= d ; i ++ ) { for ( int j = i ; j <= s ; j ++ ) { mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] ; if ( j - f - 1 >= 0 ) { mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] ; } } } return mem [ d ] [ s ] ; }
int MaxVolume ( int s ) { int max_value = 0 ; for ( int i = 1 ; i <= s - 2 ; i ++ ) { for ( int j = 1 ; j <= s - 1 ; j ++ ) { int k = s - i - j ; max_value = max ( max_value , i * j * k ) ; } } return max_value ; }
int MinDaysToEmpty ( int c , int l ) { if ( l >= c ) { return c ; } double eq_root = ( std :: sqrt ( 1 + 8 * ( c - l ) ) - 1 ) / 2 ; return ceil ( eq_root ) + l ; }
int MinDiff ( int arr [ ] , int n , int k ) { int result = numeric_limits < int > :: max ( ) ; sort ( arr , arr + n ) ; for ( int i = 0 ; i <= n - k ; i ++ ) { result = min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; } return result ; }
void Concatenate ( char a [ ] , char b [ ] , char c [ ] , int n1 , int n2 ) { int i ; for ( i = 0 ; i < n1 ; i ++ ) { c [ i ] = a [ i ] ; } for ( int j = 0 ; j < n2 ; j ++ ) { c [ i ++ ] = b [ j ] ; } }
int CeilSearch ( int arr [ ] , int low , int high , int x ) { if ( x <= arr [ low ] ) { return low ; } for ( int i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) { return i ; } if ( arr [ i ] < x && arr [ i + 1 ] >= x ) { return i + 1 ; } } return - 1 ; }
void PrintMaxSubSquare ( bool m [ kRow ] [ kCol ] ) { int s [ kRow ] [ kCol ] ; int max_of_s , max_i , max_j ; for ( int i = 0 ; i < kRow ; i ++ ) { s [ i ] [ 0 ] = m [ i ] [ 0 ] ; } for ( int j = 0 ; j < kCol ; j ++ ) { s [ 0 ] [ j ] = m [ 0 ] [ j ] ; } for ( int i = 1 ; i < kRow ; i ++ ) { for ( int j = 1 ; j < kCol ; j ++ ) { if ( m [ i ] [ j ] == 1 ) { s [ i ] [ j ] = min ( s [ i ] [ j - 1 ] , min ( s [ i - 1 ] [ j ] , s [ i - 1 ] [ j - 1 ] ) ) + 1 ; } else { s [ i ] [ j ] = 0 ; } } } max_of_s = s [ 0 ] [ 0 ] ; max_i = 0 ; max_j = 0 ; for ( int i = 0 ; i < kRow ; i ++ ) { for ( int j = 0 ; j < kCol ; j ++ ) { if ( max_of_s < s [ i ] [ j ] ) { max_of_s = s [ i ] [ j ] ; max_i = i ; max_j = j ; } } } cout << " Maximum ▁ size ▁ sub - matrix ▁ is : ▁ " << endl ; for ( int i = max_i ; i > max_i - max_of_s ; i -- ) { for ( int j = max_j ; j > max_j - max_of_s ; j -- ) { cout << m [ i ] [ j ] << " ▁ " ; } cout << endl ; } }
int MinMaxProduct ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { int max = arr1 [ 0 ] ; int min = arr2 [ 0 ] ; int i ; for ( i = 1 ; i < n1 && i < n2 ; ++ i ) { if ( arr1 [ i ] > max ) { max = arr1 [ i ] ; } if ( arr2 [ i ] < min ) { min = arr2 [ i ] ; } } while ( i < n1 ) { if ( arr1 [ i ] > max ) { max = arr1 [ i ] ; } i ++ ; } while ( i < n2 ) { if ( arr2 [ i ] < min ) { min = arr2 [ i ] ; } i ++ ; } return max * min ; }
bool IsComposite ( int n ) { if ( n <= 1 ) { return false ; } if ( n <= 3 ) { return false ; } if ( n % 2 == 0 || n % 3 == 0 ) { return true ; } for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return true ; } } return false ; }
void FindMaxGuests ( int arrl [ ] , int exit [ ] , int n ) { sort ( arrl , arrl + n ) ; sort ( exit , exit + n ) ; int guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in ++ ; if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] ; } i ++ ; } else { guests_in -- ; j ++ ; } } cout << " Maximum ▁ Number ▁ of ▁ Guests ▁ = ▁ " << max_guests << " ▁ at ▁ time ▁ " << time ; }
int Identity ( int num ) { int row , col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) { cout << 1 << " ▁ " ; } else { cout << 0 << " ▁ " ; } } cout << endl ; } return 0 ; }
int PrintKDistinct ( int arr [ ] , int n , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) { if ( i != j && arr [ j ] == arr [ i ] ) { break ; } } if ( j == n ) { dist_count ++ ; } if ( dist_count == k ) { return arr [ i ] ; } } return - 1 ; }
void Reorder ( int arr [ ] , int index [ ] , int n ) { int temp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { temp [ index [ i ] ] = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = temp [ i ] ; index [ i ] = i ; } }
int PrintCountDp ( int dist ) { int count [ dist + 1 ] ; count [ 0 ] = 1 , count [ 1 ] = 1 , count [ 2 ] = 2 ; for ( int i = 3 ; i <= dist ; i ++ ) { count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ; } return count [ dist ] ; }
int MaximumChars ( const string & str ) { int n = str . length ( ) ; int res = - 1 ; int first_inds [ kMaxChar ] ; for ( int i = 0 ; i < kMaxChar ; i ++ ) { first_inds [ i ] = - 1 ; } for ( int i = 0 ; i < n ; i ++ ) { int first_ind = first_inds [ str [ i ] ] ; if ( first_ind == - 1 ) { first_inds [ str [ i ] ] = i ; } else { res = max ( res , abs ( i - first_ind - 1 ) ) ; } } return res ; }
int FirstRepeated ( const string & str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { int val = ( str [ i ] - ' a ' ) ; if ( checker & ( 1 << val ) > 0 ) { return i ; } checker |= ( 1 << val ) ; } return - 1 ; }
int FindMaxProduct ( int arr [ ] , int n ) { int i ; int ans = numeric_limits < int > :: min ( ) ; int max_val = 1 ; int min_val = 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { max_val = max_val * arr [ i ] ; min_val = min ( 1 , min_val * arr [ i ] ) ; } else if ( arr [ i ] == 0 ) { min_val = 1 ; max_val = 0 ; } else if ( arr [ i ] < 0 ) { int prev_max = max_val ; max_val = min_val * arr [ i ] ; min_val = prev_max * arr [ i ] ; } ans = max ( ans , max_val ) ; if ( max_val <= 0 ) { max_val = 1 ; } } return ans ; }
void Survival ( int s , int n , int m ) { if ( ( ( n * 6 ) < ( m * 7 ) && s > 6 ) || m > n ) { cout << " No " << endl ; } else { int days = ( m * s ) / n ; if ( ( m * s ) % n != 0 ) { days ++ ; } cout << " Yes ▁ " << days << endl ; } }
void FirstNonRepeating ( const string & str ) { int char_count [ kMaxChar ] ; memset ( char_count , 0 , sizeof ( char_count ) ) ; queue < char > q ; for ( int i = 0 ; str [ i ] ; i ++ ) { q . push ( str [ i ] ) ; char_count [ str [ i ] - ' a ' ] ++ ; while ( ! q . empty ( ) ) { if ( char_count [ q . front ( ) - ' a ' ] > 1 ) { q . pop ( ) ; } else { cout << q . front ( ) << " ▁ " ; break ; } } if ( q . empty ( ) ) { cout << - 1 << " ▁ " ; } } cout << endl ; }
void Dfs ( vector < int > list [ ] , int node , int arrival ) { cout << node << endl ; for ( int i = 0 ; i < list [ node ] . size ( ) ; i ++ ) { if ( list [ node ] [ i ] != arrival ) { Dfs ( list , list [ node ] [ i ] , node ) ; } } }
int FindRepeating ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { res = res ^ ( i + 1 ) ^ arr [ i ] ; } res = res ^ arr [ n - 1 ] ; return res ; }
int GetCount ( char keypad [ ] [ 3 ] , int n ) { if ( keypad == nullptr || n <= 0 ) { return 0 ; } if ( n == 1 ) { return 10 ; } int odd [ 10 ] , even [ 10 ] ; int use_odd = 0 , total_count = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) { odd [ i ] = 1 ; } for ( int j = 2 ; j <= n ; j ++ ) { use_odd = 1 - use_odd ; if ( use_odd == 1 ) { even [ 0 ] = odd [ 0 ] + odd [ 8 ] ; even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ] ; even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] ; even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ] ; even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] ; even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] ; even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] ; even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] ; even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] ; even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ] ; } else { odd [ 0 ] = even [ 0 ] + even [ 8 ] ; odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ] ; odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ] ; odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ] ; odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ] ; odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ] ; odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ] ; odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ] ; odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ] ; odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ] ; } } total_count = 0 ; if ( use_odd == 1 ) { for ( int i = 0 ; i <= 9 ; i ++ ) { total_count += even [ i ] ; } } else { for ( int i = 0 ; i <= 9 ; i ++ ) { total_count += odd [ i ] ; } } return total_count ; }
int CountSubarrWithEqualZeroAndOne ( int arr [ ] , int n ) { map < int , int > my_map ; int sum = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { arr [ i ] = - 1 ; } sum += arr [ i ] ; if ( sum == 0 ) { count ++ ; } if ( my_map . find ( sum ) != my_map . end ( ) ) { count += my_map [ sum ] ; } my_map [ sum ] ++ ; } return count ; }
void Search ( int mat [ kRow ] [ kCol ] , int from_row , int to_row , int from_col , int to_col , int key ) { int i = from_row + ( to_row - from_row ) / 2 ; int j = from_col + ( to_col - from_col ) / 2 ; if ( mat [ i ] [ j ] == key ) { cout << " Found ▁ " << key << " ▁ at ▁ " << i << " ▁ " << j << endl ; } else { if ( i != to_row || j != from_col ) { Search ( mat , from_row , i , j , to_col , key ) ; } if ( from_row == to_row && from_col + 1 == to_col ) { if ( mat [ from_row ] [ to_col ] == key ) { cout << " Found ▁ " << key << " ▁ at ▁ " << from_row << " ▁ " << to_col << endl ; } } if ( mat [ i ] [ j ] < key ) { if ( i + 1 <= to_row ) { Search ( mat , i + 1 , to_row , from_col , to_col , key ) ; } } else { if ( j - 1 >= from_col ) { Search ( mat , from_row , to_row , from_col , j - 1 , key ) ; } } } }
int KthGroupSum ( int k ) { return k * k * k ; }
bool AreKAnagrams ( const string & str1 , const string & str2 , int k ) { int n = str1. length ( ) ; if ( str2. length ( ) != n ) { return false ; } int hash_str1 [ kMaxChar ] ; memset ( hash_str1 , 0 , sizeof ( hash_str1 ) ) ; for ( int i = 0 ; i < n ; i ++ ) { hash_str1 [ str1 [ i ] - ' a ' ] ++ ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash_str1 [ str2 [ i ] - ' a ' ] > 0 ) { hash_str1 [ str2 [ i ] - ' a ' ] -- ; } else { count ++ ; } if ( count > k ) { return false ; } } return true ; }
void BonacciSeries ( int n , int m ) { int a [ m ] ; memset ( a , 0 , sizeof ( a ) ) ; a [ n - 1 ] = 1 ; for ( int i = n ; i < m ; i ++ ) { for ( int j = i - n ; j < i ; j ++ ) { a [ i ] += a [ j ] ; } } for ( int i = 0 ; i < m ; i ++ ) { cout << a [ i ] << " ▁ " ; } }
void PrintMinIndexChar ( const string & str , const string & patt ) { int min_index = numeric_limits < int > :: max ( ) ; int m = str . size ( ) ; int n = patt . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( patt [ i ] == str [ j ] && j < min_index ) { min_index = j ; break ; } } } if ( min_index != numeric_limits < int > :: max ( ) ) { cout << " Minimum ▁ Index ▁ Character ▁ = ▁ " << str [ min_index ] ; } else { cout << " No ▁ character ▁ present " ; } }
bool NegCycleFloydWarshall ( int graph [ kVNum ] [ kVNum ] ) { int dist [ kVNum ] [ kVNum ] ; for ( int i = 0 ; i < kVNum ; i ++ ) { for ( int j = 0 ; j < kVNum ; j ++ ) { dist [ i ] [ j ] = graph [ i ] [ j ] ; } } for ( int k = 0 ; k < kVNum ; k ++ ) { for ( int i = 0 ; i < kVNum ; i ++ ) { for ( int j = 0 ; j < kVNum ; j ++ ) { if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) { dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] ; } } } } for ( int i = 0 ; i < kVNum ; i ++ ) { if ( dist [ i ] [ i ] < 0 ) { return true ; } } return false ; }
string LexNext ( const string & str , int n ) { string s ( str ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] != ' z ' ) { s [ i ] ++ ; return s ; } s [ i ] = ' a ' ; } }
void PrintDuo ( const string & str ) { int count_char [ kMaxChar ] ; memset ( count_char , 0 , sizeof ( count_char ) ) ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { count_char [ str [ i ] - ' a ' ] ++ ; } string str1 , str2 ; for ( int i = 0 ; i < kMaxChar ; i ++ ) { if ( count_char [ i ] > 1 ) { str2 = str2 + ( char ) ( i + ' a ' ) ; } else if ( count_char [ i ] == 1 ) { str1 = str1 + ( char ) ( i + ' a ' ) ; } } cout << " String ▁ with ▁ characters ▁ occurring ▁ once : " << endl ; cout << str1 << endl ; cout << " String ▁ with ▁ characters ▁ occurring ▁ multiple ▁ times : " << endl ; cout << str2 << endl ; }
void RoundOff ( double n0 , double n ) { int h ; double b , c , d , e , i , j , m , f ; b = n0 ; c = floor ( n0 ) ; for ( i = 0 ; b >= 1 ; ++ i ) { b = b / 10 ; } d = n - i ; b = n0 ; b = b * pow ( 10 , d ) ; e = b + 0.5 ; if ( ( float ) e == ( float ) ceil ( b ) ) { f = ceil ( b ) ; h = f - 2 ; if ( h % 2 != 0 ) { e = e - 1 ; } } j = floor ( e ) ; m = pow ( 10 , d ) ; j = j / m ; cout << " The ▁ number ▁ after ▁ rounding - off ▁ is ▁ " << j ; }
void PrintRotatedString ( const string & str ) { int len = str . length ( ) ; string temp ( len , ' ▁ ' ) ; for ( int i = 0 ; i < len ; i ++ ) { int j = i ; int k = 0 ; while ( j < len ) { temp [ k ] = str [ j ] ; k ++ ; j ++ ; } j = 0 ; while ( j < i ) { temp [ k ] = str [ j ] ; j ++ ; k ++ ; } cout << temp << endl ; } }
int Difference ( int arr [ ] [ kMax ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) { d1 += arr [ i ] [ j ] ; } if ( i == n - j - 1 ) { d2 += arr [ i ] [ j ] ; } } } return abs ( d1 - d2 ) ; }
int Calculate ( const string & n ) { int len = n . length ( ) ; int l = len / 2 ; int count = 0 ; for ( int i = 1 ; i <= l ; i ++ ) { string s = n . substr ( 0 , i ) ; int l1 = s . length ( ) ; string t = n . substr ( i , l1 ) ; if ( s [ 0 ] == ' 0 ' || t [ 0 ] == ' 0 ' ) { continue ; } if ( s . compare ( t ) == 0 ) { count ++ ; } } return count ; }
int PrintUnion ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) { cout << arr1 [ i ++ ] << " ▁ " ; } else if ( arr2 [ j ] < arr1 [ i ] ) { cout << arr2 [ j ++ ] << " ▁ " ; } else { cout << arr2 [ j ++ ] << " ▁ " ; i ++ ; } } while ( i < m ) { cout << arr1 [ i ++ ] << " ▁ " ; } while ( j < n ) { cout << arr2 [ j ++ ] << " ▁ " ; } }
void PrintDistinct ( const string & str ) { int n = str . length ( ) ; int count [ kMaxChar ] , index [ kMaxChar ] ; memset ( count , 0 , sizeof ( count ) ) ; memset ( index , n , sizeof ( index ) ) ; for ( int i = 0 ; i < n ; i ++ ) { char x = str [ i ] ; ++ count [ x ] ; if ( count [ x ] == 1 && x != ' ▁ ' ) { index [ x ] = i ; } if ( count [ x ] == 2 ) { index [ x ] = n ; } } sort ( index , index + kMaxChar ) ; for ( int i = 0 ; i < kMaxChar && index [ i ] != n ; i ++ ) { cout << str [ index [ i ] ] ; } }
int FindCommon ( int mat [ M ] [ N ] ) { int column [ M ] ; for ( int i = 0 ; i < M ; i ++ ) { column [ i ] = N - 1 ; } int min_row = 0 ; while ( column [ min_row ] >= 0 ) { for ( int i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) { min_row = i ; } } int eq_count = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) { if ( column [ i ] == 0 ) { return - 1 ; } column [ i ] -= 1 ; } else { eq_count ++ ; } } if ( eq_count == M ) { return mat [ min_row ] [ column [ min_row ] ] ; } } return - 1 ; }
double PolygonArea ( double x [ ] , double y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( x [ j ] + x [ i ] ) * ( y [ j ] - y [ i ] ) ; j = i ; } return abs ( area / 2.0 ) ; }
int MaxProfit ( int price [ ] , int n , int k ) { int profit [ k + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= k ; i ++ ) { profit [ i ] [ 0 ] = 0 ; } for ( int j = 0 ; j <= n ; j ++ ) { profit [ 0 ] [ j ] = 0 ; } for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { int max_so_far = numeric_limits < int > :: min ( ) ; for ( int m = 0 ; m < j ; m ++ ) { max_so_far = max ( max_so_far , price [ j ] - price [ m ] + profit [ i - 1 ] [ m ] ) ; } profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ] , max_so_far ) ; } } return profit [ k ] [ n - 1 ] ; }
bool Match ( const string & first , const string & second ) { if ( first . length ( ) == 0 && second . length ( ) == 0 ) { return true ; } if ( first . length ( ) > 1 && first [ 0 ] == ' * ' && second . length ( ) == 0 ) { return false ; } if ( ( first . length ( ) > 1 && first [ 0 ] == ' ? ' ) || ( first . length ( ) > 0 && second . length ( ) > 0 && first [ 0 ] == second [ 0 ] ) ) { return Match ( first . substr ( 1 ) , second . substr ( 1 ) ) ; } if ( first . length ( ) > 0 && first [ 0 ] == ' * ' ) { return Match ( first . substr ( 1 ) , second ) || Match ( first , second . substr ( 1 ) ) ; } return false ; }
int FindSum ( int n , int k ) { int ans = 0 ; int y = n / k ; int x = n % k ; ans = ( k * ( k - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; }
bool IsPermutedMatrix ( int mat [ kMax ] [ kMax ] , int n ) { string str_cat ; for ( int i = 0 ; i < n ; i ++ ) { str_cat += " - " ; str_cat += to_string ( mat [ 0 ] [ i ] ) ; } str_cat += str_cat ; for ( int i = 1 ; i < n ; i ++ ) { string curr_str ; for ( int j = 0 ; j < n ; j ++ ) { curr_str = curr_str + " - " + to_string ( mat [ i ] [ j ] ) ; } if ( str_cat . find ( curr_str ) == string :: npos ) { return false ; } } return true ; }
bool IsSparse ( int array [ ] [ kMax ] , int m , int n ) { int counter = 0 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( array [ i ] [ j ] == 0 ) { ++ counter ; } } } return counter > ( ( m * n ) / 2 ) ; }
float FindArea ( float r ) { return numbers :: pi * pow ( r , 2 ) ; }
int CountObtuseAngles ( int a , int b , int k ) { int c1 = b - a - 1 ; int c2 = k - b + a - 1 ; if ( c1 == c2 ) { return 0 ; } return min ( c1 , c2 ) ; }
void CounterClockSpiralPrint ( int m , int n , int arr [ kRow ] [ kCol ] ) { int k = 0 , l = 0 , cnt = 0 ; int total = m * n ; while ( k < m && l < n ) { if ( cnt == total ) { break ; } for ( int i = k ; i < m ; ++ i ) { cout << arr [ i ] [ l ] << " ▁ " ; cnt ++ ; } l ++ ; if ( cnt == total ) { break ; } for ( int i = l ; i < n ; ++ i ) { cout << arr [ m - 1 ] [ i ] << " ▁ " ; cnt ++ ; } m -- ; if ( cnt == total ) { break ; } if ( k < m ) { for ( int i = m - 1 ; i >= k ; -- i ) { cout << arr [ i ] [ n - 1 ] << " ▁ " ; cnt ++ ; } n -- ; } if ( cnt == total ) { break ; } if ( l < n ) { for ( int i = n - 1 ; i >= l ; -- i ) { cout << arr [ k ] [ i ] << " ▁ " ; cnt ++ ; } k ++ ; } } }
int NumberOfTriangles ( int n ) { int ans = 2 * pow ( 3 , n ) - 1 ; return ans ; }
int MinMaxProduct ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { sort ( arr1 , arr1 + n1 ) ; sort ( arr2 , arr2 + n2 ) ; return arr1 [ n1 - 1 ] * arr2 [ 0 ] ; }
void TimeToMeet ( double s , double v0 ) { double v = 3 * v0 / 2 ; double time = s / v ; cout << time << endl ; }
int CountToMake01Alternate ( const string & s ) { int result = 0 ; for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { result ++ ; } } return result ; }
int PrintCountRec ( int dist ) { if ( dist < 0 ) { return 0 ; } if ( dist == 0 ) { return 1 ; } return PrintCountRec ( dist - 1 ) + PrintCountRec ( dist - 2 ) + PrintCountRec ( dist - 3 ) ; }
int ComputeAverage ( int a , int b ) { return ( a / 2 ) + ( b / 2 ) + ( ( a % 2 + b % 2 ) / 2 ) ; }
int CountSubStr ( const string & str ) { int res = 0 ; for ( int i = 0 ; str [ i ] != ' \ 0 ' ; i ++ ) { if ( str [ i ] == ' 1 ' ) { for ( int j = i + 1 ; str [ j ] != ' \ 0 ' ; j ++ ) { if ( str [ j ] == ' 1 ' ) { res ++ ; } } } } return res ; }
bool IsDivisibleBy10 ( const string & bin ) { int n = bin . size ( ) ; if ( bin [ n - 1 ] == ' 1 ' ) { return false ; } int sum = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( bin [ i ] == ' 1 ' ) { int pos_from_right = n - i - 1 ; if ( pos_from_right % 4 == 1 ) { sum = sum + 2 ; } else if ( pos_from_right % 4 == 2 ) { sum = sum + 4 ; } else if ( pos_from_right % 4 == 3 ) { sum = sum + 8 ; } else if ( pos_from_right % 4 == 0 ) { sum = sum + 6 ; } } } if ( sum % 10 == 0 ) { return true ; } return false ; }
void Search ( int arr [ ] , int low , int high ) { if ( low > high ) { return ; } if ( low == high ) { cout << " The ▁ required ▁ element ▁ is ▁ " << arr [ low ] << endl ; return ; } int mid = ( low + high ) / 2 ; if ( mid % 2 == 0 ) { if ( arr [ mid ] == arr [ mid + 1 ] ) { Search ( arr , mid + 2 , high ) ; } else { Search ( arr , low , mid ) ; } } else { if ( arr [ mid ] == arr [ mid - 1 ] ) { Search ( arr , mid + 1 , high ) ; } else { Search ( arr , low , mid - 1 ) ; } } }
bool Find3Numbers ( int a [ ] , int arr_size , int sum ) { sort ( a , a + arr_size ) ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { int l = i + 1 ; int r = arr_size - 1 ; while ( l < r ) { if ( a [ i ] + a [ l ] + a [ r ] == sum ) { cout << " Triplet ▁ is ▁ " << a [ i ] << " , ▁ " << a [ l ] << " , ▁ " << a [ r ] ; return true ; } else if ( a [ i ] + a [ l ] + a [ r ] < sum ) { l ++ ; } else { r -- ; } } } return false ; }
void MakePermutation ( int a [ ] , int n ) { unordered_map < int , int > count ; for ( int i = 0 ; i < n ; i ++ ) { count [ a [ i ] ] ++ ; } int next_missing = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count [ a [ i ] ] != 1 || a [ i ] > n || a [ i ] < 1 ) { count [ a [ i ] ] -- ; while ( count . find ( next_missing ) != count . end ( ) ) { next_missing ++ ; } a [ i ] = next_missing ; count [ next_missing ] = 1 ; } } }
int OptimalStrategyOfGame ( int arr [ ] , int n ) { int table [ n ] [ n ] ; for ( int gap = 0 ; gap < n ; ++ gap ) { for ( int i = 0 , j = gap ; j < n ; ++ i , ++ j ) { int x = ( i + 2 <= j ) ? table [ i + 2 ] [ j ] : 0 ; int y = ( i + 1 <= j - 1 ) ? table [ i + 1 ] [ j - 1 ] : 0 ; int z = ( i <= j - 2 ) ? table [ i ] [ j - 2 ] : 0 ; table [ i ] [ j ] = max ( arr [ i ] + min ( x , y ) , arr [ j ] + min ( y , z ) ) ; } } return table [ 0 ] [ n - 1 ] ; }
long long FindSumSubsets ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; }
int SeiresSum ( int n , int a [ ] ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; }
void InterchangeFirstLast ( int m [ ] [ n ] ) { int rows = n ; for ( int i = 0 ; i < n ; i ++ ) { int t = m [ 0 ] [ i ] ; m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] ; m [ rows - 1 ] [ i ] = t ; } }
int CutRod ( int price [ ] , int n ) { int val [ n + 1 ] ; val [ 0 ] = 0 ; int i , j ; for ( i = 1 ; i <= n ; i ++ ) { int max_val = numeric_limits < int > :: min ( ) ; for ( j = 0 ; j < i ; j ++ ) { max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; } val [ i ] = max_val ; } return val [ n ] ; }
void MaxOverlap ( const vector < int > & start , const vector < int > & end ) { int n = start . size ( ) ; int max_a = * max_element ( start . begin ( ) , start . end ( ) ) ; int max_b = * max_element ( end . begin ( ) , end . end ( ) ) ; int max_c = max ( max_a , max_b ) ; int x [ max_c + 2 ] ; memset ( x , 0 , sizeof x ) ; int cur = 0 , idx = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ++ x [ start [ i ] ] ; -- x [ end [ i ] + 1 ] ; } int max_y = numeric_limits < int > :: min ( ) ; for ( int i = 0 ; i <= max_c ; i ++ ) { cur += x [ i ] ; if ( max_y < cur ) { max_y = cur ; idx = i ; } } cout << " Maximum ▁ value ▁ is ▁ " << max_y << " ▁ at ▁ position ▁ " << idx << endl ; }
bool CanFormPalindrome ( const string & str ) { vector < char > list ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { auto pos = find ( list . begin ( ) , list . end ( ) , str [ i ] ) ; if ( pos != list . end ( ) ) { list . erase ( pos ) ; } else { list . push_back ( str [ i ] ) ; } } if ( ( str . length ( ) % 2 == 0 && list . empty ( ) ) || ( str . length ( ) % 2 == 1 && list . size ( ) == 1 ) ) { return true ; } else { return false ; } }
int Fib ( int n , int a , int b ) { if ( n == 0 ) { return a ; } if ( n == 1 ) { return b ; } return Fib ( n - 1 , b , a + b ) ; }
int CountPairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( a [ i ] & a [ j ] ) == 0 ) { count += 2 ; } } } return count ; }
void KMax ( int arr [ ] , int k , int n ) { for ( int c = 0 ; c < k ; c ++ ) { int max_so_far = numeric_limits < int > :: min ( ) ; int max_here = 0 , start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_here += arr [ i ] ; if ( max_so_far < max_here ) { max_so_far = max_here ; start = s ; end = i ; } if ( max_here < 0 ) { max_here = 0 ; s = i + 1 ; } } cout << " Maximum ▁ non - overlapping ▁ sub - array ▁ sum " << c + 1 << " : ▁ " << max_so_far << " , ▁ starting ▁ index : ▁ " << start << " , ▁ ending ▁ index : ▁ " << end << " . " << endl ; for ( int l = start ; l <= end ; l ++ ) { arr [ l ] = numeric_limits < int > :: min ( ) ; } } cout << endl ; }
int MinimumCostOfBreaking ( int x [ ] , int y [ ] , int m , int n ) { int res = 0 ; sort ( x , x + m , greater < int > ( ) ) ; sort ( y , y + n , greater < int > ( ) ) ; int hzntl = 1 , vert = 1 ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( x [ i ] > y [ j ] ) { res += x [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += y [ j ] * hzntl ; vert ++ ; j ++ ; } } int total = 0 ; while ( i < m ) { total += x [ i ++ ] ; } res += total * vert ; total = 0 ; while ( j < n ) { total += y [ j ++ ] ; } res += total * hzntl ; return res ; }
int KSmallest ( int arr [ ] , int n , int k ) { int b [ kMax ] ; memset ( b , 0 , sizeof b ) ; for ( int i = 0 ; i < n ; i ++ ) { b [ arr [ i ] ] = 1 ; } for ( int j = 1 ; j < kMax ; j ++ ) { if ( b [ j ] != 1 ) { k -- ; } if ( k == 0 ) { return j ; } } return numeric_limits < int > :: max ( ) ; }
int MinPalPartion ( const string & str ) { int n = str . length ( ) ; int c [ n ] ; bool p [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { p [ i ] [ i ] = true ; } for ( int l = 2 ; l <= n ; l ++ ) { for ( int i = 0 ; i < n - l + 1 ; i ++ ) { int j = i + l - 1 ; if ( l == 2 ) { p [ i ] [ j ] = str [ i ] == str [ j ] ; } else { p [ i ] [ j ] = str [ i ] == str [ j ] && p [ i + 1 ] [ j - 1 ] ; } } } for ( int i = 0 ; i < n ; i ++ ) { if ( p [ 0 ] [ i ] == true ) { c [ i ] = 0 ; } else { c [ i ] = numeric_limits < int > :: max ( ) ; for ( int j = 0 ; j < i ; j ++ ) { if ( p [ j + 1 ] [ i ] == true && 1 + c [ j ] < c [ i ] ) { c [ i ] = 1 + c [ j ] ; } } } } return c [ n - 1 ] ; }
bool IsProduct ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; i < n ; i ++ ) { if ( arr [ i ] * arr [ j ] == x ) { return true ; } } } return false ; }
int FindSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += i * ( n - i ) ; } return 2 * sum ; }
void PrintLevels ( vector < int > graph [ ] , int v , int x ) { int level [ v ] ; bool marked [ v ] ; queue < int > que ; que . push ( x ) ; level [ x ] = 0 ; marked [ x ] = true ; while ( ! que . empty ( ) ) { x = que . front ( ) ; que . pop ( ) ; for ( int i = 0 ; i < graph [ x ] . size ( ) ; i ++ ) { int b = graph [ x ] [ i ] ; if ( ! marked [ b ] ) { que . push ( b ) ; level [ b ] = level [ x ] + 1 ; marked [ b ] = true ; } } } cout << " Nodes " << " ▁ " << " Level " << endl ; for ( int i = 0 ; i < v ; i ++ ) { cout << " ▁ " << i << " ▁ - - > ▁ " << level [ i ] << endl ; } }
int NumOfWays ( int n , int k ) { int p = 1 ; if ( k % 2 ) { p = - 1 ; } return ( pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ; }
int Dealnnoy ( int n , int m ) { if ( m == 0 || n == 0 ) { return 1 ; } return Dealnnoy ( m - 1 , n ) + Dealnnoy ( m - 1 , n - 1 ) + Dealnnoy ( m , n - 1 ) ; }
bool SubArrayExists ( int arr [ ] , int n ) { unordered_set < int > sum_set ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum == 0 || sum_set . find ( sum ) != sum_set . end ( ) ) { return true ; } sum_set . insert ( sum ) ; } return false ; }
void Merge ( int ar1 [ ] , int ar2 [ ] , int m , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int j , last = ar1 [ m - 1 ] ; for ( j = m - 2 ; j >= 0 && ar1 [ j ] > ar2 [ i ] ; j -- ) { ar1 [ j + 1 ] = ar1 [ j ] ; } if ( j != m - 2 || last > ar2 [ i ] ) { ar1 [ j + 1 ] = ar2 [ i ] ; ar2 [ i ] = last ; } } }
void LongestString ( const string & str1 , const string & str2 ) { int count1 [ 26 ] = { 0 } , count2 [ 26 ] = { 0 } ; for ( int i = 0 ; i < str1. length ( ) ; i ++ ) { count1 [ str1 [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < str2. length ( ) ; i ++ ) { count2 [ str2 [ i ] - ' a ' ] ++ ; } string result ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 1 ; j <= min ( count1 [ i ] , count2 [ i ] ) ; j ++ ) { result += ( char ) ( ' a ' + i ) ; } } cout << result ; }
int Fact ( int n ) { if ( n == 0 ) { return 1 ; } return n * Fact ( n - 1 ) ; }
string DecodeMedianString ( const string & s ) { int l = s . length ( ) ; string s1 ; bool isEven = ( l % 2 == 0 ) ? true : false ; for ( int i = 0 ; i < l ; i += 2 ) { if ( isEven ) { s1. insert ( 0 , 1 , s [ i ] ) ; s1 += s [ i + 1 ] ; } else { if ( l - i > 1 ) { s1 += s [ i ] ; s1. insert ( 0 , 1 , s [ i + 1 ] ) ; } else { s1 += s [ i ] ; } } } return s1 ; }
int MaximumPath ( int mat [ ] [ N ] ) { int result = 0 ; int dp [ N ] [ N + 2 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i < N ; i ++ ) { dp [ 0 ] [ i + 1 ] = mat [ 0 ] [ i ] ; } for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ] , max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + mat [ i ] [ j - 1 ] ; } } for ( int i = 0 ; i <= N ; i ++ ) { result = max ( result , dp [ N - 1 ] [ i ] ) ; } return result ; }
int MinSwap ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] <= k ) { ++ count ; } } int bad = 0 ; for ( int i = 0 ; i < count ; ++ i ) { if ( arr [ i ] > k ) { ++ bad ; } } int ans = bad ; for ( int i = 0 , j = count ; j < n ; ++ i , ++ j ) { if ( arr [ i ] > k ) { -- bad ; } if ( arr [ j ] > k ) { ++ bad ; } ans = min ( ans , bad ) ; } return ans ; }
void DecToOctal ( int n ) { int octal_num [ 100 ] ; int i = 0 ; while ( n != 0 ) { octal_num [ i ] = n % 8 ; n = n / 8 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) { cout << octal_num [ j ] ; } }
int SumOfDigitsFrom1ToN ( int n ) { if ( n < 10 ) { return n * ( n + 1 ) / 2 ; } int d = ( int ) log10 ( n ) ; int a [ d + 1 ] ; a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( int i = 2 ; i <= d ; i ++ ) { a [ i ] = a [ i - 1 ] * 10 + 45 * ceil ( pow ( 10 , i - 1 ) ) ; } int p = ceil ( pow ( 10 , d ) ) ; int msd = n / p ; return msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + SumOfDigitsFrom1ToN ( n % p ) ; }
double VolTetra ( int side ) { double volume = pow ( side , 3 ) / ( 6 * sqrt ( 2 ) ) ; return volume ; }
void MyCopy ( const string & s1 , string & s2 , int index ) { s2 [ index ] = s1 [ index ] ; if ( index == s1. length ( ) - 1 ) { return ; } MyCopy ( s1 , s2 , index + 1 ) ; }
int FindFlips ( const string & str , int n ) { char last = ' ▁ ' ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( last != str [ i ] ) { res ++ ; } last = str [ i ] ; } return res / 2 ; }
void InterLeaveQueue ( queue < int > & q ) { if ( q . size ( ) % 2 != 0 ) { cout << " Input ▁ even ▁ number ▁ of ▁ integers . " << endl ; } stack < int > s ; int half_size = q . size ( ) / 2 ; for ( int i = 0 ; i < half_size ; i ++ ) { s . push ( q . front ( ) ) ; q . pop ( ) ; } while ( ! s . empty ( ) ) { q . push ( s . top ( ) ) ; s . pop ( ) ; } for ( int i = 0 ; i < half_size ; i ++ ) { q . push ( q . front ( ) ) ; q . pop ( ) ; } for ( int i = 0 ; i < half_size ; i ++ ) { s . push ( q . front ( ) ) ; q . pop ( ) ; } while ( ! s . empty ( ) ) { q . push ( s . top ( ) ) ; s . pop ( ) ; q . push ( q . front ( ) ) ; q . pop ( ) ; } }
void OddEvenSort ( int arr [ ] , int n ) { bool is_sorted = false ; while ( ! is_sorted ) { is_sorted = true ; for ( int i = 1 ; i <= n - 2 ; i = i + 2 ) { if ( arr [ i ] > arr [ i + 1 ] ) { swap ( arr [ i ] , arr [ i + 1 ] ) ; is_sorted = false ; } } for ( int i = 0 ; i <= n - 2 ; i = i + 2 ) { if ( arr [ i ] > arr [ i + 1 ] ) { swap ( arr [ i ] , arr [ i + 1 ] ) ; is_sorted = false ; } } } return ; }
int ShortestSeq ( const string & s , const string & t ) { int m = s . length ( ) , n = t . length ( ) ; int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { dp [ i ] [ 0 ] = 1 ; } for ( int i = 0 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = kMax ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { char ch = s [ i - 1 ] ; int k ; for ( k = j - 1 ; k >= 0 ; k -- ) { if ( t [ k ] == ch ) { break ; } } if ( k == - 1 ) { dp [ i ] [ j ] = 1 ; } else { dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 ) ; } } } int ans = dp [ m ] [ n ] ; if ( ans >= kMax ) { ans = - 1 ; } return ans ; }
int FindLongestConseqSubseq ( int arr [ ] , int n ) { unordered_set < int > s ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s . insert ( arr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( s . find ( arr [ i ] - 1 ) == s . end ( ) ) { int j = arr [ i ] ; while ( s . find ( j ) != s . end ( ) ) { j ++ ; } ans = max ( ans , j - arr [ i ] ) ; } } return ans ; }
void PrintPowerSet ( char set [ ] , int set_size ) { long pow_set_size = ( long long ) pow ( 2 , set_size ) ; for ( int counter = 0 ; counter < pow_set_size ; counter ++ ) { for ( int j = 0 ; j < set_size ; j ++ ) { if ( counter & ( 1 << j ) ) { cout << set [ j ] ; } } cout << endl ; } }
int GetMissingNo ( int a [ ] , int n ) { int x1 = a [ 0 ] ; int x2 = 1 ; for ( int i = 1 ; i < n ; i ++ ) { x1 = x1 ^ a [ i ] ; } for ( int i = 2 ; i <= n + 1 ; i ++ ) { x2 = x2 ^ i ; } return x1 ^ x2 ; }
void PrintRotatedString ( const string & str ) { int n = str . length ( ) ; string temp ( str + str ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j != n ; j ++ ) { cout << temp [ i + j ] ; } cout << endl ; } }
int GetMaxGold ( int gold [ ] [ kMax ] , int m , int n ) { int gold_table [ m ] [ n ] ; memset ( gold_table , 0 , sizeof ( gold_table ) ) ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) { int right = ( col == n - 1 ) ? 0 : gold_table [ row ] [ col + 1 ] ; int right_up = ( row == 0 || col == n - 1 ) ? 0 : gold_table [ row - 1 ] [ col + 1 ] ; int right_down = ( row == m - 1 || col == n - 1 ) ? 0 : gold_table [ row + 1 ] [ col + 1 ] ; gold_table [ row ] [ col ] = gold [ row ] [ col ] + max ( right , max ( right_up , right_down ) ) ; } } int res = gold_table [ 0 ] [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) { res = max ( res , gold_table [ i ] [ 0 ] ) ; } return res ; }
int PossibleWays ( int n , int m , int k ) { int dp [ N ] [ N ] , pre_sum [ N ] [ N ] ; memset ( dp , 0 , sizeof dp ) ; memset ( pre_sum , 0 , sizeof pre_sum ) ; for ( int i = 1 ; i < n + 1 ; i ++ ) { dp [ 0 ] [ i ] = 0 ; pre_sum [ 0 ] [ i ] = 1 ; } for ( int i = 0 ; i < m + 1 ; i ++ ) { pre_sum [ i ] [ 0 ] = dp [ i ] [ 0 ] = 1 ; } for ( int i = 1 ; i < m + 1 ; i ++ ) { for ( int j = 1 ; j < n + 1 ; j ++ ) { dp [ i ] [ j ] = pre_sum [ i - 1 ] [ j ] ; if ( j > k ) { dp [ i ] [ j ] -= pre_sum [ i - 1 ] [ j - k - 1 ] ; } } for ( int j = 1 ; j < n + 1 ; j ++ ) { pre_sum [ i ] [ j ] = dp [ i ] [ j ] + pre_sum [ i ] [ j - 1 ] ; } } return dp [ m ] [ n ] ; }
void FindRoots ( int a , int b , int c ) { if ( a == 0 ) { cout << " Invalid " << endl ; return ; } int d = b * b - 4 * a * c ; double sqrt_val = sqrt ( abs ( d ) ) ; if ( d > 0 ) { cout << " Roots ▁ are ▁ real ▁ and ▁ different ▁ " << endl ; cout << ( - b + sqrt_val ) / ( 2 * a ) << endl ; cout << ( - b - sqrt_val ) / ( 2 * a ) << endl ; } else if ( d == 0 ) { cout << " Roots ▁ are ▁ real ▁ and ▁ same ▁ " << endl ; cout << - ( double ) b / ( 2 * a ) << endl ; } else { cout << " Roots ▁ are ▁ complex ▁ " << endl ; cout << - ( double ) b / ( 2 * a ) << " ▁ + ▁ i " << sqrt_val << endl ; cout << - ( double ) b / ( 2 * a ) << " ▁ - ▁ i " << sqrt_val << endl ; } }
int BinaryToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base ; base = base * 2 ; } return dec_value ; }
int Sum ( int a [ ] , int n ) { unordered_map < int , int > cnt ; int ans = 0 , pre_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += ( i * a [ i ] ) - pre_sum ; pre_sum += a [ i ] ; if ( cnt . find ( a [ i ] - 1 ) != cnt . end ( ) ) { ans -= cnt [ a [ i ] - 1 ] ; } if ( cnt . find ( a [ i ] + 1 ) != cnt . end ( ) ) { ans += cnt [ a [ i ] + 1 ] ; } cnt [ a [ i ] ] ++ ; } return ans ; }
int MinimumSquare ( int m , int n ) { int vertical_min = numeric_limits < int > :: max ( ) ; int horizontal_min = numeric_limits < int > :: max ( ) ; if ( m == n ) { return 1 ; } if ( dp [ m ] [ n ] ) { return dp [ m ] [ n ] ; } for ( int i = 1 ; i <= m / 2 ; i ++ ) { horizontal_min = min ( MinimumSquare ( i , n ) + MinimumSquare ( m - i , n ) , horizontal_min ) ; } for ( int j = 1 ; j <= n / 2 ; j ++ ) { vertical_min = min ( MinimumSquare ( m , j ) + MinimumSquare ( m , n - j ) , vertical_min ) ; } dp [ m ] [ n ] = min ( vertical_min , horizontal_min ) ; return dp [ m ] [ n ] ; }
void CycleSort ( int arr [ ] , int n ) { int writes = 0 ; for ( int cycle_start = 0 ; cycle_start <= n - 2 ; cycle_start ++ ) { int item = arr [ cycle_start ] ; int pos = cycle_start ; for ( int i = cycle_start + 1 ; i < n ; i ++ ) { if ( arr [ i ] < item ) { pos ++ ; } } if ( pos == cycle_start ) { continue ; } while ( item == arr [ pos ] ) { pos += 1 ; } if ( pos != cycle_start ) { swap ( item , arr [ pos ] ) ; writes ++ ; } while ( pos != cycle_start ) { pos = cycle_start ; for ( int i = cycle_start + 1 ; i < n ; i ++ ) { if ( arr [ i ] < item ) { pos += 1 ; } } while ( item == arr [ pos ] ) { pos += 1 ; } if ( item != arr [ pos ] ) { swap ( item , arr [ pos ] ) ; writes ++ ; } } } }
int CountNonDecreasing ( int n ) { int dp [ 10 ] [ n + 1 ] ; memset ( dp , 0 , sizeof dp ) ; for ( int i = 0 ; i < 10 ; i ++ ) { dp [ i ] [ 1 ] = 1 ; } for ( int digit = 0 ; digit <= 9 ; digit ++ ) { for ( int len = 2 ; len <= n ; len ++ ) { for ( int x = 0 ; x <= digit ; x ++ ) { dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] ; } } } int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { count += dp [ i ] [ n ] ; } return count ; }
int Count ( int s [ ] , int m , int n ) { if ( n == 0 ) { return 1 ; } if ( n < 0 ) { return 0 ; } if ( m <= 0 && n >= 1 ) { return 0 ; } return Count ( s , m - 1 , n ) + Count ( s , m , n - s [ m - 1 ] ) ; }
void SectorArea ( double radius , double angle ) { if ( angle >= 360 ) { cout << " Angle ▁ not ▁ possible " << endl ; } else { double sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; cout << sector << endl ; } }
void KSwapMaximum ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) { int index_position = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( k <= j - i ) { break ; } if ( arr [ j ] > arr [ index_position ] ) { index_position = j ; } } for ( int j = index_position ; j > i ; -- j ) { swap ( arr [ j ] , arr [ j - 1 ] ) ; } k -= index_position - i ; } }
int PositionRightmostSetbit ( int n ) { int position = 1 ; int m = 1 ; while ( ! ( n & m ) ) { m = m << 1 ; position ++ ; } return position ; }
void FindPairs ( int arr1 [ ] , int arr2 [ ] , int n , int m , int x ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] + arr2 [ j ] == x ) { cout << arr1 [ i ] << " ▁ " << arr2 [ j ] << endl ; } } } }
int SparseSearch ( string arr [ ] , const string & x , int n ) { return BinarySearch ( arr , 0 , n - 1 , x ) ; }
void PrintDiagonalSums ( int mat [ ] [ kMax ] , int n ) { int principal = 0 , secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { principal += mat [ i ] [ i ] ; secondary += mat [ i ] [ n - i - 1 ] ; } cout << " Principal ▁ Diagonal : " << principal << endl ; cout << " Secondary ▁ Diagonal : " << secondary << endl ; }
int CountSeq ( int n , int diff ) { if ( abs ( diff ) > n ) { return 0 ; } if ( n == 1 && diff == 0 ) { return 2 ; } if ( n == 1 && abs ( diff ) == 1 ) { return 1 ; } int res = CountSeq ( n - 1 , diff + 1 ) + 2 * CountSeq ( n - 1 , diff ) + CountSeq ( n - 1 , diff - 1 ) ; return res ; }
void Transpose ( int a [ ] [ N ] , int b [ ] [ M ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < M ; j ++ ) { b [ i ] [ j ] = a [ j ] [ i ] ; } } }
int LongestCommonSum ( int arr1 [ ] , int arr2 [ ] , int n ) { int max_len = 0 ; int pre_sum1 = 0 , pre_sum2 = 0 ; int diff [ 2 * n + 1 ] ; memset ( diff , - 1 , sizeof ( diff ) ) ; for ( int i = 0 ; i < n ; i ++ ) { pre_sum1 += arr1 [ i ] ; pre_sum2 += arr2 [ i ] ; int curr_diff = pre_sum1 - pre_sum2 ; int diff_index = n + curr_diff ; if ( curr_diff == 0 ) { max_len = i + 1 ; } else if ( diff [ diff_index ] == - 1 ) { diff [ diff_index ] = i ; } else { int len = i - diff [ diff_index ] ; if ( len > max_len ) { max_len = len ; } } } return max_len ; }
void ShuffleArray ( int a [ ] , int n ) { for ( int i = 0 , q = 1 , k = n ; i < n ; i ++ , k ++ , q ++ ) { for ( int j = k ; j > i + q ; j -- ) { swap ( a [ j - 1 ] , a [ j ] ) ; } } }
int FindCount ( const string & str ) { int result = 0 ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) { if ( i == str [ i ] - ' a ' || i == str [ i ] - ' A ' ) { result ++ ; } } return result ; }
void PrintSumTricky ( int mat [ ] [ n ] , int k ) { if ( k > n ) { return ; } int strip_sum [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) { sum += mat [ i ] [ j ] ; } strip_sum [ 0 ] [ j ] = sum ; for ( int i = 1 ; i < n - k + 1 ; i ++ ) { sum += mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ; strip_sum [ i ] [ j ] = sum ; } } for ( int i = 0 ; i < n - k + 1 ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) { sum += strip_sum [ i ] [ j ] ; } cout << sum << " ▁ " ; for ( int j = 1 ; j < n - k + 1 ; j ++ ) { sum += strip_sum [ i ] [ j + k - 1 ] - strip_sum [ i ] [ j - 1 ] ; cout << sum << " ▁ " ; } cout << endl ; } }
int CountPairs ( const string & s ) { int cnt [ kMax ] ; memset ( cnt , 0 , sizeof ( cnt ) ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { cnt [ s [ i ] ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < kMax ; i ++ ) { ans += cnt [ i ] * cnt [ i ] ; } return ans ; }
int Eulerian ( int n , int m ) { int dp [ n + 1 ] [ m + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) { dp [ i ] [ j ] = 1 ; } else { dp [ i ] [ j ] = ( i - j ) * dp [ i - 1 ] [ j - 1 ] + ( j + 1 ) * dp [ i - 1 ] [ j ] ; } } } } return dp [ n ] [ m ] ; }
int CountWords ( const string & str ) { int state = kOut ; int wc = 0 ; int i = 0 ; while ( i < str . length ( ) ) { if ( str [ i ] == ' ▁ ' || str [ i ] == ' \ n ' || str [ i ] == ' \ t ' ) { state = kOut ; } else if ( state == kOut ) { state = kIn ; ++ wc ; } ++ i ; } return wc ; }
int FindPossibleMoves ( int mat [ n ] [ m ] , int p , int q ) { int xs [ 8 ] = { 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 } ; int ys [ 8 ] = { 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 } ; int count = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { int x = p + xs [ i ] ; int y = q + ys [ i ] ; if ( x >= 0 && y >= 0 && x < n && y < m && mat [ x ] [ y ] == 0 ) { count ++ ; } } return count ; }
int Factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * Factorial ( n - 1 ) ; }
bool PythagoreanQuadruple ( int a , int b , int c , int d ) { int sum = a * a + b * b + c * c ; if ( d * d == sum ) { return true ; } else { return false ; } }
void PerformQueries ( const vector < int > & a , const vector < pair < long long , int > > & vec ) { vector < int > ans ; int n = a . size ( ) - 1 ; int q = vec . size ( ) ; for ( int i = 0 ; i < q ; ++ i ) { long long t = vec [ i ] . first ; int m = vec [ i ] . second ; if ( m > n ) { ans . push_back ( - 1 ) ; continue ; } int turn = t / n ; int rem = t % n ; if ( rem == 0 and turn % 2 == 1 ) { ans . push_back ( - 1 ) ; continue ; } if ( rem == 0 and turn % 2 == 0 ) { ans . push_back ( a [ m ] ) ; continue ; } if ( turn % 2 == 0 ) { int cur_size = n - rem ; if ( cur_size < m ) { ans . push_back ( - 1 ) ; continue ; } ans . push_back ( a [ m + rem ] ) ; } else { int cur_size = rem ; if ( cur_size < m ) { ans . push_back ( - 1 ) ; continue ; } ans . push_back ( a [ m ] ) ; } } for ( int i : ans ) { cout << i << endl ; } }
int FindSum ( int arr [ ] , int n ) { int sum = 0 ; unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . find ( arr [ i ] ) == s . end ( ) ) { sum += arr [ i ] ; s . insert ( arr [ i ] ) ; } } return sum ; }
int Count9s ( const string & number ) { int n = number . length ( ) ; int d [ 9 ] = { 0 } ; d [ 0 ] = 1 ; int result = 0 , mod_sum = 0 , continuous_zero = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( number [ i ] - ' 0 ' ) ) { continuous_zero ++ ; } else { continuous_zero = 0 ; } mod_sum += number [ i ] - ' 0 ' ; mod_sum %= 9 ; result += d [ mod_sum ] ; d [ mod_sum ] ++ ; result -= continuous_zero ; } return result ; }
bool AreDisjoint ( int set1 [ ] , int set2 [ ] , int m , int n ) { for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( set1 [ i ] == set2 [ j ] ) { return false ; } } } return true ; }
int GetNthUglyNo ( int n ) { int ugly [ n ] ; int i2 = 0 , i3 = 0 , i5 = 0 ; int next_multiple_of_2 = 2 ; int next_multiple_of_3 = 3 ; int next_multiple_of_5 = 5 ; int next_ugly_no = 1 ; ugly [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { next_ugly_no = min ( next_multiple_of_2 , min ( next_multiple_of_3 , next_multiple_of_5 ) ) ; ugly [ i ] = next_ugly_no ; if ( next_ugly_no == next_multiple_of_2 ) { i2 = i2 + 1 ; next_multiple_of_2 = ugly [ i2 ] * 2 ; } if ( next_ugly_no == next_multiple_of_3 ) { i3 = i3 + 1 ; next_multiple_of_3 = ugly [ i3 ] * 3 ; } if ( next_ugly_no == next_multiple_of_5 ) { i5 = i5 + 1 ; next_multiple_of_5 = ugly [ i5 ] * 5 ; } } return next_ugly_no ; }
int BinarySearch ( int arr [ ] , int left , int right ) { if ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) { return mid ; } if ( arr [ mid ] < arr [ mid + 1 ] ) { return BinarySearch ( arr , mid + 1 , right ) ; } else { return BinarySearch ( arr , left , mid - 1 ) ; } } return - 1 ; }
int MinTime ( int arr [ ] , int n ) { if ( n <= 0 ) { return 0 ; } int incl = arr [ 0 ] ; int excl = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int incl_new = arr [ i ] + min ( excl , incl ) ; int excl_new = incl ; incl = incl_new ; excl = excl_new ; } return min ( incl , excl ) ; }
int FindLength ( const string & str , int n ) { int current_sum = 0 ; int max_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { current_sum += ( str [ i ] == ' 0 ' ? 1 : - 1 ) ; if ( current_sum < 0 ) { current_sum = 0 ; } max_sum = max ( current_sum , max_sum ) ; } return max_sum == 0 ? - 1 : max_sum ; }
int ModInverse ( int a , int m ) { int m0 = m ; int y = 0 , x = 1 ; if ( m == 1 ) { return 0 ; } while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m ; a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) { x += m0 ; } return x ; }
bool IsPrime ( int n ) { if ( n <= 1 ) { return false ; } for ( int i = 2 ; i < n ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; }
void Find3Largest ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int check = 0 , count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( count < 4 ) { if ( check != arr [ n - i ] ) { cout << arr [ n - i ] << " ▁ " ; check = arr [ n - i ] ; count ++ ; } } else { break ; } } }
void CountCurrency ( int amount ) { int notes [ 9 ] = { 2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 } ; int note_counter [ 9 ] = { 0 } ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( amount >= notes [ i ] ) { note_counter [ i ] = amount / notes [ i ] ; amount = amount - note_counter [ i ] * notes [ i ] ; } } cout << " Currency ▁ Count ▁ - > " << endl ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( note_counter [ i ] != 0 ) { cout << notes [ i ] << " ▁ : ▁ " << note_counter [ i ] << endl ; } } }
void Translate ( string & str ) { for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( str [ i - 1 ] == ' A ' && str [ i ] == ' B ' ) { str [ i - 1 ] = ' C ' ; int j ; for ( j = i ; j < str . length ( ) ; j ++ ) { str [ j ] = str [ j + 1 ] ; } str [ j ] = ' ▁ ' ; } } return ; }
void PrintMinNumberForPattern ( const string & arr ) { int curr_max = 0 ; int last_entry = 0 ; for ( int i = 0 ; i < arr . length ( ) ; i ++ ) { int no_of_next_d = 0 ; switch ( arr [ i ] ) { case ' I ' : int j = i + 1 ; while ( j < arr . length ( ) && arr [ j ] == ' D ' ) { no_of_next_d ++ ; j ++ ; } if ( i == 0 ) { curr_max = no_of_next_d + 2 ; cout << " ▁ " << ++ last_entry ; cout << " ▁ " << curr_max ; last_entry = curr_max ; } else { curr_max = curr_max + no_of_next_d + 1 ; last_entry = curr_max ; cout << " ▁ " << last_entry ; } for ( int k = 0 ; k < no_of_next_d ; k ++ ) { cout << " ▁ " << -- last_entry ; i ++ ; } break ; case ' D ' : if ( i == 0 ) { int j = i + 1 ; while ( j < arr . length ( ) && arr [ j ] == ' D ' ) { no_of_next_d ++ ; j ++ ; } curr_max = no_of_next_d + 2 ; cout << " ▁ " << curr_max << " ▁ " << curr_max - 1 ; last_entry = curr_max - 1 ; } else { cout << " ▁ " << last_entry - 1 ; last_entry -- ; } break ; } } cout << endl ; }
int CountSubstr ( const string & s ) { int n = s . length ( ) ; int aux_arr [ n ] ; memset ( aux_arr , 0 , sizeof ( aux_arr ) ) ; if ( s [ 0 ] == ' 1 ' ) { aux_arr [ 0 ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == ' 1 ' ) { aux_arr [ i ] = aux_arr [ i - 1 ] + 1 ; } else { aux_arr [ i ] = aux_arr [ i - 1 ] ; } } int count = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == ' 1 ' ) { count += aux_arr [ i ] ; } } return count ; }
int CountDivisbleBy4 ( const string & s ) { int n = s . length ( ) ; int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( s [ i ] == ' 4 ' || s [ i ] == ' 8 ' || s [ i ] == ' 0 ' ) { count ++ ; } } for ( int i = 0 ; i < n - 1 ; ++ i ) { int h = ( s [ i ] - ' 0 ' ) * 10 + ( s [ i + 1 ] - ' 0 ' ) ; if ( h % 4 == 0 ) { count = count + i + 1 ; } } return count ; }
bool AreDisjoint ( int set1 [ ] , int set2 [ ] , int m , int n ) { sort ( set1 , set1 + m ) ; sort ( set2 , set2 + n ) ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( set1 [ i ] < set2 [ j ] ) { i ++ ; } else if ( set2 [ j ] < set1 [ i ] ) { j ++ ; } else { return false ; } } return true ; }
int CountStrs ( int n ) { long long dp [ n + 1 ] [ 27 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i <= 25 ; i ++ ) { dp [ 1 ] [ i ] = 1 ; } for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 25 ; j ++ ) { if ( j == 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; } else { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) ; } } } long long sum = 0 ; for ( int i = 0 ; i <= 25 ; i ++ ) { sum = sum + dp [ n ] [ i ] ; } return sum ; }
int FindCountOfSolutions ( int n , int p ) { int ans = 0 ; for ( int x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { int last = x + p * ( n / p ) ; if ( last > n ) { last -= p ; } ans += ( last - x ) / p + 1 ; } } return ans ; }
bool CheckJumbled ( int num ) { if ( num / 10 == 0 ) { return true ; } while ( num != 0 ) { if ( num / 10 == 0 ) { return true ; } int digit1 = num % 10 ; int digit2 = ( num / 10 ) % 10 ; if ( abs ( digit2 - digit1 ) > 1 ) { return false ; } num = num / 10 ; } return true ; }
int MaxProd ( int n ) { if ( n == 0 || n == 1 ) { return 0 ; } int max_val = 0 ; for ( int i = 1 ; i < n ; i ++ ) { max_val = max ( max_val , max ( i * ( n - i ) , MaxProd ( n - i ) * i ) ) ; } return max_val ; }
string PrintNumbers ( int numbers [ ] , int n ) { vector < int > one_two_three ; for ( int i = 0 ; i < n ; i ++ ) { if ( FindContainsOneTwoThree ( numbers [ i ] ) ) { one_two_three . push_back ( numbers [ i ] ) ; } } sort ( one_two_three . begin ( ) , one_two_three . end ( ) ) ; string result ; for ( auto & number : one_two_three ) { int value = number ; if ( result . length ( ) > 0 ) { result += " , ▁ " ; } result += to_string ( value ) ; } return ( result . length ( ) > 0 ) ? result : " - 1 " ; }
int SwapBits ( int x ) { int even_bits = x & 0xAAAAAAAA ; int odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return even_bits | odd_bits ; }
int MatrixChainOrder ( int p [ ] , int n ) { int m [ n ] [ n ] ; for ( int i = 1 ; i < n ; i ++ ) { m [ i ] [ i ] = 0 ; } for ( int l = 2 ; l < n ; l ++ ) { for ( int i = 1 ; i < n - l + 1 ; i ++ ) { int j = i + l - 1 ; m [ i ] [ j ] = numeric_limits < int > :: max ( ) ; for ( int k = i ; k <= j - 1 ; k ++ ) { int q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) { m [ i ] [ j ] = q ; } } } } return m [ 1 ] [ n - 1 ] ; }
int MinDifferenceAmongMaxMin ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int res = numeric_limits < int > :: max ( ) ; for ( int i = 0 ; i <= n - k ; i ++ ) { int cur_seq_diff = arr [ i + k - 1 ] - arr [ i ] ; res = min ( res , cur_seq_diff ) ; } return res ; }
int BellNumber ( int n ) { int bell [ n + 1 ] [ n + 1 ] ; bell [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] ; for ( int j = 1 ; j <= i ; j ++ ) { bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] ; } } return bell [ n ] [ 0 ] ; }
int SmallestSumSubarr ( int arr [ ] , int n ) { int min_ending_here = numeric_limits < int > :: max ( ) ; int min_so_far = numeric_limits < int > :: max ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( min_ending_here > 0 ) { min_ending_here = arr [ i ] ; } else { min_ending_here += arr [ i ] ; } min_so_far = min ( min_so_far , min_ending_here ) ; } return min_so_far ; }
int CountDer ( int n ) { if ( n == 1 ) { return 0 ; } if ( n == 0 ) { return 1 ; } if ( n == 2 ) { return 1 ; } return ( n - 1 ) * ( CountDer ( n - 1 ) + CountDer ( n - 2 ) ) ; }
void MyCopy ( const string & s1 , string & s2 ) { for ( int i = 0 ; i < s1. length ( ) ; i ++ ) { s2 [ i ] = s1 [ i ] ; } }
int SumOfFactors ( int n ) { int res = 1 ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { int curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) { res *= 1 + n ; } return res ; }
string Convert ( const string & s ) { int n = s . length ( ) ; string s1 ; s1 += tolower ( s [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == ' ▁ ' && i < n ) { s1 += tolower ( s [ i + 1 ] ) ; i ++ ; } else { s1 += toupper ( s [ i ] ) ; } } return s1 ; }
void ManipulatedSeive ( int n ) { is_prime [ 0 ] = false ; is_prime [ 1 ] = false ; for ( int i = 2 ; i < n ; i ++ ) { if ( is_prime [ i ] ) { prime . push_back ( i ) ; spf [ i ] = i ; } for ( int j = 0 ; j < prime . size ( ) && i * prime [ j ] < n && prime [ j ] <= spf [ i ] ; j ++ ) { is_prime [ i * prime [ j ] ] = false ; spf [ i * prime [ j ] ] = prime [ j ] ; } } }
long long FindDigits ( int n ) { if ( n < 0 ) { return 0 ; } if ( n <= 1 ) { return 1 ; } double x = ( ( n * log10 ( n / numbers :: e ) + log10 ( 2 * numbers :: pi * n ) / 2.0 ) ) ; return floor ( x ) + 1 ; }
int CountSubSeq ( int a [ ] , int n , int m ) { int ans = 0 ; int h [ m ] ; memset ( h , 0 , sizeof ( h ) ) ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = a [ i ] % m ; h [ a [ i ] ] ++ ; } for ( int i = 0 ; i < m ; i ++ ) { for ( int j = i ; j < m ; j ++ ) { int rem = ( m - ( i + j ) % m ) % m ; if ( rem < j ) { continue ; } if ( i == j && rem == j ) { ans += h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6 ; } else if ( i == j ) { ans += h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 ; } else if ( i == rem ) { ans += h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 ; } else if ( rem == j ) { ans += h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2 ; } else { ans = ans + h [ i ] * h [ j ] * h [ rem ] ; } } } return ans ; }
void Search ( const string & pat , const string & txt ) { int m = pat . length ( ) ; int n = txt . length ( ) ; for ( int i = 0 ; i <= n - m ; i ++ ) { int j ; for ( j = 0 ; j < m ; j ++ ) { if ( txt [ i + j ] != pat [ j ] ) { break ; } } if ( j == m ) { cout << " Pattern ▁ found ▁ at ▁ index ▁ " << i << endl ; } } }
long long CalculateSum ( int n ) { long long sum = 0 ; for ( int row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; }
bool IsSubset ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; if ( m < n ) { return false ; } sort ( arr1 , arr1 + m ) ; sort ( arr2 , arr2 + n ) ; while ( i < n && j < m ) { if ( arr1 [ j ] < arr2 [ i ] ) { j ++ ; } else if ( arr1 [ j ] == arr2 [ i ] ) { j ++ ; i ++ ; } else if ( arr1 [ j ] > arr2 [ i ] ) { return 0 ; } } return ! ( i < n ) ; }
int GetRemainder ( int num , int divisor ) { while ( num >= divisor ) { num -= divisor ; } return num ; }
int MaxSum ( int arr [ ] , int n ) { int sum = 0 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) { sum -= 2 * arr [ i ] ; sum += 2 * arr [ n - i - 1 ] ; } return sum ; }
int NumOffBt ( int arr [ ] , int n ) { int max_value = numeric_limits < int > :: min ( ) ; int min_value = numeric_limits < int > :: max ( ) ; for ( int i = 0 ; i < n ; i ++ ) { max_value = max ( max_value , arr [ i ] ) ; min_value = min ( min_value , arr [ i ] ) ; } int mark [ max_value + 2 ] , value [ max_value + 2 ] ; memset ( mark , 0 , sizeof ( mark ) ) ; memset ( value , 0 , sizeof ( value ) ) ; for ( int i = 0 ; i < n ; i ++ ) { mark [ arr [ i ] ] = 1 ; value [ arr [ i ] ] = 1 ; } int ans = 0 ; for ( int i = min_value ; i <= max_value ; i ++ ) { if ( mark [ i ] ) { for ( int j = i + i ; j <= max_value && j / i <= i ; j += i ) { if ( ! mark [ j ] ) { continue ; } value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] ) ; if ( i != j / i ) { value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] ) ; } } } ans += value [ i ] ; } return ans ; }
void PrintSpiral ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int x ; x = min ( min ( i , j ) , min ( n - 1 - i , n - 1 - j ) ) ; if ( i <= j ) { cout << ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) << " \ t " ; } else { cout << ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) << " \ t " ; } } cout << endl ; } }
int PrintBinomial ( int max ) { for ( int m = 0 ; m <= max ; m ++ ) { cout << m << " ▁ " ; int binom = 1 ; for ( int x = 0 ; x <= m ; x ++ ) { if ( m != 0 && x != 0 ) { binom = binom * ( m - x + 1 ) / x ; } cout << binom << " ▁ " ; } cout << endl ; } }
int CoutSubSeq ( int a [ ] , int n , int m ) { int sum = 0 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { sum = a [ i ] + a [ j ] + a [ k ] ; if ( sum % m == 0 ) { ans ++ ; } } } } return ans ; }
int Solve ( int a [ ] , int b [ ] , int c [ ] , int i , int j , int k ) { int min_diff , current_diff , max_term ; min_diff = abs ( max ( a [ i ] , max ( b [ j ] , c [ k ] ) ) - min ( a [ i ] , min ( b [ j ] , c [ k ] ) ) ) ; while ( i != - 1 && j != - 1 && k != - 1 ) { current_diff = abs ( max ( a [ i ] , max ( b [ j ] , c [ k ] ) ) - min ( a [ i ] , min ( b [ j ] , c [ k ] ) ) ) ; if ( current_diff < min_diff ) { min_diff = current_diff ; } max_term = max ( a [ i ] , max ( b [ j ] , c [ k ] ) ) ; if ( a [ i ] == max_term ) { i -= 1 ; } else if ( b [ j ] == max_term ) { j -= 1 ; } else { k -= 1 ; } } return min_diff ; }
int MaxSumDifference ( int a [ ] , int n ) { vector < int > final_sequence ; sort ( a , a + n ) ; for ( int i = 0 ; i < n / 2 ; ++ i ) { final_sequence . push_back ( a [ i ] ) ; final_sequence . push_back ( a [ n - i - 1 ] ) ; } int maximum_sum = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { maximum_sum = maximum_sum + abs ( final_sequence [ i ] - final_sequence [ i + 1 ] ) ; } maximum_sum = maximum_sum + abs ( final_sequence [ n - 1 ] - final_sequence [ 0 ] ) ; return maximum_sum ; }
int NumberOfSquares ( int base ) { base = base - 2 ; base = base / 2 ; return base * ( base + 1 ) / 2 ; }
double HexagonArea ( double s ) { return ( 3 * sqrt ( 3 ) * ( s * s ) ) / 2 ; }
void DrawPattern ( int n0 ) { int n = n0 ; int row = 1 ; int nst = 1 ; int nsp1 = n - 1 ; int nsp2 = - 1 ; int val1 = row ; int val2 = 1 ; while ( row <= n ) { int csp1 = 1 ; while ( csp1 <= nsp1 ) { cout << " ▁ ▁ " ; csp1 = csp1 + 1 ; } int cst1 = 1 ; while ( cst1 <= nst ) { cout << val1 << " ▁ " ; val1 = val1 - 1 ; cst1 = cst1 + 1 ; } int csp2 = 1 ; while ( csp2 <= nsp2 ) { cout << " ▁ ▁ " ; csp2 = csp2 + 1 ; } if ( row != 1 && row != n ) { int cst2 = 1 ; while ( cst2 <= nst ) { cout << val2 << " ▁ " ; val2 = val2 + 1 ; cst2 = cst2 + 1 ; } } cout << endl ; if ( row <= n / 2 ) { nst = nst + 1 ; nsp1 = nsp1 - 2 ; nsp2 = nsp2 + 2 ; val1 = row + 1 ; val2 = 1 ; } else { nst = nst - 1 ; nsp1 = nsp1 + 2 ; nsp2 = nsp2 - 2 ; val1 = n - row ; val2 = 1 ; } row = row + 1 ; } }
bool FindWinner ( int x , int y , int n ) { int dp [ n + 1 ] ; dp [ 0 ] = false ; dp [ 1 ] = true ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i - 1 >= 0 and ! dp [ i - 1 ] ) { dp [ i ] = true ; } else if ( i - x >= 0 and ! dp [ i - x ] ) { dp [ i ] = true ; } else if ( i - y >= 0 and ! dp [ i - y ] ) { dp [ i ] = true ; } else { dp [ i ] = false ; } } return dp [ n ] ; }
int FindDifference ( int arr [ ] , int n , int m ) { int max = 0 , min = 0 ; sort ( arr , arr + n ) ; for ( int i = 0 , j = n - 1 ; i < m ; i ++ , j -- ) { min += arr [ i ] ; max += arr [ j ] ; } return max - min ; }
bool IfPossible ( int arr [ ] , int n ) { int cp [ n ] ; copy ( arr , arr + n , cp ) ; sort ( cp , cp + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( arr [ i ] == cp [ i ] ) && ! ( arr [ n - 1 - i ] == cp [ i ] ) ) { return false ; } } return true ; }
long long DoubleFactorial ( long long n ) { if ( n == 0 || n == 1 ) { return 1 ; } return n * DoubleFactorial ( n - 2 ) ; }
int FloorSqrt ( int x ) { if ( x == 0 || x == 1 ) { return x ; } int start = 1 , end = x , ans ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( mid * mid == x ) { return mid ; } if ( mid * mid < x ) { start = mid + 1 ; ans = mid ; } else { end = mid - 1 ; } } return ans ; }
string WordReverse ( const string & str ) { int i = str . length ( ) - 1 ; int start = i + 1 ; int end = i + 1 ; string result ; while ( i >= 0 ) { if ( str [ i ] == ' ▁ ' ) { start = i + 1 ; while ( start != end ) { result += str [ start ++ ] ; } result += ' ▁ ' ; end = i ; } i -- ; } start = 0 ; while ( start != end ) { result += str [ start ++ ] ; } return result ; }
int ShortestPath ( int graph [ ] [ kVNum ] , int u , int v , int k ) { int sp [ kVNum ] [ kVNum ] [ k + 1 ] ; for ( int e = 0 ; e <= k ; e ++ ) { for ( int i = 0 ; i < kVNum ; i ++ ) { for ( int j = 0 ; j < kVNum ; j ++ ) { sp [ i ] [ j ] [ e ] = kInf ; if ( e == 0 && i == j ) { sp [ i ] [ j ] [ e ] = 0 ; } if ( e == 1 && graph [ i ] [ j ] != kInf ) { sp [ i ] [ j ] [ e ] = graph [ i ] [ j ] ; } if ( e > 1 ) { for ( int a = 0 ; a < kVNum ; a ++ ) { if ( graph [ i ] [ a ] != kInf && i != a && j != a && sp [ a ] [ j ] [ e - 1 ] != kInf ) { sp [ i ] [ j ] [ e ] = min ( sp [ i ] [ j ] [ e ] , graph [ i ] [ a ] + sp [ a ] [ j ] [ e - 1 ] ) ; } } } } } } return sp [ u ] [ v ] [ k ] ; }
void Overflow ( int h0 , int r , int h , int n , int r0 ) { float tank_cap = 3.14 * r * r * h0 ; float water_vol = 3.14 * r * r * h ; float balls_vol = n * ( ( double ) 4 / 3 ) * 3.14 * r0 * r0 * r0 ; float vol = water_vol + balls_vol ; if ( vol > tank_cap ) { cout << " Overflow " << endl ; } else { cout << " Not ▁ in ▁ overflow ▁ state " << endl ; } }
float CalcExpectation ( float a [ ] , float n ) { float prb = 1 / n ; float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] * prb ; } return sum ; }
void FindAndPrintUncommonChars ( const string & str1 , const string & str2 ) { int present [ kMaxChar ] ; memset ( present , 0 , sizeof ( present ) ) ; int l1 = str1. length ( ) ; int l2 = str2. length ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) { present [ str1 [ i ] - ' a ' ] = 1 ; } for ( int i = 0 ; i < l2 ; i ++ ) { if ( present [ str2 [ i ] - ' a ' ] == 1 || present [ str2 [ i ] - ' a ' ] == - 1 ) { present [ str2 [ i ] - ' a ' ] = - 1 ; } else { present [ str2 [ i ] - ' a ' ] = 2 ; } } for ( int i = 0 ; i < kMaxChar ; i ++ ) { if ( present [ i ] == 1 || present [ i ] == 2 ) { cout << ( char ( i + ' a ' ) ) << " ▁ " ; } } }
void PrintDistinct ( const string & str ) { int count [ kNoOfChars ] ; int i ; for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] != ' ▁ ' ) { count [ str [ i ] ] ++ ; } } int n = i ; for ( i = 0 ; i < n ; i ++ ) { if ( count [ str [ i ] ] == 1 ) { cout << str [ i ] ; } } }
int FindExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { int index = n ; int left = 0 , right = n - 1 ; while ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr2 [ mid ] == arr1 [ mid ] ) { left = mid + 1 ; } else { index = mid ; right = mid - 1 ; } } return index ; }
int NobleInteger ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < size ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { count ++ ; } } if ( count == arr [ i ] ) { return arr [ i ] ; } } return - 1 ; }
int CountStr ( int n , int b_count , int c_count ) { if ( b_count < 0 || c_count < 0 ) { return 0 ; } if ( n == 0 ) { return 1 ; } if ( b_count == 0 && c_count == 0 ) { return 1 ; } int res = CountStr ( n - 1 , b_count , c_count ) ; res += CountStr ( n - 1 , b_count - 1 , c_count ) ; res += CountStr ( n - 1 , b_count , c_count - 1 ) ; return res ; }
int GcdOfFactorial ( int m , int n ) { return Factorial ( min ( m , n ) ) ; }
void SubArraySum ( int arr [ ] , int n , int sum ) { unordered_map < int , int > map ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum = curr_sum + arr [ i ] ; if ( curr_sum == sum ) { cout << " Sum ▁ found ▁ between ▁ indexes ▁ " << 0 << " ▁ to ▁ " << i << endl ; return ; } if ( map . find ( curr_sum - sum ) != map . end ( ) ) { cout << " Sum ▁ found ▁ between ▁ indexes ▁ " << map [ curr_sum - sum ] + 1 << " ▁ to ▁ " << i << endl ; return ; } map [ curr_sum ] = i ; } cout << " No ▁ subarray ▁ with ▁ given ▁ sum ▁ exists " ; }
bool CheckReverse ( int arr [ ] , int n ) { int temp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { temp [ i ] = arr [ i ] ; } sort ( temp , temp + n ) ; int front ; for ( front = 0 ; front < n ; front ++ ) { if ( temp [ front ] != arr [ front ] ) { break ; } } int back ; for ( back = n - 1 ; back >= 0 ; back -- ) { if ( temp [ back ] != arr [ back ] ) { break ; } } if ( front >= back ) { return true ; } while ( front != back ) { front ++ ; if ( arr [ front - 1 ] < arr [ front ] ) { return false ; } } return true ; }
void Freq ( int ar [ ] [ kMax ] , int m , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( ( ar [ i ] [ j ] % 2 ) == 0 ) { ++ even ; } else { ++ odd ; } } } cout << " ▁ Frequency ▁ of ▁ odd ▁ number ▁ = " << odd << endl ; cout << " ▁ Frequency ▁ of ▁ odd ▁ even ▁ number ▁ = " << even << endl ; }
int LongLenStrictBitonicSub ( int arr [ ] , int n ) { map < int , int > inc , dcr ; int len_inc [ n ] , len_dcr [ n ] ; int long_len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( inc . find ( arr [ i ] - 1 ) != inc . end ( ) ) { len = inc [ arr [ i ] - 1 ] ; } len_inc [ i ] = len + 1 ; inc [ arr [ i ] ] = len_inc [ i ] ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { int len = 0 ; if ( dcr . find ( arr [ i ] - 1 ) != dcr . end ( ) ) { len = dcr [ arr [ i ] - 1 ] ; } len_dcr [ i ] = len + 1 ; dcr [ arr [ i ] ] = len_dcr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( long_len < ( len_inc [ i ] + len_dcr [ i ] - 1 ) ) { long_len = len_inc [ i ] + len_dcr [ i ] - 1 ; } } return long_len ; }
int Mod ( const string & num , int a ) { int res = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) { res = ( res * 10 + ( int ) num [ i ] - ' 0 ' ) % a ; } return res ; }
string PrintShortestSuperSeq ( const string & x , const string & y ) { int m = x . length ( ) ; int n = y . length ( ) ; int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) { dp [ i ] [ j ] = j ; } else if ( j == 0 ) { dp [ i ] [ j ] = i ; } else if ( x [ i - 1 ] == y [ j - 1 ] ) { dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } } int index = dp [ m ] [ n ] ; string str ; int i = m , j = n ; while ( i > 0 && j > 0 ) { if ( x [ i - 1 ] == y [ j - 1 ] ) { str . push_back ( x [ i - 1 ] ) ; i -- , j -- , index -- ; } else if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] ) { str . push_back ( y [ j - 1 ] ) ; j -- , index -- ; } else { str . push_back ( x [ i - 1 ] ) ; i -- , index -- ; } } while ( i > 0 ) { str . push_back ( x [ i - 1 ] ) ; i -- , index -- ; } while ( j > 0 ) { str . push_back ( y [ j - 1 ] ) ; j -- , index -- ; } reverse ( str . begin ( ) , str . end ( ) ) ; return str ; }
void FindElements ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) { cout << arr [ i ] << " ▁ " ; } }
int Count ( int n ) { int dp [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= 1 && i <= 3 ) { dp [ i ] = 1 ; } else if ( i == 4 ) { dp [ i ] = 2 ; } else { dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ; } } return dp [ n ] ; }
int NumberOfTriangles ( int n ) { int answer [ n + 1 ] ; memset ( answer , 0 , sizeof ( answer ) ) ; answer [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { answer [ i ] = answer [ i - 1 ] * 3 + 2 ; } return answer [ n ] ; }
int Power ( int x , int y ) { if ( y == 0 ) { return 1 ; } else if ( y % 2 == 0 ) { return Power ( x , y / 2 ) * Power ( x , y / 2 ) ; } else { return x * Power ( x , y / 2 ) * Power ( x , y / 2 ) ; } }
bool CheckOrigin ( int x1 , int y1 , int x2 , int y2 ) { return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) ; }