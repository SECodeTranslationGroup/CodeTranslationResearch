float Power ( float x , int y ) { if ( y == 0 ) { return 1 ; } float temp = Power ( x , y / 2 ) ; if ( y % 2 == 0 ) { return temp * temp ; } else { if ( y > 0 ) { return x * temp * temp ; } else { return ( temp * temp ) / x ; } } }
void PrintDistSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } bool dp [ n + 1 ] [ sum + 1 ] ; memset ( dp , false , sizeof ( dp ) ) ; for ( int i = 0 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = true ; } for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i - 1 ] ] = true ; for ( int j = 1 ; j <= sum ; j ++ ) { if ( dp [ i - 1 ] [ j ] == true ) { dp [ i ] [ j ] = true ; dp [ i ] [ j + arr [ i - 1 ] ] = true ; } } } for ( int j = 0 ; j <= sum ; j ++ ) { if ( dp [ n ] [ j ] == true ) { cout << j << " ▁ " ; } } }
int CountWays ( int n ) { if ( n == 1 ) { return 4 ; } int count_b = 1 , count_s = 1 , prev_count_b , prev_count_s ; for ( int i = 2 ; i <= n ; i ++ ) { prev_count_b = count_b ; prev_count_s = count_s ; count_s = prev_count_b + prev_count_s ; count_b = prev_count_s ; } int result = count_s + count_b ; return result * result ; }
void ScalarProductMat ( int mat [ ] [ N ] , int k ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { mat [ i ] [ j ] = mat [ i ] [ j ] * k ; } } }
int MaxSum ( int arr [ ] , int n ) { int arr_sum = 0 ; int curr_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr_sum = arr_sum + arr [ i ] ; curr_val = curr_val + ( i * arr [ i ] ) ; } int max_val = curr_val ; for ( int j = 1 ; j < n ; j ++ ) { curr_val = curr_val + arr_sum - n * arr [ n - j ] ; if ( curr_val > max_val ) { max_val = curr_val ; } } return max_val ; }
int LowerInsertionPoint ( int arr [ ] , int n , int x ) { if ( x < arr [ 0 ] ) { return 0 ; } else if ( x > arr [ n - 1 ] ) { return n ; } int lower_pnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < x ) { lower_pnt = i ; i = i * 2 ; } while ( lower_pnt < n && arr [ lower_pnt ] < x ) { lower_pnt ++ ; } return lower_pnt ; }
int FindMinDiff ( int arr [ ] , int n , int m ) { if ( m == 0 || n == 0 ) { return 0 ; } sort ( arr , arr + n ) ; if ( n < m ) { return - 1 ; } int min_diff = numeric_limits < int > :: max ( ) ; int first = 0 , last = 0 ; for ( int i = 0 ; i + m - 1 < n ; i ++ ) { int diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < min_diff ) { min_diff = diff ; first = i ; last = i + m - 1 ; } } return arr [ last ] - arr [ first ] ; }
int MinRemove ( int a [ ] , int b [ ] , int n , int m ) { unordered_map < int , int > count_a , count_b ; for ( int i = 0 ; i < n ; i ++ ) { count_a [ a [ i ] ] ++ ; } for ( int i = 0 ; i < m ; i ++ ) { count_b [ b [ i ] ] ++ ; } int res = 0 ; for ( auto & x : count_a ) { if ( count_b . find ( x . first ) != count_b . end ( ) ) { res += min ( x . second , count_b [ x . first ] ) ; } } return res ; }
int Knapsack ( int w0 , int wt [ ] , int val [ ] , int n ) { int i , w ; int k [ n + 1 ] [ w0 + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= w0 ; w ++ ) { if ( i == 0 || w == 0 ) { k [ i ] [ w ] = 0 ; } else if ( wt [ i - 1 ] <= w ) { k [ i ] [ w ] = max ( val [ i - 1 ] + k [ i - 1 ] [ w - wt [ i - 1 ] ] , k [ i - 1 ] [ w ] ) ; } else { k [ i ] [ w ] = k [ i - 1 ] [ w ] ; } } } return k [ n ] [ w0 ] ; }
int ArraySortedOrNot ( int arr [ ] , int n ) { if ( n == 1 || n == 0 ) { return 1 ; } if ( arr [ n - 1 ] < arr [ n - 2 ] ) { return 0 ; } return ArraySortedOrNot ( arr , n - 1 ) ; }
int MinTime ( int n , int k , int a [ ] ) { sort ( a , a + n , greater < int > ( ) ) ; int min_time = 0 ; for ( int i = 0 ; i < n ; i += k ) { min_time += 2 * a [ i ] ; } return min_time ; }
int FindElement ( int arr [ ] , int n , int key ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == key ) { return i ; } } return - 1 ; }
void FindMax ( int a [ ] , int n , int k ) { map < int , int > count ; for ( int i = 0 ; i < k - 1 ; i ++ ) { count [ a [ i ] ] ++ ; } set < int > my_set ; for ( auto & x : count ) { if ( x . second == 1 ) { my_set . insert ( x . first ) ; } } for ( int i = k - 1 ; i < n ; i ++ ) { count [ a [ i ] ] ++ ; if ( count [ a [ i ] ] == 1 ) { my_set . insert ( a [ i ] ) ; } else { my_set . erase ( a [ i ] ) ; } if ( my_set . size ( ) == 0 ) { cout << " Nothing " << endl ; } else { cout << * my_set . rbegin ( ) << endl ; } int x = a [ i - k + 1 ] ; count [ x ] -- ; if ( count [ x ] == 1 ) { my_set . insert ( x ) ; } if ( count [ x ] == 0 ) { my_set . erase ( x ) ; } } }
int CountP ( int n , int k ) { if ( n == 0 || k == 0 || k > n ) { return 0 ; } if ( k == 1 || k == n ) { return 1 ; } return k * CountP ( n - 1 , k ) + CountP ( n - 1 , k - 1 ) ; }
int TotalNodes ( vector < int > adjac [ ] , int n , int x , int y ) { bool visited [ n + 1 ] ; memset ( visited , false , sizeof ( visited ) ) ; int p [ n ] ; queue < int > q ; q . push ( x ) ; visited [ x ] = true ; int m ; while ( ! q . empty ( ) ) { m = q . front ( ) ; q . pop ( ) ; for ( int i = 0 ; i < adjac [ m ] . size ( ) ; ++ i ) { int h = adjac [ m ] [ i ] ; if ( ! visited [ h ] ) { visited [ h ] = true ; p [ h ] = m ; q . push ( h ) ; } } } int count = 0 ; int i = p [ y ] ; while ( i != x ) { count ++ ; i = p [ i ] ; } return count ; }
int Solve ( int a [ ] , int n ) { int i , cnt = 0 , j ; int parent [ n + 1 ] , vis [ n + 1 ] ; memset ( parent , - 1 , sizeof ( parent ) ) ; memset ( vis , 0 , sizeof ( vis ) ) ; for ( i = 0 ; i < n ; i ++ ) { j = i ; if ( parent [ j ] == - 1 ) { while ( parent [ j ] == - 1 ) { parent [ j ] = i ; j = ( j + a [ j ] + 1 ) % n ; } if ( parent [ j ] == i ) { while ( ! vis [ j ] ) { vis [ j ] = 1 ; cnt ++ ; j = ( j + a [ j ] + 1 ) % n ; } } } } return cnt ; }
int CountDistinctSubarray ( int arr [ ] , int n ) { map < int , int > vis ; for ( int i = 0 ; i < n ; ++ i ) { vis [ arr [ i ] ] = 1 ; } int k = vis . size ( ) ; vis . clear ( ) ; int ans = 0 , right = 0 , window = 0 ; for ( int left = 0 ; left < n ; ++ left ) { while ( right < n && window < k ) { ++ vis [ arr [ right ] ] ; if ( vis [ arr [ right ] ] == 1 ) { ++ window ; } ++ right ; } if ( window == k ) { ans += n - right + 1 ; } -- vis [ arr [ left ] ] ; if ( vis [ arr [ left ] ] == 0 ) { -- window ; } } return ans ; }
int MinOperation ( int a [ ] , int b [ ] , int n ) { sort ( a , a + n ) ; sort ( b , b + n ) ; int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { result = result + abs ( a [ i ] - b [ i ] ) ; } return result ; }
int MinHeight ( double base , double area ) { return ceil ( ( 2 * area ) / base ) ; }
bool CheckSentence ( const string & str ) { int len = str . length ( ) ; if ( str [ 0 ] < ' A ' || str [ 0 ] > ' Z ' ) { return false ; } if ( str [ len - 1 ] != ' . ' ) { return false ; } int prev_state = 0 , curr_state = 0 ; int index = 1 ; while ( str [ index ] ) { if ( str [ index ] >= ' A ' && str [ index ] <= ' Z ' ) { curr_state = 0 ; } else if ( str [ index ] == ' ▁ ' ) { curr_state = 1 ; } else if ( str [ index ] >= ' a ' && str [ index ] <= ' z ' ) { curr_state = 2 ; } else if ( str [ index ] == ' . ' ) { curr_state = 3 ; } if ( prev_state == curr_state && curr_state != 2 ) { return false ; } if ( prev_state == 2 && curr_state == 0 ) { return false ; } if ( curr_state == 3 && prev_state != 1 ) { return ( str [ index + 1 ] == ' \ 0 ' ) ; } index ++ ; prev_state = curr_state ; } return false ; }
void AlternateSort ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int i = 0 , j = n - 1 ; while ( i < j ) { cout << arr [ j -- ] << " ▁ " ; cout << arr [ i ++ ] << " ▁ " ; } if ( n % 2 != 0 ) { cout << arr [ i ] ; } }
int GetFirstSetBitPos ( int n ) { return ( int ) log2 ( n & - n ) + 1 ; }
int FindNth ( int n ) { int count = 0 ; for ( int curr = 19 ; ; curr += 9 ) { int sum = 0 ; for ( int x = curr ; x > 0 ; x = x / 10 ) { sum = sum + x % 10 ; } if ( sum == 10 ) { count ++ ; } if ( count == n ) { return curr ; } } return - 1 ; }
int FindMaxSum ( int arr [ ] , int n ) { int res = numeric_limits < int > :: min ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int prefix_sum = arr [ i ] ; for ( int j = 0 ; j < i ; j ++ ) { prefix_sum += arr [ j ] ; } int suffix_sum = arr [ i ] ; for ( int j = n - 1 ; j > i ; j -- ) { suffix_sum += arr [ j ] ; } if ( prefix_sum == suffix_sum ) { res = max ( res , prefix_sum ) ; } } return res ; }
void Section ( double x1 , double x2 , double y1 , double y2 , double m , double n ) { double x = ( ( n * x1 ) + ( m * x2 ) ) / ( m + n ) ; double y = ( ( n * y1 ) + ( m * y2 ) ) / ( m + n ) ; cout << " ( " << x << " , ▁ " << y << " ) " << endl ; }
bool CheckPair ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } if ( sum % 2 != 0 ) { return false ; } sum = sum / 2 ; unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { int val = sum - arr [ i ] ; if ( s . find ( val ) != s . end ( ) ) { cout << format ( " Pair ▁ elements ▁ are ▁ { } ▁ and ▁ { } " , arr [ i ] , val ) << endl ; return true ; } s . insert ( arr [ i ] ) ; } return false ; }
int CountFibs ( int low , int high ) { int f1 = 0 , f2 = 1 , f3 = 1 ; int result = 0 ; while ( f1 <= high ) { if ( f1 >= low ) { result ++ ; } f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; } return result ; }
int Count ( int n ) { if ( n < 4 ) { return - 1 ; } int rem = n % 4 ; if ( rem == 0 ) { return n / 4 ; } if ( rem == 1 ) { if ( n < 9 ) { return - 1 ; } return ( n - 9 ) / 4 + 1 ; } if ( rem == 2 ) { return ( n - 6 ) / 4 + 1 ; } if ( rem == 3 ) { if ( n < 15 ) { return - 1 ; } return ( n - 15 ) / 4 + 2 ; } }
int KthNonRepeating ( const string & str , int k ) { int n = str . length ( ) ; int count [ kMaxChar ] ; int index [ kMaxChar ] ; for ( int i = 0 ; i < kMaxChar ; i ++ ) { count [ i ] = 0 ; index [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { char x = str [ i ] ; ++ count [ x ] ; if ( count [ x ] == 1 ) { index [ x ] = i ; } if ( count [ x ] == 2 ) { index [ x ] = n ; } } sort ( index , index + kMaxChar ) ; return ( index [ k - 1 ] != n ) ? index [ k - 1 ] : - 1 ; }
int Find ( double p ) { return ceil ( sqrt ( 2 * 365 * log ( 1 / ( 1 - p ) ) ) ) ; }
void Midpoint ( int x1 , int x2 , int y1 , int y2 ) { cout << ( float ) ( x1 + x2 ) / 2 << " ▁ , ▁ " << ( float ) ( y1 + y2 ) / 2 ; }
void GroupElements ( int arr [ ] , int n ) { bool visited [ n ] ; memset ( visited , false , sizeof ( visited ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! visited [ i ] ) { cout << arr [ i ] << " ▁ " ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { cout << arr [ i ] << " ▁ " ; visited [ j ] = true ; } } } } }
bool ArekAnagrams ( const string & str1 , const string & str2 , int k ) { int n = str1. length ( ) ; if ( str2. length ( ) != n ) { return false ; } int count1 [ kMaxChar ] , count2 [ kMaxChar ] ; memset ( count1 , false , sizeof ( count1 ) ) ; memset ( count2 , false , sizeof ( count2 ) ) ; for ( int i = 0 ; i < n ; i ++ ) { count1 [ str1 [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { count2 [ str2 [ i ] - ' a ' ] ++ ; } int count = 0 ; for ( int i = 0 ; i < kMaxChar ; i ++ ) { if ( count1 [ i ] > count2 [ i ] ) { count = count + abs ( count1 [ i ] - count2 [ i ] ) ; } } return count <= k ; }
void PrintPrevSmaller ( int arr [ ] , int n ) { cout << " _ , ▁ " ; for ( int i = 1 ; i < n ; i ++ ) { int j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ j ] < arr [ i ] ) { cout << arr [ j ] << " , ▁ " ; break ; } } if ( j == - 1 ) { cout << " _ , ▁ " ; } } }
int Lcs ( int i , int j , int count ) { if ( i == 0 || j == 0 ) { return count ; } if ( x [ i - 1 ] == y [ j - 1 ] ) { count = Lcs ( i - 1 , j - 1 , count + 1 ) ; } count = max ( count , max ( Lcs ( i , j - 1 , 0 ) , Lcs ( i - 1 , j , 0 ) ) ) ; return count ; }
int FindLargestSumPair ( int arr [ ] , int n ) { int first , second ; if ( arr [ 0 ] > arr [ 1 ] ) { first = arr [ 0 ] ; second = arr [ 1 ] ; } else { first = arr [ 1 ] ; second = arr [ 0 ] ; } for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second && arr [ i ] != first ) { second = arr [ i ] ; } } return first + second ; }
int CheckDuck ( const string & num ) { int len = num . length ( ) ; int count_zero = 0 ; for ( int i = 1 ; i < len ; i ++ ) { char ch = num [ i ] ; if ( ch == ' 0 ' ) { count_zero ++ ; } } return count_zero ; }
bool CheckIfAllTogether ( const string & s , char c ) { bool one_seen = false ; int i = 0 , n = s . length ( ) ; while ( i < n ) { if ( s [ i ] == c ) { if ( one_seen == true ) { return false ; } while ( i < n && s [ i ] == c ) { i ++ ; } one_seen = true ; } else { i ++ ; } } return true ; }
bool AreElementsContiguous ( int arr [ ] , int n ) { unordered_set < int > us ; for ( int i = 0 ; i < n ; i ++ ) { us . insert ( arr [ i ] ) ; } int count = 1 ; int curr_ele = arr [ 0 ] - 1 ; while ( us . find ( curr_ele ) != us . end ( ) ) { count ++ ; curr_ele -- ; } curr_ele = arr [ 0 ] + 1 ; while ( us . find ( curr_ele ) != us . end ( ) ) { count ++ ; curr_ele ++ ; } return count == ( int ) ( us . size ( ) ) ; }
int FindMinSum ( int num ) { int sum = 0 ; for ( int i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ; return sum ; }
int MinStringValue ( const string & str , int k ) { int l = str . length ( ) ; if ( k >= l ) { return 0 ; } int frequency [ kMaxChar ] ; memset ( frequency , 0 , sizeof ( frequency ) ) ; for ( int i = 0 ; i < l ; i ++ ) { frequency [ str [ i ] - ' a ' ] ++ ; } priority_queue < int > q ; for ( int i = 0 ; i < kMaxChar ; i ++ ) { if ( frequency [ i ] != 0 ) { q . push ( frequency [ i ] ) ; } } while ( k != 0 ) { int temp = q . top ( ) ; q . pop ( ) ; temp = temp - 1 ; q . push ( temp ) ; k -- ; } int result = 0 ; while ( ! q . empty ( ) ) { int temp = q . top ( ) ; result += temp * temp ; q . pop ( ) ; } return result ; }
void ReverseFibonacci ( int n ) { int a [ n ] ; a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) { a [ i ] = a [ i - 2 ] + a [ i - 1 ] ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { cout << a [ i ] << " ▁ " ; } }
int CountSubarrWithEqualZeroAndOne ( int arr [ ] , int n ) { unordered_map < int , int > um ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += ( arr [ i ] == 0 ) ? - 1 : arr [ i ] ; um [ curr_sum ] ++ ; } int count = 0 ; for ( auto & x : um ) { if ( x . second > 1 ) { count += ( x . second * ( x . second - 1 ) ) / 2 ; } } if ( um . find ( 0 ) != um . end ( ) ) { count += um [ 0 ] ; } return count ; }
bool IsLucky ( int n ) { int next_position = n ; if ( counter > n ) { return true ; } if ( n % counter == 0 ) { return false ; } next_position -= next_position / counter ; counter ++ ; return IsLucky ( next_position ) ; }
int Count ( const string & s , int len ) { int cur = 0 , dig = 0 ; int sum [ kMax ] , dp [ kMax ] [ 3 ] ; memset ( sum , 0 , sizeof ( sum ) ) ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= len ; i ++ ) { dig = int ( s [ i - 1 ] ) - 48 ; cur += dig ; cur %= 3 ; sum [ i ] = cur ; dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ] ; dp [ i ] [ sum [ i ] ] ++ ; } int ans = 0 , dprev = 0 , value = 0 , dprev2 = 0 ; for ( int i = 1 ; i <= len ; i ++ ) { dig = int ( s [ i - 1 ] ) - 48 ; if ( dig == 8 ) { ans ++ ; } if ( i - 2 >= 0 ) { dprev = int ( s [ i - 2 ] ) - 48 ; value = dprev * 10 + dig ; if ( ( value % 8 == 0 ) && ( value % 3 != 0 ) ) { ans ++ ; } } if ( i - 3 >= 0 ) { dprev2 = int ( s [ i - 3 ] ) - 48 ; dprev = int ( s [ i - 2 ] ) - 48 ; value = dprev2 * 100 + dprev * 10 + dig ; if ( value % 8 != 0 ) { continue ; } ans += ( i - 2 ) ; ans -= ( dp [ i - 3 ] [ sum [ i ] ] ) ; } } return ans ; }
int NextPowerOf2 ( int n ) { int count = 0 ; if ( n > 0 && ! ( n & ( n - 1 ) ) ) { return n ; } while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
bool CanFormPalindrome ( const string & str ) { int count [ kNoOfChars ] ; memset ( count , 0 , sizeof ( count ) ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { count [ str [ i ] ] ++ ; } int odd = 0 ; for ( int i = 0 ; i < kNoOfChars ; i ++ ) { if ( count [ i ] & 1 ) { odd ++ ; } if ( odd > 1 ) { return false ; } } return true ; }
float SquareRoot ( float n ) { float x = n ; float y = 1 ; float e = 0.000001f ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; }
int BinarySearch ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( mid == arr [ mid ] ) { return mid ; } if ( mid > arr [ mid ] ) { return BinarySearch ( arr , ( mid + 1 ) , high ) ; } else { return BinarySearch ( arr , low , ( mid - 1 ) ) ; } } return - 1 ; }
int CountDyckPaths ( int n ) { int res = 1 ; for ( int i = 0 ; i < n ; ++ i ) { res *= 2 * n - i ; res /= i + 1 ; } return res / ( n + 1 ) ; }
void PushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 0 ) { arr [ count ++ ] = arr [ i ] ; } } while ( count < n ) { arr [ count ++ ] = 0 ; } }
bool IsConvertible ( const string & str1 , const string & str2 , int k ) { if ( ( str1. length ( ) + str2. length ( ) ) < k ) { return true ; } int common_length = 0 ; for ( int i = 0 ; i < min ( str1. length ( ) , str2. length ( ) ) ; i ++ ) { if ( str1 [ i ] == str2 [ i ] ) { common_length ++ ; } else { break ; } } if ( ( k - str1. length ( ) - str2. length ( ) + 2 * common_length ) % 2 == 0 ) { return true ; } return false ; }
int AnswerQuery ( int a [ ] , int n , int l , int r ) { int count = 0 ; l = l - 1 ; for ( int i = l ; i < r ; i ++ ) { int element = a [ i ] ; int divisors = 0 ; for ( int j = l ; j < r ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) { divisors ++ ; } else { break ; } } if ( divisors == r - l ) { count ++ ; } } return count ; }
void Swap ( int & xp , int & yp ) { if ( xp == yp ) { return ; } xp = xp + yp ; yp = xp - yp ; xp = xp - yp ; }
int MaxProfit ( int price [ ] , int n , int k ) { int profit [ k + 1 ] [ n + 1 ] ; memset ( profit , 0 , sizeof ( profit ) ) ; for ( int i = 1 ; i <= k ; i ++ ) { int prev_diff = numeric_limits < int > :: min ( ) ; for ( int j = 1 ; j < n ; j ++ ) { prev_diff = max ( prev_diff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) ; profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ] , price [ j ] + prev_diff ) ; } } return profit [ k ] [ n - 1 ] ; }
void FindMissing ( int a [ ] , int b [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < m ; j ++ ) { if ( a [ i ] == b [ j ] ) { break ; } } if ( j == m ) { cout << a [ i ] << " ▁ " ; } } }
int CountNumberOfTriangles ( int n ) { return n * ( n - 1 ) * ( n - 2 ) / 6 ; }
void PrintSorted ( int arr [ ] , int start , int end ) { if ( start > end ) { return ; } PrintSorted ( arr , start * 2 + 1 , end ) ; cout << arr [ start ] << " ▁ " ; PrintSorted ( arr , start * 2 + 2 , end ) ; }
int Search ( int mat [ 4 ] [ 4 ] , int n , int x ) { if ( n == 0 ) { return - 1 ; } int smallest = a [ 0 ] [ 0 ] , largest = a [ n - 1 ] [ n - 1 ] ; if ( x < smallest || x > largest ) { return - 1 ; } int i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { cout << " n ▁ Found ▁ at ▁ " << i << " , ▁ " << j ; return 1 ; } if ( mat [ i ] [ j ] > x ) { j -- ; } else { i ++ ; } } cout << " n ▁ Element ▁ not ▁ found " ; return 0 ; }
int FindInteger ( int arr [ ] , int n ) { int neg = 0 , pos = 0 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] < 0 ) { neg ++ ; } else { pos ++ ; } } return sum / abs ( neg - pos ) ; }
int CountGroups ( int position , int previous_sum , int length , const string & num ) { if ( position == length ) { return 1 ; } int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += num [ i ] - ' 0 ' ; if ( sum >= previous_sum ) { res += CountGroups ( i + 1 , sum , length , num ) ; } } return res ; }
void DigitsNum ( int n ) { if ( n == 0 ) { cout << " 0 " << endl ; } if ( n % 9 != 0 ) { cout << n % 9 ; } for ( int i = 1 ; i <= n / 9 ; ++ i ) { cout << " 9 " ; } for ( int i = 1 ; i <= n ; ++ i ) { cout << " 0 " ; } cout << endl ; }
void CheckCollision ( int a , int b , int c , int x , int y , int radius ) { int dist = abs ( a * x + b * y + c ) / sqrt ( a * a + b * b ) ; if ( radius == dist ) { cout << " Touch " << endl ; } else if ( radius > dist ) { cout << " Intersect " << endl ; } else { cout << " Outside " << endl ; } }
int Difference ( int arr [ ] [ kMax ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += arr [ i ] [ i ] ; d2 += arr [ i ] [ n - i - 1 ] ; } return abs ( d1 - d2 ) ; }
double AreaCircumscribed ( double a ) { return a * a * ( numbers :: pi / 2 ) ; }
int CountRotations ( int arr [ ] , int n ) { int min = arr [ 0 ] , min_index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min > arr [ i ] ) { min = arr [ i ] ; min_index = i ; } } return min_index ; }
int Lps ( const string & s ) { int n = s . length ( ) ; int a [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int back_up = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( j == i ) { a [ j ] = 1 ; } else if ( s [ i ] == s [ j ] ) { int temp = a [ j ] ; a [ j ] = back_up + 2 ; back_up = temp ; } else { back_up = a [ j ] ; a [ j ] = max ( a [ j - 1 ] , a [ j ] ) ; } } } return a [ n - 1 ] ; }
double SquareRoot ( double n ) { return pow ( 2 , 0.5 * log2 ( n ) ) ; }
void PrintSmall ( int arr [ ] , int n , int k ) { for ( int i = k ; i < n ; ++ i ) { int max_var = arr [ k - 1 ] ; int pos = k - 1 ; for ( int j = k - 2 ; j >= 0 ; j -- ) { if ( arr [ j ] > max_var ) { max_var = arr [ j ] ; pos = j ; } } if ( max_var > arr [ i ] ) { int j = pos ; while ( j < k - 1 ) { arr [ j ] = arr [ j + 1 ] ; j ++ ; } arr [ k - 1 ] = arr [ i ] ; } } for ( int i = 0 ; i < k ; i ++ ) { cout << arr [ i ] << " ▁ " ; } }
void BestApproximate ( int x [ ] , int y [ ] , int n ) { float m , c , sum_x = 0 , sum_y = 0 , sum_xy = 0 , sum_x2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_x += x [ i ] ; sum_y += y [ i ] ; sum_xy += x [ i ] * y [ i ] ; sum_x2 += pow ( x [ i ] , 2 ) ; } m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ; c = ( sum_y - m * sum_x ) / n ; cout << " m ▁ = " << m << endl ; cout << " c ▁ = " << c << endl ; }
double CosXSertiesSum ( double x , int n ) { x = x * ( numbers :: pi / 180.0 ) ; double res = 1 ; double sign = 1 , fact = 1 , pow = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) { sign = sign * - 1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; }
void PrintArray ( int arr [ ] [ 5 ] , int row , int col ) { unordered_set < string > uset ; for ( int i = 0 ; i < row ; i ++ ) { string s ; for ( int j = 0 ; j < col ; j ++ ) { s += to_string ( arr [ i ] [ j ] ) ; } if ( uset . find ( s ) != uset . end ( ) ) { uset . insert ( s ) ; cout << s << endl ; } } }
int Factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * Factorial ( n - 1 ) ; }
long CountWays ( int n , int k ) { int total = k ; int mod = 1000000007 ; int same = 0 , diff = k ; for ( int i = 2 ; i <= n ; i ++ ) { same = diff ; diff = total * ( k - 1 ) % mod ; total = ( same + diff ) % mod ; } return total ; }
int LinearSearch ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) { return i ; } } return - 1 ; }
int Pad ( int n ) { int p_prev_prev = 1 , p_prev = 1 , p_curr = 1 , p_next = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { p_next = p_prev_prev + p_prev ; p_prev_prev = p_prev ; p_prev = p_curr ; p_curr = p_next ; } return p_next ; }
int MaxLevel ( int boxes [ ] , int n ) { sort ( boxes , boxes + n ) ; int ans = 1 ; int prev_width = boxes [ 0 ] ; int prev_count = 1 ; int curr_count = 0 ; int curr_width = 0 ; for ( int i = 1 ; i < n ; i ++ ) { curr_width += boxes [ i ] ; curr_count += 1 ; if ( curr_width > prev_width && curr_count > prev_count ) { prev_width = curr_width ; prev_count = curr_count ; curr_count = 0 ; curr_width = 0 ; ans ++ ; } } return ans ; }
int MaximumHeight ( int n ) { return ( int ) floor ( ( - 1 + sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ; }
int Compute ( vector < int > graph [ ] , int n ) { int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( graph [ i ] . size ( ) == 0 ) { count ++ ; } } return count ; }
int ProductAtKthLevel ( const string & tree , int k ) { int level = - 1 ; int product = 1 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree [ i ] == ' ( ' ) { level ++ ; } else if ( tree [ i ] == ' ) ' ) { level -- ; } else if ( level == k ) { product *= tree [ i ] - ' 0 ' ; } } return product ; }
void ProductArray ( int arr [ ] , int n ) { if ( n == 1 ) { cout << 0 ; return ; } int left [ n ] , right [ n ] , prod [ n ] ; memset ( left , 0 , sizeof ( left ) ) ; memset ( right , 0 , sizeof ( right ) ) ; memset ( prod , 0 , sizeof ( prod ) ) ; int i , j ; left [ 0 ] = 1 ; right [ n - 1 ] = 1 ; for ( i = 1 ; i < n ; i ++ ) { left [ i ] = arr [ i - 1 ] * left [ i - 1 ] ; } for ( j = n - 2 ; j >= 0 ; j -- ) { right [ j ] = arr [ j + 1 ] * right [ j + 1 ] ; } for ( i = 0 ; i < n ; i ++ ) { prod [ i ] = left [ i ] * right [ i ] ; } for ( i = 0 ; i < n ; i ++ ) { cout << prod [ i ] << " ▁ " ; } }
void FindPairs ( int arr1 [ ] , int arr2 [ ] , int n , int m , int x ) { unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { s . insert ( arr1 [ i ] ) ; } for ( int j = 0 ; j < m ; j ++ ) { if ( s . find ( x - arr2 [ j ] ) != s . end ( ) ) { cout << x - arr2 [ j ] << " ▁ " << arr2 [ j ] << endl ; } } }
int SumOfSeries ( int n ) { return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ; }
int PrintKDistinct ( int arr [ ] , int n , int k ) { unordered_map < int , int > h ; for ( int i = 0 ; i < n ; i ++ ) { h [ arr [ i ] ] ++ ; } if ( h . size ( ) < k ) { return - 1 ; } int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( h [ arr [ i ] ] == 1 ) { dist_count ++ ; } if ( dist_count == k ) { return arr [ i ] ; } } return - 1 ; }
int MinInsertion ( const string & str ) { int n = str . length ( ) ; int res = 0 ; int count [ 26 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { count [ str [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] % 2 == 1 ) { res ++ ; } } return ( res == 0 ) ? 0 : res - 1 ; }
void PrintStringAlternate ( const string & str ) { unordered_map < char , int > occ ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char temp = tolower ( str [ i ] ) ; occ [ temp ] ++ ; if ( occ [ temp ] & 1 ) { cout << str [ i ] ; } } cout << endl ; }
int MaxTripletSum ( int arr [ ] , int n ) { int max_a = numeric_limits < int > :: min ( ) , max_b = numeric_limits < int > :: min ( ) , max_c = numeric_limits < int > :: min ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max_a ) { max_c = max_b ; max_b = max_a ; max_a = arr [ i ] ; } else if ( arr [ i ] > max_b ) { max_c = max_b ; max_b = arr [ i ] ; } else if ( arr [ i ] > max_c ) { max_c = arr [ i ] ; } } return max_a + max_b + max_c ; }
int DayOfWeek ( int d , int m , int y ) { int t [ ] = { 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 } ; y -= ( m < 3 ) ? 1 : 0 ; return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ; }
void LongestSubsequence ( int a [ ] , int n ) { unordered_map < int , int > mp ; int dp [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; int maximum = numeric_limits < int > :: min ( ) ; int index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . find ( a [ i ] - 1 ) != mp . end ( ) ) { int lastIndex = mp [ a [ i ] - 1 ] - 1 ; dp [ i ] = 1 + dp [ lastIndex ] ; } else { dp [ i ] = 1 ; } mp [ a [ i ] ] = i + 1 ; if ( maximum < dp [ i ] ) { maximum = dp [ i ] ; index = i ; } } for ( int curr = a [ index ] - maximum + 1 ; curr <= a [ index ] ; curr ++ ) { cout << curr << " ▁ " ; } }
bool IsPowerOfK ( int n , int k ) { bool oneSeen = false ; while ( n > 0 ) { int digit = n % k ; if ( digit > 1 ) { return false ; } if ( digit == 1 ) { if ( oneSeen ) { return false ; } oneSeen = true ; } n /= k ; } return true ; }
int Calculate ( int a [ ] , int n ) { sort ( a , a + n ) ; int count = 1 ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { count += 1 ; } else { answer = answer + count * ( count - 1 ) / 2 ; count = 1 ; } } answer = answer + count * ( count - 1 ) / 2 ; return answer ; }
int FindIndex ( const string & str ) { int len = str . length ( ) ; int open [ len + 1 ] , close [ len + 1 ] ; memset ( open , 0 , sizeof ( open ) ) ; memset ( close , 0 , sizeof ( close ) ) ; int index = - 1 ; open [ 0 ] = 0 ; close [ len ] = 0 ; if ( str [ 0 ] == ' ( ' ) { open [ 1 ] = 1 ; } if ( str [ len - 1 ] == ' ) ' ) { close [ len - 1 ] = 1 ; } for ( int i = 1 ; i < len ; i ++ ) { if ( str [ i ] == ' ( ' ) { open [ i + 1 ] = open [ i ] + 1 ; } else { open [ i + 1 ] = open [ i ] ; } } for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str [ i ] == ' ) ' ) { close [ i ] = close [ i + 1 ] + 1 ; } else { close [ i ] = close [ i + 1 ] ; } } if ( open [ len ] == 0 ) { return len ; } if ( close [ 0 ] == 0 ) { return 0 ; } for ( int i = 0 ; i <= len ; i ++ ) { if ( open [ i ] == close [ i ] ) { index = i ; } } return index ; }
void FindTriplets ( int arr [ ] , int n ) { bool found = true ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) { cout << arr [ i ] << " ▁ " << arr [ j ] << " ▁ " << arr [ k ] << endl ; found = true ; } } } } if ( found == false ) { cout << " ▁ not ▁ exist ▁ " << endl ; } }
int GetIndexInSortedArray ( int arr [ ] , int n , int idx ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ idx ] ) { result ++ ; } if ( arr [ i ] == arr [ idx ] && i < idx ) { result ++ ; } } return result ; }
string LongestRepeatedSubstring ( const string & str ) { int n = str . length ( ) ; int lcs_re [ n + 1 ] [ n + 1 ] ; memset ( lcs_re , 0 , sizeof ( lcs_re ) ) ; string res ; int res_length = 0 ; int i , index = 0 ; for ( i = 1 ; i <= n ; i ++ ) { for ( int j = i + 1 ; j <= n ; j ++ ) { if ( str [ i - 1 ] == str [ j - 1 ] && lcs_re [ i - 1 ] [ j - 1 ] < ( j - i ) ) { lcs_re [ i ] [ j ] = lcs_re [ i - 1 ] [ j - 1 ] + 1 ; if ( lcs_re [ i ] [ j ] > res_length ) { res_length = lcs_re [ i ] [ j ] ; index = max ( i , index ) ; } } else { lcs_re [ i ] [ j ] = 0 ; } } } if ( res_length > 0 ) { for ( i = index - res_length + 1 ; i <= index ; i ++ ) { res . push_back ( str [ i - 1 ] ) ; } } return res ; }
void BubbleSort ( int arr [ ] , int n ) { bool swapped ; for ( int i = 0 ; i < n - 1 ; i ++ ) { swapped = false ; for ( int j = 0 ; j < n - i - 1 ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) { swap ( arr [ j ] , arr [ j + 1 ] ) ; swapped = true ; } } if ( swapped == false ) { break ; } } }
int MinStepToDeleteString ( const string & str ) { int n = str . length ( ) ; int dp [ n + 1 ] [ n + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int len = 1 ; len <= n ; len ++ ) { for ( int i = 0 , j = len - 1 ; j < n ; i ++ , j ++ ) { if ( len == 1 ) { dp [ i ] [ j ] = 1 ; } else { dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ; if ( str [ i ] == str [ i + 1 ] ) { dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ; } for ( int k = i + 2 ; k <= j ; k ++ ) { if ( str [ i ] == str [ k ] ) { dp [ i ] [ j ] = min ( dp [ i + 1 ] [ k - 1 ] + dp [ k + 1 ] [ j ] , dp [ i ] [ j ] ) ; } } } } } return dp [ 0 ] [ n - 1 ] ; }
int FloorSearch ( int arr [ ] , int low , int high , int x ) { if ( low > high ) { return - 1 ; } if ( x >= arr [ high ] ) { return high ; } int mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) { return mid ; } if ( mid > 0 && arr [ mid - 1 ] <= x && x < arr [ mid ] ) { return mid - 1 ; } if ( x < arr [ mid ] ) { return FloorSearch ( arr , low , mid - 1 , x ) ; } return FloorSearch ( arr , mid + 1 , high , x ) ; }
bool AreAnagram ( string & str1 , string & str2 ) { int n1 = str1. length ( ) ; int n2 = str2. length ( ) ; if ( n1 != n2 ) { return false ; } sort ( str1. begin ( ) , str1. end ( ) ) ; sort ( str2. begin ( ) , str2. end ( ) ) ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( str1 [ i ] != str2 [ i ] ) { return false ; } } return true ; }
int FindMaxSegment ( const string & s , int k ) { int seg_len = s . length ( ) - k ; int res = 0 ; for ( int i = 0 ; i < seg_len ; i ++ ) { res = res * 10 + ( s [ i ] - ' 0 ' ) ; } int seg_len_pow = pow ( 10 , seg_len - 1 ) ; int curr_val = res ; for ( int i = 1 ; i <= ( s . length ( ) - seg_len ) ; i ++ ) { curr_val = curr_val - ( s [ i - 1 ] - ' 0 ' ) * seg_len_pow ; curr_val = curr_val * 10 + ( s [ i + seg_len - 1 ] - ' 0 ' ) ; res = max ( res , curr_val ) ; } return res ; }
void RearrangeArray ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int temp_arr [ n ] ; int arr_index = 0 ; for ( int i = 0 , j = n - 1 ; i <= n / 2 || j > n / 2 ; i ++ , j -- ) { temp_arr [ arr_index ] = arr [ i ] ; arr_index ++ ; temp_arr [ arr_index ] = arr [ j ] ; arr_index ++ ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = temp_arr [ i ] ; } }
int MostFrequent ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int max_count = 1 , res = arr [ 0 ] , curr_count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { curr_count ++ ; } else { if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ i - 1 ] ; } curr_count = 1 ; } } if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ n - 1 ] ; } return res ; }
int SumOfSeries ( int n ) { return ( int ) ( 0.6172 * ( pow ( 10 , n ) - 1 ) - 0.55 * n ) ; }
int MinSum ( int a [ ] , int n ) { sort ( a , a + n ) ; int num1 = 0 ; int num2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { num1 = num1 * 10 + a [ i ] ; } else { num2 = num2 * 10 + a [ i ] ; } } return num2 + num1 ; }
int PerfectSquare ( const string & s ) { int n = s . length ( ) ; int ans = - 1 ; string num ; for ( int i = 1 ; i < ( 1 << n ) ; i ++ ) { string str ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i >> j ) & 1 ) { str += s [ j ] ; } } if ( str [ 0 ] != ' 0 ' ) { int temp = 0 ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { temp = temp * 10 + ( int ) ( str [ j ] - ' 0 ' ) ; } int k = sqrt ( temp ) ; if ( k * k == temp ) { if ( ans < str . length ( ) ) { ans = str . length ( ) ; num = str ; } } } } if ( ans == - 1 ) { return ans ; } else { cout << num << " ▁ " ; return n - ans ; } }
bool CheckPlusPerfect ( int x ) { int temp = x ; int n = 0 ; while ( x != 0 ) { x /= 10 ; n ++ ; } x = temp ; int sum = 0 ; while ( x != 0 ) { sum += pow ( x % 10 , n ) ; x /= 10 ; } return sum == temp ; }
bool CheckStackPermutation ( int ip [ ] , int op [ ] , int n ) { queue < int > input ; for ( int i = 0 ; i < n ; i ++ ) { input . push ( ip [ i ] ) ; } queue < int > output ; for ( int i = 0 ; i < n ; i ++ ) { output . push ( op [ i ] ) ; } stack < int > temp_stack ; while ( ! input . empty ( ) ) { int ele = input . front ( ) ; input . pop ( ) ; if ( ele == output . front ( ) ) { output . pop ( ) ; while ( ! temp_stack . empty ( ) ) { if ( temp_stack . top ( ) == output . front ( ) ) { temp_stack . pop ( ) ; output . pop ( ) ; } else { break ; } } } else { temp_stack . push ( ele ) ; } } return input . empty ( ) && temp_stack . empty ( ) ; }
int ReplaceSpaces ( string & str ) { int space_count = 0 , i ; for ( i = 0 ; str [ i ] ; i ++ ) { if ( str [ i ] == ' ▁ ' ) { space_count ++ ; } } while ( str [ i - 1 ] == ' ▁ ' ) { space_count -- ; i -- ; } int new_length = i + space_count * 2 + 1 ; if ( new_length > kMax ) { return - 1 ; } int index = new_length - 1 ; str [ index -- ] = ' \ 0 ' ; for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( str [ j ] == ' ▁ ' ) { str [ index ] = ' 0 ' ; str [ index - 1 ] = ' 2 ' ; str [ index - 2 ] = ' % ' ; index = index - 3 ; } else { str [ index ] = str [ j ] ; index -- ; } } return new_length ; }
void NthPalindrome ( int n , int k ) { int temp = ( k & 1 ) ? ( k / 2 ) : ( k / 2 - 1 ) ; int palindrome = ( int ) pow ( 10 , temp ) ; palindrome += n - 1 ; cout << palindrome ; if ( k & 1 ) { palindrome /= 10 ; } while ( palindrome ) { cout << palindrome % 10 ; palindrome /= 10 ; } cout << endl ; }
int GetOddOccurrence ( int arr [ ] , int size ) { unordered_map < int , int > hash ; for ( int i = 0 ; i < size ; i ++ ) { hash [ arr [ i ] ] ++ ; } for ( auto & a : hash ) { if ( a . second % 2 != 0 ) { return a . first ; } } return - 1 ; }
int FindCommon ( int mat [ M ] [ N ] ) { unordered_map < int , int > cnt ; int i , j ; for ( i = 0 ; i < M ; i ++ ) { cnt [ mat [ i ] [ 0 ] ] ++ ; for ( j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] != mat [ i ] [ j - 1 ] ) { cnt [ mat [ i ] [ j ] ] ++ ; } } } for ( auto & ele : cnt ) { if ( ele . second == M ) { return ele . first ; } } return - 1 ; }
int MinCost ( int coin [ ] , int n , int k ) { sort ( coin , coin + n ) ; int coins_needed = ceil ( 1.0 * n / ( k + 1 ) ) ; int ans = 0 ; for ( int i = 0 ; i <= coins_needed - 1 ; i ++ ) { ans += coin [ i ] ; } return ans ; }
string FindSum ( const string & str1 , const string & str2 ) { if ( str1. length ( ) > str2. length ( ) ) { return " " ; } string str ; int n1 = str1. length ( ) , n2 = str2. length ( ) ; int diff = n2 - n1 ; int carry = 0 ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { int sum = ( str1 [ i ] - ' 0 ' ) + ( str2 [ i + diff ] - ' 0 ' ) + carry ; str . push_back ( sum % 10 + ' 0 ' ) ; carry = sum / 10 ; } for ( int i = n2 - n1 - 1 ; i >= 0 ; i -- ) { int sum = ( str2 [ i ] - ' 0 ' ) + carry ; str . push_back ( sum % 10 + ' 0 ' ) ; carry = sum / 10 ; } if ( carry ) { str . push_back ( carry + ' 0 ' ) ; } reverse ( str . begin ( ) , str . end ( ) ) ; return str ; }
int FindRepeatFirstN2 ( const string & s ) { int p = - 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } } if ( p != - 1 ) { break ; } } return p ; }
int UnitNumber ( int x , int y ) { x = x % 10 ; if ( y != 0 ) { y = y % 4 + 4 ; } return ( int ) ( pow ( x , y ) ) % 10 ; }
int PoliceThief ( char arr [ ] , int n , int k ) { int res = 0 ; vector < int > thi ; vector < int > pol ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == ' P ' ) { pol . push_back ( i ) ; } else if ( arr [ i ] == ' T ' ) { thi . push_back ( i ) ; } } int l = 0 , r = 0 ; while ( l < thi . size ( ) && r < pol . size ( ) ) { if ( abs ( thi [ l ] - pol [ r ] ) <= k ) { res ++ ; l ++ ; r ++ ; } else if ( thi [ l ] < pol [ r ] ) { l ++ ; } else { r ++ ; } } return res ; }
int Calculate ( int a , int b , int c , int m ) { int res = Power ( b , c , m - 1 ) ; int ans = Power ( a , res , m ) ; return ans ; }
int NumberOfWays ( int x ) { if ( x == 0 || x == 1 ) { return 1 ; } else { return NumberOfWays ( x - 1 ) + ( x - 1 ) * NumberOfWays ( x - 2 ) ; } }
int Unique ( int mat [ kRow ] [ kCol ] , int n , int m ) { int maximum = 0 , flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( maximum < mat [ i ] [ j ] ) { maximum = mat [ i ] [ j ] ; } } } int b [ maximum + 1 ] ; memset ( b , 0 , sizeof ( b ) ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { b [ mat [ i ] [ j ] ] ++ ; } } for ( int i = 1 ; i <= maximum ; i ++ ) { if ( b [ i ] == 1 ) { cout << i << " ▁ " ; flag = 1 ; } } if ( ! flag ) { cout << " No ▁ unique ▁ element ▁ in ▁ the ▁ matrix " ; } }
int Knapsack ( int w , int wt [ ] , int val [ ] , int n ) { if ( n == 0 || w == 0 ) { return 0 ; } if ( wt [ n - 1 ] > w ) { return Knapsack ( w , wt , val , n - 1 ) ; } else { return max ( val [ n - 1 ] + Knapsack ( w - wt [ n - 1 ] , wt , val , n - 1 ) , Knapsack ( w , wt , val , n - 1 ) ) ; } }
int CountSubsets ( int arr [ ] , int n ) { unordered_set < int > us ; int even_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { us . insert ( arr [ i ] ) ; } } even_count = us . size ( ) ; return ( int ) pow ( 2 , even_count ) - 1 ; }
int FindSubarraySum ( int arr [ ] , int n , int sum ) { unordered_map < int , int > prev_sum ; int res = 0 ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; if ( curr_sum == sum ) { res ++ ; } if ( prev_sum . find ( curr_sum - sum ) != prev_sum . end ( ) ) { res += ( prev_sum [ curr_sum - sum ] ) ; } prev_sum [ curr_sum ] ++ ; } return res ; }
int SummingSeries ( long long n ) { int s = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { s += i * i - ( i - 1 ) * ( i - 1 ) ; } return s ; }
void ShuffleArray ( int a [ ] , int f , int l ) { if ( l > f ) { return ; } if ( l - f == 1 ) { return ; } int mid = ( f + l ) / 2 ; int ptr = mid + 1 ; int mmid = ( f + mid ) / 2 ; for ( int i = mmid + 1 ; i <= mid ; i ++ ) { swap ( a [ i ] , a [ ptr ++ ] ) ; } ShufleArray ( a , f , mid ) ; ShufleArray ( a , mid + 1 , l ) ; }
int GcdExtended ( int a , int b , int & x , int & y ) { if ( a == 0 ) { x = 0 ; y = 1 ; return b ; } int x1 , y1 ; x1 = 1 ; y1 = 1 ; int gcd = GcdExtended ( b % a , a , x1 , y1 ) ; x = y1 - ( b / a ) * x1 ; y = x1 ; return gcd ; }
void GenerateGrayArr ( int n ) { if ( n <= 0 ) { return ; } vector < string > arr ; arr . push_back ( " 0 " ) ; arr . push_back ( " 1 " ) ; for ( int i = 2 ; i < ( 1 << n ) ; i = i << 1 ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { arr . push_back ( arr [ j ] ) ; } for ( int j = 0 ; j < i ; j ++ ) { arr [ j ] = " 0 " + arr [ j ] ; } for ( int j = i ; j < 2 * i ; j ++ ) { arr [ j ] = " 1 " + arr [ j ] ; } } for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { cout << arr [ i ] << endl ; } }
int DivSum ( int num ) { int result = 0 ; for ( int i = 2 ; i <= sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == num / i ) { result += i ; } else { result += i + num / i ; } } } return result + 1 ; }
int Lcis ( int arr1 [ ] , int n , int arr2 [ ] , int m ) { int table [ m ] ; for ( int j = 0 ; j < m ; j ++ ) { table [ j ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { int current = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) { if ( current + 1 > table [ j ] ) { table [ j ] = current + 1 ; } } if ( arr1 [ i ] > arr2 [ j ] ) { if ( table [ j ] > current ) { current = table [ j ] ; } } } } int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( table [ i ] > result ) { result = table [ i ] ; } } return result ; }
bool Find3Numbers ( int a [ ] , int arr_size , int sum ) { for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { unordered_set < int > s ; int curr_sum = sum - a [ i ] ; for ( int j = i + 1 ; j < arr_size ; j ++ ) { if ( s . find ( curr_sum - a [ j ] ) != s . end ( ) ) { cout << format ( " Triplet ▁ is ▁ { } , ▁ { } , ▁ { } " , a [ i ] , a [ j ] , curr_sum - a [ j ] ) ; return true ; } s . insert ( a [ j ] ) ; } } return false ; }
string Multiply ( const string & num1 , const string & num2 ) { int len1 = num1. length ( ) ; int len2 = num2. length ( ) ; if ( len1 == 0 || len2 == 0 ) { return " 0 " ; } vector < int > result ( len1 + len2 , 0 ) ; int i_n1 = 0 ; int i_n2 = 0 ; for ( int i = len1 - 1 ; i >= 0 ; i -- ) { int carry = 0 ; int n1 = num1 [ i ] - ' 0 ' ; i_n2 = 0 ; for ( int j = len2 - 1 ; j >= 0 ; j -- ) { int n2 = num2 [ j ] - ' 0 ' ; int sum = n1 * n2 + result [ i_n1 + i_n2 ] + carry ; carry = sum / 10 ; result [ i_n1 + i_n2 ] = sum % 10 ; i_n2 ++ ; } if ( carry > 0 ) { result [ i_n1 + i_n2 ] += carry ; } i_n1 ++ ; } int i = result . size ( ) - 1 ; while ( i >= 0 && result [ i ] == 0 ) { i -- ; } if ( i == - 1 ) { return " 0 " ; } string s ; while ( i >= 0 ) { s += to_string ( result [ i -- ] ) ; } return s ; }
int ModFact ( int n , int p ) { if ( n >= p ) { return 0 ; } int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { result = ( result * i ) % p ; } return result ; }
void SortString ( const string & str ) { int char_count [ kMaxChar ] ; memset ( char_count , 0 , sizeof ( char_count ) ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char_count [ str [ i ] - ' a ' ] ++ ; } for ( int i = kMaxChar - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < char_count [ i ] ; j ++ ) { cout << ( char ) ( ' a ' + i ) ; } } }
int CountFact ( int low , int high ) { int fact = 1 , x = 1 ; while ( fact < low ) { fact = fact * x ; x ++ ; } int res = 0 ; while ( fact <= high ) { res ++ ; fact = fact * x ; x ++ ; } return res ; }
float AreaOfSegment ( float radius , float angle ) { float area_of_sector = ( float ) numbers :: pi * ( radius * radius ) * ( angle / 360 ) ; float area_of_triangle = ( float ) 1 / 2 * ( radius * radius ) * sin ( ( angle * numbers :: pi ) / 180 ) ; return area_of_sector - area_of_triangle ; }
void PrintPrevSmaller ( int arr [ ] , int n ) { stack < int > s ; for ( int i = 0 ; i < n ; i ++ ) { while ( ! s . empty ( ) && s . top ( ) >= arr [ i ] ) { s . pop ( ) ; } if ( s . empty ( ) ) { cout << " _ , ▁ " ; } else { cout << s . top ( ) << " , ▁ " ; } s . push ( arr [ i ] ) ; } }
bool CheckStar ( int mat [ ] [ arr_size ] ) { int vertex_d1 = 0 , vertex_dn_1 = 0 ; if ( arr_size == 1 ) { return ( mat [ 0 ] [ 0 ] == 0 ) ; } if ( arr_size == 2 ) { return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 0 ] == 1 && mat [ 1 ] [ 1 ] == 0 ) ; } for ( int i = 0 ; i < arr_size ; i ++ ) { int degree_i = 0 ; for ( int j = 0 ; j < arr_size ; j ++ ) { if ( mat [ i ] [ j ] ) { degree_i ++ ; } } if ( degree_i == 1 ) { vertex_d1 ++ ; } else if ( degree_i == arr_size - 1 ) { vertex_dn_1 ++ ; } } return vertex_d1 == ( arr_size - 1 ) && vertex_dn_1 == 1 ; }
void ComputeTotient ( int n ) { long long phi [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { phi [ i ] = i ; } for ( int p = 2 ; p <= n ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i <= n ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } for ( int i = 1 ; i <= n ; i ++ ) { cout << " Totient ▁ of ▁ " << i << " ▁ is ▁ " << phi [ i ] << endl ; } }
int FindIndex ( int n ) { float fibo = ( float ) ( 2.078087 * log ( n ) + 1.672276 ) ; return round ( fibo ) ; }
void MidPoint ( int x1 , int y1 , int x2 , int y2 ) { int dx = x2 - x1 ; int dy = y2 - y1 ; int d = dy - ( dx / 2 ) ; int x = x1 , y = y1 ; cout << x << " , " << y << endl ; while ( x < x2 ) { x ++ ; if ( d < 0 ) { d = d + dy ; } else { d += ( dy - dx ) ; y ++ ; } cout << x << " , " << y << endl ; } }
bool IsPossible ( int n , int index , int sum , int m , int arr [ ] , int dp [ ] [ kMax ] ) { if ( index == n ) { if ( ( sum % m ) == 0 ) { return true ; } return false ; } else if ( sum < 0 || sum >= kMax ) { return false ; } if ( dp [ index ] [ sum ] != - 1 ) { return dp [ index ] [ sum ] ; } bool placeAdd = IsPossible ( n , index + 1 , sum + arr [ index ] , m , arr , dp ) ; bool placeMinus = IsPossible ( n , index + 1 , sum - arr [ index ] , m , arr , dp ) ; bool res = placeAdd || placeMinus ; dp [ index ] [ sum ] = res ; return res ; }
void RearrangeArr ( int arr [ ] , int n ) { int evenPos = n / 2 ; int oddPos = n - evenPos ; int temp_arr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { temp_arr [ i ] = arr [ i ] ; } sort ( temp_arr , temp_arr + n ) ; int j = oddPos - 1 ; for ( int i = 0 ; i < n ; i += 2 ) { arr [ i ] = temp_arr [ j ] ; j -- ; } j = oddPos ; for ( int i = 1 ; i < n ; i += 2 ) { arr [ i ] = temp_arr [ j ] ; j ++ ; } for ( int i = 0 ; i < n ; i ++ ) { cout << arr [ i ] << " ▁ " ; } }
void PrintFirstNegativeInteger ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < ( n - k + 1 ) ; i ++ ) { boolean flag = false ; for ( int j = 0 ; j < k ; j ++ ) { if ( arr [ i + j ] < 0 ) { cout << arr [ i + j ] << " ▁ " ; flag = true ; break ; } } if ( ! flag ) { cout << " 0 " << " ▁ " ; } } }
string SortString ( const string & str ) { string temp_array ( str ) ; sort ( temp_array . begin ( ) , temp_array . end ( ) ) ; return temp_array ; }
bool PairWiseConsecutive ( stack < int > & s ) { stack < int > aux ; while ( ! s . empty ( ) ) { aux . push ( s . top ( ) ) ; s . pop ( ) ; } bool result = true ; while ( aux . empty ( ) > 1 ) { int x = aux . top ( ) ; aux . pop ( ) ; int y = aux . top ( ) ; aux . pop ( ) ; if ( abs ( x - y ) != 1 ) { result = false ; } s . push ( x ) ; s . push ( y ) ; } if ( aux . size ( ) == 1 ) { s . push ( aux . top ( ) ) ; } return result ; }
string NextGreater ( const string & str ) { string num ( str ) ; int l = num . length ( ) ; int i ; for ( i = l - 1 ; i >= 0 ; i -- ) { if ( num [ i ] == ' 0 ' ) { num [ i ] = ' 1 ' ; break ; } else { num [ i ] = ' 0 ' ; } } if ( i < 0 ) { num . insert ( 0 , 1 , ' 1 ' ) ; } return num ; }
vector < int > RestoreTree ( int start [ ] , int end [ ] ) { vector < int > identity ( N , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) { identity [ start [ i ] ] = i ; } vector < int > parent ( N , - 1 ) ; int curr_parent = identity [ 0 ] ; for ( int j = 1 ; j < N ; j ++ ) { int child = identity [ j ] ; if ( end [ child ] - j > 1 ) { parent [ child ] = curr_parent ; curr_parent = child ; } else { parent [ child ] = curr_parent ; } while ( end [ child ] == end [ parent [ child ] ] ) { child = parent [ child ] ; curr_parent = parent [ child ] ; if ( curr_parent == identity [ 0 ] ) { break ; } } } for ( int i = 0 ; i < N ; i ++ ) { parent [ i ] += 1 ; } return parent ; }
void PrintPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int c = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { cout << c << " ▁ " ; c = c * ( line - i ) / i ; } cout << endl ; } }
int MaxSum ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * i ; } return sum ; }
void SubsetDifference ( int n ) { int s = n * ( n + 1 ) / 2 ; if ( n % 4 == 0 ) { cout << " First ▁ subset ▁ sum ▁ = ▁ " << s / 2 << endl ; cout << " Second ▁ subset ▁ sum ▁ = ▁ " << s / 2 << endl ; cout << " Difference ▁ = ▁ " << 0 << endl ; } else { if ( n % 4 == 1 || n % 4 == 2 ) { cout << " First ▁ subset ▁ sum ▁ = ▁ " << s / 2 << endl ; cout << " Second ▁ subset ▁ sum ▁ = ▁ " << s / 2 + 1 << endl ; cout << " Difference ▁ = ▁ " << 1 << endl ; } else { cout << " First ▁ subset ▁ sum ▁ = ▁ " << s / 2 << endl ; cout << " Second ▁ subset ▁ sum ▁ = ▁ " << s / 2 << endl ; cout << " Difference ▁ = ▁ " << 0 << endl ; } } }
bool IsReversible ( const string & str ) { int i = 0 , j = str . length ( ) - 1 ; while ( i < j ) { if ( str [ i ] != str [ j ] ) { return false ; } i ++ ; j -- ; } return true ; }
bool GetParity ( int n ) { bool parity = 0 ; while ( n ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; }
char MaxRepeating ( const string & str ) { int len = str . length ( ) ; int count = 0 ; char res = str [ 0 ] ; for ( int i = 0 ; i < len ; i ++ ) { int cur_count = 1 ; for ( int j = i + 1 ; j < len ; j ++ ) { if ( str [ i ] != str [ j ] ) { break ; } cur_count ++ ; } if ( cur_count > count ) { count = cur_count ; res = str [ i ] ; } } return res ; }
int SeiresSum ( int n , int a [ ] ) { int res = 0 ; for ( int i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) { res += a [ i ] * a [ i ] ; } else { res -= a [ i ] * a [ i ] ; } } return res ; }
void PrintTwoElements ( int arr [ ] , int size ) { cout << " ▁ The ▁ repeating ▁ element ▁ is ▁ " ; for ( int i = 0 ; i < size ; i ++ ) { if ( arr [ abs ( arr [ i ] ) - 1 ] > 0 ) { arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] ; } else { cout << abs ( arr [ i ] ) << endl ; } } cout << " and ▁ the ▁ missing ▁ element ▁ is ▁ " ; for ( int i = 0 ; i < size ; i ++ ) { if ( arr [ i ] > 0 ) { cout << i + 1 ; } } }
bool IsSubSequence ( const string & str1 , const string & str2 , int m , int n ) { int j = 0 ; for ( int i = 0 ; i < n && j < m ; i ++ ) { if ( str1 [ j ] == str2 [ i ] ) { j ++ ; } } return ( j == m ) ; }
int SieveOfSundaram ( int n ) { int n_new = ( n - 2 ) / 2 ; bool marked [ n_new + 1 ] ; memset ( marked , false , sizeof ( marked ) ) ; for ( int i = 1 ; i <= n_new ; i ++ ) { for ( int j = i ; ( i + j + 2 * i * j ) <= n_new ; j ++ ) { marked [ i + j + 2 * i * j ] = true ; } } if ( n > 2 ) { cout << 2 << " ▁ " ; } for ( int i = 1 ; i <= n_new ; i ++ ) { if ( marked [ i ] == false ) { cout << 2 * i + 1 << " ▁ " ; } } return - 1 ; }
string FindTwosComplement ( const string & s ) { string str ( s ) ; int n = str . length ( ) ; int i ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == ' 1 ' ) { break ; } } if ( i == - 1 ) { return ' 1 ' + str ; } for ( int k = i - 1 ; k >= 0 ; k -- ) { if ( str [ k ] == ' 1 ' ) { str [ k ] = ' 0 ' ; } else { str [ k ] = ' 1 ' ; } } return str ; }
int SmallestSubWithSum ( int arr [ ] , int n , int x ) { int curr_sum = 0 , min_len = n + 1 ; int start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) { curr_sum += arr [ end ++ ] ; } while ( curr_sum > x && start < n ) { if ( end - start < min_len ) { min_len = end - start ; } curr_sum -= arr [ start ++ ] ; } } return min_len ; }
int Circumference ( int l , int w ) { return 2 * ( l + w ) ; }
void SortString ( const string & str ) { string arr ( str ) ; sort ( arr . begin ( ) , arr . end ( ) ) ; cout << arr ; }
int CountPair ( int a , int b ) { string s = to_string ( b ) ; int i ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] != ' 9 ' ) { break ; } } int result ; if ( i == s . length ( ) ) { result = a * s . length ( ) ; } else { result = a * ( s . length ( ) - 1 ) ; } return result ; }
int MinOperations ( const string & str , int n ) { int i , last_upper = - 1 , first_lower = - 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( isupper ( str [ i ] ) ) { last_upper = i ; break ; } } for ( i = 0 ; i < n ; i ++ ) { if ( islower ( str [ i ] ) ) { first_lower = i ; break ; } } if ( last_upper == - 1 || first_lower == - 1 ) { return 0 ; } int count_upper = 0 ; for ( i = first_lower ; i < n ; i ++ ) { if ( isupper ( str [ i ] ) ) { count_upper ++ ; } } int count_lower = 0 ; for ( i = 0 ; i < last_upper ; i ++ ) { if ( islower ( str [ i ] ) ) { count_lower ++ ; } } return min ( count_lower , count_upper ) ; }
int FindSmallest ( int arr [ ] , int n ) { int res = 1 ; for ( int i = 0 ; i < n && arr [ i ] <= res ; i ++ ) { res = res + arr [ i ] ; } return res ; }
void PrintMaxOfMin ( int arr [ ] , int n ) { stack < int > s ; int left [ n + 1 ] ; int right [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] = - 1 ; right [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { while ( ! s . empty ( ) && arr [ s . top ( ) ] >= arr [ i ] ) { s . pop ( ) ; } if ( ! s . empty ( ) ) { left [ i ] = s . top ( ) ; } s . push ( i ) ; } while ( ! s . empty ( ) ) { s . pop ( ) ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( ! s . empty ( ) && arr [ s . top ( ) ] >= arr [ i ] ) { s . pop ( ) ; } if ( ! s . empty ( ) ) { right [ i ] = s . top ( ) ; } s . push ( i ) ; } int ans [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { ans [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { int len = right [ i ] - left [ i ] - 1 ; ans [ len ] = max ( ans [ len ] , arr [ i ] ) ; } for ( int i = n - 1 ; i >= 1 ; i -- ) { ans [ i ] = max ( ans [ i ] , ans [ i + 1 ] ) ; } for ( int i = 1 ; i <= n ; i ++ ) { cout << ans [ i ] << " ▁ " ; } }
int Factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * Factorial ( n - 1 ) ; }
int Add ( int x , int y ) { while ( y != 0 ) { int carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; }
void ReverseSpiralPrint ( int m , int n , int a [ kRow ] [ kCol ] ) { long long b [ 100 ] ; int i , k = 0 , l = 0 ; int z = 0 ; int size = m * n ; while ( k < m && l < n ) { int val ; for ( i = l ; i < n ; ++ i ) { val = a [ k ] [ i ] ; b [ z ] = val ; ++ z ; } k ++ ; for ( i = k ; i < m ; ++ i ) { val = a [ i ] [ n - 1 ] ; b [ z ] = val ; ++ z ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { val = a [ m - 1 ] [ i ] ; b [ z ] = val ; ++ z ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { val = a [ i ] [ l ] ; b [ z ] = val ; ++ z ; } l ++ ; } } for ( int x = size - 1 ; x >= 0 ; -- x ) { cout << b [ x ] << " ▁ " ; } }
int MaximumHeight ( int a [ ] , int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { long long y = ( i * ( i + 1 ) ) / 2 ; if ( y < n ) { result = i ; } else { break ; } } return result ; }
bool PairInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { break ; } } int l = ( i + 1 ) % n ; int r = i ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { return true ; } if ( arr [ l ] + arr [ r ] < x ) { l = ( l + 1 ) % n ; } else { r = ( n + r - 1 ) % n ; } } return false ; }
int MaxSubArraySum ( int a [ ] , int size ) { int max_so_far = a [ 0 ] ; int curr_max = a [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { curr_max = max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = max ( max_so_far , curr_max ) ; } return max_so_far ; }
int MinOperation ( int a [ ] , int n , int k ) { int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] != 1 && a [ i ] > k ) { result = result + min ( a [ i ] % k , k - a [ i ] % k ) ; } else { result = result + k - a [ i ] ; } } return result ; }
int MinElements ( int arr [ ] , int n ) { int half_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { half_sum = half_sum + arr [ i ] ; } half_sum = half_sum / 2 ; sort ( arr , arr + n , greater < int > ( ) ) ; int res = 0 , curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > half_sum ) { return res ; } } return res ; }
float AreaOfInscribedCircle ( float a ) { return ( numbers :: pi / 4 ) * a * a ; }
int MaxSubArraySum ( int a [ ] , int size ) { int max_so_far = numeric_limits < int > :: min ( ) ; int max_ending_here = 0 , start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here += a [ i ] ; if ( max_so_far < max_ending_here ) { max_so_far = max_ending_here ; start = s ; end = i ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; s = i + 1 ; } } cout << " Maximum ▁ contiguous ▁ sum ▁ is ▁ " << max_so_far << endl ; cout << " Starting ▁ index ▁ " << start << endl ; cout << " Ending ▁ index ▁ " << end << endl ; }
int SubsetGraph ( int c [ ] [ N ] ) { set < int > vertices ; for ( int i = 0 ; i < N ; ++ i ) { vertices . insert ( i ) ; } while ( ! vertices . empty ( ) ) { if ( vertices . size ( ) == 1 ) { return 1 ; } bool someone_removed = false ; for ( int x : vertices ) { set < int > values ; for ( int y : vertices ) { if ( y != x ) { values . insert ( c [ x ] [ y ] ) ; } } if ( values . size ( ) == 1 ) { vertices . erase ( x ) ; someone_removed = true ; break ; } } if ( ! someone_removed ) { break ; } } return vertices . size ( ) ; }
int MaxXor ( int mat [ ] [ kMax ] , int n ) { int max_xor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int r_xor = 0 , c_xor = 0 ; for ( int j = 0 ; j < n ; j ++ ) { r_xor = r_xor ^ mat [ i ] [ j ] ; c_xor = c_xor ^ mat [ j ] [ i ] ; } if ( max_xor < max ( r_xor , c_xor ) ) { max_xor = max ( r_xor , c_xor ) ; } } return max_xor ; }
int CountSubsequences ( const string & s ) { int a_count = 0 , b_count = 0 , c_count = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == ' a ' ) { a_count = 1 + 2 * a_count ; } else if ( s [ i ] == ' b ' ) { b_count = a_count + 2 * b_count ; } else if ( s [ i ] == ' c ' ) { c_count = b_count + 2 * c_count ; } } return c_count ; }
int MaximumChars ( const string & str ) { int n = str . length ( ) ; int res = - 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( str [ i ] == str [ j ] ) { res = max ( res , abs ( j - i - 1 ) ) ; } } } return res ; }
void PrintRoots ( int n ) { double theta = numbers :: pi * 2 / n ; for ( int k = 0 ; k < n ; k ++ ) { double real = cos ( k * theta ) ; double img = sin ( k * theta ) ; cout << real << endl ; if ( img >= 0 ) { cout << " ▁ + ▁ i ▁ " << endl ; } else { cout << " ▁ - ▁ i ▁ " << endl ; } cout << abs ( img ) << endl ; } }
int SieveOfAtkin ( int limit ) { if ( limit > 2 ) { cout << 2 << " ▁ " ; } if ( limit > 3 ) { cout << 3 << " ▁ " ; } bool sieve [ limit ] ; memset ( sieve , false , sizeof ( sieve ) ) for ( int x = 1 ; x * x < limit ; x ++ ) { for ( int y = 1 ; y * y < limit ; y ++ ) { int n = ( 4 * x * x ) + ( y * y ) ; if ( n <= limit && ( n % 12 == 1 || n % 12 == 5 ) ) { sieve [ n ] ^= true ; } n = ( 3 * x * x ) + ( y * y ) ; if ( n <= limit && n % 12 == 7 ) { sieve [ n ] ^= true ; } n = ( 3 * x * x ) - ( y * y ) ; if ( x > y && n <= limit && n % 12 == 11 ) { sieve [ n ] ^= true ; } } } for ( int r = 5 ; r * r < limit ; r ++ ) { if ( sieve [ r ] ) { for ( int i = r * r ; i < limit ; i += r * r ) { sieve [ i ] = false ; } } } for ( int a = 5 ; a < limit ; a ++ ) { if ( sieve [ a ] ) { cout << a << " ▁ " ; } } }
int SmallestKFreq ( int a [ ] , int n , int k ) { unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { m [ a [ i ] ] ++ ; } int res = numeric_limits < int > :: max ( ) ; for ( auto & it : m ) { if ( it . second == k ) { res = min ( res , it . first ) ; } } return ( res != numeric_limits < int > :: max ( ) ) ? res : - 1 ; }
int MinimumFlip ( int mat [ ] [ N ] , int n ) { int transpose [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { transpose [ i ] [ j ] = mat [ j ] [ i ] ; } } int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( transpose [ i ] [ j ] != mat [ i ] [ j ] ) { flip ++ ; } } } return flip / 2 ; }
void MinAbsSumPair ( int arr [ ] , int arr_size ) { int inv_count = 0 ; if ( arr_size < 2 ) { cout << " Invalid ▁ Input " ; return ; } int min_l = 0 ; int min_r = 1 ; int min_sum = arr [ 0 ] + arr [ 1 ] ; for ( int l = 0 ; l < arr_size - 1 ; l ++ ) { for ( int r = l + 1 ; r < arr_size ; r ++ ) { int sum = arr [ l ] + arr [ r ] ; if ( abs ( min_sum ) > abs ( sum ) ) { min_sum = sum ; min_l = l ; min_r = r ; } } } cout << " The ▁ two ▁ elements ▁ whose ▁ sum ▁ is ▁ minimum ▁ are ▁ " << arr [ min_l ] << " ▁ and ▁ " << arr [ min_r ] ; }
void MaxProduct ( int arr [ ] , int n ) { if ( n < 2 ) { cout << " No ▁ pairs ▁ exists " << endl ; return ; } int a = arr [ 0 ] , b = arr [ 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] * arr [ j ] > a * b ) { a = arr [ i ] ; b = arr [ j ] ; } } } cout << " Max ▁ product ▁ pair ▁ is ▁ { " << a << " , ▁ " << b << " } " ; }
int PageFaults ( int pages [ ] , int n , int capacity ) { unordered_set < int > s ; queue < int > indexes ; int page_faults = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . size ( ) < capacity ) { if ( s . find ( pages [ i ] ) == s . end ( ) ) { s . insert ( pages [ i ] ) ; page_faults ++ ; indexes . push ( pages [ i ] ) ; } } else { if ( s . find ( pages [ i ] ) == s . end ( ) ) { int val = indexes . front ( ) ; indexes . pop ( ) ; s . erase ( val ) ; s . insert ( pages [ i ] ) ; indexes . push ( pages [ i ] ) ; page_faults ++ ; } } } return page_faults ; }
int NextFit ( int weight [ ] , int n , int c ) { int res = 0 , bin_rem = c ; for ( int i = 0 ; i < n ; i ++ ) { if ( weight [ i ] > bin_rem ) { res ++ ; bin_rem = c - weight [ i ] ; } else { bin_rem -= weight [ i ] ; } } return res ; }
int CountPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { l ++ ; r -- ; count ++ ; } else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) { l ++ ; } else { r -- ; } } return count ; }
float CircumferenceParallelogram ( float a , float b ) { return ( 2 * a ) + ( 2 * b ) ; }
void Print ( int n , int k ) { int rem = 1 ; for ( int i = 0 ; i < k ; i ++ ) { cout << ( 10 * rem ) / n ; rem = ( 10 * rem ) % n ; } }
string FindString ( int n , int k ) { string res ; for ( int i = 0 ; i < k ; i ++ ) { res = res + ( char ) ( ' a ' + i ) ; } int count = 0 ; for ( int i = 0 ; i < n - k ; i ++ ) { res = res + ( char ) ( ' a ' + count ) ; count ++ ; if ( count == k ) { count = 0 ; } } return res ; }
bool CheckForSorting ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) { swap ( arr [ i ] , arr [ i + 1 ] ) ; } else { return false ; } } } return true ; }
int Round ( int n ) { int a = ( n / 10 ) * 10 ; int b = a + 10 ; return ( n - a > b - n ) ? b : a ; }
int GetRemainder ( int num , int divisor ) { if ( divisor == 0 ) { cout << " Error : ▁ divisor ▁ can ' t ▁ be ▁ zero ▁ " << endl ; return - 1 ; } if ( divisor < 0 ) { divisor = - divisor ; } if ( num < 0 ) { num = - num ; } int i = 1 ; int product = 0 ; while ( product <= num ) { product = divisor * i ; i ++ ; } return num - ( product - divisor ) ; }
int UnitDigitXRaisedY ( int x , int y ) { int res = 1 ; for ( int i = 0 ; i < y ; i ++ ) { res = ( res * x ) % 10 ; } return res ; }
int CostToBalance ( const string & s ) { if ( s . length ( ) == 0 ) { cout << 0 << endl ; } int ans = 0 ; int o = 0 , c = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' ( ' ) { o ++ ; } if ( s [ i ] == ' ) ' ) { c ++ ; } } if ( o != c ) { return - 1 ; } int a [ s . size ( ) ] ; if ( s [ 0 ] == ' ( ' ) { a [ 0 ] = 1 ; } else { a [ 0 ] = - 1 ; } if ( a [ 0 ] < 0 ) { ans += abs ( a [ 0 ] ) ; } for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' ( ' ) { a [ i ] = a [ i - 1 ] + 1 ; } else { a [ i ] = a [ i - 1 ] - 1 ; } if ( a [ i ] < 0 ) { ans += abs ( a [ i ] ) ; } } return ans ; }
int MaxSubArraySum ( int a [ ] , int size ) { int max_so_far = numeric_limits < int > :: min ( ) , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) { max_so_far = max_ending_here ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; } } return max_so_far ; }
int CountSub ( int arr [ ] , int n ) { int count [ 10 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - 1 ; j >= 0 ; j -- ) { count [ arr [ i ] ] += count [ j ] ; } count [ arr [ i ] ] ++ ; } int result = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { result += count [ i ] ; } return result ; }
int CountMinReversals ( const string & expr ) { int len = expr . length ( ) ; if ( len % 2 ) { return - 1 ; } stack < char > s ; for ( int i = 0 ; i < len ; i ++ ) { if ( expr [ i ] == ' } ' && ! s . empty ( ) ) { if ( s . top ( ) == ' { ' ) { s . pop ( ) ; } else { s . push ( expr [ i ] ) ; } } else { s . push ( expr [ i ] ) ; } } int red_len = s . size ( ) ; int n = 0 ; while ( ! s . empty ( ) && s . top ( ) == ' { ' ) { s . pop ( ) ; n ++ ; } return red_len / 2 + n % 2 ; }
bool PrintPairs ( int arr [ ] , int n , int k ) { bool is_pair_found = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && arr [ i ] % arr [ j ] == k ) { cout << " ( " << arr [ i ] << " , ▁ " << arr [ j ] << " ) " << " ▁ " ; is_pair_found = true ; } } } return is_pair_found ; }
int FindRepeatFirst ( const string & s ) { int p = - 1 , i , k ; int hash [ kMaxChar ] ; memset ( hash , 0 , sizeof ( hash ) ) ; int pos [ kMaxChar ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int k = s [ i ] ; if ( hash [ k ] == 0 ) { hash [ k ] ++ ; pos [ k ] = i ; } else if ( hash [ k ] == 1 ) { hash [ k ] ++ ; } } for ( int i = 0 ; i < kMaxChar ; i ++ ) { if ( hash [ i ] == 2 ) { if ( p == - 1 ) { p = pos [ i ] ; } else if ( p > pos [ i ] ) { p = pos [ i ] ; } } } return p ; }
int CountSetBitsRec ( int num ) { int nibble = 0 ; if ( 0 == num ) { return num_to_bits [ 0 ] ; } nibble = num & 0xf ; return num_to_bits [ nibble ] + CountSetBitsRec ( num >> 4 ) ; }
int GetSum ( int n ) { int sum ; for ( sum = 0 ; n > 0 ; sum += n % 10 , n /= 10 ) { } return sum ; }
int CountPaths ( int n , int m ) { int dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = 1 ; } for ( int i = 0 ; i <= m ; i ++ ) { dp [ 0 ] [ i ] = 1 ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; } } return dp [ n ] [ m ] ; }
int Factorial ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { res *= i ; } return res ; }
void PrintDiagonalSums ( int mat [ ] [ kMax ] , int n ) { int principal = 0 , secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) { principal += mat [ i ] [ j ] ; } if ( i + j == n - 1 ) { secondary += mat [ i ] [ j ] ; } } } cout << " Principal ▁ Diagonal : " << principal << endl ; cout << " Secondary ▁ Diagonal : " << secondary << endl ; }
int CountIntegralSolutions ( int n ) { return ( n + 1 ) * ( n + 2 ) / 2 ; }
int FindPlatform ( int arr [ ] , int dep [ ] , int n ) { sort ( arr , arr + n ) ; sort ( dep , dep + n ) ; int plat_needed = 1 , result = 1 ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arr [ i ] <= dep [ j ] ) { plat_needed ++ ; i ++ ; if ( plat_needed > result ) { result = plat_needed ; } } else { plat_needed -- ; j ++ ; } } return result ; }
bool ModularSum ( int arr [ ] , int n , int m ) { if ( n > m ) { return true ; } bool dp [ m ] ; memset ( dp , false , m ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ 0 ] ) { return true ; } bool temp [ m ] ; memset ( temp , false , m ) ; for ( int j = 0 ; j < m ; j ++ ) { if ( dp [ j ] == true ) { if ( dp [ ( j + arr [ i ] ) % m ] == false ) { temp [ ( j + arr [ i ] ) % m ] = true ; } } } for ( int j = 0 ; j < m ; j ++ ) { if ( temp [ j ] ) { dp [ j ] = true ; } } dp [ arr [ i ] % m ] = true ; } return dp [ 0 ] ; }
int SumOfLargePrimeFactor ( int n ) { int prime [ n + 1 ] ; memset ( prime , 0 , sizeof ( prime ) ) ; int sum = 0 ; int max = n / 2 ; for ( int p = 2 ; p <= max ; p ++ ) { if ( prime [ p ] == 0 ) { for ( int i = p * 2 ; i <= n ; i += p ) { prime [ i ] = p ; } } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { sum += prime [ p ] ; } else { sum += p ; } } return sum ; }
int MinJumps ( int a , int b , int d ) { int temp = a ; a = min ( a , b ) ; b = max ( temp , b ) ; if ( d >= b ) { return ( d + b - 1 ) / b ; } if ( d == 0 ) { return 0 ; } if ( d == a ) { return 1 ; } return 2 ; }
int CountSetBits ( int n ) { int count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; }
void PermutatedRows ( int mat [ ] [ kMax ] , int m , int n , int r ) { unordered_set < int > s ; for ( int j = 0 ; j < n ; j ++ ) { s . insert ( mat [ r ] [ j ] ) ; } for ( int i = 0 ; i < m ; i ++ ) { if ( i == r ) { continue ; } int j ; for ( j = 0 ; j < n ; j ++ ) { if ( s . find ( mat [ i ] [ j ] ) == s . end ( ) ) { break ; } } if ( j != n ) { continue ; } cout << i << " , ▁ " ; } }
void PrintSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = i * ( i + 1 ) * ( i + 2 ) / 6 ; cout << num << " ▁ " ; } }
void ZigZag ( int rows , int columns , int numbers [ ] ) { int k = 0 ; int arr [ rows ] [ columns ] ; for ( int i = 0 ; i < rows ; i ++ ) { if ( i % 2 == 0 ) { for ( int j = 0 ; j < columns and numbers [ k ] > 0 ; j ++ ) { arr [ i ] [ j ] = k + 1 ; numbers [ k ] -- ; if ( numbers [ k ] == 0 ) { k ++ ; } } } else { for ( int j = columns - 1 ; j >= 0 and numbers [ k ] > 0 ; j -- ) { arr [ i ] [ j ] = k + 1 ; numbers [ k ] -- ; if ( numbers [ k ] == 0 ) { k ++ ; } } } } for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < columns ; j ++ ) { cout << arr [ i ] [ j ] << " ▁ " ; } cout << endl ; } }
int FindElement ( int arr [ ] , int ranges [ ] [ 2 ] , int rotations , int index ) { for ( int i = rotations - 1 ; i >= 0 ; i -- ) { int left = ranges [ i ] [ 0 ] ; int right = ranges [ i ] [ 1 ] ; if ( left <= index && right >= index ) { if ( index == left ) { index = right ; } else { index -- ; } } } return arr [ index ] ; }
string SmallestNumber ( const string & str ) { string num ( str ) ; int n = str . length ( ) ; int right_min [ n ] , right ; right_min [ n - 1 ] = - 1 ; right = n - 1 ; for ( int i = n - 2 ; i >= 1 ; i -- ) { if ( num [ i ] >= num [ right ] ) { right_min [ i ] = right ; } else { if ( num [ i ] == num [ i + 1 ] ) { right_min [ i ] = right ; } else { right_min [ i ] = - 1 ; right = i ; } } } int small = - 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( num [ i ] != ' 0 ' ) { if ( small == - 1 ) { if ( num [ i ] < num [ 0 ] ) { small = i ; } } else if ( num [ i ] <= num [ small ] ) { small = i ; } } } if ( small != - 1 ) { swap ( num [ 0 ] , num [ small ] ) ; } else { for ( int i = 1 ; i < n ; i ++ ) { if ( right_min [ i ] != - 1 && num [ i ] != num [ right_min [ i ] ] ) { swap ( num [ i ] , num [ right_min [ i ] ] ) ; break ; } } } return num ; }
int CountPaths ( int maze [ ] [ kCol ] ) { if ( maze [ 0 ] [ 0 ] == - 1 ) { return 0 ; } for ( int i = 0 ; i < kRow ; i ++ ) { if ( maze [ i ] [ 0 ] == 0 ) { maze [ i ] [ 0 ] = 1 ; } else { break ; } } for ( int i = 1 ; i < kCol ; i ++ ) { if ( maze [ 0 ] [ i ] == 0 ) { maze [ 0 ] [ i ] = 1 ; } else { break ; } } for ( int i = 1 ; i < kRow ; i ++ ) { for ( int j = 1 ; j < kCol ; j ++ ) { if ( maze [ i ] [ j ] == - 1 ) { continue ; } if ( maze [ i - 1 ] [ j ] > 0 ) { maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) ; } if ( maze [ i ] [ j - 1 ] > 0 ) { maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) ; } } } return max ( maze [ kRow - 1 ] [ kCol - 1 ] , 0 ) ; }
void MinMaxLengthWords ( const string & input , string & min_word , string & max_word ) { int len = input . length ( ) ; int si = 0 , ei = 0 ; int min_length = len , min_start_index = 0 , max_length = 0 , max_start_index = 0 ; while ( ei <= len ) { if ( ei < len && input [ ei ] != ' ▁ ' ) { ei ++ ; } else { int curr_length = ei - si ; if ( curr_length < min_length ) { min_length = curr_length ; min_start_index = si ; } if ( curr_length > max_length ) { max_length = curr_length ; max_start_index = si ; } ei ++ ; si = ei ; } } min_word = input . substr ( min_start_index , min_length ) ; max_word = input . substr ( max_start_index , max_length ) ; }
float FindVolume ( float l , float b , float h ) { float volume = ( l * b * h ) / 2 ; return volume ; }
string SortString ( const string & str , int n ) { string new_str ; for ( int i = ' a ' ; i <= ' z ' ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( str [ j ] == i ) { new_str += str [ j ] ; } } } return new_str ; }
int CountTrees ( int n ) { int bt [ n + 1 ] ; memset ( bt , 0 , sizeof ( bt ) ) ; bt [ 0 ] = bt [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) { for ( int j = 0 ; j < i ; j ++ ) { bt [ i ] += bt [ j ] * bt [ i - j - 1 ] ; } } return bt [ n ] ; }
int GetPairsCount ( int arr [ ] , int n , int sum ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] + arr [ j ] == sum ) { count ++ ; } } } return count ; }
bool Check ( const string & str ) { int n = str . length ( ) ; int digit_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { digit_sum += ( str [ i ] - ' 0 ' ) ; } return digit_sum % 3 == 0 ; }
int LcSubStr ( const string & x , const string & y ) { int m = x . length ( ) ; int n = y . length ( ) ; int result = 0 ; int len [ 2 ] [ n ] ; int curr_row = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 || j == 0 ) { len [ curr_row ] [ j ] = 0 ; } else if ( x [ i - 1 ] == y [ j - 1 ] ) { len [ curr_row ] [ j ] = len [ 1 - curr_row ] [ j - 1 ] + 1 ; result = max ( result , len [ curr_row ] [ j ] ) ; } else { len [ curr_row ] [ j ] = 0 ; } } curr_row = 1 - curr_row ; } return result ; }
int RemoveConsecutiveSame ( vector < string > v ) { int n = v . size ( ) ; for ( int i = 0 ; i < n - 1 ; ) { if ( v [ i ] . compare ( v [ i + 1 ] ) == 0 ) { v . erase ( v . begin ( ) + i ) ; v . erase ( v . begin ( ) + i ) ; if ( i > 0 ) { i -- ; } n = n - 2 ; } else { i ++ ; } } return v . size ( ) ; }
int Perimeter ( int diameter , int height ) { return 2 * ( diameter + height ) ; }
bool IsPossibleToMakeDivisible ( int arr [ ] , int n ) { int remainder = 0 ; for ( int i = 0 ; i < n ; i ++ ) { remainder = ( remainder + arr [ i ] ) % 3 ; } return remainder == 0 ; }
int GetInvCount ( int arr [ ] , int n ) { int inv_count = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ j ] > arr [ k ] ) { inv_count ++ ; } } } } } return inv_count ; }
void Bin ( int n ) { if ( n > 1 ) { Bin ( n / 2 ) ; } cout << n % 2 ; }
int MinSum ( int ar [ ] , int n ) { if ( n <= 4 ) { return * min_element ( ar , ar + n ) ; } int sum [ n ] ; sum [ 0 ] = ar [ 0 ] ; sum [ 1 ] = ar [ 1 ] ; sum [ 2 ] = ar [ 2 ] ; sum [ 3 ] = ar [ 3 ] ; for ( int i = 4 ; i < n ; i ++ ) { sum [ i ] = ar [ i ] + ( * min_element ( sum + i - 4 , sum + i ) ) ; } return * min_element ( sum + n - 4 , sum + n ) ; }
bool FindTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < n2 ; j ++ ) { for ( int k = 0 ; k < n3 ; k ++ ) { if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) { return true ; } } } } return false ; }
int MinDist ( int arr [ ] , int n , int x , int y ) { int i = 0 ; int min_dist = numeric_limits < int > :: max ( ) ; int prev ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x || arr [ i ] == y ) { prev = i ; break ; } } for ( ; i < n ; i ++ ) { if ( arr [ i ] == x || arr [ i ] == y ) { if ( arr [ prev ] != arr [ i ] && ( i - prev ) < min_dist ) { min_dist = i - prev ; prev = i ; } else { prev = i ; } } } return min_dist ; }
int Solve ( int a [ ] , int b [ ] , int n ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s += ( a [ i ] + b [ i ] ) ; } if ( n == 1 ) { return a [ 0 ] + b [ 0 ] ; } if ( s % n != 0 ) { return - 1 ; } int x = s / n ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) { return - 1 ; } if ( i > 0 ) { a [ i ] += b [ i - 1 ] ; b [ i - 1 ] = 0 ; } if ( a [ i ] == x ) { continue ; } int y = a [ i ] + b [ i ] ; if ( i + 1 < n ) { y += b [ i + 1 ] ; } if ( y == x ) { a [ i ] = y ; b [ i ] = b [ i + 1 ] = 0 ; continue ; } if ( a [ i ] + b [ i ] == x ) { a [ i ] += b [ i ] ; b [ i ] = 0 ; continue ; } if ( i + 1 < n && a [ i ] + b [ i + 1 ] == x ) { a [ i ] += b [ i + 1 ] ; b [ i + 1 ] = 0 ; continue ; } return - 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( b [ i ] != 0 ) { return - 1 ; } } return x ; }
void FindString ( const string & str , int n , int k ) { if ( k == 0 ) { cout << str << endl ; return ; } string str2 = str ; int p = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str2 [ i ] != ' a ' ) { str2 [ i ] = ' a ' ; p ++ ; if ( p == k ) { break ; } } } if ( p < k ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == ' a ' ) { str2 [ i ] = ' b ' ; p ++ ; if ( p == k ) { break ; } } } } cout << str2 << endl ; }
int FindLongestRepeatingSubSeq ( const string & x , int m , int n ) { if ( dp [ m ] [ n ] != - 1 ) { return dp [ m ] [ n ] ; } if ( m == 0 || n == 0 ) { return dp [ m ] [ n ] = 0 ; } if ( x [ m - 1 ] == x [ n - 1 ] && m != n ) { return dp [ m ] [ n ] = FindLongestRepeatingSubSeq ( x , m - 1 , n - 1 ) + 1 ; } dp [ m ] [ n ] = = max ( FindLongestRepeatingSubSeq ( x , m , n - 1 ) , FindLongestRepeatingSubSeq ( x , m - 1 , n ) ) ; return dp [ m ] [ n ] ; }
int ProductSubSeqCount ( const vector < int > & arr , int k ) { int n = arr . size ( ) ; int dp [ k + 1 ] [ n + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; if ( arr [ j - 1 ] <= i && arr [ j - 1 ] > 0 ) { dp [ i ] [ j ] += dp [ i / arr [ j - 1 ] ] [ j - 1 ] + 1 ; } } } return dp [ k ] [ n ] ; }
int Pow ( int a , int b ) { if ( b == 0 ) { return 1 ; } int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; }
int Fix ( int a [ ] , int len ) { for ( int i = 0 ; i < len ; i ++ ) { if ( a [ i ] != - 1 && a [ i ] != i ) { int x = a [ i ] ; while ( a [ x ] != - 1 && a [ x ] != x ) { int y = a [ x ] ; a [ x ] = x ; x = y ; } a [ x ] = x ; if ( a [ i ] != i ) { a [ i ] = - 1 ; } } } }
long long Calculate ( long long a [ ] , long long n ) { sort ( a , a + n ) ; vector < long long > s ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { s . push_back ( a [ i ] + a [ j ] ) ; } long long min_i = * min_element ( s . begin ( ) , s . end ( ) ) ; long long max_i = * max_element ( s . begin ( ) , s . end ( ) ) ; return abs ( max_i - min_i ) ; }
float SumOfSeries ( int n ) { return 0.0246 * ( pow ( 10 , n ) - 1 - ( 9 * n ) ) ; }
int Calculate ( const string & s ) { int ans = 6 ; for ( int i = 0 ; i < 10 ; ++ i ) { for ( int j = 0 ; j < 10 ; ++ j ) { for ( int k = 0 ; k < 10 ; ++ k ) { for ( int l = 0 ; l < 10 ; ++ l ) { for ( int m = 0 ; m < 10 ; ++ m ) { for ( int n = 0 ; n < 10 ; ++ n ) { if ( i + j + k == l + m + n ) { int c = 0 ; if ( i != s [ 0 ] - ' 0 ' ) { c ++ ; } if ( j != s [ 1 ] - ' 0 ' ) { c ++ ; } if ( k != s [ 2 ] - ' 0 ' ) { c ++ ; } if ( l != s [ 3 ] - ' 0 ' ) { c ++ ; } if ( m != s [ 4 ] - ' 0 ' ) { c ++ ; } if ( n != s [ 5 ] - ' 0 ' ) { c ++ ; } if ( c < ans ) { ans = c ; } } } } } } } } return ans ; }
int GetTotalNumberOfSequences ( int m , int n ) { if ( m < n ) { return 0 ; } if ( n == 0 ) { return 1 ; } return GetTotalNumberOfSequences ( m - 1 , n ) + GetTotalNumberOfSequences ( m / 2 , n - 1 ) ; }
void SortInWave ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i += 2 ) { swap ( arr [ i ] , arr [ i + 1 ] ) ; } }
void Search ( int arr [ ] , int low , int high ) { if ( low > high ) { return ; } if ( low == high ) { cout << format ( " The ▁ required ▁ element ▁ is ▁ { } ▁ " , arr [ low ] ) ; return ; } int mid = ( low + high ) / 2 ; if ( mid % 2 == 0 ) { if ( arr [ mid ] == arr [ mid + 1 ] ) { Search ( arr , mid + 2 , high ) ; } else { Search ( arr , low , mid ) ; } } else { if ( arr [ mid ] == arr [ mid - 1 ] ) { Search ( arr , mid + 1 , high ) ; } else { Search ( arr , low , mid - 1 ) ; } } }
bool Check ( const string & str ) { int n = str . length ( ) ; if ( ( str [ n - 1 ] - ' 0 ' ) % 2 != 0 ) { return false ; } int digit_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { digit_sum += ( str [ i ] - ' 0 ' ) ; } return digit_sum % 3 == 0 ; }
int StirlingFactorial ( int n ) { if ( n == 1 ) { return 1 ; } double e = 2.71 ; double z = sqrt ( 2 * 3.14 * n ) * pow ( ( n / e ) , n ) ; return ( int ) z ; }
bool CheckCount ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] == arr [ i ] ) { count ++ ; } if ( count > 2 * k ) { return false ; } } } return true ; }
bool AreElementsContiguous ( int arr [ ] , int n ) { int max = * max_element ( arr , arr + n ) ; int min = * min_element ( arr , arr + n ) ; int m = max - min + 1 ; if ( m > n ) { return false ; } bool visited [ m ] ; memset ( visited , false , sizeof ( visited ) ) ; for ( int i = 0 ; i < n ; i ++ ) { visited [ arr [ i ] - min ] = true ; } for ( int i = 0 ; i < m ; i ++ ) { if ( visited [ i ] == false ) { return false ; } } return true ; }
int Zigzag ( int n , int k ) { if ( n == 0 && k == 0 ) { return 1 ; } if ( k == 0 ) { return 0 ; } return Zigzag ( n , k - 1 ) + Zigzag ( n - 1 , n - k ) ; }
int Lcs ( const string & x , const string & y ) { int m = x . length ( ) , n = y . length ( ) ; int l [ 2 ] [ n + 1 ] ; int bi = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { bi = i & 1 ; for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 || j == 0 ) { l [ bi ] [ j ] = 0 ; } else if ( x [ i - 1 ] == y [ j - 1 ] ) { l [ bi ] [ j ] = l [ 1 - bi ] [ j - 1 ] + 1 ; } else { l [ bi ] [ j ] = max ( l [ 1 - bi ] [ j ] , l [ bi ] [ j - 1 ] ) ; } } } return l [ bi ] [ n ] ; }
void PrintFirstNegativeInteger ( int arr [ ] , int n , int k ) { deque < int > di ; int i ; for ( i = 0 ; i < k ; i ++ ) { if ( arr [ i ] < 0 ) { di . push_back ( i ) ; } } for ( ; i < n ; i ++ ) { if ( ! di . empty ( ) ) { cout << arr [ di . front ( ) ] << " ▁ " ; } else { cout << " 0 " << " ▁ " ; } while ( ! di . empty ( ) && di . front ( ) < ( i - k + 1 ) ) { di . pop_front ( ) ; } if ( arr [ i ] < 0 ) { di . push_back ( i ) ; } } if ( ! di . empty ( ) ) { cout << arr [ di . front ( ) ] << " ▁ " ; } else { cout << " 0 " << " ▁ " ; } }
int FindRoot ( pair < int , int > arr [ ] , int n ) { int root = 0 ; for ( int i = 0 ; i < n ; i ++ ) { root += ( arr [ i ] . first - arr [ i ] . second ) ; } return root ; }
int FindArea ( int arr [ ] , int n ) { set < int > s ; int first = 0 , second = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . find ( arr [ i ] ) == s . end ( ) ) { s . insert ( arr [ i ] ) ; continue ; } if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) { second = arr [ i ] ; } } return first * second ; }
void Rearrange ( int arr [ ] , int n ) { int max_ele = arr [ n - 1 ] ; int min_ele = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] = max_ele ; max_ele -= 1 ; } else { arr [ i ] = min_ele ; min_ele += 1 ; } } }
int FindMaxProduct ( int arr [ ] [ n ] , int n ) { int max = 0 , result ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ; if ( max < result ) { max = result ; } } if ( ( i - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ; if ( max < result ) { max = result ; } } if ( ( i - 3 ) >= 0 && ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ; if ( max < result ) { max = result ; } } } } return max ; }
bool IsTriangular ( int num ) { if ( num < 0 ) { return false ; } int c = - 2 * num ; int b = 1 , a = 1 ; int d = b * b - 4 * a * c ; if ( d < 0 ) { return false ; } float root1 = ( float ) ( - b + sqrt ( d ) ) / ( 2 * a ) ; float root2 = ( float ) ( - b - sqrt ( d ) ) / ( 2 * a ) ; if ( root1 > 0 && floor ( root1 ) == root1 ) { return true ; } if ( root2 > 0 && floor ( root2 ) == root2 ) { return true ; } return false ; }
int CountLattice ( int r ) { if ( r <= 0 ) { return 0 ; } int result = 4 ; for ( int x = 1 ; x < r ; x ++ ) { int y_square = r * r - x * x ; int y = sqrt ( y_square ) ; if ( y * y == y_square ) { result += 4 ; } } return result ; }
int MaxOnesIndex ( bool arr [ ] , int n ) { int max_count = 0 ; int max_index ; int prev_zero = - 1 ; int prev_prev_zero = - 1 ; for ( int curr = 0 ; curr < n ; ++ curr ) { if ( arr [ curr ] == false ) { if ( curr - prev_prev_zero > max_count ) { max_count = curr - prev_prev_zero ; max_index = prev_zero ; } prev_prev_zero = prev_zero ; prev_zero = curr ; } } if ( n - prev_prev_zero > max_count ) { max_index = prev_zero ; } return max_index ; }
void LeafNode ( int pre_order [ ] , int n ) { stack < int > s ; for ( int i = 0 , j = 1 ; j < n ; i ++ , j ++ ) { bool found = false ; if ( pre_order [ i ] > pre_order [ j ] ) { s . push ( pre_order [ i ] ) ; } else { while ( ! s . empty ( ) ) { if ( pre_order [ j ] > s . top ( ) ) { s . pop ( ) ; found = true ; } else { break ; } } } if ( found ) { cout << pre_order [ i ] << " ▁ " ; } } cout << pre_order [ n - 1 ] ; }
bool IsSubset ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 ; int j = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) { if ( arr2 [ i ] == arr1 [ j ] ) { break ; } } if ( j == m ) { return 0 ; } } return true ; }
int MultiplyBySeven ( int n ) { return ( n << 3 ) - n ; }
int UnboundedKnapsack ( int w , int n , int val [ ] , int wt [ ] ) { int dp [ w + 1 ] ; memset ( dp , 0 , sizeof dp ) ; for ( int i = 0 ; i <= w ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( wt [ j ] <= i ) { dp [ i ] = max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] ) ; } } } return dp [ w ] ; }
void AlternateSubarray ( bool arr [ ] , int n ) { int count = 1 ; bool prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) { if ( ! ( arr [ i ] ^ prev ) ) { while ( count ) { cout << count -- << " ▁ " ; } } ++ count ; prev = arr [ i ] ; } while ( count ) { cout << count -- << " ▁ " ; } }
int CountKDist ( const string & str , int k ) { int n = str . length ( ) ; int res = 0 ; int cnt [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int dist_count = 0 ; memset ( cnt , 0 , sizeof ( cnt ) ) ; for ( int j = i ; j < n ; j ++ ) { if ( cnt [ str [ j ] - ' a ' ] == 0 ) { dist_count ++ ; } cnt [ str [ j ] - ' a ' ] ++ ; if ( dist_count == k ) { res ++ ; } if ( dist_count > k ) { break ; } } } return res ; }
void ModularInverse ( int n , int prime ) { int dp [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] = dp [ prime % i ] * ( prime - prime / i ) % prime ; } for ( int i = 1 ; i <= n ; i ++ ) { cout << dp [ i ] << ' ▁ ' ; } }
int CountWays ( int n ) { int dp [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = dp [ 2 ] = 1 ; dp [ 3 ] = 2 ; for ( int i = 4 ; i <= n ; i ++ ) { dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + dp [ i - 4 ] ; } return dp [ n ] ; }
int Count ( int n ) { if ( n < 3 ) { return n ; } if ( n >= 3 && n < 10 ) { return n - 1 ; } int po = 1 ; while ( n / po > 9 ) { po = po * 10 ; } int msd = n / po ; if ( msd != 3 ) { return Count ( msd ) * Count ( po - 1 ) + Count ( msd ) + Count ( n % po ) ; } else { return Count ( msd * po - 1 ) ; } }
int CountPattern ( const string & str ) { int len = str . length ( ) ; bool one_seen = false ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == ' 1 ' && one_seen == true ) { if ( str [ i - 1 ] == ' 0 ' ) { count ++ ; } } if ( str [ i ] == ' 1 ' && one_seen == false ) { one_seen = true ; } if ( str [ i ] != ' 0 ' && str [ i ] != ' 1 ' ) { one_seen = false ; } } return count ; }
int MaxRemoval ( int arr [ ] , int n ) { int count = 0 ; int cumulative_sum = 0 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= cumulative_sum ) { count ++ ; cumulative_sum += arr [ i ] ; } } return count ; }
string LexicographicalMaxString ( const string & str ) { string mx ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { if ( mx . compare ( str . substr ( i ) ) <= 0 ) { mx = str . substr ( i ) ; } } return mx ;
