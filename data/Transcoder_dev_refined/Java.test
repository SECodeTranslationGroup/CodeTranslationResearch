float power ( float x , int y ) { if ( y == 0 ) { return 1 ; } float temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) { return temp * temp ; } else { if ( y > 0 ) { return x * temp * temp ; } else { return ( temp * temp ) / x ; } } }
void printDistSum ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } boolean [ ] [ ] dp = new boolean [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = true ; } for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i - 1 ] ] = true ; for ( int j = 1 ; j <= sum ; j ++ ) { if ( dp [ i - 1 ] [ j ] == true ) { dp [ i ] [ j ] = true ; dp [ i ] [ j + arr [ i - 1 ] ] = true ; } } } for ( int j = 0 ; j <= sum ; j ++ ) { if ( dp [ n ] [ j ] == true ) { System . out . print ( j + " ▁ " ) ; } } }
int countWays ( int n ) { if ( n == 1 ) { return 4 ; } int countB = 1 , countS = 1 , prevCountB , prevCountS ; for ( int i = 2 ; i <= n ; i ++ ) { prevCountB = countB ; prevCountS = countS ; countS = prevCountB + prevCountS ; countB = prevCountS ; } int result = countS + countB ; return result * result ; }
void scalarProductMat ( int [ ] [ ] mat , int k ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { mat [ i ] [ j ] = mat [ i ] [ j ] * k ; } } }
int maxSum ( int [ ] arr , int n ) { int arrSum = 0 ; int currVal = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { arrSum = arrSum + arr [ i ] ; currVal = currVal + ( i * arr [ i ] ) ; } int maxVal = currVal ; for ( int j = 1 ; j < arr . length ; j ++ ) { currVal = currVal + arrSum - arr . length * arr [ arr . length - j ] ; if ( currVal > maxVal ) { maxVal = currVal ; } } return maxVal ; }
int lowerInsertionPoint ( int [ ] arr , int n , int x ) { if ( x < arr [ 0 ] ) { return 0 ; } else if ( x > arr [ n - 1 ] ) { return n ; } int lowerPnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < x ) { lowerPnt = i ; i = i * 2 ; } while ( lowerPnt < n && arr [ lowerPnt ] < x ) { lowerPnt ++ ; } return lowerPnt ; }
int findMinDiff ( int [ ] arr , int n , int m ) { if ( m == 0 || n == 0 ) { return 0 ; } Arrays . sort ( arr ) ; if ( n < m ) { return - 1 ; } int minDiff = Integer . MAX_VALUE ; int first = 0 , last = 0 ; for ( int i = 0 ; i + m - 1 < n ; i ++ ) { int diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < minDiff ) { minDiff = diff ; first = i ; last = i + m - 1 ; } } return arr [ last ] - arr [ first ] ; }
int minRemove ( int [ ] a , int [ ] b , int n , int m ) { HashMap < Integer , Integer > countA = new HashMap <> ( ) ; HashMap < Integer , Integer > countB = new HashMap <> ( ) ; for ( int i = 0 ; i < n ; i ++ ) { countA . put ( a [ i ] , countA . getOrDefault ( a [ i ] , 0 ) + 1 ) ; } for ( int i = 0 ; i < m ; i ++ ) { countB . put ( b [ i ] , countA . getOrDefault ( b [ i ] , 0 ) + 1 ) ; } int res = 0 ; for ( var x : countA . entrySet ( ) ) { if ( countB . containsKey ( x . getKey ( ) ) ) { res += Math . min ( x . getValue ( ) , countB . get ( x . getKey ( ) ) ) ; } } return res ; }
int knapsack ( int w0 , int [ ] wt , int [ ] val , int n ) { int i , w ; int [ ] [ ] k = new int [ n + 1 ] [ w0 + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= w0 ; w ++ ) { if ( i == 0 || w == 0 ) { k [ i ] [ w ] = 0 ; } else if ( wt [ i - 1 ] <= w ) { k [ i ] [ w ] = Math . max ( val [ i - 1 ] + k [ i - 1 ] [ w - wt [ i - 1 ] ] , k [ i - 1 ] [ w ] ) ; } else { k [ i ] [ w ] = k [ i - 1 ] [ w ] ; } } } return k [ n ] [ w0 ] ; }
int arraySortedOrNot ( int [ ] arr , int n ) { if ( n == 1 || n == 0 ) { return 1 ; } if ( arr [ n - 1 ] < arr [ n - 2 ] ) { return 0 ; } return arraySortedOrNot ( arr , n - 1 ) ; }
int minTime ( int n , int k , Integer [ ] a ) { Arrays . sort ( a , Collections . reverseOrder ( ) ) ; int minTime = 0 ; for ( int i = 0 ; i < n ; i += k ) { minTime += 2 * a [ i ] ; } return minTime ; }
int findElement ( int [ ] arr , int n , int key ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == key ) { return i ; } } return - 1 ; }
void findMax ( int [ ] a , int n , int k ) { TreeMap < Integer , Integer > count = new TreeMap <> ( ) ; for ( int i = 0 ; i < k - 1 ; i ++ ) { count . put ( a [ i ] , count . getOrDefault ( a [ i ] , 0 ) + 1 ) ; } TreeSet < Integer > mySet = new TreeSet <> ( ) ; for ( var x : count . entrySet ( ) ) { if ( x . getValue ( ) == 1 ) { mySet . add ( x . getKey ( ) ) ; } } for ( int i = k - 1 ; i < n ; i ++ ) { count . put ( a [ i ] , count . getOrDefault ( a [ i ] , 0 ) + 1 ) ; if ( count . get ( a [ i ] ) == 1 ) { mySet . add ( a [ i ] ) ; } else { mySet . remove ( a [ i ] ) ; } if ( mySet . size ( ) == 0 ) { System . out . println ( " Nothing " ) ; } else { System . out . println ( mySet . last ( ) ) ; } int x = a [ i - k + 1 ] ; count . put ( x , count . get ( x ) - 1 ) ; if ( count . get ( x ) == 1 ) { mySet . add ( x ) ; } if ( count . get ( x ) == 0 ) { mySet . remove ( x ) ; } } }
int countP ( int n , int k ) { if ( n == 0 || k == 0 || k > n ) { return 0 ; } if ( k == 1 || k == n ) { return 1 ; } return k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ; }
int totalNodes ( List < Integer > [ ] adjac , int n , int x , int y ) { Boolean [ ] visited = new Boolean [ n + 1 ] ; int [ ] p = new int [ n ] ; Queue < Integer > q = new ArrayDeque <> ( ) ; q . add ( x ) ; visited [ x ] = true ; int m ; while ( ! q . isEmpty ( ) ) { m = q . peek ( ) ; q . poll ( ) ; for ( int i = 0 ; i < adjac [ m ] . size ( ) ; ++ i ) { int h = adjac [ m ] . get ( i ) ; if ( ! visited [ h ] ) { visited [ h ] = true ; p [ h ] = m ; q . add ( h ) ; } } } int count = 0 ; int i = p [ y ] ; while ( i != x ) { count ++ ; i = p [ i ] ; } return count ; }
int solve ( int [ ] a , int n ) { int i , cnt = 0 , j ; int [ ] parent = new int [ n + 1 ] ; int [ ] vis = new int [ n + 1 ] ; for ( i = 0 ; i < n + 1 ; i ++ ) { parent [ i ] = - 1 ; } for ( i = 0 ; i < n ; i ++ ) { j = i ; if ( parent [ j ] == - 1 ) { while ( parent [ j ] == - 1 ) { parent [ j ] = i ; j = ( j + a [ j ] + 1 ) % n ; } if ( parent [ j ] == i ) { while ( vis [ j ] == 0 ) { vis [ j ] = 1 ; cnt ++ ; j = ( j + a [ j ] + 1 ) % n ; } } } } return cnt ; }
int countDistinctSubarray ( int [ ] arr , int n ) { TreeMap < Integer , Integer > vis = new TreeMap <> ( ) ; for ( int i = 0 ; i < n ; ++ i ) { vis . put ( arr [ i ] , 1 ) ; } int k = vis . size ( ) ; vis . clear ( ) ; int ans = 0 , right = 0 , window = 0 ; for ( int left = 0 ; left < n ; ++ left ) { while ( right < n && window < k ) { vis . put ( arr [ right ] , vis . getOrDefault ( arr [ right ] , 0 ) + 1 ) ; if ( vis . get ( arr [ right ] ) == 1 ) { ++ window ; } ++ right ; } if ( window == k ) { ans += n - right + 1 ; } vis . put ( arr [ left ] , vis . get ( arr [ right ] ) - 1 ) ; if ( vis . get ( arr [ left ] ) == 0 ) { -- window ; } } return ans ; }
int minOperation ( int [ ] a , int [ ] b , int n ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { result = result + Math . abs ( a [ i ] - b [ i ] ) ; } return result ; }
double minHeight ( double base , double area ) { return Math . ceil ( ( 2 * area ) / base ) ; }
boolean checkSentence ( String str ) { int len = str . length ( ) ; if ( str . charAt ( 0 ) < ' A ' || str . charAt ( 0 ) > ' Z ' ) { return false ; } if ( str . charAt ( len - 1 ) != ' . ' ) { return false ; } int prevState = 0 , currState = 0 ; int index = 1 ; while ( index <= str . length ( ) ) { if ( str . charAt ( index ) >= ' A ' && str . charAt ( index ) <= ' Z ' ) { currState = 0 ; } else if ( str . charAt ( index ) == ' ▁ ' ) { currState = 1 ; } else if ( str . charAt ( index ) >= ' a ' && str . charAt ( index ) <= ' z ' ) { currState = 2 ; } else if ( str . charAt ( index ) == ' . ' ) { currState = 3 ; } if ( prevState == currState && currState != 2 ) { return false ; } if ( prevState == 2 && currState == 0 ) { return false ; } if ( currState == 3 && prevState != 1 ) { return ( index + 1 == str . length ( ) ) ; } index ++ ; prevState = currState ; } return false ; }
void alternateSort ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int i = 0 , j = n - 1 ; while ( i < j ) { System . out . print ( arr [ j -- ] + " ▁ " ) ; System . out . print ( arr [ i ++ ] + " ▁ " ) ; } if ( n % 2 != 0 ) { System . out . print ( arr [ i ] ) ; } }
int getFirstSetBitPos ( int n ) { return ( int ) ( ( Math . log ( n & - n ) ) / Math . log ( 2 ) ) + 1 ; }
int findNth ( int n ) { int count = 0 ; for ( int curr = 19 ; ; curr += 9 ) { int sum = 0 ; for ( int x = curr ; x > 0 ; x = x / 10 ) { sum = sum + x % 10 ; } if ( sum == 10 ) { count ++ ; } if ( count == n ) { return curr ; } } }
int findMaxSum ( int [ ] arr , int n ) { int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int prefixSum = arr [ i ] ; for ( int j = 0 ; j < i ; j ++ ) { prefixSum += arr [ j ] ; } int suffixSum = arr [ i ] ; for ( int j = n - 1 ; j > i ; j -- ) { suffixSum += arr [ j ] ; } if ( prefixSum == suffixSum ) { res = Math . max ( res , prefixSum ) ; } } return res ; }
void section ( double x1 , double x2 , double y1 , double y2 , double m , double n ) { double x = ( ( n * x1 ) + ( m * x2 ) ) / ( m + n ) ; double y = ( ( n * y1 ) + ( m * y2 ) ) / ( m + n ) ; System . out . println ( " ( " + x + " , ▁ " + y + " ) " ) ; }
boolean checkPair ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } if ( sum % 2 != 0 ) { return false ; } sum = sum / 2 ; HashSet < Integer > s = new HashSet <> ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int val = sum - arr [ i ] ; if ( s . contains ( val ) ) { System . out . printf ( " Pair ▁ elements ▁ are ▁ % d ▁ and ▁ % d \ n " , arr [ i ] , val ) ; return true ; } s . add ( arr [ i ] ) ; } return false ; }
int countFibs ( int low , int high ) { int f1 = 0 , f2 = 1 , f3 = 1 ; int result = 0 ; while ( f1 <= high ) { if ( f1 >= low ) { result ++ ; } f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; } return result ; }
int count ( int n ) { if ( n < 4 ) { return - 1 ; } int rem = n % 4 ; if ( rem == 0 ) { return n / 4 ; } if ( rem == 1 ) { if ( n < 9 ) { return - 1 ; } return ( n - 9 ) / 4 + 1 ; } if ( rem == 2 ) { return ( n - 6 ) / 4 + 1 ; } if ( rem == 3 ) { if ( n < 15 ) { return - 1 ; } return ( n - 15 ) / 4 + 2 ; } return 0 ; }
int kthNonRepeating ( String str , int k ) { int n = str . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; int [ ] index = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { count [ i ] = 0 ; index [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { char x = str . charAt ( i ) ; ++ count [ x ] ; if ( count [ x ] == 1 ) { index [ x ] = i ; } if ( count [ x ] == 2 ) { index [ x ] = n ; } } Arrays . sort ( index ) ; return ( index [ k - 1 ] != n ) ? index [ k - 1 ] : - 1 ; }
double find ( double p ) { return Math . ceil ( Math . sqrt ( 2 * 365 * Math . log ( 1 / ( 1 - p ) ) ) ) ; }
void midpoint ( int x1 , int x2 , int y1 , int y2 ) { System . out . print ( ( x1 + x2 ) / 2 + " ▁ , ▁ " + ( y1 + y2 ) / 2 ) ; }
void groupElements ( int [ ] arr , int n ) { boolean [ ] visited = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! visited [ i ] ) { System . out . print ( arr [ i ] + " ▁ " ) ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { System . out . print ( arr [ i ] + " ▁ " ) ; visited [ j ] = true ; } } } } }
boolean arekAnagrams ( String str1 , String str2 , int k ) { int n = str1. length ( ) ; if ( str2. length ( ) != n ) { return false ; } int [ ] count1 = new int [ MAX_CHAR ] ; int [ ] count2 = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { count1 [ str1. charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { count2 [ str2. charAt ( i ) - ' a ' ] ++ ; } int count = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( count1 [ i ] > count2 [ i ] ) { count = count + Math . abs ( count1 [ i ] - count2 [ i ] ) ; } } return count <= k ; }
void printPrevSmaller ( int [ ] arr , int n ) { System . out . print ( " _ , ▁ " ) ; for ( int i = 1 ; i < n ; i ++ ) { int j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ j ] < arr [ i ] ) { System . out . print ( arr [ j ] + " , ▁ " ) ; break ; } } if ( j == - 1 ) { System . out . print ( " _ , ▁ " ) ; } } }
int lcs ( int i , int j , int count ) { if ( i == 0 || j == 0 ) { return count ; } if ( x . charAt ( i - 1 ) == y . charAt ( j - 1 ) ) { count = lcs ( i - 1 , j - 1 , count + 1 ) ; } count = Math . max ( count , Math . max ( lcs ( i , j - 1 , 0 ) , lcs ( i - 1 , j , 0 ) ) ) ; return count ; }
int findLargestSumPair ( int [ ] arr , int n ) { int first , second ; if ( arr [ 0 ] > arr [ 1 ] ) { first = arr [ 0 ] ; second = arr [ 1 ] ; } else { first = arr [ 1 ] ; second = arr [ 0 ] ; } for ( int i = 2 ; i < arr . length ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second && arr [ i ] != first ) { second = arr [ i ] ; } } return first + second ; }
int checkDuck ( String num ) { int len = num . length ( ) ; int countZero = 0 ; for ( int i = 1 ; i < len ; i ++ ) { char ch = num . charAt ( i ) ; if ( ch == ' 0 ' ) { countZero ++ ; } } return countZero ; }
boolean checkIfAllTogether ( String s , char c ) { boolean oneSeen = false ; int i = 0 , n = s . length ( ) ; while ( i < n ) { if ( s . charAt ( i ) == c ) { if ( oneSeen == true ) { return false ; } while ( i < n && s . charAt ( i ) == c ) { i ++ ; } oneSeen = true ; } else { i ++ ; } } return true ; }
boolean areElementsContiguous ( int [ ] arr , int n ) { HashSet < Integer > us = new HashSet <> ( ) ; for ( int i = 0 ; i < n ; i ++ ) { us . add ( arr [ i ] ) ; } int count = 1 ; int currEle = arr [ 0 ] - 1 ; while ( us . contains ( currEle ) ) { count ++ ; currEle -- ; } currEle = arr [ 0 ] + 1 ; while ( us . contains ( currEle ) ) { count ++ ; currEle ++ ; } return count == ( us . size ( ) ) ; }
int findMinSum ( int num ) { int sum = 0 ; for ( int i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ; return sum ; }
int minStringValue ( String str , int k ) { int l = str . length ( ) ; if ( k >= l ) { return 0 ; } int [ ] frequency = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < l ; i ++ ) { frequency [ str . charAt ( i ) - ' a ' ] ++ ; } PriorityQueue < Integer > q = new PriorityQueue <> ( ) ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( frequency [ i ] != 0 ) { q . add ( frequency [ i ] ) ; } } while ( k != 0 ) { int temp = q . peek ( ) ; q . poll ( ) ; temp = temp - 1 ; q . add ( temp ) ; k -- ; } int result = 0 ; while ( ! q . isEmpty ( ) ) { int temp = q . peek ( ) ; result += temp * temp ; q . poll ( ) ; } return result ; }
void reverseFibonacci ( int n ) { int [ ] a = new int [ n ] ; a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) { a [ i ] = a [ i - 2 ] + a [ i - 1 ] ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { System . out . print ( a [ i ] + " ▁ " ) ; } }
int countSubarrWithEqualZeroAndOne ( int [ ] arr , int n ) { HashMap < Integer , Integer > um = new HashMap <> ( ) ; int currSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currSum += ( arr [ i ] == 0 ) ? - 1 : arr [ i ] ; um . put ( currSum , um . getOrDefault ( currSum , 0 ) + 1 ) ; } int count = 0 ; for ( var x : um . entrySet ( ) ) { if ( x . getValue ( ) > 1 ) { count += ( x . getValue ( ) * ( x . getValue ( ) - 1 ) ) / 2 ; } } if ( um . containsKey ( 0 ) ) { count += um . get ( 0 ) ; } return count ; }
boolean isLucky ( int n ) { int nextPosition = n ; if ( counter > n ) { return true ; } if ( n % counter == 0 ) { return false ; } nextPosition -= nextPosition / counter ; counter ++ ; return isLucky ( nextPosition ) ; }
int count ( String s , int len ) { int cur = 0 , dig = 0 ; int [ ] sum = new int [ MAX ] ; int [ ] [ ] dp = new int [ MAX ] [ 3 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= len ; i ++ ) { dig = ( int ) ( s . charAt ( i - 1 ) ) - 48 ; cur += dig ; cur %= 3 ; sum [ i ] = cur ; dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ] ; dp [ i ] [ sum [ i ] ] ++ ; } int ans = 0 , dprev = 0 , value = 0 , dprev2 = 0 ; for ( int i = 1 ; i <= len ; i ++ ) { dig = ( int ) ( s . charAt ( i - 1 ) ) - 48 ; if ( dig == 8 ) { ans ++ ; } if ( i - 2 >= 0 ) { dprev = ( int ) ( s . charAt ( i - 2 ) ) - 48 ; value = dprev * 10 + dig ; if ( ( value % 8 == 0 ) && ( value % 3 != 0 ) ) { ans ++ ; } } if ( i - 3 >= 0 ) { dprev2 = ( int ) ( s . charAt ( i - 3 ) ) - 48 ; dprev = ( int ) ( s . charAt ( i - 2 ) ) - 48 ; value = dprev2 * 100 + dprev * 10 + dig ; if ( value % 8 != 0 ) { continue ; } ans += ( i - 2 ) ; ans -= ( dp [ i - 3 ] [ sum [ i ] ] ) ; } } return ans ; }
int nextPowerOf2 ( int n ) { int count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) { return n ; } while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
boolean canFormPalindrome ( String str ) { int [ ] count = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { count [ str . charAt ( i ) ] ++ ; } int odd = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( ( count [ i ] & 1 ) != 0 ) { odd ++ ; } if ( odd > 1 ) { return false ; } } return true ; }
float squareRoot ( float n ) { float x = n ; float y = 1 ; float e = 0.000001f ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; }
int binarySearch ( int [ ] arr , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( mid == arr [ mid ] ) { return mid ; } if ( mid > arr [ mid ] ) { return binarySearch ( arr , ( mid + 1 ) , high ) ; } else { return binarySearch ( arr , low , ( mid - 1 ) ) ; } } return - 1 ; }
int countDyckPaths ( int n ) { int res = 1 ; for ( int i = 0 ; i < n ; ++ i ) { res *= 2 * n - i ; res /= i + 1 ; } return res / ( n + 1 ) ; }
void pushZerosToEnd ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 0 ) { arr [ count ++ ] = arr [ i ] ; } } while ( count < n ) { arr [ count ++ ] = 0 ; } }
boolean isConvertible ( String str1 , String str2 , int k ) { if ( ( str1. length ( ) + str2. length ( ) ) < k ) { return true ; } int commonLength = 0 ; for ( int i = 0 ; i < Math . min ( str1. length ( ) , str2. length ( ) ) ; i ++ ) { if ( str1 == str2 ) { commonLength ++ ; } else { break ; } } if ( ( k - str1. length ( ) - str2. length ( ) + 2 * commonLength ) % 2 == 0 ) { return true ; } return false ; }
int answerQuery ( int [ ] a , int n , int l , int r ) { int count = 0 ; l = l - 1 ; for ( int i = l ; i < r ; i ++ ) { int element = a [ i ] ; int divisors = 0 ; for ( int j = l ; j < r ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) { divisors ++ ; } else { break ; } } if ( divisors == r - l ) { count ++ ; } } return count ; }
void swap ( int [ ] xp , int [ ] yp ) { if ( xp [ 0 ] == yp [ 0 ] ) { return ; } xp [ 0 ] = xp [ 0 ] + yp [ 0 ] ; yp [ 0 ] = xp [ 0 ] - yp [ 0 ] ; xp [ 0 ] = xp [ 0 ] - yp [ 0 ] ; }
int maxProfit ( int [ ] price , int n , int k ) { int [ ] [ ] profit = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= k ; i ++ ) { int prevDiff = Integer . MIN_VALUE ; for ( int j = 1 ; j < n ; j ++ ) { prevDiff = Math . max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) ; profit [ i ] [ j ] = Math . max ( profit [ i ] [ j - 1 ] , price [ j ] + prevDiff ) ; } } return profit [ k ] [ n - 1 ] ; }
void findMissing ( int [ ] a , int [ ] b , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < m ; j ++ ) { if ( a [ i ] == b [ j ] ) { break ; } } if ( j == m ) { System . out . print ( a [ i ] + " ▁ " ) ; } } }
int countNumberOfTriangles ( int n ) { return n * ( n - 1 ) * ( n - 2 ) / 6 ; }
void printSorted ( int [ ] arr , int start , int end ) { if ( start > end ) { return ; } printSorted ( arr , start * 2 + 1 , end ) ; System . out . print ( arr [ start ] + " ▁ " ) ; printSorted ( arr , start * 2 + 2 , end ) ; }
int search ( int [ ] [ ] mat , int n , int x ) { int i = 0 , j = n - 1 ; int smallest = a [ 0 ] [ 0 ] , largest = a [ n - 1 ] [ n - 1 ] ; if ( x < smallest || x > largest ) { return - 1 ; } while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { System . out . print ( " n ▁ Found ▁ at ▁ " + i + " ▁ " + j ) ; return 1 ; } if ( mat [ i ] [ j ] > x ) { j -- ; } else { i ++ ; } } System . out . print ( " n ▁ Element ▁ not ▁ found " ) ; return 0 ; }
int findInteger ( int [ ] arr , int n ) { int neg = 0 , pos = 0 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] < 0 ) { neg ++ ; } else { pos ++ ; } } return sum / Math . abs ( neg - pos ) ; }
int countGroups ( int position , int previousSum , int length , String num ) { if ( position == length ) { return 1 ; } int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += num . charAt ( i ) - ' 0 ' ; if ( sum >= previousSum ) { res += countGroups ( i + 1 , sum , length , num ) ; } } return res ; }
void digitsNum ( int n ) { if ( n == 0 ) { System . out . println ( " 0 " ) ; } if ( n % 9 != 0 ) { System . out . print ( n % 9 ) ; } for ( int i = 1 ; i <= n / 9 ; ++ i ) { System . out . print ( " 9 " ) ; } for ( int i = 1 ; i <= n ; ++ i ) { System . out . print ( " 0 " ) ; } System . out . println ( ) ; }
void checkCollision ( int a , int b , int c , int x , int y , int radius ) { double dist = Math . abs ( a * x + b * y + c ) / Math . sqrt ( a * a + b * b ) ; if ( radius == dist ) { System . out . println ( " Touch " ) ; } else if ( radius > dist ) { System . out . println ( " Intersect " ) ; } else { System . out . println ( " Outside " ) ; } }
int difference ( int [ ] [ ] arr , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += arr [ i ] [ i ] ; d2 += arr [ i ] [ n - i - 1 ] ; } return Math . abs ( d1 - d2 ) ; }
double areaCircumscribed ( double a ) { return a * a * ( Math . PI / 2 ) ; }
int countRotations ( int [ ] arr , int n ) { int min = arr [ 0 ] , minIndex = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min > arr [ i ] ) { min = arr [ i ] ; minIndex = i ; } } return minIndex ; }
int lps ( String s ) { int n = s . length ( ) ; int [ ] a = new int [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int backUp = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( j == i ) { a [ j ] = 1 ; } else if ( s . charAt ( i ) == s . charAt ( j ) ) { int temp = a [ j ] ; a [ j ] = backUp + 2 ; backUp = temp ; } else { backUp = a [ j ] ; a [ j ] = Math . max ( a [ j - 1 ] , a [ j ] ) ; } } } return a [ n - 1 ] ; }
double squareRoot ( double n ) { return Math . pow ( 2 , 0.5 * ( Math . log ( n ) / Math . log ( 2 ) ) ) ; }
void printSmall ( int [ ] arr , int n , int k ) { for ( int i = k ; i < n ; ++ i ) { int maxVar = arr [ k - 1 ] ; int pos = k - 1 ; for ( int j = k - 2 ; j >= 0 ; j -- ) { if ( arr [ j ] > maxVar ) { maxVar = arr [ j ] ; pos = j ; } } if ( maxVar > arr [ i ] ) { int j = pos ; while ( j < k - 1 ) { arr [ j ] = arr [ j + 1 ] ; j ++ ; } arr [ k - 1 ] = arr [ i ] ; } } for ( int i = 0 ; i < k ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } }
void bestApproximate ( int [ ] x , int [ ] y ) { int n = x . length ; double m , c , sumX = 0 , sumY = 0 , sumXY = 0 , sumX2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sumX += x [ i ] ; sumY += y [ i ] ; sumXY += x [ i ] * y [ i ] ; sumX2 += Math . pow ( x [ i ] , 2 ) ; } m = ( n * sumXY - sumX * sumY ) / ( n * sumX2 - Math . pow ( sumX , 2 ) ) ; c = ( sumY - m * sumX ) / n ; System . out . println ( " m ▁ = ▁ " + m ) ; System . out . println ( " c ▁ = ▁ " + c ) ; }
double cosXSertiesSum ( double x , int n ) { x = x * ( Math . PI / 180.0 ) ; double res = 1 ; double sign = 1 , fact = 1 , pow = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) { sign = sign * - 1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; }
void printArray ( int [ ] [ ] arr , int row , int col ) { HashSet < String > uset = new HashSet <> ( ) ; for ( int i = 0 ; i < row ; i ++ ) { StringBuilder s = new StringBuilder ( ) ; for ( int j = 0 ; j < col ; j ++ ) { s . append ( String . valueOf ( arr [ i ] [ j ] ) ) ; } if ( ! uset . contains ( s . toString ( ) ) ) { uset . add ( s . toString ( ) ) ; System . out . println ( s . toString ( ) ) ; } } }
int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
long countWays ( int n , int k ) { int total = k ; int mod = 1000000007 ; int same = 0 , diff = k ; for ( int i = 2 ; i <= n ; i ++ ) { same = diff ; diff = total * ( k - 1 ) % mod ; total = ( same + diff ) % mod ; } return total ; }
int linearSearch ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) { return i ; } } return - 1 ; }
int pad ( int n ) { int pPrevPrev = 1 , pPrev = 1 , pCurr = 1 , pNext = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { pNext = pPrevPrev + pPrev ; pPrevPrev = pPrev ; pPrev = pCurr ; pCurr = pNext ; } return pNext ; }
int maxLevel ( int [ ] boxes , int n ) { Arrays . sort ( boxes ) ; int ans = 1 ; int prevWidth = boxes [ 0 ] ; int prevCount = 1 ; int currCount = 0 ; int currWidth = 0 ; for ( int i = 1 ; i < n ; i ++ ) { currWidth += boxes [ i ] ; currCount += 1 ; if ( currWidth > prevWidth && currCount > prevCount ) { prevWidth = currWidth ; prevCount = currCount ; currCount = 0 ; currWidth = 0 ; ans ++ ; } } return ans ; }
int maximumHeight ( int n ) { return ( int ) Math . floor ( ( - 1 + Math . sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ; }
int compute ( List < Integer > [ ] graph , int n ) { int count = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( graph [ i ] . size ( ) == 0 ) { count ++ ; } } return count ; }
int productAtKthLevel ( String tree , int k ) { int level = - 1 ; int product = 1 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree . charAt ( i ) == ' ( ' ) { level ++ ; } else if ( tree . charAt ( i ) == ' ) ' ) { level -- ; } else if ( level == k ) { product *= tree . charAt ( i ) - ' 0 ' ; } } return product ; }
void productArray ( int [ ] arr , int n ) { if ( n == 1 ) { System . out . print ( 0 ) ; return ; } int [ ] left = new int [ n ] ; int [ ] right = new int [ n ] ; int [ ] prod = new int [ n ] ; int i , j ; left [ 0 ] = 1 ; right [ n - 1 ] = 1 ; for ( i = 1 ; i < n ; i ++ ) { left [ i ] = arr [ i - 1 ] * left [ i - 1 ] ; } for ( j = n - 2 ; j >= 0 ; j -- ) { right [ j ] = arr [ j + 1 ] * right [ j + 1 ] ; } for ( i = 0 ; i < n ; i ++ ) { prod [ i ] = left [ i ] * right [ i ] ; } for ( i = 0 ; i < n ; i ++ ) { System . out . print ( prod [ i ] + " ▁ " ) ; } }
void findPairs ( int [ ] arr1 , int [ ] arr2 , int n , int m , int x ) { HashSet < Integer > s = new HashSet <> ( ) ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( arr1 [ i ] ) ; } for ( int j = 0 ; j < m ; j ++ ) { if ( s . contains ( x - arr2 [ j ] ) ) { System . out . println ( x - arr2 [ j ] + " ▁ " + arr2 [ j ] ) ; } } }
int sumOfSeries ( int n ) { return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ; }
int printKDistinct ( int [ ] arr , int n , int k ) { HashMap < Integer , Integer > h = new HashMap <> ( ) ; for ( int i = 0 ; i < n ; i ++ ) { h . put ( arr [ i ] , h . getOrDefault ( arr [ i ] , 0 ) + 1 ) ; } if ( h . size ( ) < k ) { return - 1 ; } int distCount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( h . get ( arr [ i ] ) == 1 ) { distCount ++ ; } if ( distCount == k ) { return arr [ i ] ; } } return - 1 ; }
int minInsertion ( String str ) { int n = str . length ( ) ; int res = 0 ; int [ ] count = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { count [ str . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] % 2 == 1 ) { res ++ ; } } return ( res == 0 ) ? 0 : res - 1 ; }
void printStringAlternate ( String str ) { HashMap < Character , Integer > occ = new HashMap <> ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char temp = Character . toLowerCase ( str . charAt ( i ) ) ; occ . put ( temp , occ . getOrDefault ( temp , 0 ) + 1 ) ; if ( ( occ . get ( temp ) & 1 ) != 0 ) { System . out . print ( str . charAt ( i ) ) ; } } System . out . println ( ) ; }
int maxTripletSum ( int [ ] arr , int n ) { int maxA = Integer . MIN_VALUE , maxB = Integer . MIN_VALUE , maxC = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) { maxC = arr [ i ] ; } } return maxA + maxB + maxC ; }
int dayOfWeek ( int d , int m , int y ) { int [ ] t = { 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 } ; y -= ( m < 3 ) ? 1 : 0 ; return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ; }
void longestSubsequence ( int [ ] a , int n ) { HashMap < Integer , Integer > mp = new HashMap <> ( ) ; int [ ] dp = new int [ n ] ; int maximum = Integer . MIN_VALUE ; int index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( a [ i ] - 1 ) ) { int lastIndex = mp . get ( a [ i ] - 1 ) - 1 ; dp [ i ] = 1 + dp [ lastIndex ] ; } else { dp [ i ] = 1 ; } mp . put ( a [ i ] , i + 1 ) ; if ( maximum < dp [ i ] ) { maximum = dp [ i ] ; index = i ; } } for ( int curr = a [ index ] - maximum + 1 ; curr <= a [ index ] ; curr ++ ) { System . out . print ( curr + " ▁ " ) ; } }
boolean isPowerOfK ( int n , int k ) { boolean oneSeen = false ; while ( n > 0 ) { int digit = n % k ; if ( digit > 1 ) { return false ; } if ( digit == 1 ) { if ( oneSeen ) { return false ; } oneSeen = true ; } n /= k ; } return true ; }
int calculate ( int [ ] a , int n ) { Arrays . sort ( a ) ; int count = 1 ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { count += 1 ; } else { answer = answer + count * ( count - 1 ) / 2 ; count = 1 ; } } answer = answer + count * ( count - 1 ) / 2 ; return answer ; }
int findIndex ( String str ) { int len = str . length ( ) ; int [ ] open = new int [ len + 1 ] ; int [ ] close = new int [ len + 1 ] ; int index = - 1 ; open [ 0 ] = 0 ; close [ len ] = 0 ; if ( str . charAt ( 0 ) == ' ( ' ) { open [ 1 ] = 1 ; } if ( str . charAt ( len - 1 ) == ' ) ' ) { close [ len - 1 ] = 1 ; } for ( int i = 1 ; i < len ; i ++ ) { if ( str . charAt ( i ) == ' ( ' ) { open [ i + 1 ] = open [ i ] + 1 ; } else { open [ i + 1 ] = open [ i ] ; } } for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == ' ) ' ) { close [ i ] = close [ i + 1 ] + 1 ; } else { close [ i ] = close [ i + 1 ] ; } } if ( open [ len ] == 0 ) { return len ; } if ( close [ 0 ] == 0 ) { return 0 ; } for ( int i = 0 ; i <= len ; i ++ ) { if ( open [ i ] == close [ i ] ) { index = i ; } } return index ; }
void findTriplets ( int [ ] arr , int n ) { boolean found = true ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) { System . out . println ( arr [ i ] + " ▁ " + arr [ j ] + " ▁ " + arr [ k ] ) ; found = true ; } } } } if ( found == false ) { System . out . println ( " ▁ not ▁ exist ▁ " ) ; } }
int getIndexInSortedArray ( int [ ] arr , int n , int idx ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ idx ] ) { result ++ ; } if ( arr [ i ] == arr [ idx ] && i < idx ) { result ++ ; } } return result ; }
String longestRepeatedSubstring ( String str ) { int n = str . length ( ) ; int [ ] [ ] lcsRe = new int [ n + 1 ] [ n + 1 ] ; StringBuilder res = new StringBuilder ( ) ; int resLength = 0 ; int i , index = 0 ; for ( i = 1 ; i <= n ; i ++ ) { for ( int j = i + 1 ; j <= n ; j ++ ) { if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && lcsRe [ i - 1 ] [ j - 1 ] < ( j - i ) ) { lcsRe [ i ] [ j ] = lcsRe [ i - 1 ] [ j - 1 ] + 1 ; if ( lcsRe [ i ] [ j ] > resLength ) { resLength = lcsRe [ i ] [ j ] ; index = Math . max ( i , index ) ; } } else { lcsRe [ i ] [ j ] = 0 ; } } } if ( resLength > 0 ) { for ( i = index - resLength + 1 ; i <= index ; i ++ ) { res . append ( str . charAt ( i - 1 ) ) ; } } return res . toString ( ) ; }
void bubbleSort ( int [ ] arr , int n ) { boolean swapped ; for ( int i = 0 ; i < n - 1 ; i ++ ) { swapped = false ; for ( int j = 0 ; j < n - i - 1 ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) { int temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; swapped = true ; } } if ( swapped == false ) { break ; } } }
int minStepToDeleteString ( String str ) { int n = str . length ( ) ; int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int len = 1 ; len <= n ; len ++ ) { for ( int i = 0 , j = len - 1 ; j < n ; i ++ , j ++ ) { if ( len == 1 ) { dp [ i ] [ j ] = 1 ; } else { dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ; if ( str . charAt ( i ) == str . charAt ( i + 1 ) ) { dp [ i ] [ j ] = Math . min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ; } for ( int k = i + 2 ; k <= j ; k ++ ) { if ( str . charAt ( i ) == str . charAt ( k ) ) { dp [ i ] [ j ] = Math . min ( dp [ i + 1 ] [ k - 1 ] + dp [ k + 1 ] [ j ] , dp [ i ] [ j ] ) ; } } } } } return dp [ 0 ] [ n - 1 ] ; }
int floorSearch ( int [ ] arr , int low , int high , int x ) { if ( low > high ) { return - 1 ; } if ( x >= arr [ high ] ) { return high ; } int mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) { return mid ; } if ( mid > 0 && arr [ mid - 1 ] <= x && x < arr [ mid ] ) { return mid - 1 ; } if ( x < arr [ mid ] ) { return floorSearch ( arr , low , mid - 1 , x ) ; } return floorSearch ( arr , mid + 1 , high , x ) ; }
boolean areAnagram ( char [ ] str1 , char [ ] str2 ) { int n1 = str1. length ; int n2 = str2. length ; if ( n1 != n2 ) { return false ; } Arrays . sort ( str1 ) ; Arrays . sort ( str2 ) ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( str1 [ i ] != str2 [ i ] ) { return false ; } } return true ; }
int findMaxSegment ( String s , int k ) { int segLen = s . length ( ) - k ; int res = 0 ; for ( int i = 0 ; i < segLen ; i ++ ) { res = res * 10 + ( s . charAt ( i ) - ' 0 ' ) ; } int segLenPow = ( int ) Math . pow ( 10 , segLen - 1 ) ; int currVal = res ; for ( int i = 1 ; i <= ( s . length ( ) - segLen ) ; i ++ ) { currVal = currVal - ( s . charAt ( i - 1 ) - ' 0 ' ) * segLenPow ; currVal = currVal * 10 + ( s . charAt ( i + segLen - 1 ) - ' 0 ' ) ; res = Math . max ( res , currVal ) ; } return res ; }
void rearrangeArray ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int [ ] tempArr = new int [ n ] ; int arrIndex = 0 ; for ( int i = 0 , j = n - 1 ; i <= n / 2 || j > n / 2 ; i ++ , j -- ) { tempArr [ arrIndex ] = arr [ i ] ; arrIndex ++ ; tempArr [ arrIndex ] = arr [ j ] ; arrIndex ++ ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = tempArr [ i ] ; } }
int mostFrequent ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int maxCount = 1 , res = arr [ 0 ] ; int currCount = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { currCount ++ ; } else { if ( currCount > maxCount ) { maxCount = currCount ; res = arr [ i - 1 ] ; } currCount = 1 ; } } if ( currCount > maxCount ) { maxCount = currCount ; res = arr [ n - 1 ] ; } return res ; }
int sumOfSeries ( int n ) { return ( int ) ( 0.6172 * ( Math . pow ( 10 , n ) - 1 ) - 0.55 * n ) ; }
int minSum ( int [ ] a , int n ) { Arrays . sort ( a ) ; int num1 = 0 ; int num2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { num1 = num1 * 10 + a [ i ] ; } else { num2 = num2 * 10 + a [ i ] ; } } return num2 + num1 ; }
int perfectSquare ( String s ) { int n = s . length ( ) ; int ans = - 1 ; String num = " " ; for ( int i = 1 ; i < ( 1 << n ) ; i ++ ) { StringBuilder str = new StringBuilder ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( ( i >> j ) & 1 ) == 1 ) { str . append ( s . charAt ( j ) ) ; } } if ( str . charAt ( 0 ) != ' 0 ' ) { int temp = 0 ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { temp = temp * 10 + ( str . charAt ( j ) - ' 0 ' ) ; } int k = ( int ) Math . sqrt ( temp ) ; if ( k * k == temp ) { if ( ans < str . length ( ) ) { ans = str . length ( ) ; num = str . toString ( ) ; } } } } if ( ans == - 1 ) { return ans ; } else { System . out . print ( num + " ▁ " ) ; return n - ans ; } }
boolean checkPlusPerfect ( int x ) { int temp = x ; int n = 0 ; while ( x != 0 ) { x /= 10 ; n ++ ; } x = temp ; int sum = 0 ; while ( x != 0 ) { sum += Math . pow ( x % 10 , n ) ; x /= 10 ; } return sum == temp ; }
boolean checkStackPermutation ( int [ ] ip , int [ ] op , int n ) { Queue < Integer > input = new ArrayDeque <> ( ) ; for ( int i = 0 ; i < n ; i ++ ) { input . add ( ip [ i ] ) ; } Queue < Integer > output = new ArrayDeque <> ( ) ; for ( int i = 0 ; i < n ; i ++ ) { output . add ( op [ i ] ) ; } Stack < Integer > tempStack = new Stack <> ( ) ; while ( ! input . isEmpty ( ) ) { int ele = input . poll ( ) ; if ( ele == output . peek ( ) ) { output . poll ( ) ; while ( ! tempStack . isEmpty ( ) ) { if ( tempStack . peek ( ) == output . peek ( ) ) { tempStack . pop ( ) ; output . poll ( ) ; } else { break ; } } } else { tempStack . push ( ele ) ; } } return input . isEmpty ( ) && tempStack . isEmpty ( ) ; }
char [ ] replaceSpaces ( char [ ] str ) { int spaceCount = 0 , i ; for ( i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] == ' ▁ ' ) { spaceCount ++ ; } } while ( str [ i - 1 ] == ' ▁ ' ) { spaceCount -- ; i -- ; } int newLength = i + spaceCount * 2 ; if ( newLength > MAX ) { return str ; } int index = newLength - 1 ; char [ ] newStr = str ; str = new char [ newLength ] ; for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( newStr [ j ] == ' ▁ ' ) { str [ index ] = ' 0 ' ; str [ index - 1 ] = ' 2 ' ; str [ index - 2 ] = ' % ' ; index = index - 3 ; } else { str [ index ] = newStr [ j ] ; index -- ; } } return str ; }
void nthPalindrome ( int n , int k ) { int temp = ( k & 1 ) != 0 ? ( k / 2 ) : ( k / 2 - 1 ) ; int palindrome = ( int ) Math . pow ( 10 , temp ) ; palindrome += n - 1 ; System . out . print ( palindrome ) ; if ( ( k & 1 ) > 0 ) { palindrome /= 10 ; } while ( palindrome > 0 ) { System . out . print ( palindrome % 10 ) ; palindrome /= 10 ; } System . out . println ( ) ; }
int getOddOccurrence ( int [ ] arr , int n ) { HashMap < Integer , Integer > hash = new HashMap <> ( ) ; for ( int i = 0 ; i < n ; i ++ ) { hash . put ( arr [ i ] , hash . getOrDefault ( arr [ i ] , 0 ) + 1 ) ; } for ( var a : hash . entrySet ( ) ) { if ( a . getValue ( ) % 2 != 0 ) { return a . getKey ( ) ; } } return - 1 ; }
int findCommon ( int [ ] [ ] mat ) { HashMap < Integer , Integer > cnt = new HashMap <> ( ) ; int i , j ; for ( i = 0 ; i < M ; i ++ ) { cnt . put ( mat [ i ] [ 0 ] , cnt . getOrDefault ( mat [ i ] [ 0 ] , 0 ) + 1 ) ; for ( j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] != mat [ i ] [ j - 1 ] ) { cnt . put ( mat [ i ] [ j ] , cnt . getOrDefault ( mat [ i ] [ j ] , 0 ) + 1 ) ; } } } for ( var ele : cnt . entrySet ( ) ) { if ( ele . getValue ( ) == M ) { return ele . getKey ( ) ; } } return - 1 ; }
int minCost ( int [ ] coin , int n , int k ) { Arrays . sort ( coin ) ; int coinsNeeded = ( int ) Math . ceil ( 1.0 * n / ( k + 1 ) ) ; int ans = 0 ; for ( int i = 0 ; i <= coinsNeeded - 1 ; i ++ ) { ans += coin [ i ] ; } return ans ; }
String findSum ( String str1 , String str2 ) { if ( str1. length ( ) > str2. length ( ) ) { return " " ; } StringBuilder str = new StringBuilder ( ) ; int n1 = str1. length ( ) , n2 = str2. length ( ) ; int diff = n2 - n1 ; int carry = 0 ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { int sum = ( str1. charAt ( i ) - ' 0 ' ) + ( str2. charAt ( i + diff ) - ' 0 ' ) + carry ; str . append ( ( char ) ( sum % 10 + ' 0 ' ) ) ; carry = sum / 10 ; } for ( int i = n2 - n1 - 1 ; i >= 0 ; i -- ) { int sum = ( str2. charAt ( i ) - ' 0 ' ) + carry ; str . append ( ( char ) ( sum % 10 + ' 0 ' ) ) ; carry = sum / 10 ; } if ( carry > 0 ) { str . append ( ( char ) ( carry + ' 0 ' ) ) ; } str . reverse ( ) ; return str . toString ( ) ; }
int findRepeatFirstN2 ( String s ) { int p = - 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( i ) == s . charAt ( j ) ) { p = i ; break ; } } if ( p != - 1 ) { break ; } } return p ; }
int unitNumber ( int x , int y ) { x = x % 10 ; if ( y != 0 ) { y = y % 4 + 4 ; } return ( int ) ( Math . pow ( x , y ) ) % 10 ; }
int policeThief ( char [ ] arr , int n , int k ) { int res = 0 ; List < Integer > thi = new ArrayList <> ( ) ; List < Integer > pol = new ArrayList <> ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == ' P ' ) { pol . add ( i ) ; } else if ( arr [ i ] == ' T ' ) { thi . add ( i ) ; } } int l = 0 , r = 0 ; while ( l < thi . size ( ) && r < pol . size ( ) ) { if ( Math . abs ( thi . get ( l ) - pol . get ( r ) ) <= k ) { res ++ ; l ++ ; r ++ ; } else if ( thi . get ( l ) < pol . get ( r ) ) { l ++ ; } else { r ++ ; } } return res ; }
int calculate ( int a , int b , int c , int m ) { int res = power ( b , c , m - 1 ) ; int ans = power ( a , res , m ) ; return ans ; }
int numberOfWays ( int x ) { if ( x == 0 || x == 1 ) { return 1 ; } else { return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; } }
void unique ( int [ ] [ ] mat , int n , int m ) { int maximum = 0 , flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( maximum < mat [ i ] [ j ] ) { maximum = mat [ i ] [ j ] ; } } } int [ ] b = new int [ maximum + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { b [ mat [ i ] [ j ] ] ++ ; } } for ( int i = 1 ; i <= maximum ; i ++ ) { if ( b [ i ] == 1 ) { System . out . print ( i + " ▁ " ) ; flag = 1 ; } } if ( flag == 0 ) { System . out . println ( " No ▁ unique ▁ element ▁ " + " in ▁ the ▁ matrix " ) ; } }
int knapsack ( int w , int [ ] wt , int [ ] val , int n ) { if ( n == 0 || w == 0 ) { return 0 ; } if ( wt [ n - 1 ] > w ) { return knapsack ( w , wt , val , n - 1 ) ; } else { return Math . max ( val [ n - 1 ] + knapsack ( w - wt [ n - 1 ] , wt , val , n - 1 ) , knapsack ( w , wt , val , n - 1 ) ) ; } }
int countSubsets ( int [ ] arr , int n ) { HashSet < Integer > us = new HashSet <> ( ) ; int evenCount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { us . add ( arr [ i ] ) ; } } evenCount = us . size ( ) ; return ( int ) ( Math . pow ( 2 , evenCount ) - 1 ) ; }
int findSubarraySum ( int [ ] arr , int n , int sum ) { HashMap < Integer , Integer > prevSum = new HashMap <> ( ) ; int res = 0 ; int currSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currSum += arr [ i ] ; if ( currSum == sum ) { res ++ ; } if ( prevSum . containsKey ( currSum - sum ) ) { res += prevSum . get ( currSum - sum ) ; } prevSum . put ( currSum , prevSum . getOrDefault ( currSum , 0 ) + 1 ) ; } return res ; }
int summingSeries ( long n ) { int s = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { s += i * i - ( i - 1 ) * ( i - 1 ) ; } return s ; }
void shuffleArray ( int [ ] a , int f , int l ) { if ( l > f ) { return ; } if ( l - f == 1 ) { return ; } int mid = ( f + l ) / 2 ; int ptr = mid + 1 ; int mmid = ( f + mid ) / 2 ; for ( int i = mmid + 1 ; i <= mid ; i ++ ) { int temp = a [ i ] ; a [ i ] = a [ ptr ] ; a [ ptr ++ ] = temp ; } shufleArray ( a , f , mid ) ; shufleArray ( a , mid + 1 , l ) ; }
int gcdExtended ( int a , int b , int [ ] x , int [ ] y ) { if ( a == 0 ) { x [ 0 ] = 0 ; y [ 0 ] = 0 ; return b ; } int [ ] x1 = { 1 } ; int [ ] y1 = { 1 } ; int gcd = gcdExtended ( b % a , a , x1 , y1 ) ; x [ 0 ] = y1 [ 0 ] - ( b / a ) * x1 [ 0 ] ; y [ 0 ] = x1 [ 0 ] ; return gcd ; }
void generateGrayArr ( int n ) { if ( n <= 0 ) { return ; } List < String > arr = new ArrayList <> ( ) ; arr . add ( " 0 " ) ; arr . add ( " 1 " ) ; for ( int i = 2 ; i < ( 1 << n ) ; i = i << 1 ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { arr . add ( arr . get ( j ) ) ; } for ( int j = 0 ; j < i ; j ++ ) { arr . set ( j , " 0 " + arr . get ( j ) ) ; } for ( int j = i ; j < 2 * i ; j ++ ) { arr . set ( j , " 1 " + arr . get ( j ) ) ; } } for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { System . out . println ( arr . get ( i ) ) ; } }
int divSum ( int num ) { int result = 0 ; for ( int i = 2 ; i <= Math . sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == num / i ) { result += i ; } else { result += i + num / i ; } } } return result + 1 ; }
int lcis ( int [ ] arr1 , int n , int [ ] arr2 , int m ) { int [ ] table = new int [ m ] ; for ( int j = 0 ; j < m ; j ++ ) { table [ j ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { int current = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) { if ( current + 1 > table [ j ] ) { table [ j ] = current + 1 ; } } if ( arr1 [ i ] > arr2 [ j ] ) { if ( table [ j ] > current ) { current = table [ j ] ; } } } } int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( table [ i ] > result ) { result = table [ i ] ; } } return result ; }
boolean find3Numbers ( int [ ] a , int arrSize , int sum ) { for ( int i = 0 ; i < arrSize - 2 ; i ++ ) { HashSet < Integer > s = new HashSet <> ( ) ; int currSum = sum - a [ i ] ; for ( int j = i + 1 ; j < arrSize ; j ++ ) { if ( s . contains ( currSum - a [ j ] ) ) { System . out . printf ( " Triplet ▁ is ▁ % d , ▁ % d , ▁ % d " , a [ i ] , a [ j ] , currSum - a [ j ] ) ; return true ; } s . add ( a [ j ] ) ; } } return false ; }
String multiply ( String num1 , String num2 ) { int len1 = num1. length ( ) ; int len2 = num2. length ( ) ; if ( len1 == 0 || len2 == 0 ) { return " 0 " ; } List < Integer > result = new ArrayList <> ( Collections . nCopies ( len1 + len2 , 0 ) ) ; int iN1 = 0 ; int iN2 = 0 ; for ( int i = len1 - 1 ; i >= 0 ; i -- ) { int carry = 0 ; int n1 = num1. charAt ( i ) - ' 0 ' ; iN2 = 0 ; for ( int j = len2 - 1 ; j >= 0 ; j -- ) { int n2 = num2. charAt ( j ) - ' 0 ' ; int sum = n1 * n2 + result . get ( iN1 + iN2 ) + carry ; carry = sum / 10 ; result . set ( iN1 + iN2 , sum % 10 ) ; iN2 ++ ; } if ( carry > 0 ) { result [ iN1 + iN2 ] += carry ; } iN1 ++ ; } int i = result . length - 1 ; while ( i >= 0 && result [ i ] == 0 ) { i -- ; } if ( i == - 1 ) { return " 0 " ; } StringBuilder s = new StringBuilder ( ) ; while ( i >= 0 ) { s . append ( result [ i -- ] ) ; } return s . toString ( ) ; }
int modFact ( int n , int p ) { if ( n >= p ) { return 0 ; } int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { result = ( result * i ) % p ; } return result ; }
void sortString ( String str ) { int [ ] charCount = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { charCount [ str . charAt ( i ) - ' a ' ] ++ ; } for ( int i = MAX_CHAR - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < charCount [ i ] ; j ++ ) { System . out . print ( ( char ) ( ' a ' + i ) ) ; } } }
int countFact ( int low , int high ) { int fact = 1 , x = 1 ; while ( fact < low ) { fact = fact * x ; x ++ ; } int res = 0 ; while ( fact <= high ) { res ++ ; fact = fact * x ; x ++ ; } return res ; }
float areaOfSegment ( float radius , float angle ) { float areaOfSector = ( float ) Math . PI * ( radius * radius ) * ( angle / 360 ) ; float areaOfTriangle = ( float ) 1 / 2 * ( radius * radius ) * ( float ) Math . sin ( ( angle * pi ) / 180 ) ; return areaOfSector - areaOfTriangle ; }
void printPrevSmaller ( int [ ] arr , int n ) { Stack < Integer > s = new Stack <> ( ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( ! s . empty ( ) && s . peek ( ) >= arr [ i ] ) { s . pop ( ) ; } if ( s . empty ( ) ) { System . out . print ( " _ , ▁ " ) ; } else { System . out . print ( s . peek ( ) + " , ▁ " ) ; } s . push ( arr [ i ] ) ; } }
boolean checkStar ( int [ ] [ ] mat ) { int vertexD1 = 0 , vertexDn1 = 0 ; if ( arrSize == 1 ) { return ( mat [ 0 ] [ 0 ] == 0 ) ; } if ( arrSize == 2 ) { return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 0 ] == 1 && mat [ 1 ] [ 1 ] == 0 ) ; } for ( int i = 0 ; i < arrSize ; i ++ ) { int degreeI = 0 ; for ( int j = 0 ; j < arrSize ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { degreeI ++ ; } } if ( degreeI == 1 ) { vertexD1 ++ ; } else if ( degreeI == arrSize - 1 ) { vertexDn1 ++ ; } } return vertexD1 == ( arrSize - 1 ) && vertexDn1 == 1 ; }
void computeTotient ( int n ) { long [ ] phi = new long [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { phi [ i ] = i ; } for ( int p = 2 ; p <= n ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i <= n ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } for ( int i = 1 ; i <= n ; i ++ ) { System . out . println ( " Totient ▁ of ▁ " + i + " ▁ is ▁ " + phi [ i ] ) ; } }
int findIndex ( int n ) { float fibo = ( float ) ( 2.078087 * Math . log ( n ) + 1.672276 ) ; return Math . round ( fibo ) ; }
void midPoint ( int x1 , int y1 , int x2 , int y2 ) { int dx = x2 - x1 ; int dy = y2 - y1 ; int d = dy - ( dx / 2 ) ; int x = x1 , y = y1 ; System . out . println ( x + " , " + y ) ; while ( x < x2 ) { x ++ ; if ( d < 0 ) { d = d + dy ; } else { d += ( dy - dx ) ; y ++ ; } System . out . println ( x + " , " + y ) ; } }
boolean isPossible ( int n , int index , int sum , int m , int [ ] arr , int [ ] [ ] dp ) { if ( index == n ) { if ( ( sum % m ) == 0 ) { return true ; } return false ; } else if ( sum < 0 || sum >= MAX ) { return false ; } if ( dp [ index ] [ sum ] != - 1 ) { return dp [ index ] [ sum ] == 0 ; } boolean placeAdd = isPossible ( n , index + 1 , sum + arr [ index ] , m , arr , dp ) ; boolean placeMinus = isPossible ( n , index + 1 , sum - arr [ index ] , m , arr , dp ) ; boolean res = placeAdd || placeMinus ; dp [ index ] [ sum ] = ( res ) ? 1 : 0 ; return res ; }
void rearrangeArr ( int [ ] arr , int n ) { int evenPos = n / 2 ; int oddPos = n - evenPos ; int [ ] tempArr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { tempArr [ i ] = arr [ i ] ; } Arrays . sort ( tempArr ) ; int j = oddPos - 1 ; for ( int i = 0 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j -- ; } j = oddPos ; for ( int i = 1 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j ++ ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } }
void printFirstNegativeInteger ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i < ( n - k + 1 ) ; i ++ ) { boolean flag = false ; for ( int j = 0 ; j < k ; j ++ ) { if ( arr [ i + j ] < 0 ) { System . out . print ( ( arr [ i + j ] ) + " ▁ " ) ; flag = true ; break ; } } if ( ! flag ) { System . out . print ( " 0 " + " ▁ " ) ; } } }
String sortString ( String str ) { char [ ] tempArray = str . toCharArray ( ) ; Arrays . sort ( tempArray ) ; return String . valueOf ( tempArray ) ; }
boolean pairWiseConsecutive ( Stack < Integer > s ) { Stack < Integer > aux = new Stack <> ( ) ; while ( ! s . isEmpty ( ) ) { aux . push ( s . peek ( ) ) ; s . pop ( ) ; } boolean result = true ; while ( aux . size ( ) > 1 ) { int x = aux . peek ( ) ; aux . pop ( ) ; int y = aux . peek ( ) ; aux . pop ( ) ; if ( Math . abs ( x - y ) != 1 ) { result = false ; } s . push ( x ) ; s . push ( y ) ; } if ( aux . size ( ) == 1 ) { s . push ( aux . peek ( ) ) ; } return result ; }
String nextGreater ( String str ) { StringBuilder num = new StringBuilder ( str ) ; int l = num . length ( ) ; int i ; for ( i = l - 1 ; i >= 0 ; i -- ) { if ( num . charAt ( i ) == ' 0 ' ) { num . setCharAt ( i , ' 1 ' ) ; break ; } else { num . setCharAt ( i , ' 0 ' ) ; } } if ( i < 0 ) { num . insert ( 0 , ' 1 ' ) ; } return num . toString ( ) ; }
int [ ] restoreTree ( int [ ] start , int [ ] end ) { List < Integer > identity = new ArrayList <> ( Collections . nCopies ( N , 0 ) ) ; for ( int i = 0 ; i < N ; i ++ ) { identity . set ( start [ i ] , i ) ; } List < Integer > parent = new ArrayList <> ( Collections . nCopies ( N , - 1 ) ) ; int currParent = identity . get ( 0 ) ; for ( int j = 1 ; j < N ; j ++ ) { int child = identity . get ( j ) ; if ( end [ child ] - j > 1 ) { parent . set ( child , currParent ) ; currParent = child ; } else { parent . set ( child , currParent ) ; while ( end [ child ] == end [ parent . get ( child ) ] ) { child = parent . get ( child ) ; currParent = parent . get ( child ) ; if ( currParent == identity . get ( 0 ) ) { break ; } } } } for ( int i = 0 ; i < N ; i ++ ) { parent . set ( i , 1 ) ; } return parent ; }
void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int c = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { System . out . print ( c + " ▁ " ) ; c = c * ( line - i ) / i ; } System . out . println ( ) ; } }
int maxSum ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * i ; } return sum ; }
void subsetDifference ( int n ) { int s = n * ( n + 1 ) / 2 ; if ( n % 4 == 0 ) { System . out . println ( " First ▁ subset ▁ sum ▁ = ▁ " + s / 2 ) ; System . out . println ( " Second ▁ subset ▁ sum ▁ = ▁ " + s / 2 ) ; System . out . println ( " Difference ▁ = ▁ " + 0 ) ; } else { if ( n % 4 == 1 || n % 4 == 2 ) { System . out . println ( " First ▁ subset ▁ sum ▁ = ▁ " + s / 2 ) ; System . out . println ( " Second ▁ subset ▁ sum ▁ = ▁ " + ( ( s / 2 ) + 1 ) ) ; System . out . println ( " Difference ▁ = ▁ " + 1 ) ; } else { System . out . println ( " First ▁ subset ▁ sum ▁ = ▁ " + s / 2 ) ; System . out . println ( " Second ▁ subset ▁ sum ▁ = ▁ " + s / 2 ) ; System . out . println ( " Difference ▁ = ▁ " + 0 ) ; } } }
boolean isReversible ( String str ) { int i = 0 , j = str . length ( ) - 1 ; while ( i < j ) { if ( str . charAt ( i ) != str . charAt ( j ) ) { return false ; } i ++ ; j -- ; } return true ; }
boolean getParity ( int n ) { boolean parity = false ; while ( n != 0 ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; }
char maxRepeating ( String str ) { int len = str . length ( ) ; int count = 0 ; char res = str . charAt ( 0 ) ; for ( int i = 0 ; i < len ; i ++ ) { int curCount = 1 ; for ( int j = i + 1 ; j < len ; j ++ ) { if ( str . charAt ( i ) != str . charAt ( j ) ) { break ; } curCount ++ ; } if ( curCount > count ) { count = curCount ; res = str . charAt ( i ) ; } } return res ; }
int seiresSum ( int n , int [ ] a ) { int res = 0 ; for ( int i = 0 ; i < 2 * n ; i ++ ) { if ( int i % 2 == 0 ) { res += a [ i ] * a [ i ] ; } else { res -= a [ i ] * a [ i ] ; } } return res ; }
void printTwoElements ( int [ ] arr , int size ) { System . out . print ( " The ▁ repeating ▁ element ▁ is ▁ " ) ; for ( int i = 0 ; i < size ; i ++ ) { int absVal = Math . abs ( arr [ i ] ) ; if ( arr [ absVal - 1 ] > 0 ) { arr [ absVal - 1 ] = - arr [ absVal - 1 ] ; } else { System . out . println ( absVal ) ; } } System . out . print ( " And ▁ the ▁ missing ▁ element ▁ is ▁ " ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( arr [ i ] > 0 ) { System . out . println ( i + 1 ) ; } } }
boolean isSubSequence ( String str1 , String str2 , int m , int n ) { int j = 0 ; for ( int i = 0 ; i < n && j < m ; i ++ ) { if ( str1. charAt ( j ) == str2. charAt ( i ) ) { j ++ ; } } return ( j == m ) ; }
int sieveOfSundaram ( int n ) { int nNew = ( n - 2 ) / 2 ; boolean [ ] marked = new boolean [ nNew + 1 ] ; for ( int i = 1 ; i <= nNew ; i ++ ) { for ( int j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) { marked [ i + j + 2 * i * j ] = true ; } } if ( n > 2 ) { System . out . print ( 2 + " ▁ " ) ; } for ( int i = 1 ; i <= nNew ; i ++ ) { if ( marked [ i ] == false ) { System . out . print ( 2 * i + 1 + " ▁ " ) ; } } return - 1 ; }
String findTwosComplement ( String s ) { StringBuilder str = new StringBuilder ( s ) ; int n = str . length ( ) ; int i ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == ' 1 ' ) { break ; } } if ( i == - 1 ) { return " 1 " + str ; } for ( int k = i - 1 ; k >= 0 ; k -- ) { if ( str . charAt ( k ) == ' 1 ' ) { str . setCharAt ( k , ' 0 ' ) ; } else { str . setCharAt ( k , ' 1 ' ) ; } } return str . toString ( ) ; }
int smallestSubWithSum ( int [ ] arr , int n , int x ) { int currSum = 0 , minLen = n + 1 ; int start = 0 , end = 0 ; while ( end < n ) { while ( currSum <= x && end < n ) { currSum += arr [ end ++ ] ; } while ( currSum > x && start < n ) { if ( end - start < minLen ) { minLen = end - start ; } currSum -= arr [ start ++ ] ; } } return minLen ; }
int circumference ( int l , int w ) { return 2 * ( l + w ) ; }
void sortString ( String str ) { char [ ] arr = str . toCharArray ( ) ; Arrays . sort ( arr ) ; System . out . print ( String . valueOf ( arr ) ) ; }
int countPair ( int a , int b ) { String s = String . valueOf ( b ) ; int i ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != ' 9 ' ) { break ; } } int result ; if ( i == s . length ( ) ) { result = a * s . length ( ) ; } else { result = a * ( s . length ( ) - 1 ) ; } return result ; }
int minOperations ( String str , int n ) { int i , lastUpper = - 1 , firstLower = - 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( Character . isUpperCase ( str . charAt ( i ) ) ) { lastUpper = i ; break ; } } for ( i = 0 ; i < n ; i ++ ) { if ( Character . isLowerCase ( str . charAt ( i ) ) ) { firstLower = i ; break ; } } if ( lastUpper == - 1 || firstLower == - 1 ) { return 0 ; } int countUpper = 0 ; for ( i = firstLower ; i < n ; i ++ ) { if ( Character . isUpperCase ( str . charAt ( i ) ) ) { countUpper ++ ; } } int countLower = 0 ; for ( i = 0 ; i < lastUpper ; i ++ ) { if ( Character . isLowerCase ( str . charAt ( i ) ) ) { countLower ++ ; } } return Math . min ( countLower , countUpper ) ; }
int findSmallest ( int [ ] arr , int n ) { int res = 1 ; for ( int i = 0 ; i < n && arr [ i ] <= res ; i ++ ) { res = res + arr [ i ] ; } return res ; }
void printMaxOfMin ( int [ ] arr , int n ) { Stack < Integer > s = new Stack <> ( ) ; int [ ] left = new int [ n + 1 ] ; int [ ] right = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] = - 1 ; right [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { while ( ! s . empty ( ) && arr [ s . peek ( ) ] >= arr [ i ] ) { s . pop ( ) ; } if ( ! s . empty ( ) ) { left [ i ] = s . peek ( ) ; } s . push ( i ) ; } while ( ! s . empty ( ) ) { s . pop ( ) ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( ! s . empty ( ) && arr [ s . peek ( ) ] >= arr [ i ] ) { s . pop ( ) ; } if ( ! s . empty ( ) ) { right [ i ] = s . peek ( ) ; } s . push ( i ) ; } int [ ] ans = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { ans [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { int len = right [ i ] - left [ i ] - 1 ; ans [ len ] = Math . max ( ans [ len ] , arr [ i ] ) ; } for ( int i = n - 1 ; i >= 1 ; i -- ) { ans [ i ] = Math . max ( ans [ i ] , ans [ i + 1 ] ) ; } for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( ans [ i ] + " ▁ " ) ; } }
int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
int add ( int x , int y ) { while ( y != 0 ) { int carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; }
void reverseSpiralPrint ( int m , int n , int [ ] [ ] a ) { long [ ] b = new long [ 100 ] ; int k = 0 , l = 0 , z = 0 ; int size = m * n ; while ( k < m && l < n ) { int val ; for ( int i = l ; i < n ; ++ i ) { val = a [ k ] [ i ] ; b [ z ] = val ; ++ z ; } k ++ ; for ( int i = k ; i < m ; ++ i ) { val = a [ i ] [ n - 1 ] ; b [ z ] = val ; ++ z ; } n -- ; if ( k < m ) { for ( int i = n - 1 ; i >= l ; -- i ) { val = a [ m - 1 ] [ i ] ; b [ z ] = val ; ++ z ; } m -- ; } if ( l < n ) { for ( int i = m - 1 ; i >= k ; -- i ) { val = a [ i ] [ l ] ; b [ z ] = val ; ++ z ; } l ++ ; } } for ( int x = size - 1 ; x >= 0 ; -- x ) { System . out . print ( b [ x ] + " ▁ " ) ; } }
int maximumHeight ( int [ ] a , int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { long y = ( i * ( i + 1 ) ) / 2 ; if ( y < n ) { result = i ; } else { break ; } } return result ; }
boolean pairInSortedRotated ( int [ ] arr , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { break ; } } int l = ( i + 1 ) % n ; int r = i ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { return true ; } if ( arr [ l ] + arr [ r ] < x ) { l = ( l + 1 ) % n ; } else { r = ( n + r - 1 ) % n ; } } return false ; }
int maxSubArraySum ( int [ ] a , int size ) { int maxSoFar = a [ 0 ] ; int currMax = a [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { currMax = Math . max ( a [ i ] , currMax + a [ i ] ) ; maxSoFar = Math . max ( maxSoFar , currMax ) ; } return maxSoFar ; }
int minOperation ( int [ ] a , int n , int k ) { int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] != 1 && a [ i ] > k ) { result = result + Math . min ( a [ i ] % k , k - a [ i ] % k ) ; } else { result = result + k - a [ i ] ; } } return result ; }
int minElements ( Integer [ ] arr , int n ) { int halfSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { halfSum = halfSum + arr [ i ] ; } halfSum = halfSum / 2 ; Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; int res = 0 , currSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currSum += arr [ i ] ; res ++ ; if ( currSum > halfSum ) { return res ; } } return res ; }
double areaOfInscribedCircle ( float a ) { return ( Math . PI / 4 ) * a * a ; }
void maxSubArraySum ( int [ ] a , int size ) { int maxSoFar = Integer . MIN_VALUE ; int maxEndingHere = 0 , start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < size ; i ++ ) { maxEndingHere += a [ i ] ; if ( maxSoFar < maxEndingHere ) { maxSoFar = maxEndingHere ; start = s ; end = i ; } if ( maxEndingHere < 0 ) { maxEndingHere = 0 ; s = i + 1 ; } } System . out . println ( " Maximum ▁ contiguous ▁ sum ▁ is ▁ " + maxSoFar ) ; System . out . println ( " Starting ▁ index ▁ " + start ) ; System . out . println ( " Ending ▁ index ▁ " + end ) ; }
int subsetGraph ( int [ ] [ ] c ) { TreeSet < Integer > vertices = new TreeSet <> ( ) ; for ( int i = 0 ; i < N ; ++ i ) { vertices . add ( i ) ; } while ( ! vertices . isEmpty ( ) ) { if ( vertices . size ( ) == 1 ) { return 1 ; } boolean someoneRemoved = false ; for ( int x : vertices ) { TreeSet < Integer > values = new TreeSet <> ( ) ; for ( int y : vertices ) { if ( y != x ) { values . add ( c [ x ] [ y ] ) ; } } if ( values . size ( ) == 1 ) { vertices . remove ( x ) ; someoneRemoved = true ; break ; } } if ( ! someoneRemoved ) { break ; } } return vertices . size ( ) ; }
int maxXor ( int [ ] [ ] mat , int n ) { int maxXor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int rXor = 0 , cXor = 0 ; for ( int j = 0 ; j < n ; j ++ ) { rXor = rXor ^ mat [ i ] [ j ] ; cXor = cXor ^ mat [ j ] [ i ] ; } if ( maxXor < Math . max ( rXor , cXor ) ) { maxXor = Math . max ( rXor , cXor ) ; } } return maxXor ; }
int countSubsequences ( String s ) { int aCount = 0 , bCount = 0 , cCount = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' a ' ) { aCount = 1 + 2 * aCount ; } else if ( s . charAt ( i ) == ' b ' ) { bCount = aCount + 2 * bCount ; } else if ( s . charAt ( i ) == ' c ' ) { cCount = bCount + 2 * cCount ; } } return cCount ; }
int maximumChars ( String str ) { int n = str . length ( ) ; int res = - 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( str . charAt ( i ) == str . charAt ( j ) ) { res = Math . max ( res , Math . abs ( j - i - 1 ) ) ; } } } return res ; }
void printRoots ( int n ) { double theta = Math . PI * 2 / n ; for ( int k = 0 ; k < n ; k ++ ) { double real = Math . cos ( k * theta ) ; double img = Math . sin ( k * theta ) ; System . out . println ( real ) ; if ( img >= 0 ) { System . out . println ( " ▁ + ▁ i ▁ " ) ; } else { System . out . println ( " ▁ - ▁ i ▁ " ) ; } System . out . println ( Math . abs ( img ) ) ; } }
int sieveOfAtkin ( int limit ) { if ( limit > 2 ) { System . out . print ( 2 + " ▁ " ) ; } if ( limit > 3 ) { System . out . print ( 3 + " ▁ " ) ; } boolean [ ] sieve = new boolean [ limit ] ; for ( int x = 1 ; x * x < limit ; x ++ ) { for ( int y = 1 ; y * y < limit ; y ++ ) { int n = ( 4 * x * x ) + ( y * y ) ; if ( n <= limit && ( n % 12 == 1 || n % 12 == 5 ) ) { sieve [ n ] ^= true ; } n = ( 3 * x * x ) + ( y * y ) ; if ( n <= limit && n % 12 == 7 ) { sieve [ n ] ^= true ; } n = ( 3 * x * x ) - ( y * y ) ; if ( x > y && n <= limit && n % 12 == 11 ) { sieve [ n ] ^= true ; } } } for ( int r = 5 ; r * r < limit ; r ++ ) { if ( sieve [ r ] ) { for ( int i = r * r ; i < limit ; i += r * r ) { sieve [ i ] = false ; } } } for ( int a = 5 ; a < limit ; a ++ ) { if ( sieve [ a ] ) { System . out . print ( a + " ▁ " ) ; } } return 0 ; }
int smallestKFreq ( int [ ] a , int n , int k ) { HashMap < Integer , Integer > m = new HashMap <> ( ) ; for ( int i = 0 ; i < n ; i ++ ) { m . put ( a [ i ] , m . getOrDefault ( a [ i ] , 0 ) + 1 ) ; } int res = Integer . MAX_VALUE ; for ( var it : m . entrySet ( ) ) { if ( it . getValue ( ) == k ) { res = Math . min ( res , it . getKey ( ) ) ; } } return ( res != Integer . MAX_VALUE ) ? res : - 1 ; }
int minimumFlip ( int [ ] [ ] mat , int n ) { int [ ] [ ] transpose = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { transpose [ i ] [ j ] = mat [ j ] [ i ] ; } } int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( transpose [ i ] [ j ] != mat [ i ] [ j ] ) { flip ++ ; } } } return flip / 2 ; }
void minAbsSumPair ( int [ ] arr , int arrSize ) { int invCount = 0 ; if ( arrSize < 2 ) { System . out . println ( " Invalid ▁ Input " ) ; return ; } int minL = 0 ; int minR = 1 ; int minSum = arr [ 0 ] + arr [ 1 ] ; for ( int l = 0 ; l < arrSize - 1 ; l ++ ) { for ( int r = l + 1 ; r < arrSize ; r ++ ) { int sum = arr [ l ] + arr [ r ] ; if ( Math . abs ( minSum ) > Math . abs ( sum ) ) { minSum = sum ; minL = l ; minR = r ; } } } System . out . println ( " ▁ The ▁ two ▁ elements ▁ whose ▁ " + " sum ▁ is ▁ minimum ▁ are ▁ " + arr [ minL ] + " ▁ and ▁ " + arr [ minR ] ) ; }
void maxProduct ( int [ ] arr , int n ) { if ( n < 2 ) { System . out . println ( " No ▁ pairs ▁ exists " ) ; return ; } int a = arr [ 0 ] , b = arr [ 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] * arr [ j ] > a * b ) { a = arr [ i ] ; b = arr [ j ] ; } } } System . out . println ( " Max ▁ product ▁ pair ▁ is ▁ { " + a + " , ▁ " + b + " } " ) ; }
int pageFaults ( int [ ] pages , int n , int capacity ) { HashSet < Integer > s = new HashSet <> ( capacity ) ; Queue < Integer > indexes = new ArrayDeque <> ( ) ; int pageFaults = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . size ( ) < capacity ) { if ( ! s . contains ( pages [ i ] ) ) { s . add ( pages [ i ] ) ; pageFaults ++ ; indexes . add ( pages [ i ] ) ; } } else { if ( ! s . contains ( pages [ i ] ) ) { int val = indexes . peek ( ) ; indexes . poll ( ) ; s . remove ( val ) ; s . add ( pages [ i ] ) ; indexes . add ( pages [ i ] ) ; pageFaults ++ ; } } } return pageFaults ; }
int nextFit ( int [ ] weight , int n , int c ) { int res = 0 , binRem = c ; for ( int i = 0 ; i < n ; i ++ ) { if ( weight [ i ] > binRem ) { res ++ ; binRem = c - weight [ i ] ; } else { binRem -= weight [ i ] ; } } return res ; }
int countPairs ( int [ ] arr1 , int [ ] arr2 , int m , int n , int x ) { int count = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { l ++ ; r -- ; count ++ ; } else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) { l ++ ; } else { r -- ; } } return count ; }
float circumferenceParallelogram ( float a , float b ) { return ( 2 * a ) + ( 2 * b ) ; }
void print ( int n , int k ) { int rem = 1 ; for ( int i = 0 ; i < k ; i ++ ) { System . out . print ( ( 10 * rem ) / n ) ; rem = ( 10 * rem ) % n ; } }
String findString ( int n , int k ) { StringBuilder res = new StringBuilder ( ) ; for ( int i = 0 ; i < k ; i ++ ) { res . append ( ( char ) ( ' a ' + i ) ) ; } int count = 0 ; for ( int i = 0 ; i < n - k ; i ++ ) { res . append ( ( char ) ( ' a ' + count ) ) ; count ++ ; if ( count == k ) { count = 0 ; } } return res . toString ( ) ; }
boolean checkForSorting ( int [ ] arr , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) { int temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } else { return false ; } } } return true ; }
int round ( int n ) { int a = ( n / 10 ) * 10 ; int b = a + 10 ; return ( n - a > b - n ) ? b : a ; }
int getRemainder ( int num , int divisor ) { if ( divisor == 0 ) { System . out . println ( " Error : ▁ divisor ▁ " + " can ' t ▁ be ▁ zero ▁ " ) ; return - 1 ; } if ( divisor < 0 ) { divisor = - divisor ; } if ( num < 0 ) { num = - num ; } int i = 1 ; int product = 0 ; while ( product <= num ) { product = divisor * i ; i ++ ; } return num - ( product - divisor ) ; }
int unitDigitXRaisedY ( int x , int y ) { int res = 1 ; for ( int i = 0 ; i < y ; i ++ ) { res = ( res * x ) % 10 ; } return res ; }
int costToBalance ( String s ) { if ( s . length ( ) == 0 ) { System . out . println ( 0 ) ; } int ans = 0 ; int o = 0 , c = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' ( ' ) { o ++ ; } if ( s . charAt ( i ) == ' ) ' ) { c ++ ; } } if ( o != c ) { return - 1 ; } int [ ] a = new int [ s . length ( ) ] ; if ( s . charAt ( 0 ) == ' ( ' ) { a [ 0 ] = 1 ; } else { a [ 0 ] = - 1 ; } if ( a [ 0 ] < 0 ) { ans += Math . abs ( a [ 0 ] ) ; } for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' ( ' ) { a [ i ] = a [ i - 1 ] + 1 ; } else { a [ i ] = a [ i - 1 ] - 1 ; } if ( a [ i ] < 0 ) { ans += Math . abs ( a [ i ] ) ; } } return ans ; }
int maxSubArraySum ( int [ ] a , int size ) { int maxSoFar = Integer . MIN_VALUE , maxEndingHere = 0 ; for ( int i = 0 ; i < size ; i ++ ) { maxEndingHere = maxEndingHere + a [ i ] ; if ( maxSoFar < maxEndingHere ) { maxSoFar = maxEndingHere ; } if ( maxEndingHere < 0 ) { maxEndingHere = 0 ; } } return maxSoFar ; }
int countSub ( int [ ] arr , int n ) { int [ ] count = new int [ 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - 1 ; j >= 0 ; j -- ) { count [ arr [ i ] ] += count [ j ] ; } count [ arr [ i ] ] ++ ; } int result = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { result += count [ i ] ; } return result ; }
int countMinReversals ( String expr ) { int len = expr . length ( ) ; if ( len % 2 != 0 ) { return - 1 ; } Stack < Character > s = new Stack <> ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( expr . charAt ( i ) == ' } ' && ! s . empty ( ) ) { if ( s . peek ( ) == ' { ' ) { s . pop ( ) ; } else { s . push ( expr . charAt ( i ) ) ; } } else { s . push ( expr . charAt ( i ) ) ; } } int redLen = s . size ( ) ; int n = 0 ; while ( ! s . empty ( ) && s . peek ( ) == ' { ' ) { s . pop ( ) ; n ++ ; } return redLen / 2 + n % 2 ; }
boolean printPairs ( int [ ] arr , int n , int k ) { boolean isPairFound = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && arr [ i ] % arr [ j ] == k ) { System . out . print ( " ( " + arr [ i ] + " , ▁ " + arr [ j ] + " ) " + " ▁ " ) ; isPairFound = true ; } } } return isPairFound ; }
int findRepeatFirst ( String s ) { int p = - 1 ; int MAX_CHAR = 256 ; int [ ] hash = new int [ MAX_CHAR ] ; int [ ] pos = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int k = s . charAt ( i ) ; if ( hash [ k ] == 0 ) { hash [ k ] ++ ; pos [ k ] = i ; } else if ( hash [ k ] == 1 ) { hash [ k ] ++ ; } } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( hash [ i ] == 2 ) { if ( p == - 1 ) { p = pos [ i ] ; } else if ( p > pos [ i ] ) { p = pos [ i ] ; } } } return p ; }
int countSetBitsRec ( int num ) { int nibble = 0 ; if ( 0 == num ) { return numToBits [ 0 ] ; } nibble = num & 0xf ; return numToBits [ nibble ] + countSetBitsRec ( num >> 4 ) ; }
int getSum ( int n ) { int sum ; for ( sum = 0 ; n > 0 ; sum += n % 10 , n /= 10 ) ; return sum ; }
int countPaths ( int n , int m ) { int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = 1 ; } for ( int i = 0 ; i <= m ; i ++ ) { dp [ 0 ] [ i ] = 1 ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; } } return dp [ n ] [ m ] ; }
int factorial ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { res *= i ; } return res ; }
void printDiagonalSums ( int [ ] [ ] mat , int n ) { int principal = 0 , secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) { principal += mat [ i ] [ j ] ; } if ( i + j == n - 1 ) { secondary += mat [ i ] [ j ] ; } } } System . out . println ( " Principal ▁ Diagonal : " + principal ) ; System . out . println ( " Secondary ▁ Diagonal : " + secondary ) ; }
int countIntegralSolutions ( int n ) { return ( n + 1 ) * ( n + 2 ) / 2 ; }
int findPlatform ( int [ ] arr , int [ ] dep , int n ) { Arrays . sort ( arr ) ; Arrays . sort ( dep ) ; int platNeeded = 1 , result = 1 ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arr [ i ] <= dep [ j ] ) { platNeeded ++ ; i ++ ; if ( platNeeded > result ) { result = platNeeded ; } } else { platNeeded -- ; j ++ ; } } return result ; }
boolean modularSum ( int [ ] arr , int n , int m ) { if ( n > m ) { return true ; } boolean [ ] dp = new boolean [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ 0 ] ) { return true ; } boolean [ ] temp = new boolean [ m ] ; for ( int j = 0 ; j < m ; j ++ ) { if ( dp [ j ] == true ) { if ( dp [ ( j + arr [ i ] ) % m ] == false ) { temp [ ( j + arr [ i ] ) % m ] = true ; } } } for ( int j = 0 ; j < m ; j ++ ) { if ( temp [ j ] ) { dp [ j ] = true ; } } dp [ arr [ i ] % m ] = true ; } return dp [ 0 ] ; }
int sumOfLargePrimeFactor ( int n ) { int [ ] prime = new int [ n + 1 ] ; int sum = 0 ; int max = n / 2 ; for ( int p = 2 ; p <= max ; p ++ ) { if ( prime [ p ] == 0 ) { for ( int i = p * 2 ; i <= n ; i += p ) { prime [ i ] = p ; } } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] != 0 ) { sum += prime [ p ] ; } else { sum += p ; } } return sum ; }
int minJumps ( int a , int b , int d ) { int temp = a ; a = Math . min ( a , b ) ; b = Math . max ( temp , b ) ; if ( d >= b ) { return ( d + b - 1 ) / b ; } if ( d == 0 ) { return 0 ; } if ( d == a ) { return 1 ; } return 2 ; }
int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }
void permutatedRows ( int [ ] [ ] mat , int m , int n , int r ) { HashSet < Integer > s = new HashSet <> ( ) ; for ( int j = 0 ; j < n ; j ++ ) { s . add ( mat [ r ] [ j ] ) ; } for ( int i = 0 ; i < m ; i ++ ) { if ( i == r ) { continue ; } int j ; for ( j = 0 ; j < n ; j ++ ) { if ( ! s . contains ( mat [ i ] [ j ] ) ) { break ; } } if ( j != n ) { continue ; } System . out . print ( i + " , ▁ " ) ; } }
void printSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = i * ( i + 1 ) * ( i + 2 ) / 6 ; System . out . print ( num + " ▁ " ) ; } }
void zigZag ( int rows , int columns , int [ ] numbers ) { int k = 0 ; int [ ] [ ] arr = new int [ rows ] [ columns ] ; for ( int i = 0 ; i < rows ; i ++ ) { if ( i % 2 == 0 ) { for ( int j = 0 ; j < columns && numbers [ k ] > 0 ; j ++ ) { arr [ i ] [ j ] = k + 1 ; numbers [ k ] -- ; if ( numbers [ k ] == 0 ) { k ++ ; } } } else { for ( int j = columns - 1 ; j >= 0 && numbers [ k ] > 0 ; j -- ) { arr [ i ] [ j ] = k + 1 ; numbers [ k ] -- ; if ( numbers [ k ] == 0 ) { k ++ ; } } } } for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < columns ; j ++ ) { System . out . print ( arr [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; } }
int findElement ( int [ ] arr , int [ ] [ ] ranges , int rotations , int index ) { for ( int i = rotations - 1 ; i >= 0 ; i -- ) { int left = ranges [ i ] [ 0 ] ; int right = ranges [ i ] [ 1 ] ; if ( left <= index && right >= index ) { if ( index == left ) { index = right ; } else { index -- ; } } } return arr [ index ] ; }
String smallestNumber ( String str ) { char [ ] num = str . toCharArray ( ) ; int n = str . length ( ) ; int [ ] rightMin = new int [ n ] ; rightMin [ n - 1 ] = - 1 ; int right = n - 1 ; for ( int i = n - 2 ; i >= 1 ; i -- ) { if ( num [ i ] > num [ right ] ) { rightMin [ i ] = right ; } else { rightMin [ i ] = - 1 ; right = i ; } } int small = - 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( num [ i ] != ' 0 ' ) { if ( small == - 1 ) { if ( num [ i ] < num [ 0 ] ) { small = i ; } } else if ( num [ i ] < num [ small ] ) { small = i ; } } } if ( small != - 1 ) { char temp = num [ 0 ] ; num [ 0 ] = num [ small ] ; num [ small ] = temp ; } else { for ( int i = 1 ; i < n ; i ++ ) { if ( rightMin [ i ] != - 1 ) { char temp = num [ i ] ; num [ i ] = num [ rightMin [ i ] ] ; num [ rightMin [ i ] ] = temp ; break ; } } } return String . valueOf ( num ) ; }
int countPaths ( int [ ] [ ] maze ) { if ( maze [ 0 ] [ 0 ] == - 1 ) { return 0 ; } for ( int i = 0 ; i < ROW ; i ++ ) { if ( maze [ i ] [ 0 ] == 0 ) { maze [ i ] [ 0 ] = 1 ; } else { break ; } } for ( int i = 1 ; i < COL ; i ++ ) { if ( maze [ 0 ] [ i ] == 0 ) { maze [ 0 ] [ i ] = 1 ; } else { break ; } } for ( int i = 1 ; i < ROW ; i ++ ) { for ( int j = 1 ; j < COL ; j ++ ) { if ( maze [ i ] [ j ] == - 1 ) { continue ; } if ( maze [ i - 1 ] [ j ] > 0 ) { maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) ; } if ( maze [ i ] [ j - 1 ] > 0 ) { maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) ; } } } return Math . max ( maze [ ROW - 1 ] [ COL - 1 ] , 0 ) ; }
void minMaxLengthWords ( String input , String [ ] minWord , String [ ] maxWord ) { int len = input . length ( ) ; int si = 0 , ei = 0 ; int minLength = len , minStartIndex = 0 , maxLength = 0 , maxStartIndex = 0 ; while ( ei <= len ) { if ( ei < len && input . charAt ( ei ) != ' ▁ ' ) { ei ++ ; } else { int currLength = ei - si ; if ( currLength < minLength ) { minLength = currLength ; minStartIndex = si ; } if ( currLength > maxLength ) { maxLength = currLength ; maxStartIndex = si ; } ei ++ ; si = ei ; } } minWord [ 0 ] = input . substring ( minStartIndex , minStartIndex + minLength ) ; maxWord [ 0 ] = input . substring ( maxStartIndex , maxStartIndex + maxLength ) ; }
float findVolume ( float l , float b , float h ) { float volume = ( l * b * h ) / 2 ; return volume ; }
String sortString ( String str , int n ) { StringBuilder newStr = new StringBuilder ( ) ; for ( int i = ' a ' ; i <= ' z ' ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( str . charAt ( j ) == i ) { newStr . append ( str . charAt ( j ) ) ; } } } return newStr . toString ( ) ; }
int countTrees ( int n ) { int [ ] bt = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { bt [ i ] = 0 ; } bt [ 0 ] = bt [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) { for ( int j = 0 ; j < i ; j ++ ) { bt [ i ] += bt [ j ] * bt [ i - j - 1 ] ; } } return bt [ n ] ; }
void getPairsCount ( int [ ] arr , int sum ) { int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = i + 1 ; j < arr . length ; j ++ ) { if ( arr [ i ] + arr [ j ] == sum ) { count ++ ; } } } }
boolean check ( String str ) { int n = str . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { digitSum += ( str . charAt ( i ) - ' 0 ' ) ; } return digitSum % 3 == 0 ; }
int lcSubStr ( String x , String y ) { int m = x . length ( ) ; int n = y . length ( ) ; int result = 0 ; int [ ] [ ] len = new int [ 2 ] [ n ] ; int currRow = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 || j == 0 ) { len [ currRow ] [ j ] = 0 ; } else if ( x . charAt ( i - 1 ) == y . charAt ( j - 1 ) ) { len [ currRow ] [ j ] = len [ ( 1 - currRow ) ] [ ( j - 1 ) ] + 1 ; result = Math . max ( result , len [ currRow ] [ j ] ) ; } else { len [ currRow ] [ j ] = 0 ; } } currRow = 1 - currRow ; } return result ; }
int removeConsecutiveSame ( List < String > v ) { int n = v . size ( ) ; for ( int i = 0 ; i < n - 1 ; ) { if ( v . get ( i ) . equals ( v . get ( i + 1 ) ) ) { v . remove ( i ) ; v . remove ( i ) ; if ( i > 0 ) { i -- ; } n = n - 2 ; } else { i ++ ; } } return v . size ( ) ; }
int perimeter ( int diameter , int height ) { return 2 * ( diameter + height ) ; }
boolean isPossibleToMakeDivisible ( int [ ] arr , int n ) { int remainder = 0 ; for ( int i = 0 ; i < n ; i ++ ) { remainder = ( remainder + arr [ i ] ) % 3 ; } return remainder == 0 ; }
int getInvCount ( int [ ] arr , int n ) { int invCount = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ j ] > arr [ k ] ) { invCount ++ ; } } } } } return invCount ; }
void bin ( int n ) { if ( n > 1 ) { bin ( n / 2 ) ; } System . out . print ( n % 2 ) ; }
int minSum ( int [ ] ar , int n ) { if ( n <= 4 ) { return Arrays . stream ( ar ) . min ( ) . getAsInt ( ) ; } Integer [ ] sum = new Integer [ n ] ; sum [ 0 ] = ar [ 0 ] ; sum [ 1 ] = ar [ 1 ] ; sum [ 2 ] = ar [ 2 ] ; sum [ 3 ] = ar [ 3 ] ; for ( int i = 4 ; i < n ; i ++ ) { sum [ i ] = ar [ i ] + Collections . min ( Arrays . asList ( sum ) . subList ( i - 4 , i ) ) ; } return Collections . min ( Arrays . asList ( sum ) . subList ( n - 4 , n ) ) ; }
boolean findTriplet ( int [ ] a1 , int [ ] a2 , int [ ] a3 , int n1 , int n2 , int n3 , int sum ) { for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < n2 ; j ++ ) { for ( int k = 0 ; k < n3 ; k ++ ) { if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) { return true ; } } } } return false ; }
int minDist ( int [ ] arr , int n , int x , int y ) { int i = 0 ; int minDist = Integer . MAX_VALUE ; int prev = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x || arr [ i ] == y ) { prev = i ; break ; } } for ( ; i < n ; i ++ ) { if ( arr [ i ] == x || arr [ i ] == y ) { if ( arr [ prev ] != arr [ i ] && ( i - prev ) < minDist ) { minDist = i - prev ; prev = i ; } else { prev = i ; } } } return minDist ; }
int solve ( int [ ] a , int [ ] b , int n ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s += ( a [ i ] + b [ i ] ) ; } if ( n == 1 ) { return a [ 0 ] + b [ 0 ] ; } if ( s % n != 0 ) { return - 1 ; } int x = s / n ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) { return - 1 ; } if ( i > 0 ) { a [ i ] += b [ i - 1 ] ; b [ i - 1 ] = 0 ; } if ( a [ i ] == x ) { continue ; } int y = a [ i ] + b [ i ] ; if ( i + 1 < n ) { y += b [ i + 1 ] ; } if ( y == x ) { a [ i ] = y ; b [ i ] = 0 ; continue ; } if ( a [ i ] + b [ i ] == x ) { a [ i ] += b [ i ] ; b [ i ] = 0 ; continue ; } if ( i + 1 < n && a [ i ] + b [ i + 1 ] == x ) { a [ i ] += b [ i + 1 ] ; b [ i + 1 ] = 0 ; continue ; } return - 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( b [ i ] != 0 ) { return - 1 ; } } return x ; }
void findString ( String str , int n , int k ) { if ( k == 0 ) { System . out . println ( str ) ; return ; } char [ ] str2 = str . toCharArray ( ) ; int p = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str2 [ i ] != ' a ' ) { str2 [ i ] = ' a ' ; p ++ ; if ( p == k ) { break ; } } } if ( p < k ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == ' a ' ) { str2 [ i ] = ' b ' ; p ++ ; if ( p == k ) { break ; } } } } System . out . println ( String . valueOf ( str2 ) ) ; }
int findLongestRepeatingSubSeq ( String x , int m , int n ) { if ( dp [ m ] [ n ] != - 1 ) { return dp [ m ] [ n ] ; } if ( m == 0 || n == 0 ) { return dp [ m ] [ n ] = 0 ; } if ( x . charAt ( m - 1 ) == x . charAt ( n - 1 ) && m != n ) { return dp [ m ] [ n ] = findLongestRepeatingSubSeq ( x , m - 1 , n - 1 ) + 1 ; } dp [ m ] [ n ] = Math . max ( findLongestRepeatingSubSeq ( x , m , n - 1 ) , findLongestRepeatingSubSeq ( x , m - 1 , n ) ) ; return dp [ m ] [ n ] ; }
int productSubSeqCount ( List < Integer > arr , int k ) { int n = arr . size ( ) ; int [ ] [ ] dp = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; if ( arr . get ( j - 1 ) <= i && arr . get ( j - 1 ) > 0 ) { dp [ i ] [ j ] += dp [ i / arr . get ( j - 1 ) ] [ j - 1 ] + 1 ; } } } return dp [ k ] [ n ] ; }
int pow ( int a , int b ) { if ( b == 0 ) { return 1 ; } int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; }
int [ ] fix ( int [ ] a , int len ) { for ( int i = 0 ; i < len ; i ++ ) { if ( a [ i ] != - 1 && a [ i ] != i ) { int x = a [ i ] ; while ( a [ x ] != - 1 && a [ x ] != x ) { int y = a [ x ] ; a [ x ] = x ; x = y ; } a [ x ] = x ; if ( a [ i ] != i ) { a [ i ] = - 1 ; } } } return a ; }
long calculate ( long [ ] a , int n ) { Arrays . sort ( a ) ; int i , j ; List < Long > s = new ArrayList <> ( ) ; for ( i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { s . add ( ( a [ i ] + a [ j ] ) ) ; } long minI = Collections . min ( s ) ; long maxI = Collections . max ( s ) ; return Math . abs ( maxI - minI ) ; }
double sumOfSeries ( int n ) { return 0.0246 * ( Math . pow ( 10 , n ) - 1 - ( 9 * n ) ) ; }
int calculate ( String s ) { int ans = 6 ; for ( int i = 0 ; i < 10 ; ++ i ) { for ( int j = 0 ; j < 10 ; ++ j ) { for ( int k = 0 ; k < 10 ; ++ k ) { for ( int l = 0 ; l < 10 ; ++ l ) { for ( int m = 0 ; m < 10 ; ++ m ) { for ( int n = 0 ; n < 10 ; ++ n ) { if ( i + j + k == l + m + n ) { int c = 0 ; if ( i != s . charAt ( 0 ) - ' 0 ' ) { c ++ ; } if ( j != s . charAt ( 1 ) - ' 0 ' ) { c ++ ; } if ( k != s . charAt ( 2 ) - ' 0 ' ) { c ++ ; } if ( l != s . charAt ( 3 ) - ' 0 ' ) { c ++ ; } if ( m != s . charAt ( 4 ) - ' 0 ' ) { c ++ ; } if ( n != s . charAt ( 5 ) - ' 0 ' ) { c ++ ; } if ( c < ans ) { ans = c ; } } } } } } } } return ans ; }
int getTotalNumberOfSequences ( int m , int n ) { if ( m < n ) { return 0 ; } if ( n == 0 ) { return 1 ; } return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ; }
void sortInWave ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i += 2 ) { int temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } }
void search ( int [ ] arr , int low , int high ) { if ( low > high ) { return ; } if ( low == high ) { System . out . printf ( " The ▁ required ▁ element ▁ is ▁ % d ▁ " , arr [ low ] ) ; return ; } int mid = ( low + high ) / 2 ; if ( mid % 2 == 0 ) { if ( arr [ mid ] == arr [ mid + 1 ] ) { search ( arr , mid + 2 , high ) ; } else { search ( arr , low , mid ) ; } } else { if ( arr [ mid ] == arr [ mid - 1 ] ) { search ( arr , mid + 1 , high ) ; } else { search ( arr , low , mid - 1 ) ; } } }
boolean check ( String str ) { int n = str . length ( ) ; if ( ( str . charAt ( n - 1 ) - ' 0 ' ) % 2 != 0 ) { return false ; } int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { digitSum += ( str . charAt ( i ) - ' 0 ' ) ; } return digitSum % 3 == 0 ; }
int stirlingFactorial ( double n ) { if ( n == 1 ) { return 1 ; } double e = 2.71 ; double z = Math . sqrt ( 2 * 3.14 * n ) * Math . pow ( ( n / e ) , n ) ; return ( int ) z ; }
boolean checkCount ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] == arr [ i ] ) { count ++ ; } if ( count > 2 * k ) { return false ; } } } return true ; }
boolean areElementsContiguous ( int [ ] arr , int n ) { int max = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int min = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; int m = max - min + 1 ; if ( m > n ) { return false ; } boolean [ ] visited = new boolean [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { visited [ arr [ i ] - min ] = true ; } for ( int i = 0 ; i < m ; i ++ ) { if ( visited [ i ] == false ) { return false ; } } return true ; }
int zigzag ( int n , int k ) { if ( n == 0 && k == 0 ) { return 1 ; } if ( k == 0 ) { return 0 ; } return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) ; }
int lcs ( String x , String y ) { int m = x . length ( ) , n = y . length ( ) ; int [ ] [ ] l = new int [ 2 ] [ n + 1 ] ; int bi = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { bi = i & 1 ; for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 || j == 0 ) { l [ bi ] [ j ] = 0 ; } else if ( x . charAt ( i - 1 ) == y . charAt ( j - 1 ) ) { l [ bi ] [ j ] = l [ 1 - bi ] [ j - 1 ] + 1 ; } else { l [ bi ] [ j ] = Math . max ( l [ 1 - bi ] [ j ] , l [ bi ] [ j - 1 ] ) ; } } } return l [ bi ] [ n ] ; }
void printFirstNegativeInteger ( int [ ] arr , int n , int k ) { Deque < Integer > di = new ArrayDeque <> ( ) ; int i ; for ( i = 0 ; i < k ; i ++ ) { if ( arr [ i ] < 0 ) { di . add ( i ) ; } } for ( ; i < n ; i ++ ) { if ( ! di . isEmpty ( ) ) { System . out . print ( arr [ di . peek ( ) ] + " ▁ " ) ; } else { System . out . print ( " 0 " + " ▁ " ) ; } while ( ! di . isEmpty ( ) && di . peek ( ) < ( i - k + 1 ) ) { di . remove ( ) ; } if ( arr [ i ] < 0 ) { di . add ( i ) ; } } if ( ! di . isEmpty ( ) ) { System . out . print ( arr [ di . peek ( ) ] + " ▁ " ) ; } else { System . out . print ( " 0 " + " ▁ " ) ; } }
int findRoot ( Pair < Integer , Integer > [ ] arr , int n ) { int root = 0 ; for ( int i = 0 ; i < n ; i ++ ) { root += ( arr [ i ] . getValue0 ( ) - arr [ i ] . getValue1 ( ) ) ; } return root ; }
int findArea ( int [ ] arr , int n ) { TreeSet < Integer > s = new TreeSet <> ( ) ; int first = 0 , second = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! s . contains ( arr [ i ] ) ) { s . add ( arr [ i ] ) ; continue ; } if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) { second = arr [ i ] ; } } return first * second ; }
void rearrange ( int [ ] arr , int n ) { int maxEle = arr [ n - 1 ] ; int minEle = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] = maxEle ; maxEle -= 1 ; } else { arr [ i ] = minEle ; minEle += 1 ; } } }
int findMaxProduct ( int [ ] [ ] arr , int n ) { int max = 0 , result ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ; if ( max < result ) { max = result ; } } if ( ( i - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ; if ( max < result ) { max = result ; } } if ( ( i - 3 ) >= 0 && ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ; if ( max < result ) { max = result ; } } } } return max ; }
boolean isTriangular ( int num ) { if ( num < 0 ) { return false ; } int c = - 2 * num ; int b = 1 , a = 1 ; int d = b * b - 4 * a * c ; if ( d < 0 ) { return false ; } float root1 = ( float ) ( - b + Math . sqrt ( d ) ) / ( 2 * a ) ; float root2 = ( float ) ( - b - Math . sqrt ( d ) ) / ( 2 * a ) ; if ( root1 > 0 && Math . floor ( root1 ) == root1 ) { return true ; } if ( root2 > 0 && Math . floor ( root2 ) == root2 ) { return true ; } return false ; }
int countLattice ( int r ) { if ( r <= 0 ) { return 0 ; } int result = 4 ; for ( int x = 1 ; x < r ; x ++ ) { int ySquare = r * r - x * x ; int y = ( int ) Math . sqrt ( ySquare ) ; if ( y * y == ySquare ) { result += 4 ; } } return result ; }
int maxOnesIndex ( boolean [ ] arr , int n ) { int maxCount = 0 ; int maxIndex = 0 ; int prevZero = - 1 ; int prevPrevZero = - 1 ; for ( int curr = 0 ; curr < n ; ++ curr ) { if ( arr [ curr ] == false ) { if ( curr - prevPrevZero > maxCount ) { maxCount = curr - prevPrevZero ; maxIndex = prevZero ; } prevPrevZero = prevZero ; prevZero = curr ; } } if ( n - prevPrevZero > maxCount ) { maxIndex = prevZero ; } return maxIndex ; }
void leafNode ( int [ ] preOrder , int n ) { Stack < Integer > s = new Stack <> ( ) ; for ( int i = 0 , j = 1 ; j < n ; i ++ , j ++ ) { boolean found = false ; if ( preOrder [ i ] > preOrder [ j ] ) { s . push ( preOrder [ i ] ) ; } else { while ( ! s . isEmpty ( ) ) { if ( preOrder [ j ] > s . peek ( ) ) { s . pop ( ) ; found = true ; } else { break ; } } } if ( found ) { System . out . print ( preOrder [ i ] + " ▁ " ) ; } } System . out . println ( preOrder [ n - 1 ] ) ; }
boolean isSubset ( int [ ] arr1 , int [ ] arr2 , int m , int n ) { int i = 0 ; int j = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) { if ( arr2 [ i ] == arr1 [ j ] ) { break ; } } if ( j == m ) { return false ; } } return true ; }
int multiplyBySeven ( int n ) { return ( n << 3 ) - n ; }
int unboundedKnapsack ( int w , int n , int [ ] val , int [ ] wt ) { int [ ] dp = new int [ w + 1 ] ; for ( int i = 0 ; i <= w ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( wt [ j ] <= i ) { dp [ i ] = Math . max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] ) ; } } } return dp [ w ] ; }
void alternateSubarray ( boolean [ ] arr , int n ) { int count = 1 ; boolean prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) { if ( ! ( arr [ i ] ^ prev ) ) { while ( count > 0 ) { System . out . print ( count -- + " ▁ " ) ; } } ++ count ; prev = arr [ i ] ; } while ( count != 0 ) { System . out . print ( count -- + " ▁ " ) ; } }
int countKDist ( String str , int k ) { int n = str . length ( ) ; int res = 0 ; int [ ] cnt = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int distCount = 0 ; Arrays . fill ( cnt , 0 ) ; for ( int j = i ; j < n ; j ++ ) { if ( cnt [ str . charAt ( j ) - ' a ' ] == 0 ) { distCount ++ ; } cnt [ str . charAt ( j ) - ' a ' ] ++ ; if ( distCount == k ) { res ++ ; } if ( distCount > k ) { break ; } } } return res ; }
void modularInverse ( int n , int prime ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] = dp [ prime % i ] * ( prime - prime / i ) % prime ; } for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( dp [ i ] + " ▁ " ) ; } }
int countWays ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = dp [ 2 ] = 1 ; dp [ 3 ] = 2 ; for ( int i = 4 ; i <= n ; i ++ ) { dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + dp [ i - 4 ] ; } return dp [ n ] ; }
int count ( int n ) { if ( n < 3 ) { return n ; } if ( n >= 3 && n < 10 ) { return n - 1 ; } int po = 1 ; while ( n / po > 9 ) { po = po * 10 ; } int msd = n / po ; if ( msd != 3 ) { return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ; } else { return count ( msd * po - 1 ) ; } }
int countPattern ( String str ) { int len = str . length ( ) ; boolean oneSeen = false ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { char getChar = str . charAt ( i ) ; if ( getChar == ' 1 ' && oneSeen == true ) { if ( str . charAt ( i - 1 ) == ' 0 ' ) { count ++ ; } } if ( getChar == ' 1 ' && oneSeen == false ) { oneSeen = true ; } if ( getChar != ' 0 ' && str . charAt ( i ) != ' 1 ' ) { oneSeen = false ; } } return count ; }
int maxRemoval ( int [ ] arr , int n ) { int count = 0 ; int cumulativeSum = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= cumulativeSum ) { count ++ ; cumulativeSum += arr [ i ] ; } } return count ; }
String lexicographicalMaxString ( String str ) { String mx = " " ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { if ( mx . compareTo ( str . substring ( i ) ) <= 0 ) { mx = str . substring ( i ) ; } } return mx ;
